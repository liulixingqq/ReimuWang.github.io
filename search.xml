<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Leetcode Algorithms-104.Maximum Depth of Binary Tree]]></title>
    <url>%2F2018%2F09%2F19%2FLeetcode%20Algorithms-104Maximum%20Depth%20of%20Binary%20Tree%2F</url>
    <content type="text"><![CDATA[问题地址Maximum Depth of Binary Tree - LeetCode 问题描述 解法12345678910111213public class Solution &#123; public int maxDepth(TreeNode root) &#123; return null == root ? 0 : Math.max(maxDepth(root.left), maxDepth(root.right)) + 1; &#125;&#125;class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode Algorithms</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Leetcode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode Algorithms-101.Symmetric Tree]]></title>
    <url>%2F2018%2F09%2F18%2FLeetcode%20Algorithms-101Symmetric%20Tree%2F</url>
    <content type="text"><![CDATA[问题地址Symmetric Tree - LeetCode 问题描述 解法12345678910111213141516171819public class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; return root == null || isSymmetricHelp(root.left, root.right); &#125; private boolean isSymmetricHelp(TreeNode left, TreeNode right) &#123; if(left == null || right == null) return left == right; if(left.val != right.val) return false; return isSymmetricHelp(left.left, right.right) &amp;&amp; isSymmetricHelp(left.right, right.left); &#125;&#125;class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode Algorithms</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Leetcode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode Algorithms-100.Same Tree]]></title>
    <url>%2F2018%2F09%2F18%2FLeetcode%20Algorithms-100Same%20Tree%2F</url>
    <content type="text"><![CDATA[问题地址Same Tree - LeetCode 问题描述 解法12345678910111213141516public class Solution &#123; public boolean isSameTree(TreeNode p, TreeNode q) &#123; if (p == null &amp;&amp; q == null) return true; if (p == null || q == null) return false; if (p.val != q.val) return false; return this.isSameTree(p.left, q.left) &amp;&amp; this.isSameTree(p.right, q.right); &#125;&#125;class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode Algorithms</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Leetcode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode Algorithms-88.Merge Sorted Array]]></title>
    <url>%2F2018%2F09%2F18%2FLeetcode%20Algorithms-88Merge%20Sorted%20Array%2F</url>
    <content type="text"><![CDATA[问题地址Merge Sorted Array - LeetCode 问题描述 解法1正向迭代，此时需要顾虑nums1的长度变化情况，因此比较臃肿。 12345678910111213141516171819202122232425public class Solution &#123; public void merge(int[] nums1, int m, int[] nums2, int n) &#123; int i1 = 0; int lengthI1 = m; int orginI1 = 0; int i2 = 0; while (orginI1 &lt; m &amp;&amp; i2 &lt; n) &#123; if (nums2[i2] &gt;= nums1[i1]) orginI1++; else &#123; this.insert(nums2[i2], nums1, lengthI1, i1); lengthI1++; i2++; &#125; i1++; &#125; if (orginI1 == m) for (int i = i2; i &lt; n; i++) nums1[i1++] = nums2[i]; &#125; private void insert(int value, int[] nums, int length, int index) &#123; for (int i = length; i &gt; index; i--) nums[i] = nums[i - 1]; nums[index] = value; &#125;&#125; 解法2逆向迭代，看起来好多了。不过时间复杂度其实差不多。 1234567891011public class Solution &#123; public void merge(int[] nums1, int m, int[] nums2, int n) &#123; int i1 = m - 1; int i2 = n - 1; int now = m + n - 1; while (i1 &gt; -1 &amp;&amp; i2 &gt; -1) nums1[now--] = (nums1[i1] &gt; nums2[i2]) ? nums1[i1--] : nums2[i2--]; while (i2 &gt; -1) nums1[now--] = nums2[i2--]; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode Algorithms</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Leetcode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode Algorithms-83.Remove Duplicates from Sorted List]]></title>
    <url>%2F2018%2F09%2F17%2FLeetcode%20Algorithms-83Remove%20Duplicates%20from%20Sorted%20List%2F</url>
    <content type="text"><![CDATA[问题地址Remove Duplicates from Sorted List - LeetCode 问题描述 解法非递归： 1234567891011121314151617181920212223public class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; if (null == head) return head; ListNode tail = head; ListNode now = head.next; while (null != now) &#123; if (tail.val != now.val) &#123; tail.next = now; tail = now; &#125; now = now.next; &#125; tail.next = null; return head; &#125;&#125;class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125; 递归： 1234567891011121314public class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; if(null == head || null == head.next) return head; head.next = deleteDuplicates(head.next); return head.val == head.next.val ? head.next : head; &#125;&#125;class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode Algorithms</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Leetcode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode Algorithms-70.Climbing Stairs]]></title>
    <url>%2F2018%2F09%2F17%2FLeetcode%20Algorithms-70Climbing%20Stairs%2F</url>
    <content type="text"><![CDATA[问题地址Climbing Stairs - LeetCode 问题描述 解法本题实际上就是一个斐波那契数列的变种，原始的斐波那契数列的定义为： 123F(0)=0F(1)=1F(n)=F(n-1)+F(n-2) (n&gt;=2) 即是一组这样的数:0,1,1,2,3,5,8… 本体并未改变斐波那契数列的根本特性(后一项是前两项的和)，只是拿掉了最初的两项，同时n也从1开始了： 123F(1)=1F(2)=2F(n)=F(n-1)+F(n-2) (n&gt;=3) 即是一组这样的数:1,2,3,5,8… 从最容易理解的角度来看，我们可以写出这样的递归代码： 123456public class Solution &#123; public int climbStairs(int n) &#123; return n &lt;= 2 ? n : climbStairs(n - 2) + climbStairs(n - 1); &#125;&#125; 不过，这种解法的时间复杂度将达到恐怖的2^n。因为我们欲得到F(n)，则必须先得到F(n-1)及F(n-2)，依此类推。 因此，我们通常会采用如下时间复杂度为O(n)的解法： 123456789101112131415public class Solution &#123; public int climbStairs(int n) &#123; if (n &lt;= 2) return n; int first = 1; int second = 2; int now = 0; for (int i = 3; i &lt;= n; i++) &#123; now = first + second; first = second; second = now; &#125; return now; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode Algorithms</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Leetcode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode Algorithms-69.Sqrt(x)]]></title>
    <url>%2F2018%2F09%2F17%2FLeetcode%20Algorithms-69Sqrtx%2F</url>
    <content type="text"><![CDATA[问题地址Sqrt(x) - LeetCode 问题描述 解法123456789101112131415161718public class Solution &#123; public int mySqrt(int x) &#123; if (x &lt;= 1) return x; int begin = 0; int end = x; while (begin &lt;= end) &#123; int mid = begin + (end - begin) / 2; int now = x / mid; if (now == mid) return mid; else if (now &gt; mid) &#123; if (mid + 1 &gt; x / (mid + 1)) return mid; else begin = mid + 1; &#125; else end = mid - 1; &#125; return -1; &#125;&#125; 显然，出题人不希望我们直接使用Math.sqrt()。 本解法是二分查找的变种，需要注意的是解法中使用了形如： 1int now = x / mid; 的代码，其实更符合逻辑的思路应该是正向相乘： 1int now = mid * mid; 不过，这样会有溢出的风险，因此还是应该用题中除法的形式。 另外，0是不能做除数的，因此一开始的边界判断也一定要做好。]]></content>
      <categories>
        <category>Leetcode Algorithms</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Leetcode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode Algorithms-67.Add Binary]]></title>
    <url>%2F2018%2F09%2F17%2FLeetcode%20Algorithms-67Add%20Binary%2F</url>
    <content type="text"><![CDATA[问题地址Add Binary - LeetCode 问题描述 解法12345678910111213141516171819202122232425262728293031public class Solution &#123; public String addBinary(String a, String b) &#123; if (null == a || a.length() == 0) return b; if (null == b || b.length() == 0) return a; StringBuilder sb = new StringBuilder(); int ia = a.length() - 1; int ib = b.length() - 1; boolean mark = false; while (ia &gt;= 0 || ib &gt;= 0) &#123; char ta = ia &gt;= 0 ? a.charAt(ia) : &apos;0&apos;; char tb = ib &gt;= 0 ? b.charAt(ib) : &apos;0&apos;; if (ta == &apos;0&apos; &amp;&amp; tb == &apos;0&apos;) &#123; if (mark) sb.append(&apos;1&apos;); else sb.append(&apos;0&apos;); mark = false; &#125; else if (ta == &apos;1&apos; &amp;&amp; tb == &apos;1&apos;) &#123; if (mark) sb.append(&apos;1&apos;); else sb.append(&apos;0&apos;); mark = true; &#125; else &#123; if (mark) sb.append(&apos;0&apos;); else sb.append(&apos;1&apos;); &#125; ia--; ib--; &#125; if (mark) sb.append(&apos;1&apos;); return sb.reverse().toString(); &#125;&#125;]]></content>
      <categories>
        <category>Leetcode Algorithms</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Leetcode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode Algorithms-66.Plus One]]></title>
    <url>%2F2018%2F09%2F17%2FLeetcode%20Algorithms-66Plus%20One%2F</url>
    <content type="text"><![CDATA[问题地址Plus One - LeetCode 问题描述 解法123456789101112131415161718192021public class Solution &#123; public int[] plusOne(int[] digits) &#123; if (null == digits || digits.length == 0) return digits; int now = digits.length - 1; while (now &gt;= 0) &#123; if (digits[now] != 9) &#123; digits[now]++; break; &#125; digits[now--] = 0; &#125; if (now == -1) &#123; int[] result = new int[digits.length + 1]; result[0] = 1; for (int i = 0; i &lt; digits.length; i++) result[i + 1] = digits[i]; return result; &#125; return digits; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode Algorithms</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Leetcode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode Algorithms-58.Length of Last Word]]></title>
    <url>%2F2018%2F09%2F17%2FLeetcode%20Algorithms-58Length%20of%20Last%20Word%2F</url>
    <content type="text"><![CDATA[问题地址Length of Last Word - LeetCode 问题描述 解法12345678public class Solution &#123; public int lengthOfLastWord(String s) &#123; if (null == s || s.length() == 0) return 0; String[] a = s.split(&quot; &quot;); return a.length == 0 ? 0 : a[a.length - 1].length(); &#125;&#125;]]></content>
      <categories>
        <category>Leetcode Algorithms</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Leetcode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode Algorithms-53.Maximum Subarray]]></title>
    <url>%2F2018%2F09%2F17%2FLeetcode%20Algorithms-53Maximum%20Subarray%2F</url>
    <content type="text"><![CDATA[问题地址Maximum Subarray - LeetCode 问题描述 解法1最为笨拙的暴力穷举解法，时间复杂度O(n2)。 代码 123456789101112131415public class Solution &#123; public int maxSubArray(int[] nums) &#123; if (null == nums || nums.length == 0) return 0; int result = nums[0]; for (int i = 0; i &lt; nums.length; i++) &#123; int temp = 0; for (int j = i; j &lt; nums.length; j++) &#123; temp += nums[j]; if (temp &gt; result) result = temp; &#125; &#125; return result; &#125;&#125; 解法2这是一个时间复杂度为O(n)解法。 定义3个变量： max:当前已找到的最大和。遍历结束后返回的即是该值。 now:当前求和的起始元素。这个值并未在代码中显式定义，而是隐含在sum中。 sum:当前求得的和。 我们不妨先将问题分为两类：全为负数的情况及并非全为负数的情况。 当数组中的元素全部为负数时，此时将元素相加毫无意义(因为只会越加越小)，此时问题将退化为筛选出数组中最大的元素。即每次循环均有： 1sum=nums[i] 然后和max比较以筛选出最大值。 当数组中的元素并非全为负数时，一旦某次加法进行后导致和变为了负数，说明此次加法操作肯定是不应该的：毕竟本情况下数组中是有非负数的，单拎出来最大值也不会是负数。此时就应更换起点，然后和历史上得到的最大值做比较。依次类推，最终返回最大值。 代码 123456789101112public class Solution &#123; public int maxSubArray(int[] nums) &#123; if (null == nums || nums.length == 0) return 0; int max = Integer.MIN_VALUE, sum = 0; for (int i = 0; i &lt; nums.length; i++) &#123; sum = sum &lt; 0 ? nums[i] : sum + nums[i]; if (sum &gt; max) max = sum; &#125; return max; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode Algorithms</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Leetcode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode Algorithms-38.Count and Say]]></title>
    <url>%2F2018%2F09%2F14%2FLeetcode%20Algorithms-38Count%20and%20Say%2F</url>
    <content type="text"><![CDATA[问题地址Count and Say - LeetCode 问题描述 解法代码 12345678910111213141516171819202122232425262728public class Solution &#123; public String countAndSay(int n) &#123; if (n &lt; 1 || n &gt; 30) return null; String str = &quot;1&quot;; for (int i = 1; i &lt; n; i++) &#123; StringBuilder sb = new StringBuilder(); int mark = 0; while (mark &lt; str.length()) &#123; int count = numberCount(str, mark); sb.append(count).append(str.charAt(mark)); mark += count; &#125; str = sb.toString(); &#125; return str; &#125; private int numberCount(String str, int mark) &#123; int count = 1; while (mark &lt; str.length() - 1) &#123; if (str.charAt(mark + 1) != str.charAt(mark)) break; count++; mark++; &#125; return count; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode Algorithms</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Leetcode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode Algorithms-35.Search Insert Position]]></title>
    <url>%2F2018%2F09%2F14%2FLeetcode%20Algorithms-35Search%20Insert%20Position%2F</url>
    <content type="text"><![CDATA[问题地址Search Insert Position - LeetCode 问题描述 解法123456789101112131415public class Solution &#123; public int searchInsert(int[] nums, int target) &#123; if (null == nums) return -1; int low = 0; int high = nums.length - 1; while (low &lt;= high) &#123; int mid = low + (high - low) / 2; if (target == nums[mid]) return mid; if (target &lt; nums[mid]) high = mid - 1; else low = mid + 1; &#125; return low; &#125;&#125; 本问题是二分查找的变种。当target在nums中时，和普通的二分查找一样返回mid即可。需要说明的是，当没有找到时，为何返回了low。 当无法找到时，最后一次查找必在相邻两个元素之间进行，即必有 12high=low+1mid=low+(high-low)/2=low 本次若是找到，即得出mid=target，那是最好。此时直接返回mid即可。若是找不到，在target&lt;mid时应返回low，而target&gt;mid时应返回high。我们可以回看代码，第一种情况下比较后low没有改变；而第二种情况下比较后low=mid+1，即low=low+1，恰好等于需要的high了。因此在最后一次比较结束后，直接返回low即可。]]></content>
      <categories>
        <category>Leetcode Algorithms</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Leetcode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode Algorithms-28.Implement strStr()]]></title>
    <url>%2F2018%2F09%2F14%2FLeetcode%20Algorithms-28Implement%20strStr%2F</url>
    <content type="text"><![CDATA[问题地址Implement strStr() - LeetCode 问题描述 解法显然，出题人希望我们能自行实现这个功能，而不是直接调用indexOf()或startsWith()。 代码 12345678910111213141516public class Solution &#123; public int strStr(String haystack, String needle) &#123; if (null == haystack) throw new NullPointerException(&quot;haystack is null&quot;); if (null == needle) return -1; int hl = haystack.length(); int nl = needle.length(); if (nl == 0) return 0; if (nl &gt; hl) return -1; for (int hStart = 0; hStart &lt;= hl - nl; hStart++) &#123; String temp = haystack.substring(hStart, hStart + nl); if (needle.equals(temp)) return hStart; &#125; return -1; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode Algorithms</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Leetcode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 设计模式-23.Interpreter模式]]></title>
    <url>%2F2018%2F09%2F10%2FJava%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-23Interpreter%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在《图解设计模式》一书中，Interpreter模式被归入了第10部分用类来表现。在GoF原书中，Interpreter模式则被归入了行为型设计模式。 综述现今主流的编程语言依然都属于第三代编程语言，这些语言的文法接近人类的自然语言，对程序员极其友好。然而实际执行程序的机器依然只能识别第一代编程语言(也就是一串1和0组成的流啦)，这就导致了，无论使用何种第三代编程语言，是Java也好，还是C++也罢，虽然具体的实现细节依语言不同而千差万别，但终归都需要进行一种操作：将程序员编写的高级语言代码翻译为机器能够识别的01码。 下面我们就以Java为例，来相对详细的说说这个过程。 和大多直接由高级语言翻译(编译执行与解释执行只是手段，其本质目的都还是翻译)为机器语言不同的是，Java将它内部的翻译过程又分为了两个阶段(当然，对外部使用者，也就是实际执行机器码的机器而言，这个过程是黑盒的)：首先会从程序员编写的，人类能够识别的Java语言翻译为.class文件(编译期)。而后再将.class文件翻译为机器能识别的机器码。 简单来说，程序员编写的Java语言遵循着一套语法(不妨标记为语法1)，机器识别机器码时遵循着另一套语法(语法3)。在此之外，Java又在其内部搞出了一个.class文件(语法2)。这样翻译链的顺序就变为了 1语法1 --&gt; 语法2 --&gt; 语法3 之所以要这么搞，是为了实现Java语言的语言无关性。详见Java 基础-技术体系。 且不说翻译了几次，单说翻译行为本身，它的作用大致可归为以下两点： 虽然翻译本身增加了额外的开销，却使得程序员得以用更加类似自然语言的语法编写程序，极大的降低了学习成本，同时提高了代码编写的便利性与可维护性。 完成了各级语言间的解耦。以语法1 –&gt; 语法2的过程为例。Java程序员只需要知道Java语言的语法，而它的翻译者(我们称其为编译器)在此基础上还需要知道.class文件的语法。这意味着，无论是语法1亦或是语法2发生了何种变化，只要另一种语法尚能实现相同的功能，那么对彼此而言，这种变化就是透明的：它会被翻译者消化掉。从这种意义上来讲，翻译者颇有些2.Adapter模式中的适配器的意思。 将这种思想进一步扩展，得到的就是Interpreter模式。 主流的高级编程语言都是通用的，虽然各有擅长的点，但基本都能胜任绝大多数场景。而这种通用的另一面就是不够特化：高级语言语法的设计者当然不可能因为某个需求就修改语法。不过，高级语言的设计者虽然不能这么做，但需求的设计者却可以这样做：也就是说，我们为某个需求，或是某一类需求，定制一种”迷你语言”。如果我们将其称之为”语法0”的话，那么上文的翻译链就变为了： 1语法0 --&gt; 语法1 --&gt; 语法2 --&gt; 语法3 如果想要这么做的话，我们当然也可以在语法0前面加上个”语法-1”，使得翻译链无限的向上堆叠上去，只不过这会让程序变得复杂，而这种复杂通常是没什么意义的，所以通常都不会这么做。 具体到这个应用场景，我们再来说下引入”语法0”的好处： 较之高级语言，迷你语言的语法简单，且为需求高度定制。使得代码(此时程序员写的当然就是迷你语言的代码啦)的书写更为容易，目的性也更强。 在这个场景下，高级语言的语法一般不会发生变化，迷你语言的语法通常也不会发生变化。发生变化的基本只会是使用迷你语言编写的代码。 如果要使用Interpreter模式编写程序的话，难点通常并不是在于编写迷你语言本身，而是在于编写”语法0 –&gt; 语法1”的翻译器。因为迷你语言完全是程序员根据需求生造出来的，只有他自己才知道语法，因此也只有他本身才能编写翻译器。这也是Interpreter模式被称为”解释器模式”的原因所在。通常翻译器我们都会用”语法1”，也就是作为基底的高级语言来开发。 控制人物移动的迷你语言下面我们就针对”控制人物移动”这个需求来创建一门全新的迷你语言吧！ 首先介绍下本文用于作为行走角色的妹子，来自东方Project的伊吹萃香： 萃香好可爱啊~融化了。 这是用到的行走图素材，也是萌萌哒： 按需求，我们可以向人物下达如下3种指令： 前进1个长度单位(go) 右转(right) 左转(left) 其中左转与右转是严格意义上的原地转向。在此之上，为了构成一个相对复杂的语言，我们引入了新的指令： 重复(repeat) 这可以让人物重复一定次数的指令集合。至此，我们已得到构成本文迷你语言的全部指令。 要想被称之为一门语言，光有指令(相当于自然语言中的单词)是不够的，我们还需要规定一个语法将它们组合起来。对于本文的迷你语言，我们先来看一段最简单的代码： 12programend 我们规定，这门迷你语言必须以program开头，后面跟随着指令集合(command list)。command list必须以end结尾。如果command list为空，那么就会出现上文中program后面直接跟着一个end的情况啦。显然，上述代码不会产生任何实际的效果。 程序可以采用换行，空格，tab等任何主流的分隔符，这意味上述代码我们也可以写成这样： 1program end 不过为了便于阅读，对于书写任意语言而言，适当的缩进都是很必要的。 然后我们再来看一段稍微复杂点的代码： 123456program go go right go go right go go right go go rightend 程序会按指令的书写顺序执行它们。执行这段指令，可以输出： 该代码会让人物走一个正方形，而后回到初始的位置和朝向。为了在静态的图片中表现出代码的执行过程，我们绘制了人物移动的轨迹。 如果仔细看一下上述代码的话，会发现我们将： 1go go right 这个代码片段重复写了4遍。显然这是很low的行为。因此就需要repeat指令登场啦： 123program repeat 4 go go right endend repeat指令的语法规则为：首先是作为关键字的repeat，然后是表示循环次数的数字。最后是实际被循环的command list。执行该代码后输出与前图相同。 我们可以再来走一个更复杂的轨迹： 12345678program repeat 1000 repeat 4 repeat 3 go right go left end right end endend 这段代码会重复一个相对复杂的轨迹1000次，贴几张移动过程中的截图吧： 示例程序迷你语言的语法结构至此就算是结束了，该语言非常简单，简单到只有顺序和循环结构，连分支结构都没有。不过用来作说明已经是足够了。此外，上文我们是以自然语言在进行描述，也就是说给产品经理听的。而技术人员如果要将该语法落实到代码中，还需要用更为准确的数学语言来描述才可以。 本文采取的描述方法为EBNF(Extended Backus–Naur Form，即扩展的巴科斯-瑙尔范式)。顾名思义，它是对BNF(Backus-Naur Form，巴科斯范式)的扩展。我们先给出全部的语法描述： 12345&lt;program&gt; ::= program &lt;command list&gt;&lt;command list&gt; ::= &lt;command&gt;* end&lt;command&gt; ::= &lt;repeat command&gt; | &lt;primitive command&gt;&lt;repeat command&gt; ::= repeat &lt;number&gt; &lt;command list&gt;&lt;primitive command&gt; ::= go | left | right 较之自然语言，是不是简洁了许多呢(事实上，不仅仅是看起来简洁了，也更为精确了)？下面就来逐句分析一下吧！ 1&lt;program&gt; ::= program &lt;command list&gt; 首先是第一句，这个::=我们简单的理解为赋值就可以啦！该句用于描述&lt;program&gt;这个标签，或者更确切的说，是构成语法树的&lt;program&gt;结点。按照描述，&lt;program&gt;节点就是program关键字后跟上一个&lt;command list&gt;。 至此&lt;program&gt;算是描述完了，但是我们却无法真正能说完全了解它，program作为一个普通的字符串没什么可说的，不过这个&lt;command list&gt;是什么呢？这就好比表达式y=x+3，如果我们不知道x是什么，自然也不能知道y是什么。 不过不要急，第二句就是在描述&lt;command list&gt;啦： 1&lt;command list&gt; ::= &lt;command&gt;* end 哦，原来&lt;command list&gt;是0到多个(描述范式中*所代表的含义，熟悉正则的朋友们应该会感到很亲切吧)&lt;command&gt;节点后再加上end关键字。那么这个&lt;command&gt;是什么呢： 1&lt;command&gt; ::= &lt;repeat command&gt; | &lt;primitive command&gt; 范式告诉我们，&lt;command&gt;是一个&lt;repeat command&gt;结点或是一个&lt;primitive command&gt;结点。 而&lt;repeat command&gt;： 1&lt;repeat command&gt; ::= repeat &lt;number&gt; &lt;command list&gt; 它是repeat关键字后跟随一个&lt;number&gt;结点，再跟随一个前文介绍过的&lt;command list&gt;结点。从而形成了递归结构。 最后是&lt;primitive command&gt;： 1&lt;primitive command&gt; ::= go | left | right 它是go,left,right这3个关键字中的某一个。在编程领域，像&lt;primitive command&gt;这样描述它的信息中不包含其他结点的，或者更直观的说，我们可以仅仅通过描述语句本身就完全弄明白含义的结点，被称为终结符表达式(Terminal Expression)。与之相对的，像&lt;command list&gt;，&lt;command&gt;等需要进一步展开的结点则被称为非终结符表达式(Nonterminal Expression)。所谓递归，其实就是因非终结符表达式而起，最后收束于终结符表达式。 细心的朋友想必可以发现，我们还剩一个&lt;number&gt;结点没有描述。其实是应该写的，它应该是一个大于等于0的整数，是一个终结符表达式。只不过它的描述较为复杂，这里便省略了。 完成了语法的数学化描述后，下一步就是根据该描述将迷你语言的代码依据语法规则翻译为语法树，并存入宿主语言(本文使用Java)中，这一步被称为解析。而后再执行语法树中存储的语义，得到输出。这么说还是会有一些抽象，还是让我们赶紧来看具体的代码吧。 本程序中的所有代码将被统一置于design23包下，结构如下： 迷你语言的示例程序使用前文介绍过的那个重复绘制1000次的复制图形。它被存储在名为code.txt的文件中。 code.txt 12345678program repeat 1000 repeat 4 repeat 3 go right go left end right end endend 然后我们介绍本文的重点，也就是model.parse包下的内容。这个包下的代码完成了前文说到的迷你语言的语法树的构建(即解析)以及执行。秉承Java语言”一切都是对象，对象就是一切”的思想，上文介绍的EBNF中的结点最终都被翻译为了类，这在后文的代码中将会有很明显的体现。 Node类 12345678910package design23.model.parse;import design23.model.entity.GameMap;public abstract class Node &#123; public abstract void parse(Context context) throws ParseException; public abstract void exe(GameMap map);&#125; Node类是所有结点的抽象父类。按照需求，它约束自身的子类必须实现两个基本的功能：parse() –&gt; 解析 及 exe() –&gt; 执行。很显然，这两个方法的调用是有先后顺序的，即我们必须先完成解析，形成语法树，才能执行。 在解析方法parse()的方法定义中，我们抛出了自定义异常ParseException： ParseException类 12345678910package design23.model.parse;public class ParseException extends Exception &#123; private static final long serialVersionUID = 1L; ParseException(String msg) &#123; super(msg); &#125;&#125; 这只是一个很简单的异常类，就不多做赘述了。 ProgramNode类 123456789101112131415161718192021222324252627282930package design23.model.parse;import design23.model.entity.GameMap;/** * &lt;program&gt; ::= program &lt;command list&gt; */public class ProgramNode extends Node &#123; private CommandListNode commandListNode; private static final String PROGRAM_STR = &quot;program&quot;; @Override public void parse(Context context) throws ParseException &#123; context.skip(ProgramNode.PROGRAM_STR); this.commandListNode = new CommandListNode(); this.commandListNode.parse(context); &#125; @Override public String toString() &#123; return &quot;[&quot; + ProgramNode.PROGRAM_STR + &quot; &quot; + this.commandListNode + &quot;]&quot;; &#125; @Override public void exe(GameMap map) &#123; this.commandListNode.exe(map); &#125;&#125; 终于到EBNF中介绍的真正的结点了。很显然，ProgramNode对应&lt;program&gt;，这在类首的注释中也有所体现。我们会为每一个结点都加上类似的类首注释，以表明它代表的是EBNF中的哪个结点，因此后文在介绍其他结点时就不会再显式的点出这种对应关系了。 关于将EBNF翻译为实际的类，有一个很重要的点就是”不要做多余的事”。简单来说，在我们编写ProgramNode时，能参照的就仅仅只是: 1&lt;program&gt; ::= program &lt;command list&gt; 其他的一切都不需要知道。也不要耍小聪明做一些EBNF中没有的事，如果实在是想加新功能，也需要修改EBNF，而不是在翻译出的代码中自作主张。语法的设计在EBNF中已全部完成了，从EBNF到具体的代码仅仅只需要机械的翻译。 因此，这些结点的代码本身其实没什么好说的，后续结点的代码我们将快速的贴出。 CommandListNode类 1234567891011121314151617181920212223242526272829303132333435363738394041package design23.model.parse;import java.util.ArrayList;import java.util.List;import design23.model.entity.GameMap;/** * &lt;command list&gt; ::= &lt;command&gt;* end */public class CommandListNode extends Node &#123; private List&lt;CommandNode&gt; commandList = new ArrayList&lt;CommandNode&gt;(); @Override public void parse(Context context) throws ParseException &#123; while (true) &#123; String current = context.peek(); String endstr = &quot;end&quot;; if (null == current) throw new ParseException(&quot;Missing &apos;&quot; + endstr + &quot;&apos;&quot;); if (endstr.equals(current)) &#123; context.skip(endstr); break; &#125; CommandNode commandNode = new CommandNode(); this.commandList.add(commandNode); commandNode.parse(context); &#125; &#125; @Override public String toString() &#123; return this.commandList.toString(); &#125; @Override public void exe(GameMap map) &#123; for (CommandNode commandNode : this.commandList) commandNode.exe(map); &#125;&#125; CommandNode类 1234567891011121314151617181920212223242526272829303132package design23.model.parse;import design23.model.entity.GameMap;/** * &lt;command&gt; ::= &lt;repeat command&gt; | &lt;primitive command&gt; */public class CommandNode extends Node &#123; private CommandNode commandNode; protected static final String REPEAT_STR = &quot;repeat&quot;; @Override public void parse(Context context) throws ParseException &#123; this.commandNode = CommandNode.REPEAT_STR.equals(context.peek()) ? new RepeatCommandNode() : new PrimitiveCommandNode(); this.commandNode.parse(context); &#125; @Override public String toString() &#123; return this.commandNode.toString(); &#125; @Override public void exe(GameMap map) &#123; this.commandNode.exe(map); &#125;&#125; RepeatCommandNode类 12345678910111213141516171819202122232425262728293031323334353637package design23.model.parse;import design23.model.entity.GameMap;/** * &lt;repeat command&gt; ::= repeat &lt;number&gt; &lt;command list&gt; */public class RepeatCommandNode extends CommandNode &#123; private int number; private CommandListNode commandListNode; @Override public void parse(Context context) throws ParseException &#123; context.skip(CommandNode.REPEAT_STR); try &#123; this.number = Integer.parseInt(context.peek()); &#125; catch (NumberFormatException e) &#123; throw new ParseException(&quot;fail to parse &quot; + CommandNode.REPEAT_STR + &quot; times.&quot; + e); &#125; context.next(); this.commandListNode = new CommandListNode(); this.commandListNode.parse(context); &#125; @Override public String toString() &#123; return &quot;[&quot; + CommandNode.REPEAT_STR + &quot; &quot; + this.number + &quot; &quot; + this.commandListNode + &quot;]&quot;; &#125; @Override public void exe(GameMap map) &#123; for (int i = 0; i &lt; this.number; i++) this.commandListNode.exe(map); &#125;&#125; PrimitiveCommandNode类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package design23.model.parse;import design23.model.entity.GameMap;import design23.model.entity.Grid;/** * &lt;primitive command&gt; ::= go | left | right */public class PrimitiveCommandNode extends CommandNode &#123; private String name; public static final String GO = &quot;go&quot;; public static final String LEFT = &quot;left&quot;; public static final String RIGHT = &quot;right&quot;; @Override public void parse(Context context) throws ParseException &#123; this.name = context.peek(); context.skip(this.name); if (!PrimitiveCommandNode.GO.equals(this.name) &amp;&amp; !PrimitiveCommandNode.LEFT.equals(this.name) &amp;&amp; !PrimitiveCommandNode.RIGHT.equals(this.name)) throw new ParseException(&quot;command &quot; + this.name + &quot; is undefined&quot;); &#125; @Override public String toString() &#123; return this.name; &#125; @Override public void exe(GameMap map) &#123; int maxR = map.getGrids().length; int maxC = map.getGrids()[0].length; int focusR = map.getFocusR(); int focusC = map.getFocusC(); Grid focusGrid = map.getGrids()[focusR][focusC]; int direction = focusGrid.getDirection(); if (PrimitiveCommandNode.GO.equals(this.name)) &#123; int newFocusR = focusR; int newFocusC = focusC; switch (direction) &#123; case 0: if (focusR + 1 == maxR) break; newFocusR = focusR + 1; break; case 1: if (focusC == 0) break; newFocusC = focusC - 1; break; case 2: if (focusC + 1 == maxC) break; newFocusC = focusC + 1; break; case 3: if (focusR == 0) break; newFocusR = focusR - 1; &#125; // 模拟走路动作 for (int i = 0; i &lt; map.getStageCount(); i++) &#123; try &#123; Thread.sleep(300); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; focusGrid.setStage((focusGrid.getStage() + 1) % map.getStageCount()); if (i == map.getStageCount() / 2) &#123; // 设置新的焦点格 map.getGrids()[newFocusR][newFocusC].setDirection(direction); map.getGrids()[newFocusR][newFocusC].setStage(focusGrid.getStage()); map.getGrids()[newFocusR][newFocusC].setTimes(map.getGrids()[newFocusR][newFocusC].getTimes() + 1); map.setFocusR(newFocusR); map.setFocusC(newFocusC); // 设置原来的焦点格 focusGrid.setDirection(-1); focusGrid.setStage(-1); &#125; &#125; &#125; else if (PrimitiveCommandNode.LEFT.equals(this.name)) &#123; switch (direction) &#123; case 0: focusGrid.setDirection(2); break; case 1: focusGrid.setDirection(0); break; case 2: focusGrid.setDirection(3); break; case 3: focusGrid.setDirection(1); &#125; &#125; else &#123; switch (direction) &#123; case 0: focusGrid.setDirection(1); break; case 1: focusGrid.setDirection(3); break; case 2: focusGrid.setDirection(0); break; case 3: focusGrid.setDirection(2); &#125; &#125; &#125;&#125; 至此，所有的结点我们都介绍完了。不过，为了能让翻译器接收到源码，我们还写了Context类： Context类 1234567891011121314151617181920212223242526272829303132package design23.model.parse;import java.util.StringTokenizer;public class Context &#123; private StringTokenizer st; private String current; public Context(String text) &#123; this.st = new StringTokenizer(text); this.next(); &#125; String peek() &#123; return this.current; &#125; String next() &#123; this.current = this.st.hasMoreTokens() ? this.st.nextToken() : null; return this.current; &#125; void skip(String token) throws ParseException &#123; if (!token.equals(this.current)) throw new ParseException(&quot;need &quot; + token + &quot;, but &quot; + this.current + &quot; is found&quot;); this.next(); &#125;&#125; Context类的功能很简单，它将源码按分割符分割为一个个单词，然后作为解析器会逐个读取单词，而后根据单词生成新的结点，并将结点挂载到语法树合适的位置上。随着语法树的构建，Context中的文本信息会越来越少，直至读完。 至此，本文要介绍的核心功能就已经描述完了。后文要介绍的代码都只是为了得到一个可视化的结果。 首先来看model.entity包，这个包下存储了程序要展示的一些实体。一如前文中的截图看到的，我们希望游戏最终能实现RPG制作大师做出的游戏的效果。因此我们需要一张存储所有要素的游戏地图，该地图是由一个个”小格子”组成的。 GameMap类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package design23.model.entity;public class GameMap &#123; private Grid[][] grids; private int focusR; private int focusC; private int stageCount; /** * @param row 地图上小格子的行数 * @param column 地图上小格子的列数 * @param stageCount 人物的行走状态 * @param focusR 初始时人物所在的小格子的行号 * @param focusC 初始时人物所在的小格子的列号 * @param initDirection 初始时人物的朝向 */ public GameMap(int row, int column, int stageCount, int focusR, int focusC, int direction) &#123; this.stageCount = stageCount; this.grids = new Grid[row][column]; for (int r = 0; r &lt; row; r++) for (int c = 0; c &lt; column; c++) this.grids[r][c] = new Grid(); this.focusR = focusR; this.focusC = focusC; this.grids[this.focusR][this.focusC].setDirection(direction); this.grids[this.focusR][this.focusC].setStage(1); this.grids[this.focusR][this.focusC].setTimes(1); &#125; public Grid[][] getGrids() &#123; return grids; &#125; public int getFocusR() &#123; return focusR; &#125; public void setFocusR(int focusR) &#123; this.focusR = focusR; &#125; public int getFocusC() &#123; return focusC; &#125; public void setFocusC(int focusC) &#123; this.focusC = focusC; &#125; public int getStageCount() &#123; return stageCount; &#125;&#125; Grid类 12345678910111213141516171819202122232425262728293031323334package design23.model.entity;public class Grid &#123; private int direction = -1; private int stage = -1; private int times; public int getDirection() &#123; return direction; &#125; public void setDirection(int direction) &#123; this.direction = direction; &#125; public int getStage() &#123; return stage; &#125; public void setStage(int stage) &#123; this.stage = stage; &#125; public int getTimes() &#123; return times; &#125; public void setTimes(int times) &#123; this.times = times; &#125;&#125; 调用了GameMap的构造函数后，我们便构建了这样的一张地图： row行column列 初始时人物所在的格子位置：grids[this.focusR][this.focusC] 只会有一个格子处于焦点状态。未处于焦点状态的格子的direction和stage均默认为-1。 Grid的times属性是指人物来到该格子上的次数，绘制轨迹用。 这里需要简单介绍下direction与stage的含义。其中direction表示人物当前的朝向。而stage则表示行走状态，在人物从1个格子移动到另一个格子的过程中，我们一共会变化出3张图片，从而模拟出”人物移动的动作”。 这两个字段实际都是服务于图character.png： 纵向来看，0-3分别代表下左右上四个朝向。而横向的0-2则代表三个行走状态：站立不动是中间的那张状态1。当人物从一个格子移动到另一个格子上时，发生的变化为：状态1 –&gt; 状态2 –&gt; 状态0 –&gt; 状态1。 然后我们提供了将parse包及entity包整合起来并对外(指得就是View啦)提供功能接口的Model类： Model类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package design23.model;import java.io.BufferedReader;import java.io.File;import java.io.FileInputStream;import java.io.InputStreamReader;import org.apache.commons.lang.StringUtils;import design23.model.entity.GameMap;import design23.model.parse.Context;import design23.model.parse.ParseException;import design23.model.parse.ProgramNode;public class Model &#123; private GameMap map; private ProgramNode root = new ProgramNode(); public void initMap(int row, int column, int stageCount, int focusR, int focusC, int direction) &#123; this.map = new GameMap(row, column, stageCount, focusR, focusC, direction); &#125; public void initInterpreter(String path) &#123; try &#123; this.root.parse(new Context(this.loadCode(path))); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; System.out.println(this.root); &#125; public void exe() &#123; new Thread() &#123; @Override public void run() &#123; Model.this.root.exe(Model.this.map); &#125; &#125;.start(); &#125; public GameMap getMap() &#123; return map; &#125; private String loadCode(String path) &#123; StringBuilder sb = new StringBuilder(); FileInputStream fi = null; InputStreamReader ir = null; BufferedReader br = null; try &#123; fi = new FileInputStream(new File(path)); ir = new InputStreamReader(fi, &quot;UTF-8&quot;); br = new BufferedReader(ir); String lineTxt = null; while (!StringUtils.isBlank((lineTxt = br.readLine()))) sb.append(lineTxt).append(&quot; &quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; br.close(); ir.close(); fi.close(); &#125; catch (Exception ef) &#123; ef.printStackTrace(); &#125; &#125; return sb.toString(); &#125;&#125; 然后是作为GUI显示的View类，本文使用Java AWT： View类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115package design23.view;import java.awt.Color;import java.awt.Frame;import java.awt.Graphics;import java.awt.Image;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;import java.awt.image.BufferedImage;import java.io.IOException;import javax.imageio.ImageIO;import design23.model.Model;import design23.model.entity.Grid;public class View extends Frame &#123; private static final long serialVersionUID = 1L; private int gridSize = 32; private int widebar = 31; private int narrowbar = 6; private Model model = new Model(); private BufferedImage img = this.loadImg(&quot;character.png&quot;); public void launchFrame() &#123; int gridRow = 7; int gridColumn = 7; this.model.initMap(gridRow, gridColumn, 3, 3, 0, 3); this.model.initInterpreter(&quot;src/main/java/design23/code.txt&quot;); super.setLocation(800, 300); super.setSize(this.narrowbar + this.gridSize * gridColumn + this.narrowbar, this.widebar + this.gridSize * gridRow + this.narrowbar); new Thread(this.new RepaintRunnable()).start(); super.addWindowListener( new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125; &#125; ); this.model.exe(); super.setVisible(true); &#125; @Override public void paint(Graphics g) &#123; Grid[][] grids = this.model.getMap().getGrids(); for (int r = 0; r &lt; grids.length; r++) &#123; for (int c = 0; c &lt; grids[0].length; c++) &#123; Grid grid = grids[r][c]; int dx1 = this.narrowbar + c * this.gridSize; int dy1 = this.widebar + r * this.gridSize; if (grid.getTimes() &gt; 0) &#123; Color tempColor = g.getColor(); g.setColor(Color.GRAY); g.fillRect(dx1, dy1, this.gridSize, this.gridSize); g.setColor(tempColor); &#125; if (grid.getDirection() &gt;= 0) &#123; int direction = grid.getDirection(); int stage = grid.getStage(); g.drawImage(this.img, dx1, dy1, this.narrowbar + c * this.gridSize + this.gridSize, this.widebar + r * this.gridSize + this.gridSize, stage * this.gridSize, direction * this.gridSize, stage * this.gridSize + this.gridSize, direction * this.gridSize + this.gridSize, null); &#125; &#125; &#125; &#125; private class RepaintRunnable implements Runnable &#123; @Override public void run() &#123; while (true) &#123; try &#123; View.this.repaint(); Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; @Override public void update(Graphics g) &#123; Image bImage = super.createImage(this.getWidth(), this.getHeight()); Graphics bg = bImage.getGraphics(); this.paint(bg); bg.dispose(); g.drawImage(bImage, 0, 0, this); &#125; private BufferedImage loadImg(String name) &#123; BufferedImage bImage = null; try &#123; bImage = ImageIO.read(View.class.getClassLoader().getResource(&quot;design23/&quot; + name)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return bImage; &#125;&#125; 在View的launchFrame()中，我们先调用model的initMap()初始化了地图，而后又调用model的initInterpreter()初始化了语法树。而后在需要的时候，也就是launchFrame()的最后，我们调用model的exe()方法来执行语法树。该方法会启一个新的线程，按设定的代码移动人物(其实就是改变地图中属性的值)。而View剩余要做的，就是不断的刷新并显示地图，将翻译器更新后的数据显示出来。 最后给出Main.java。执行该类后，即可得到结果。 12345678910package design23;import design23.view.View;public class Main &#123; public static void main(String[] args) &#123; new View().launchFrame(); &#125;&#125; 需要注意的是，因为我们在Model初始化语法树时将语法树打印出来了。因此除了UI外，我们还会在控制台中得到这样的一句输出： 1[program [[repeat 1000 [[repeat 4 [[repeat 3 [go, right, go, left]], right]]]]]] 大家可以对照前文的EBNF加深理解。 登场角色上面的示例程序介绍了Interpreter模式的Java实现，下面咱们试着跳出语言层面，抽象出Interpreter模式中登场的角色。 AbstractExpression(抽象表达式) 定义结点的基本约束。在示例程序中，由Node类扮演这个角色。 TerminalExpression(终结符表达式) 即EBNF中的终结符表达式，在示例程序中，由PrimitiveCommandNode类扮演这个角色。 NonterminalExpression(非终结符表达式) 即EBNF中的非终结符表达式，在示例程序中，由ProgramNode类，CommandListNode类，CommandNode类，RepeatCommandNode类联袂扮演这个角色。 Context(上下文) 在示例程序中，由Context类扮演这个角色。 迷你语言可以有哪些？其实说白了，只要功能允许，也就是语言A中所表述的实体在语言B中实际存在，那么就可以使用Interpreter模式将语言A至于语言B之上。下面列出的是几种常用和热门的。 批处理语言 也就是所谓的第二代语言。这种语言基本就是单词的拼接，能表达的含义远没有第三代语言多。但是在某些本来就不需要那么多含义的场景下，使用批处理语言会使程序”更纯粹”，反而有利于开发和维护。本文示例程序中设计的迷你语言即属于批处理语言。 正则 大多数主流语言都支持对正则语法的解析。实现细节虽然千差万别，但核心思想基本不出本文藩篱。 自然语言 自然语言的语义识别和语法树的构建是人工智能的关键技术之一。]]></content>
      <categories>
        <category>Java 设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 设计模式-22.Command模式]]></title>
    <url>%2F2018%2F09%2F07%2FJava%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-22Command%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在《图解设计模式》一书中，Command模式被归入了第10部分用类来表现。在GoF原书中，Command模式则被归入了行为型设计模式。 综述在19.State模式中，我们介绍了用类来描述状态。今天我们介绍另一个可以用类来描述的相对抽象的概念：命令。 宏观的说，一个类与其他类的关系可以归为两种： 向其他类发出命令促使其他类发生变化。 接到来自其他类的指令自身发生变化。 通常来说，系统只会记录变化的结果，而不会记录变化的过程。换句话说，当我们在某个时间点对系统进行查询时，通常只能查到系统在当前时间的静态状态，也就是因命令导致的结果，而无法查知变化的过程。虽然程序一般都会把这个过程记录在日志中，但从严格的意义上来讲，日志文件已经不属于系统本身了。 变化过程本身无法记录，但是如果我们将触发变化的命令作为对象记录下来呢？ 假设我们要画一系列的点(这也是本文的示例程序，先简要描述下)，通常来说，我们会告诉绘图实例：在位置p1绘制一个半径为r1，颜色为c1的点！绘图实例就赶紧按要求画了一个点。我们再说：在位置p2绘制一个半径为r2，颜色为c2的点！绘图程序赶紧又画了一个。最终我们得到了绘制着两个点的画布。但是触发绘制这两个点的命令却丢失了：因为我们根本不曾记录。 如果我们将这两个命令记录下来，形成表示命令的实例： 命令1：在位置p1绘制一个半径为r1，颜色为c1的点！ 命令2：在位置p2绘制一个半径为r2，颜色为c2的点！ 这样我们便算是将一个抽象的变化存储为了相对具体的实体。一旦完成了存储，我们可做的事一下子就变多了： 引入命令后，类A将从直接调用类B转化为制造一条命令，而后执行这条命令：这就使得类A与类B之间完成了解耦。 接上条，这种解耦并不仅仅是空间上的，同样还可以是时间上的，如果对命令结果的需求没那么迫切，类A完全可以只负责制造命令，而后就可以继续做自己的事了。这使得命令的执行变成了异步的。 继续接上条，一旦命令的执行变为异步，就意味着我们可以把待执行的命令存储起来，形成一个指令集。在需要的时候统一执行。 18.Memento模式可以让我们进行存档与恢复。其做法就是把某个时间点的对象像拍照那样存储下来，而后在需要时再进行恢复；引入命令后，我们也可以做到类似的事，比如某实例最初处于初始状态，而后经过了命令1，2，3后变为了状态2。如果我们想要记录状态2，方法之一自然是使用18.Memento模式将状态2照下来。但我们同样也可以存储命令1，2，3。当我们需要状态2时，我们只需要再找一个处于初始状态的实例，而后再按顺序执行一遍命令1，2，3即可。 接上条，很显然，如果要使用命令集来制作存档的话，在恢复存档时通常要比拍快照更花时间。 将这种”引入命令”的思想理论化后，得到的就是Command模式啦。有时，我们也会将命令称为事件(event)，它与”事件驱动编程”中的”事件”的含义是相同的。我们会在GUI编程中大量的用到事件：点击一次鼠标是一个事件，按下键盘上的一个按键是一个事件。而每个事件其实都可以视为一个指令，以促使系统发生相应的变化。 示例程序需求分析下面我们就来设计一个应用了Command模式的小例子吧。这是一个使用Java Swing技术实现的画图小程序。启动时的初始面板为： 区域介绍： 默认画笔粗细为10(画笔形成的点的半径为10个像素)，默认颜色为黑色，在画布上按住鼠标左键拖动即可绘制图形。下图为使用初始参数绘制一条线： 然后我们调整画笔粗细为5，颜色为绿，在线的下面再画一个圈： 点击”清空”按钮后，画布会被清空。不过画笔颜色及粗细不会恢复为默认值。例如我们可以撤销部分绘制圆的操作： 点击”撤销”按钮可以让我们撤销一次操作，即取消绘制一个点。不过并不会撤销对画笔颜色及粗细的选择。 点击”保存”按钮可以将当前画布上的图形保存到文件中。此后可以通过点击”读取”按钮恢复此前保存的图形。 功能基本就是这么多，最后附上一幅我用这个程序画的一幢好丑好丑的房子，哈哈哈： 示例程序本程序中的所有代码将被统一置于design22包下，结构如下： 下面将逐个贴出每个类的源码。 首先介绍command包里的类，顾名思义，这个包下自然全都是命令啦。 Command接口 12345678910package design22.command;import java.util.List;public interface Command &#123; void execute(); List&lt;String&gt; strList();&#125; Command是最顶层的命令接口。内部只有两个方法。其中execute()表示执行命令。而strList()则会将命令转换为字符串以用于存档。之所以返回类型是List，是因为实际实现Command接口的命令有可能并非单独一条指令，而是一个指令集。 MacroCommand类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125package design22.command;import java.awt.Color;import java.awt.Point;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.util.ArrayList;import java.util.Iterator;import java.util.List;import java.util.Stack;import org.apache.commons.lang.StringUtils;import com.alibaba.fastjson.JSONObject;import design22.view.MyCanvas;public class MacroCommand implements Command &#123; private Stack&lt;Command&gt; commands = new Stack&lt;Command&gt;(); private static final String SAVE = &quot;src/main/java/design22/save/save.txt&quot;; private static final String ENCODING = &quot;UTF-8&quot;; private MyCanvas canvas; public MacroCommand(MyCanvas canvas) &#123; this.canvas = canvas; &#125; @Override public void execute() &#123; Iterator&lt;Command&gt; iterator = this.commands.iterator(); while (iterator.hasNext()) iterator.next().execute(); &#125; public void append(Command cmd) &#123; if (this != cmd) this.commands.push(cmd); &#125; public void clear() &#123; this.commands.clear(); &#125; public void undo() &#123; if (!this.commands.isEmpty()) this.commands.pop(); &#125; public void save() &#123; List&lt;String&gt; data = this.strList(); FileOutputStream fo = null; OutputStreamWriter ow = null; BufferedWriter bw = null; try &#123; fo = new FileOutputStream(new File(MacroCommand.SAVE)); ow = new OutputStreamWriter(fo, MacroCommand.ENCODING); bw = new BufferedWriter(ow); for (String str : data) &#123; bw.write(str); bw.newLine(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; bw.close(); ow.close(); fo.close(); &#125; catch (Exception ef) &#123; ef.printStackTrace(); &#125; &#125; &#125; @Override public List&lt;String&gt; strList() &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); Iterator&lt;Command&gt; iterator = this.commands.iterator(); while (iterator.hasNext()) list.addAll(iterator.next().strList()); return list; &#125; public void load() &#123; this.clear(); this.canvas.init(); FileInputStream fi = null; InputStreamReader ir = null; BufferedReader br = null; try &#123; fi = new FileInputStream(new File(MacroCommand.SAVE)); ir = new InputStreamReader(fi, MacroCommand.ENCODING); br = new BufferedReader(ir); String lineTxt = null; while (!StringUtils.isBlank((lineTxt = br.readLine()))) &#123; JSONObject jo = JSONObject.parseObject(lineTxt); String className = jo.get(&quot;type&quot;).toString(); Command cmd = null; if (DrawCommand.class.getName().equals(className)) &#123; cmd = new DrawCommand(this.canvas, new Point(Integer.parseInt(jo.get(&quot;pointX&quot;).toString()), Integer.parseInt(jo.get(&quot;pointY&quot;).toString()))); &#125; else if (ColorCommand.class.getName().equals(className)) &#123; cmd = new ColorCommand(this.canvas, new Color(Integer.parseInt(jo.get(&quot;colorRGB&quot;).toString()))); &#125; else if (BrushCommand.class.getName().equals(className)) &#123; cmd = new BrushCommand(this.canvas, Integer.parseInt(jo.get(&quot;brushWidth&quot;).toString())); &#125; if (null != cmd) this.append(cmd); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; br.close(); ir.close(); fi.close(); &#125; catch (Exception ef) &#123; ef.printStackTrace(); &#125; &#125; &#125;&#125; MacroCommand类就是前文提到的，实现了Command接口的指令集。其最核心的字段就是commands了。对于这个字段，我们有两点需要说明： 之所以声明为栈，是为了便于进行撤销操作。 栈的泛型类型是Command，而MacroCommand类本身又实现了Command接口。这意味着commands字段中同样可以添加MacroCommand类型的数据。也就是说，指令集中的某条指令同样可以是另一个指令集，这在MacroCommand类execute()中也有所体现：最终我们是使用递归执行栈中的所有指令的(为防止无限递归下去，我们禁止将自身添加到commands字段中)。这其实是对11.Composite模式的一种应用。 commands是本程序中最核心的字段，其中存储了所有的指令。程序做的所有操作最终其实都是在操作这个字段： 清空画布：即清空commands字段。而后按照commands字段重绘图形，因为commands已被清空，自然就起到了清空画布的效果。 撤销最后一次操作：弹出最后一条指令，而后按照commands字段重绘图形，因为最后一条指令已被弹出，自然就相当于撤销操作了。 保存：将commands中的命令按顺序存储入文件。 读取：将文件中的命令按顺序读取入commands字段，而后依commands重绘图形，起到读档的作用。 DrawCommand类 12345678910111213141516171819202122232425262728293031323334353637package design22.command;import java.awt.Point;import java.util.ArrayList;import java.util.List;import com.alibaba.fastjson.JSONObject;import design22.view.MyCanvas;public class DrawCommand implements Command &#123; private MyCanvas canvas; private Point point; public DrawCommand(MyCanvas canvas, Point point) &#123; this.canvas = canvas; this.point = point; &#125; @Override public void execute() &#123; this.canvas.draw(this.point); &#125; @Override public List&lt;String&gt; strList() &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(1); JSONObject jo = new JSONObject(); jo.put(&quot;type&quot;, DrawCommand.class.getName()); jo.put(&quot;pointX&quot;, this.point.x); jo.put(&quot;pointY&quot;, this.point.y); list.add(jo.toJSONString()); return list; &#125;&#125; 命令：在画布特定的位置上绘制一个点。 ColorCommand类 123456789101112131415161718192021222324252627282930313233343536package design22.command;import java.awt.Color;import java.util.ArrayList;import java.util.List;import com.alibaba.fastjson.JSONObject;import design22.view.MyCanvas;public class ColorCommand implements Command &#123; private MyCanvas canvas; private Color color; public ColorCommand(MyCanvas canvas, Color color) &#123; this.canvas = canvas; this.color = color; &#125; @Override public void execute() &#123; this.canvas.setColor(this.color); &#125; @Override public List&lt;String&gt; strList() &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(1); JSONObject jo = new JSONObject(); jo.put(&quot;type&quot;, ColorCommand.class.getName()); jo.put(&quot;colorRGB&quot;, this.color.getRGB()); list.add(jo.toJSONString()); return list; &#125;&#125; 命令：将画笔变更为特定的颜色。 BrushCommand类 1234567891011121314151617181920212223242526272829303132333435package design22.command;import java.util.ArrayList;import java.util.List;import com.alibaba.fastjson.JSONObject;import design22.view.MyCanvas;public class BrushCommand implements Command &#123; private MyCanvas canvas; private int width; public BrushCommand(MyCanvas canvas, int width) &#123; this.canvas = canvas; this.width = width; &#125; @Override public void execute() &#123; this.canvas.setR(this.width); &#125; @Override public List&lt;String&gt; strList() &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(1); JSONObject jo = new JSONObject(); jo.put(&quot;type&quot;, BrushCommand.class.getName()); jo.put(&quot;brushWidth&quot;, this.width); list.add(jo.toJSONString()); return list; &#125;&#125; 命令：将画笔变更为特定的粗细。 然后是view包： MyCanvas类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package design22.view;import java.awt.Canvas;import java.awt.Color;import java.awt.Graphics;import java.awt.Point;import design22.command.MacroCommand;public class MyCanvas extends Canvas &#123; private static final long serialVersionUID = 1L; private static final Color DEF_COLOR = Color.BLACK; private static final int DEF_R = 10; Color color = MyCanvas.DEF_COLOR; int r = MyCanvas.DEF_R; MacroCommand history = new MacroCommand(this); public MyCanvas(int width, int height) &#123; this.setSize(width, height); this.setBackground(Color.WHITE); &#125; public void paint(Graphics g) &#123; this.init(); this.history.execute(); &#125; public void draw(Point point) &#123; Graphics g = this.getGraphics(); g.setColor(this.color); g.fillOval(point.x - this.r, point.y - this.r, 2 * this.r, 2 * this.r); &#125; public void setColor(Color color) &#123; this.color = color; &#125; public void setR(int r) &#123; this.r = r; &#125; public void init() &#123; this.color = MyCanvas.DEF_COLOR; this.r = MyCanvas.DEF_R; &#125;&#125; 即为自己实现的画板类。 View类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162package design22.view;import java.awt.Color;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.MouseEvent;import java.awt.event.MouseMotionAdapter;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;import java.util.ArrayList;import java.util.List;import javax.swing.Box;import javax.swing.BoxLayout;import javax.swing.ButtonGroup;import javax.swing.JButton;import javax.swing.JCheckBox;import javax.swing.JFrame;import design22.command.BrushCommand;import design22.command.ColorCommand;import design22.command.Command;import design22.command.DrawCommand;public class View extends JFrame implements ActionListener &#123; private static final long serialVersionUID = 1L; MyCanvas canvas = new MyCanvas(50 * 16, 50 * 9); private int maxBrush = 20; private List&lt;JCheckBox&gt; brushBoxs = new ArrayList&lt;JCheckBox&gt;(); private List&lt;ColorBox&gt; colorBoxs = new ArrayList&lt;ColorBox&gt;(); private List&lt;JButton&gt; buttons = new ArrayList&lt;JButton&gt;(); public View() &#123; // 制作按钮 this.buttons.add(new JButton(&quot;清空&quot;)); this.buttons.add(new JButton(&quot;撤销&quot;)); this.buttons.add(new JButton(&quot;保存&quot;)); this.buttons.add(new JButton(&quot;读取&quot;)); for (JButton button : this.buttons) button.addActionListener(this); // 制作颜色CheckBox this.colorBoxs.add(new ColorBox(Color.BLACK, &quot;黑&quot;, this)); this.colorBoxs.add(new ColorBox(Color.DARK_GRAY, &quot;深灰&quot;, this)); this.colorBoxs.add(new ColorBox(Color.GRAY, &quot;灰&quot;, this)); this.colorBoxs.add(new ColorBox(Color.LIGHT_GRAY, &quot;浅灰&quot;, this)); this.colorBoxs.add(new ColorBox(Color.BLUE, &quot;蓝&quot;, this)); this.colorBoxs.add(new ColorBox(Color.CYAN, &quot;青&quot;, this)); this.colorBoxs.add(new ColorBox(Color.GREEN, &quot;绿&quot;, this)); this.colorBoxs.add(new ColorBox(Color.MAGENTA, &quot;洋红&quot;, this)); this.colorBoxs.add(new ColorBox(Color.RED, &quot;红&quot;, this)); this.colorBoxs.add(new ColorBox(Color.PINK, &quot;粉&quot;, this)); this.colorBoxs.add(new ColorBox(Color.ORANGE, &quot;橘&quot;, this)); this.colorBoxs.add(new ColorBox(Color.YELLOW, &quot;黄&quot;, this)); ButtonGroup colorGroup = new ButtonGroup(); for (ColorBox colorBox : this.colorBoxs) &#123; colorBox.checkBox.addActionListener(this); colorGroup.add(colorBox.checkBox); &#125; // 制作画笔CheckBox ButtonGroup brushGroup = new ButtonGroup(); for (int i = 1; i &lt;= this.maxBrush; i++) &#123; JCheckBox brushCheckBox = new JCheckBox(i + &quot;&quot;, i == this.canvas.r); this.brushBoxs.add(brushCheckBox); brushCheckBox.addActionListener(this); brushGroup.add(brushCheckBox); &#125; // 画布拖动监听 this.canvas.addMouseMotionListener( new MouseMotionAdapter() &#123; @Override public void mouseDragged(MouseEvent e) &#123; Command cmd = new DrawCommand(View.this.canvas, e.getPoint()); View.this.canvas.history.append(cmd); cmd.execute(); &#125; &#125; ); // 布局 Box firstBox = new Box(BoxLayout.X_AXIS); for (JButton button : this.buttons) firstBox.add(button); Box secondBox = new Box(BoxLayout.X_AXIS); Box brushBox = new Box(BoxLayout.Y_AXIS); for (JCheckBox temp : this.brushBoxs) brushBox.add(temp); secondBox.add(brushBox); secondBox.add(this.canvas); Box colorBox = new Box(BoxLayout.Y_AXIS); for (ColorBox temp : this.colorBoxs) colorBox.add(temp.checkBox); secondBox.add(colorBox); Box mainBox = new Box(BoxLayout.Y_AXIS); mainBox.add(firstBox); mainBox.add(secondBox); super.getContentPane().add(mainBox); // 关闭 this.addWindowListener( new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125; &#125; ); // 显示 super.pack(); super.setVisible(true); &#125; @Override public void actionPerformed(ActionEvent e) &#123; for (JButton button : this.buttons) &#123; if (e.getSource() == button) &#123; if (&quot;清空&quot;.equals(button.getText())) &#123; this.canvas.history.clear(); this.canvas.repaint(); &#125; else if (&quot;撤销&quot;.equals(button.getText())) &#123; this.canvas.history.undo(); this.canvas.repaint(); &#125; else if (&quot;保存&quot;.equals(button.getText())) &#123; this.canvas.history.save(); &#125; else if (&quot;读取&quot;.equals(button.getText())) &#123; this.canvas.history.load(); this.canvas.repaint(); &#125; return; &#125; &#125; for (ColorBox colorBox : this.colorBoxs) &#123; if (e.getSource() == colorBox.checkBox) &#123; Command cmd = new ColorCommand(this.canvas, colorBox.color); this.canvas.history.append(cmd); cmd.execute(); return; &#125; &#125; for (JCheckBox brushBox : this.brushBoxs) &#123; if (e.getSource() == brushBox) &#123; Command cmd = new BrushCommand(this.canvas, Integer.parseInt(brushBox.getText())); this.canvas.history.append(cmd); cmd.execute(); return; &#125; &#125; &#125;&#125;class ColorBox &#123; Color color; JCheckBox checkBox; String desc; ColorBox (Color color, String desc, View view) &#123; this.color = color; this.checkBox = new JCheckBox(desc, this.color == view.canvas.color); &#125;&#125; View负责创建及调用命令。方式主要有两种。 第一种为创建命令并直接调用。以切换颜色为例，会触发actionPerformed()监听事件。从代码中可以看到，我们会创建并直接执行命令。当然，我们也会将该命令存入MacroCommand类的commands字段中，以形成存档，View作为面板，每个实例都会创建并绑定一个MyCanvas(画布)类的实例，而每一个画布，同样会创建并绑定一个MacroCommand类的实例：在MyCanvas中，这个MacroCommand被称为history。 第二种并不会创建新命令，但会导致commands中的已有命令会被重新全部执行一遍。例如当我们按下”撤销”按钮后，会触发actionPerformed()方法。其中undo()会导致commands中最新的命令被弹出，而repaint()则会先清空画布，而后将commands中剩余的命令重新执行一遍。 save.txt 我们会在save包下存放存档。该存档只有一份，反复存档只会导致存档覆盖。因为拖动时每一个点都会生成1条命令，因此这个文件行数通常都会很多。上文绘制房子的那个存档文件就有16000+的行数。现只截取最开始的那部分： 12345678910111213141516171819202122232425&#123;&quot;brushWidth&quot;:20,&quot;type&quot;:&quot;design22.command.BrushCommand&quot;&#125;&#123;&quot;colorRGB&quot;:-16711936,&quot;type&quot;:&quot;design22.command.ColorCommand&quot;&#125;&#123;&quot;pointX&quot;:4,&quot;pointY&quot;:411,&quot;type&quot;:&quot;design22.command.DrawCommand&quot;&#125;&#123;&quot;pointX&quot;:6,&quot;pointY&quot;:411,&quot;type&quot;:&quot;design22.command.DrawCommand&quot;&#125;&#123;&quot;pointX&quot;:8,&quot;pointY&quot;:411,&quot;type&quot;:&quot;design22.command.DrawCommand&quot;&#125;&#123;&quot;pointX&quot;:10,&quot;pointY&quot;:411,&quot;type&quot;:&quot;design22.command.DrawCommand&quot;&#125;&#123;&quot;pointX&quot;:13,&quot;pointY&quot;:411,&quot;type&quot;:&quot;design22.command.DrawCommand&quot;&#125;&#123;&quot;pointX&quot;:16,&quot;pointY&quot;:411,&quot;type&quot;:&quot;design22.command.DrawCommand&quot;&#125;&#123;&quot;pointX&quot;:20,&quot;pointY&quot;:411,&quot;type&quot;:&quot;design22.command.DrawCommand&quot;&#125;&#123;&quot;pointX&quot;:25,&quot;pointY&quot;:411,&quot;type&quot;:&quot;design22.command.DrawCommand&quot;&#125;&#123;&quot;pointX&quot;:29,&quot;pointY&quot;:411,&quot;type&quot;:&quot;design22.command.DrawCommand&quot;&#125;&#123;&quot;pointX&quot;:32,&quot;pointY&quot;:411,&quot;type&quot;:&quot;design22.command.DrawCommand&quot;&#125;&#123;&quot;pointX&quot;:35,&quot;pointY&quot;:411,&quot;type&quot;:&quot;design22.command.DrawCommand&quot;&#125;&#123;&quot;pointX&quot;:37,&quot;pointY&quot;:411,&quot;type&quot;:&quot;design22.command.DrawCommand&quot;&#125;&#123;&quot;pointX&quot;:40,&quot;pointY&quot;:411,&quot;type&quot;:&quot;design22.command.DrawCommand&quot;&#125;&#123;&quot;pointX&quot;:42,&quot;pointY&quot;:411,&quot;type&quot;:&quot;design22.command.DrawCommand&quot;&#125;&#123;&quot;pointX&quot;:45,&quot;pointY&quot;:411,&quot;type&quot;:&quot;design22.command.DrawCommand&quot;&#125;&#123;&quot;pointX&quot;:48,&quot;pointY&quot;:411,&quot;type&quot;:&quot;design22.command.DrawCommand&quot;&#125;&#123;&quot;pointX&quot;:52,&quot;pointY&quot;:411,&quot;type&quot;:&quot;design22.command.DrawCommand&quot;&#125;&#123;&quot;pointX&quot;:54,&quot;pointY&quot;:411,&quot;type&quot;:&quot;design22.command.DrawCommand&quot;&#125;&#123;&quot;pointX&quot;:56,&quot;pointY&quot;:411,&quot;type&quot;:&quot;design22.command.DrawCommand&quot;&#125;&#123;&quot;pointX&quot;:60,&quot;pointY&quot;:411,&quot;type&quot;:&quot;design22.command.DrawCommand&quot;&#125;&#123;&quot;pointX&quot;:63,&quot;pointY&quot;:411,&quot;type&quot;:&quot;design22.command.DrawCommand&quot;&#125;&#123;&quot;pointX&quot;:67,&quot;pointY&quot;:411,&quot;type&quot;:&quot;design22.command.DrawCommand&quot;&#125;&#123;&quot;pointX&quot;:72,&quot;pointY&quot;:412,&quot;type&quot;:&quot;design22.command.DrawCommand&quot;&#125; 最后是直接位于design22包下的Main.java： 12345678910package design22;import design22.view.View;public class Main &#123; public static void main(String[] args) &#123; new View(); &#125;&#125; 执行该类后，即可启动程序。 登场角色上面的示例程序介绍了Command模式的Java实现，下面咱们试着跳出语言层面，抽象出Command模式中登场的角色。 Command(命令) 在示例程序中，由Command接口扮演这个角色。 ConcreteCommand(具体的命令) 在示例程序中，由MacroCommand类，DrawCommand类，ColorCommand类，BrushCommand类联袂扮演这个角色。 Receiver(接收者) 接收命令，或是受命令影响的角色。在示例程序中，由MyCanvas类扮演这个角色。 Invoker(发动者) Invoker是Command的触发者(通常也是创建者)。在示例程序中，由View类扮演这个角色。 适配器在此，我想说点与Command模式没什么关系的事。 在示例程序中，View实现监听的方式是写匿名的适配器类。例如我们在为画布添加拖动鼠标的监听时，是这样做的： 12345678910this.canvas.addMouseMotionListener( new MouseMotionAdapter() &#123; @Override public void mouseDragged(MouseEvent e) &#123; Command cmd = new DrawCommand(View.this.canvas, e.getPoint()); View.this.canvas.history.append(cmd); cmd.execute(); &#125; &#125;); 我们不妨稍微看下源码。这个this.canvas.addMouseMotionListener()的方法定义为： 1public synchronized void addMouseMotionListener(MouseMotionListener l) 很显然，它接收一个MouseMotionListener类型的数据，而这个MouseMotionListener则是一个接口： 1234567891011package java.awt.event;import java.util.EventListener;public interface MouseMotionListener extends EventListener &#123; public void mouseDragged(MouseEvent e); public void mouseMoved(MouseEvent e);&#125; 上面是MouseMotionListener接口的全部源码。其中mouseDragged()表示”按住鼠标拖动”这一事件；而mouseMoved()则表示鼠标移动事件。 那么自然，我们传入的这个MouseMotionAdapter就该实现MouseMotionListener啦，那么是不是呢： 12345678package java.awt.event;public abstract class MouseMotionAdapter implements MouseMotionListener &#123; public void mouseDragged(MouseEvent e) &#123;&#125; public void mouseMoved(MouseEvent e) &#123;&#125;&#125; 代码不长，我就全部贴出了。可以看到，MouseMotionAdapter除了将接口中约束的两个方法声明非抽象的以外，实际上什么都没做。 其实比起这种使用匿名内部类，也就是适配器的做法，我们其实可以直接找一个类实现MouseMotionListener接口，然后将这个类的实例传给addMouseMotionListener()方法(通常来说，我们会让面板去实现这个接口，也就是说传入this)。那么二者各有什么利弊呢？ 先说说使用匿名类的好处吧。如果要自己写一个类去实现监听接口，这就意味着必须要强制实现接口中所有约束的方法。例如，此时我们就必须实现mouseMoved()了，即便我们根本不关心鼠标移动事件，那也要写一个空方法放在那里才行。这在接口本身约束很多(例如WindowListener)，而实际用到的很少时尤其的麻烦：我们需要写大量的空方法，使得代码有失优雅。而使用适配器类则解决了这个问题。MouseMotionAdapter被声明为了抽象类，但其中并没有抽象方法。这样做的原因有二：类被声明为抽象的是不希望直接new出对象来，要写继承的子类才行；而方法均不是抽象的则让自己只需要重写需要的约束即可。 然后说一下继承接口的好处。使用匿名类的问题在于，每次使用都会初始化一个新的匿名类，在需要多次使用同一个监听时将会很不方便。如果专门弄一个类去监听，又显得小题大做。当然，直接让面板或其他组件更是糟糕的决策：从使用上讲，因为Java是单继承的语言，这会消耗掉宝贵的继承机会；另一方面，组件根本就不是监听器，也就是根本不符合里氏替换原则及合成聚合复用原则，从逻辑上更是说不通。因此，此时让面板直接实现接口就成为了最好的选择：View便直接实现了ActionListener，而后将需要此监听的按钮及选框均与其绑定。]]></content>
      <categories>
        <category>Java 设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 设计模式-21.Proxy模式]]></title>
    <url>%2F2018%2F09%2F05%2FJava%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-21Proxy%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在《图解设计模式》一书中，Proxy模式被归入了第9部分避免浪费。在GoF原书中，Proxy模式则被归入了结构型设计模式。 综述在日常生活中，我们常会遇到如下类似的情况： 场景1：消费者(角色1)想买菜，于是他找到商人(角色2)，商人卖给消费者他从菜农(角色3)那收上来的菜。 场景2：产品经理(角色2)收集用户(角色1)的需求，将其汇总整理后提给程序员(角色3)。 场景3：用户(角色1)发现了产品的问题，于是他打电话给客服(角色2)，客服再将问题转交给技术人员(角色3)。 虽然场景不同，但是上述示例均由如下3个角色构成： 角色1：提出需求的人 角色2：将角色1的需求转交给角色3 角色3：实际完成需求的人 这么来看，角色二似乎是可有可无的。这也是为什么在古代商人一直遭人轻贱的重要原因之一。直至今日，也总会冒出下面这样的广告，试图甩掉角色2： 那么实际上是这样的吗？ 当然不是。 客观的说，如果必须要在这3个角色中拿掉一个的话，那么还是会拿掉角色2。因为角色1与角色3构成了事件的根基，二者如果缺了任一个事件本身就进展不下去了，这也是为什么我们会觉得角色2可有可无的原因。但是如果如果没有角色2，角色1与角色3的沟通将异常艰难，也很难形成健康的关系。这就好比物质基础与精神追求哪一个对人更重要那样：如果硬要只能选一个的话，那肯定是物质基础，毕竟活下去是前提条件。但是如果成为一个健全的人，精神追求是必不可少的。 我们可以具体分析一下角色2的作用。在上述需求中，角色3作为实际需求的处理者，往往不愿意，或者说是没能力直接对接角色1。我们以场景2为例。假如没有了产品经理，客户直接与程序员对接。那么在客户看来，我就只是说加一个按钮，面前这个家伙就神神叨叨的说了一大堆自己听不懂的专业名词；而在程序员看来，面前的这家伙就是个SB，提的都是什么智障需求，感觉做什么似乎都很容易。换句话说，我们需要这样一个角色，他既能听懂程序员在说什么，也知道说什么客户能听懂，这自然就是角色2，产品经理啦。 不仅如此，在所有场景中，角色1一般都是远多于角色3的。而每个角色1的需求又总会略有不同。如果角色1与角色3直接碰面。那么角色3就不得不面对形形色色的需求。但实际上，角色3通常都只会完成一个或者至多几个原型，将哪个原型交给哪个角色1，或者是将哪个原型微调1下交给角色1，这又是角色2的工作了。 简单来说，虽然角色3最终的目的是为角色1服务，但是在具体的需求中，角色3通常是无法面面俱到考虑到角色1所有的需求的。此时就需要角色2，也就是代理登场了。角色1与角色3完成了解耦，而角色2则承担起了代理人的作用。 由此，演化出来的设计模式就是Proxy模式。 说到这里，我们很容易就会想到另一个设计模式：2.Adapter模式。在Adapter模式中，也有如下3个角色： 角色1：需要数据 角色2：转换数据格式以适配 角色3：提供数据 这样看来，二者确实极为接近。不过，二者最本质的不同在于角色2，也就是各自的核心角色。在Adapter模式中，角色2被称为适配器，它只承载很简单的转换的功能，我们以显示器通过适配器连接主机为例，显示器(角色1)很明确最终数据还是主机(角色3)提供的，只不过格式对不上，因此需要适配器(角色2)转换一下，此时，角色2只是一个小小的原件。而在Proxy模式中，角色2被称为代理，顾名思义，在角色1看来，角色3仿佛是不存在的。或者说，角色2就是角色3。举个例子，作为消费者(角色1)，当我们向菜贩(角色2)买菜时，我们根本不会关心菜到底是哪个菜农(角色3)种的。 不仅如此，适配器仅仅只是在转换数据，不具有任何制造数据的能力。而在代理存在的场景中，角色1的核心需求由角色3完成。这意味着，对于一些不那么核心的需求而言，代理则无需麻烦角色3。以上文的场景3为例，客服并不会将用户所有的投诉都反馈给技术人员，对于那些明显简单或者明显逗逼的投诉客服自己就会处理掉 – 这是非常重要的，正如我们前文讲到的，在应用代理的场景下，角色1的数量往往远多于角色3。代理的这种能力能够在很大程度上缓解角色3的压力。 示例程序下面我们来看一个应用了Proxy模式的小例子。该程序会通过代理(角色2)为调用者(角色1)找到工人(角色3)。首先是类图： 本程序中的所有代码将被统一置于design21包下，结构如下： 下面将逐个贴出每个类的源码。 Workable接口 12345678package design21;public interface Workable &#123; String getType(); void work();&#125; Worker类 1234567891011121314151617181920package design21;public class Worker implements Workable &#123; private String type; Worker(String type) &#123; this.type = type; &#125; @Override public String getType() &#123; return this.type; &#125; @Override public void work() &#123; System.out.println(this.type + &quot;在工作&quot;); &#125;&#125; WorkerProxy类 1234567891011121314151617181920212223package design21;public class WorkerProxy implements Workable &#123; private Worker worker; private String type; public WorkerProxy(String type) &#123; this.type = type; &#125; @Override public String getType() &#123; return this.type; &#125; @Override public void work() &#123; if (null == worker) this.worker = new Worker(this.type); this.worker.work(); &#125;&#125; Main类 12345678910package design21;public class Main &#123; public static void main(String[] args) &#123; Workable worker = new WorkerProxy(&quot;水暖工&quot;); System.out.println(worker.getType()); worker.work(); &#125;&#125; 执行后，输出： 12水暖工水暖工在工作 代码整体比较简单，不过还是有如下几点需要说明一下，大家可以对照着前文的综述加深理解。 本程序中，Main类是角色1，WorkerProxy类是角色2，而Worker类则是角色3。剩下的Workable接口则是抽象WorkerProxy与Worker后得到的。如果仅讨论Proxy模式最核心的功能，那么是不需要Workable，此时Main只能感知得到WorkerProxy。而在引入了Workable之后(通常我们都是会引入的)，Main连WorkerProxy都无需感知了。在示例程序中，WorkerProxy实例是在main方法中new出来的，这可能会给大家造成误解，不过在更常见的场景中，这个Workable应该是作为参数传递给角色1的，角色1根本不需要也不想要了解这个Workable到底是什么：这确实很合乎逻辑，对于调用者而言，他要的就是一个工人，或者更具体的来说，他要的不是工人，他要的是工作被完成。所以对调用者而言，其实他根部不在意这个Workable具体是个啥，到底做了啥，什么代理，什么委托，和调用者都没半毛钱的关系。因此抽象出Workable可以将调用者很好的与其他的角色解耦。 然后是问题二，调用者只需要一个Workable我们已经理解了。但是为什么要让WorkerProxy与Worker均实现Workable呢？换句话说，代理是代理，工人是工人。为什么要让角色2与角色3实现相同的接口呢？ 这样的好处在于，代理与工人因此就具备了统一性。从逻辑上讲，对于调用者而言，为他服务的这个Workable其实只有一个身份：”能帮助自己完成工作的人”。至于这个人是自己亲自做还是委托给他人调用者并不在意，从这个角度来看，角色2与角色3的身份确实是统一的；从实际的代码结构来看，代理是可以分级的。换句话说，代理找到的并不一定是真正的工人，它还有可能是另一个代理，只要身份统一，它就可以扮演工人的角色。很显然，这是对11.Composite模式的应用。 正因为如此，这种将WorkerProxy与Worker统一起来的方式也成为了Proxy模式的默认思路。只不过，这同样会产生一些问题。因为Workable是调用者需要的接口，换句话说，它内部约束的那些方法就是调用者提出的需要。让WorkerProxy实现这个接口倒没什么。但是让Worker直接暴露在调用者的需求下却不太妥当。正如前文分析过的，角色3通常只会生成少量的几个原型，代理有一个很重要的工作就是将这几个原型稍加修改从而适应千变万化的需求。因此某些场景下，我们也会将角色2与角色3严格分隔开。这样角色1提出的需求对于角色3而言就是完全透明的了。 对于Main而言，当new出WorkerProxy时，它就认为工人已经生成好了。但是实际上，直到work()方法被调用之前，其实都并没有真正的生成工人。这其中还包括一个worker.getType()，也就是说main还像模像样的获取了一下工人的类型。只不过，该功能其实是被代理直接完成了，并不需要真正的工人(还记得综述中那个客服的例子吗)，因此依然不需要生成工人。直到不生成不行，也就是要让工人工作的时候，代理才通过懒加载的方式创建了工人，而后委托工人工作。这样就对工人的生成尽可能的做出了推迟，在系统规模较大时，这种将操作尽量移出初始化的做法可以极大的减少系统的启动时间。 在本示例中，Worker是无需感知到WorkerProxy的，这是理所当然的。而WorkerProxy为了能够将工作委托给Worker，则必须能够感知得到Worker才行(示例程序将Worker加为了WorkerProxy的字段)，这在逻辑上也是说得通的。不过在实际应用中，为了进一步提高灵活性，角色2与角色3也会解耦，即代理也不会记录实际工作的人是谁。在需要实际工人时，我们传递一个一个标志给代理，告诉它：”我要用这个工人！”。通常这会是一个表征类的字符串，然后代理会通过反射将其解析出来。这样的坏处在于：虽然将角色2与角色3进行了解耦，但需要在调用时由角色1告知角色2要用哪个角色3，无形中又将角色1与角色3耦合在了一起，所以其实是有利有弊。 登场角色上面的示例程序介绍了Proxy模式的Java实现，下面咱们试着跳出语言层面，抽象出Proxy模式中登场的角色。 Subject(主体功能) Subject抽象出了调用者的需求。Proxy与Real也因为Subject而具有了一致性。在示例程序中，由Workable接口扮演这个角色。 Real(实际的工人) 在示例程序中，由Worker类扮演这个角色。 Proxy(代理人) 在示例程序中，由WorkerProxy类扮演这个角色。 Client(请求者) 在示例程序中，由Main类扮演这个角色。 下面是抽象后，无关语言的类图： HTTP代理提到代理，我们很容易想到HTTP代理。HTTP代理是指位于HTTP服务器(Web服务器)和HTTP客户端(Web浏览器)之间的一组软件。我们可以把其看作是对Proxy模式的一种应用。其中，HTTP服务器是Real，HTTP代理是Proxy，Web浏览器则是Client。我们不妨以HTTP代理的缓存功能来说明一下。在我们通过Web浏览器访问Web页面时，并非每次都会真的去访问HTTP服务器，而是会先去获取HTTP代理缓存的页面，只有当没有缓存，缓存有更新或是缓存失效时才会真的去访问Web浏览器。 代理的各种形式Virtual Proxy(虚拟代理) 本文介绍的Proxy模式及给出的示例采用的就是这种方式，也是最基本的代理。只有当真正需要实例时才会生成。 Remote Proxy(远程代理) 当Real角色处于网络远端时，Remote Proxy可以让我们仿佛使用本地实例那样使用它们。Java的RMI(Remote Method Invocation，远程方法调用)就是Remote Proxy的应用。 Access Proxy 较之普通的Proxy，Access Proxy引入了访问权限。即我们可以只允许指定的用户调用指定的方法。]]></content>
      <categories>
        <category>Java 设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 设计模式-20.Flyweight模式]]></title>
    <url>%2F2018%2F09%2F04%2FJava%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-20Flyweight%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在《图解设计模式》一书中，Flyweight模式被归入了第9部分避免浪费。在GoF原书中，Flyweight模式则被归入了结构型设计模式。 综述flyweight这个单词的释义为”次最轻量级的拳击选手”。顾名思义，Flyweight模式的目的就是让对象”变轻”。更具体的来说，是让对象消耗的资源变少。其中最易于理解的消耗自然就是内存占用了。通俗来说，Flyweight模式就是在通过共享实例来尽量避免new出实例(少进行new的操作其实也相当于减少了时间的消耗，只是这没有内存减耗那么明显)。JVM所管理的”字符串常量池”遵循的其实也是类似的思想。 示例程序下面来看一段应用了Flyweight模式的小例子。首先我们有0-9这10个数字的10张png图片： 我们希望在输入一段数字后，程序能通过拼接这10张素材图片，从而生成一张新的图片。这里就用我的女神，苏联卫国战争时期的王牌女飞行员，被称为”斯大林格勒的白百合”的莉莉娅的生日为例吧 女神(↓↓) 输入19210818后，程序最终会输出： 在具体编写代码之前，我们可以先思考一下如何去做。最为简单的思路就是需要什么我们就去加载什么。如果我们将每一张原始的素材图片都视为一个对象的话，那么，对于19210818而言，毫无疑问，我们需要生成8个这样的图片对象。然后将这8个对象拼接为一个新的对象。显然，这是可行的做法。但这真的是最优的做法吗？ 当然不是。 细心的朋友们应该都已经注意到了，虽然最终拼接需要8个对象，但实际用到的数字只有”19208”这5个，有3个数字是重复的。省掉这3个重复的数字的空间就是Flyweight模式要做的工作。 下面就赶快来看代码吧~首先是类图： 本程序中的所有代码将被统一置于design20包下，结构如下： 其中Main.java是测试代码，并没有出现在类图中。而img包下则是前文展示的那10张数字素材图片。 下面将逐个贴出每个类的源码。 Img类 1234567891011121314151617181920212223package design20;import java.awt.image.BufferedImage;import java.io.IOException;import javax.imageio.ImageIO;import design19.view.View;public class Img &#123; int number; BufferedImage image; Img(int number) &#123; try &#123; this.image = ImageIO.read(View.class.getClassLoader().getResource(&quot;design20/img/&quot; + number + &quot;.png&quot;)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; ImgFactory类 12345678910111213141516171819202122232425262728package design20;import java.awt.image.BufferedImage;import java.util.HashMap;import java.util.Map;public class ImgFactory &#123; private Map&lt;Integer, Img&gt; pool = new HashMap&lt;Integer, Img&gt;(); private static ImgFactory SINGLETON; public static final int WIDTH = 88; public static final int HEIGHT = 151; private ImgFactory() &#123;&#125; public static ImgFactory getInstance() &#123; if (null == ImgFactory.SINGLETON) ImgFactory.SINGLETON = new ImgFactory(); return ImgFactory.SINGLETON; &#125; public BufferedImage getNumImg(int number) &#123; if (!this.pool.containsKey(number)) this.pool.put(number, new Img(number)); return this.pool.get(number).image; &#125;&#125; 从逻辑的角度分析，生产Img的工厂是一个独立的个体，因此应该允许其生成实例而非使用类方法。同时工厂又只需要有一个，因此应用了5.Singleton模式。 对外界而言，是否应用Flyweight模式并没有什么不同。因为他们只是在调用getNumImg()方法获得自己想要的数字对应的图片。至于这个图片是新生成的还是复用之前已经存在的，他们并不在意。而在ImgFactory内部，我们创建了一个存储Img的”池”pool：调用方传入的数字千千万万，但池中最多只会存储0-9共计十张图片，这就从一定程度上节省了内存的开销。 虽然与Flyweight模式无关，本程序还在试图从另一个维度上节省开销。本文在创建Img的策略上采用了懒加载，初始时pool中是空的，只有当获取某个具体数字对应的图片时才会检查该图片是否已在pool中，如果在则返回，反之则创建后返回。这相当于将图片初始化的时间由pool的初始化推迟至调用时。不仅如此，我们还可以很容易想到，如果某个数字就是不会被调用，那么它永远不会被初始化，和一开始就全部初始化好相比，不仅节省了时间，还节省了空间。 当然，懒加载对时间的节省只是相对的。它能让程序启动时间大大减少。但正所谓出来混总是要还的，既然要使用，那么终究还是要初始化的，懒加载只是将初始化的实际延后了。不仅如此，这种延后还要付出更大的时间代价：如果最初就将pool中的图片全部初始化好，那么在getNumImg()时直接返回即可，因为我们确信此时pool中已经有了所有需要的图片了。反之，使用懒加载后，每次取图片时都需判断图片是否已经生成，反而相当于增加了时间开销。因此，是否使用懒加载，完全是要根据实际情况具体问题具体分析的。 Main类 123456789101112131415161718192021222324252627package design20;import java.awt.image.BufferedImage;import java.io.File;import java.io.IOException;import javax.imageio.ImageIO;public class Main &#123; public static void main(String[] args) throws IOException &#123; Main.createImg(&quot;19210818&quot;); &#125; private static void createImg(String str) throws IOException &#123; int length = str.length(); BufferedImage bufferedImage = new BufferedImage(ImgFactory.WIDTH * length, ImgFactory.HEIGHT, BufferedImage.TYPE_INT_RGB); for (int i = 0; i &lt; length; i++) &#123; int tempNum = Integer.parseInt(str.substring(i, i + 1)); BufferedImage tempImg = ImgFactory.getInstance().getNumImg(tempNum); for (int y = 0; y &lt; tempImg.getHeight(); y++) for (int x = 0; x &lt; tempImg.getWidth(); x++) bufferedImage.setRGB(x + i * ImgFactory.WIDTH, y, tempImg.getRGB(x, y)); &#125; ImageIO.write(bufferedImage, &quot;jpg&quot;, new File(&quot;D:\\img.jpg&quot;)); &#125;&#125; 执行后，即可得到前文展示的结果。 登场角色上面的示例程序介绍了Flyweight模式的Java实现，下面咱们试着跳出语言层面，抽象出Flyweight模式中登场的角色。 Flyweight(轻量级类) 即可共享的类，在示例程序中，由Img类扮演这个角色。 FlyweightFactory(轻量级类工厂) 即控制Flyweight共享情况的工厂。在示例程序中，由ImgFactory类扮演这个角色。 下面是抽象后，无关语言的类图： Intrinsic与ExtrinsicFlyweight模式的核心在于共享实例。这里隐含着一个前提，那就是必须先判断实例能否被共享(因为共享实例的改变，会导致所有用到它的地方所得到的实例均会发生变化)，只有能被共享的实例，才有资格进一步考虑到底要不要共享。在编程领域，可以被共享的信息被称为Intrinsic信息，Intrinsic意思是”本质的，固有的”，顾名思义，这是指那些不会因调用环境不同而改变的信息；相对的，不能被共享的信息被称为Extrinsic信息，Extrinsic的含义是”外在的，非本质的”。 依这种思路来分析，类字段均应是Intrinsic信息，被定义为单例的实例中存储的也均应是Intrinsic信息。 在本示例中，每个数字对应的图片是唯一且不可变的，属于Intrinsic信息，当我们输入数字”11”时，这两个1对应的都是那同一张代表1的图片，因此这些图片实例可以成为Flyweight角色被共享。]]></content>
      <categories>
        <category>Java 设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 设计模式-19.State模式]]></title>
    <url>%2F2018%2F08%2F31%2FJava%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-19State%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在《图解设计模式》一书中，State模式被归入了第8部分管理状态。在GoF原书中，State模式则被归入了行为型设计模式。 综述在面向对象编程领域，有这样一句话：一切都是对象，对象就是一切。这话虽说有些绝对了，但也从一个侧面说明对象在面向对象编程领域的普遍性。在我们通常的认知中，对象指的是某个具体的事物，例如一张桌子，一把椅子。但是对象其实还可以表示一些抽象的事物，例如本文要提到的”状态”。 漫画《七龙珠》的主人公是卡卡罗特(孙悟空)。将卡卡罗特看作一个对象是比较好理解的。但我们同样也可以将卡卡罗特所处于的状态视为对象。例如我们可以将普通状态视为一个类，超级赛亚人状态视为另一个类。这样再描述卡卡罗特所处于的状态时，就可以用具体状态的实例来表示。 普通状态(左)与超级赛亚人状态(右)下的卡卡罗特： 在编程领域，由此演化而来的设计模式就是State模式。以类来表示状态后，我们就能通过切换表示状态的类来方便的改变对象所处于的状态。同时，当需要增加新的状态时(例如为卡卡罗特再增加一个巨猿状态)，条理也会更为清晰。 示例需求描述狂野女猎手-奈德丽(Nidalee)是一位出自游戏英雄联盟(LOL)的女英雄，在描述具体的需求之前，先展示几张她的皮肤原画吧~ 默认 雪装 丛林猎豹 法国女仆 艳后 魅惑女巫(2011年万圣节) 枭姬 孙尚香 勇者 好漂亮啊有没有，尤其是枭姬，英姿勃发。不过我们之所以介绍得这么详细并不完全是因为她生得俊俏(你够了)，而是因为她是具有双形态的英雄。下面就以枭姬这个皮肤的3D模型来展示一下： 人形态 豹形态 奈德丽的R技能为形态切换。在各自的形态下，她有着独立的两套QWE技能(传说中拥有7个主动技能的女人)。本文的示例程序将应用State模式模拟奈德丽的技能释放。 示例需求分析不知不觉中GoF的23种设计模式也快介绍到尾声了(19/23)，之前给出的设计模式的示例程序大多很简单，也很粗糙，其目的仅仅是为了说明某个设计模式的核心思想。本文将打破这一点(毕竟总写一些实验性质的小demo着实无聊)，会写一个相对完整的产品出来。关于奈德丽具体的英雄参数可参见奈德丽数据介绍。本程序会以奈德丽的满级(18级)属性为基础，再进行适当的提升(因为人物是会穿装备的)。 GUI设计技术为Java AWT，程序启动后初始状态如下： 这也是程序的主体面板界面。它的区域介绍如下： 默认形态为人形态。此时： 区域一：人形态是有MP的，因此血条与蓝条均会展示，初始时默认血蓝全满。 区域二：人形态下的立绘采用我最喜欢的枭姬皮肤(啦啦啦)。 区域三：此时展示的是人形态下的技能图标。 当按下键盘上的R键后，即被认为释放了一次R技能(QWE技能同理)，此时奈德丽会从人形态切换为豹形态： 切换后： 区域一：因为奈德丽在豹形态下是没有MP的，因此不绘制蓝条。 区域二：立绘切换为枭姬皮肤的豹形态(没找到太合适的图，比较遗憾)。 区域三：技能图标切换为豹形态。 关于技能图标，有以下几点需要说明： 第一，我们可以注意到上图中豹形态下的R技能”黑了一块”。这表示R技能在冷却。只有当它冷却完成后，我们才能再次释放，以切换为人形态。因为奈德丽的7个技能都是主动技能，因此其他技能的冷却机制同理。 当R技能冷却完成后： 我们可以注意到，相较于人形态，奈德丽的R技能的图标并没有改变。这也是我们要说的第二点，QWE技能是独立的，而R技能只有一个(因此我们才说奈德丽有7个技能，而非8个)。 QWE独立还意味着，QWE技能的冷却时间计算也是独立的，例如我们可以在人形态下快速释放QWE(俗称脸滚键盘)，使他们均进入冷却状态： 此时如果我们再按下R切换为豹形态，我们会发现豹形态下的QWE又是可释放的了，不过R技能因为人豹形态共用一个，因此进入了冷却状态。此时我们可以在豹形态下再QWE脸滚键盘一波： 当R技能冷却完成后，我们又可以切换回人形态，如果我们进行如上人-豹-人的操作的速度足够快，当我们再切回人形态时，情况可能是这样的： R技能又开始接着计算冷却了，这个前文已经介绍过原因，并没有什么。但是除了冷却时间较短的Q技能之外，人形态下的WE技能并没有冷却完。这个效果当我们在R技能冷却好再次切到豹形态时也是同理的(只不过豹形态下技能CD普遍较短，不太容易看出来)。之所以会这样，是因为QWE技能独立同样意味着技能CD独立。举例来说，如果人形态的Q技能的CD为6秒，那么无论如何，它都只能6秒后才能再次释放，我们切换为豹形态会让我们看不到人形态Q技能的CD情况，但也仅仅只是看不到而已，它依然在不停的倒数自身的冷却时间。 由上文的技能CD介绍还能看出的是，人形态下释放QWE技能导致MP减少(蓝条变短)。而豹形态的技能则是无消耗的。R技能作为形态切换的桥梁也是无消耗的。这意味着，豹形态技能的释放只受CD的影响，而人形态在此之上，还需剩余的蓝量大于技能的消耗。 蓝条可以通过技能释放来减少。为了模拟血条减少，我们规定当按下键盘上的X键后，会扣一定数值的血量： 虽然用静态的图片无法表现，不过HP与MP均会按一定速率自动回复。 按照一般游戏的设定，蓝条始终都会是蓝色的，而血条则会在减少的过程中逐渐由绿转黄，再由黄转红(所谓的满血，黄血，红血)。本程序也是如此。上文已经展示了血量比较健康时血条的颜色，下面我们来看一张半血时的： 然后是残血时的： 奈德丽人形态下的E技能会为指向的英雄回复一定的HP，本程序默认会对自身释放，因此人形态释放E技能后会回复一定数值的HP(按照设定，回复量在一个范围之间，HP越低回复量越多)。除此之外，除了R技能会导致形态切换，其他技能(人形态的QW，豹形态的QWE)均为对敌方造成伤害，在本程序中不会有所体现。 当HP降到0时，英雄会死亡： 形态会被定格在死亡的那一刻。届时将不再接受任何键盘输入，也不会提供初始化的方法，只能关掉重来。此时： 区域一：血条当然是清空了。而人形态下的蓝条将定格在死亡的时刻，不再变动。 区域二：立绘将被虚化，同时添加表示阵亡的文字。 区域三：技能图标将被虚化，同时清除可能会存在的尚未完成的CD遮挡。 呼~需求终于大致描述完了。累死我了。 作为一名技术，我们很少会关注产品经理的工作，不过即便是这么小的一个需求，我在整理并力求没有歧义的描述清楚(而且我并不敢说真的就描述清楚了)时，也费了很大的力气。这说明产品经理确实在日常的工作中为我们屏蔽了很多技术不愿意关注的点。之所以会有矛盾冲突，我想大多是因为需求本身就充斥着更多的冲突，没有产品经理，技术将更难以工作。 伪代码分析需求描述完了，下面就来思考一下怎么写。 假设我们只考虑Q技能的释放，那么最容易想到的写法是这样的： 123456789101112类 奈德丽 &#123; 方法 释放Q &#123; if (当前状态为人形态) &#123; 人形态下释放Q &#125; else if (当前状态为豹形态) &#123; 豹形态下释放Q &#125; else &#123; 异常 &#125; &#125;&#125; 这样做当然没什么毛病，但是问题在于每当我们要做什么操作时都需要先判断一下状态。随着状态的增多，代码逻辑的复杂，这种判断的成本将越来越高，同时也越发的不易于维护。 如果使用State模式，我们就可以将形态抽象为类: 12345678910111213类 人形态 &#123; 方法 释放Q &#123; 人形态下释放Q &#125;&#125;类 豹形态 &#123; 方法 释放Q &#123; 豹形态下释放Q &#125;&#125; 此时奈德丽类就可以这样写了： 12345678类 奈德丽 &#123; 字段 当前状态 方法 释放Q &#123; 当前状态.方法 释放Q &#125;&#125; 显然，代码逻辑变得清晰了许多，也更利于维护。 示例代码首先是类图： 因为希望能做出一个相对完整的产品，所以添加了很多无关State模式的代码。因此较之真实的程序，类图将只描述与State模式相关的那一部分。 本程序中的所有代码将被统一置于design19包下，结构如下： 下面将逐个贴出每个类的源码。 首先要说明的是，既然较之此前的设计模式(我想此后的其实也一样)，我费了更大的力气写需求分析。那么我在介绍示例代码时，也打算说得详细一些：并不仅仅是说State模式本身，而是把用到的其他的模式与想法也都详细介绍一下，算是我个人这段时间学习的总结。 程序是以简化版的MVC模式设计的(即只有M与V，没有C)。下面先来介绍M。 Hero类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package design19.model;public abstract class Hero &#123; protected boolean ifDeath; protected int maxHealth = 2 * (370 + 90 * 17); protected int healthRegen = (int)(3 * (1 + 0.12 * 17)); protected int health = maxHealth; protected int ap; public abstract void useQ(); public abstract void useW(); public abstract void useE(); public abstract void useR(); public abstract boolean ifHaveMana(); protected abstract double manaRate(); public abstract String getImgKeyWord(); public abstract double remainQ(); public abstract double remainW(); public abstract double remainE(); public abstract double remainR(); Hero() &#123; // 回血 new Thread() &#123; @Override public void run() &#123; while (true) &#123; if (Hero.this.ifDeath) &#123; Hero.this.health = 0; break; &#125; try &#123; int tempHealth = Hero.this.health + Hero.this.healthRegen; Hero.this.health = tempHealth &gt; Hero.this.maxHealth ? Hero.this.maxHealth : tempHealth; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;.start(); &#125; public boolean isDeath() &#123; return ifDeath; &#125; public void damage(int value) &#123; int tempHealth = this.health - value; if (tempHealth &lt;= 0) &#123; this.ifDeath = true; this.health = 0; return; &#125; this.health = tempHealth; &#125; public double getHealthRate() &#123; return 1.0 * this.health / this.maxHealth; &#125; public double getManaRate() &#123; if (!this.ifHaveMana()) throw new UnsupportedOperationException(); return this.manaRate(); &#125; long remainTime(Skill skill) &#123; long pass = System.currentTimeMillis() - skill.last; return (pass - skill.cd) &gt;= 0 ? 0 : (skill.cd - pass); &#125; boolean check(String mark) &#123; if (this.ifDeath) return false; if (&quot;Q&quot;.equals(mark)) if (this.remainQ() &gt; 0) return false; if (&quot;W&quot;.equals(mark)) if (this.remainW() &gt; 0) return false; if (&quot;E&quot;.equals(mark)) if (this.remainE() &gt; 0) return false; if (&quot;R&quot;.equals(mark)) if (this.remainR() &gt; 0) return false; return true; &#125;&#125; 从逻辑上来说，Hero类与后文要介绍的Skill类是model模块中外部(本程序中是View)能感知到的仅有的两个类。因为英雄联盟有很多位英雄，对于外部调用者而言，针对不同英雄写不同的代码是很不现实的，相反，正如其他MVC中的V那样，V需要的是M能提供一套通用的API。具体到本示例，就是”英雄释放技能，造成影响”。这都是很抽象的东西，换句话说，如果我们将奈德丽换为另一位英雄，例如寒冰射手艾希，View层不应做任何或只应做极少的修改。 因为本示例的逻辑相对简单，因此对外暴露的API仅仅只有Hero类一个。Skill类依逻辑可以暴露API，只是没必要。而model中的其他类则是不准暴露。这点务必要理解透彻才可以。 为了不使得程序看着过于臃肿，除非是需要对外提供的API，model内部各个类之间互相使用字段时尽量都没有写get-set方法，而仅仅只是通过访问权限来屏蔽外界，这在比较严谨的场合(例如实际工作时的代码)往往是不可以的。 之所以将Hero声明为抽象类而非接口，比较直观的解释自然就是我们希望在其中添加一些属于实例的字段及方法，以及我们确信在本程序中继承Hero的Nidalee类不会有其他父类。不过更本质的原因在于，这种继承关系遵循合成聚合复用原则(奈德丽是一位英雄，即ISA)及里氏替换原则，这才是原因所在，最开始说的那个所谓的”直观的解释”，比起原因，更像是由原因导致的现象。 作为LOL这种竞技游戏通常都会有的属性，HP与MP。我只将HP及HP相关的属性作为字段加入到了Hero类中。其原因就在于所有的英雄都有HP，但并不是所有的英雄都会有MP。比如就会有德玛西亚之力盖伦，不祥之刃卡特琳娜这种完全没有MP的英雄，或是盲僧李青，蛮族之王泰达米尔这种拥有能量或是怒气等与MP性质类似的东西的英雄。再或者是甚至像本文介绍的拥有双形态的奈德丽，某个形态下像大多英雄那样拥有MP，某个形态下又像盖伦那样无消耗。基于这个考虑，我将MP沉到了再下一个层级：如果这个英雄有MP，那么就在自己内部添加。而Hero这一层尽量只添加所有英雄都会有的字段。这也是抽象的本质思路所在：抽取相同的部分以形成更高的层级。因为相同的原因，就很容易理解Hero类中剩下的两个字段了：表示是否死亡的ifDeath，以及表示魔法能力的ap值。作为一个英雄，其实还会有更多复杂的属性，例如ad，护甲，魔抗，移速等等。本示例只使用了少量需要的部分。 除了字段之外，我们还将其他对HP的操作都尽量提到了Hero这一层，因为这是所有英雄通用的。我在Hero的构造函数中起了一个线程模拟回血。还提供了damage()方法供外部调用模拟扣血。 use Q/w/E/R方法表示外界按下了一次QWER键。而remain Q/w/E/R方法则返回QWER技能技能CD恢复的百分比。很显然，该值的取值范围为[0,1]。当该值等于0时说明技能没有进入冷却，可以释放(当然仅仅只是冷却好了，人形态下还要蓝够才可以)；而等于1则说明技能刚进入冷却。 ifHaveMana()这个方法会判断英雄是否有蓝条(本程序在设计时就不考虑怒气能量等奇怪的东西了)。依上文所说的MP下沉的思路，这个方法放在Hero类里虽然有点不太美观，但终归是还能接受。而getManaRate()方法就有些诡异了，它返回的是当前MP值占MP最大值的比例，是为了显示蓝条长度用的。由代码不难看出，当外部调用该方法后，会先再判断一次ifHaveMana()，如果返回false，即英雄没有MP，则抛出异常。反之才会调用子类本身计算比例的manaRate()方法，这里运用了Template Method模式。不过这不是重点。我想说的是，对于没有MP的英雄而言，这个方法是根本不该被调用的，这种提供了功能却在内部抛出异常的做法相当于甩锅给调用方，显然是很不优雅的。更有问题的是，明明将MP下沉到了更下一层，却还是在Hero这一层出现了这么具体的计算MP相关值的方法，看着着实扎眼。说了这么多，之所以千不该万不是还是把代码写成了这样，是因为我们在写代码时，比起面面俱到，更多时候是在两害相权取其轻。因为我们要向外界暴露一个通用的Hero而非具体的英雄，那么在外界需要蓝条时，只能做一个这样折中的方案。或是将程序写得更复杂：例如抽象出一个能统合MP，怒气，能量，甚至是无的东西，代表释放技能的代价。不过本程序显然没必要那么复杂就是了。 Skill类 123456789101112131415package design19.model;public class Skill &#123; long cd; long last; int cost; Skill(long cd, int cost) &#123; this.cd = cd; this.cost = cost; &#125;&#125; 相对而言，Skill类就要简单得多了。也没有提供对外的API。 Nidalee类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package design19.model;public class Nidalee extends Hero &#123; Skill skillR = new Skill(4000L, 0); NidaleeState state; public Nidalee() &#123; NidaleeState humanState = new HumanState(this); NidaleeState leopardState = new LeopardState(this); humanState.otherState = leopardState; leopardState.otherState = humanState; this.state = humanState; &#125; @Override public void useQ() &#123; this.state.useQ(); &#125; @Override public void useW() &#123; this.state.useW(); &#125; @Override public void useE() &#123; this.state.useE(); &#125; @Override public void useR() &#123; this.state.useR(); &#125; @Override public boolean ifHaveMana() &#123; return this.state.maxMana &gt; 0; &#125; @Override public double manaRate() &#123; return 1.0 * this.state.mana / this.state.maxMana; &#125; @Override public String getImgKeyWord() &#123; return this.state.type; &#125; @Override public double remainQ() &#123; if (this.ifDeath) return 0.0; return 1.0 * this.remainTime(this.state.skillQ) / this.state.skillQ.cd; &#125; @Override public double remainW() &#123; if (this.ifDeath) return 0.0; return 1.0 * this.remainTime(this.state.skillW) / this.state.skillW.cd; &#125; @Override public double remainE() &#123; if (this.ifDeath) return 0.0; return 1.0 * this.remainTime(this.state.skillE) / this.state.skillE.cd; &#125; @Override public double remainR() &#123; if (this.ifDeath) return 0.0; return 1.0 * this.remainTime(this.skillR) / this.skillR.cd; &#125;&#125; state字段表示奈德丽当前处于的状态。在构造函数中，我们将默认的状态设置为人形态。然后我们又声明了一个豹形态的对象。将人形态与豹形态互相绑定。这意味着，在按下R技能，需要进行形态切换时，Nidalee类是不需要做任何操作的，切换操作将由表示形态的类完成：人形态时变为豹形态，豹形态时变为人形态。进而，Nidalee类在使用state时(我们可以看到，Nidalee类中绝大多数的操作最终实际都是由state完成的)，并不关心当前到底处于什么形态，它都会当做只有一个形态那样去使用。 本程序中，Nidalee类中只会存储一个表示形态的字段。形态的切换由形态本身完成。它并不能统计出当前一共有多少种形态 – 这当然是State模式的设计方式之一。这样的好处在于既然Nidalee类将状态相关的处理都委托给各State类去做，那么”状态切换”显然也是相关处理之一。那么在它被触发的地方直接完成显然是最简洁干脆的做法 – 正如本文所做的那样。不过，这样做的问题在于，State之间需要彼此感知，因为唯有这样，一个State才能知道要切换为谁。这其实并不是十分符合逻辑：因为各State类之间其实是兄弟关系，并没有义务互相感知。从这个思路来想，负责切换的工作应该交给再上一层，也就是这些State类的宿主Nidalee类。此时，Nidalee类就需要记录自己保管的所有State类，以及它们之间的切换逻辑。 奈德丽共有7个不同的技能。我们将人形态的QWE与豹形态的QWE均放在了对应形态的类中，因为我们认为这些技能是属于那个形态特有的。而将人豹共用的R技能提到了Nidalee类中。同理，我们依然没有将MP放到Nidalee类中，而是将它继续下放：因为只有人形态下才有MP，豹形态下没有。 NidaleeState类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package design19.model;public abstract class NidaleeState &#123; protected Nidalee nidalee; protected String type; protected NidaleeState otherState; protected int maxMana; protected int manaRegen; protected int mana; protected Skill skillQ; protected Skill skillW; protected Skill skillE; protected abstract void handleQ(); protected abstract void handleW(); protected abstract void handleE(); NidaleeState(Nidalee nidalee) &#123; this.nidalee = nidalee; &#125; void useQ() &#123; if (!this.nidalee.check(&quot;Q&quot;)) return; if (this.mana &lt; this.skillQ.cost) return; this.skillQ.last = System.currentTimeMillis(); this.handleQ(); &#125; void useW() &#123; if (!this.nidalee.check(&quot;W&quot;)) return; if (this.mana &lt; this.skillW.cost) return; this.skillW.last = System.currentTimeMillis(); this.handleW(); &#125; void useE() &#123; if (!this.nidalee.check(&quot;E&quot;)) return; if (this.mana &lt; this.skillE.cost) return; this.skillE.last = System.currentTimeMillis(); this.handleE(); &#125; void useR() &#123; if (!this.nidalee.check(&quot;R&quot;)) return; this.nidalee.skillR.last = System.currentTimeMillis(); this.nidalee.state = this.otherState; &#125;&#125; NidaleeState类是奈德丽这个英雄特有的，由其双状态提取共性后抽象出的类。正如V需要一个相对通用的Hero那样。Nidalee类也需要一个通用的表示状态的类。对于更上面的层级而言(Hero，View)，奈德丽拥有双形态是其自身内部的事，它们并不会，也不需要感知得到。 另外一个有趣的点是，Hero作为直接暴露在外的类，会提供很多与外部逻辑紧密相关的功能。例如Hero中的ifHaveMana()，而Nidalee作为它的子类也必须实现。但是作为最终工作者的NidaleeState中却没有这个方法 – Nidalee的ifHaveMana()实际是通过判断当前状态的maxMana来实现的。关于这一点我想说的是，外部需求是在不停扩充的，需求也将千变万化。而不论Hero也好，Nidalee也罢，其实都是model模块内部的类。这会导致model与外部需求耦合得过于紧密，不利于代码的维护。而通常的做法是，我们会在M与V之间再加入一个DAO，也就是数据传输层。因为本质上来说，MVC其实就是”V向M要数据”以及”V触发M修改自身的数据”(很少会出现”M主动向V推送数据”的情况，因为下层一般无需对上层负责，毕竟M都是被动的，笑)。而DAO则是M与V之间的桥梁。当引入DAO后，这部分与V耦合得过于紧密的代码就可以自M转移到DAO中了。从更大的视角来看，这个所谓的DAO，实际上是MVC中C所承载的功能的一部分。所以说，出来混终归是要还的。本示例程序节省了C这一层，终究还是给程序引入了风险(话是这么说没错啦，小程序其实问题不大。还是要具体问题具体分析)。 HumanState类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package design19.model;public class HumanState extends NidaleeState &#123; HumanState(Nidalee nidalee) &#123; super(nidalee); this.type = &quot;human&quot;; this.maxMana = 4 * (220 + 45 * 17); this.manaRegen = (int)(5 * (0.9 + 0.06 * 17)); this.mana = maxMana; this.skillQ = new Skill(6000L, 90); this.skillW = new Skill(18000L, 60); this.skillE = new Skill(10000L, 120); // 回蓝 new Thread() &#123; @Override public void run() &#123; while (true) &#123; if (HumanState.this.nidalee.ifDeath) break; try &#123; int tempMana = HumanState.this.mana + HumanState.this.manaRegen; HumanState.this.mana = tempMana &gt; HumanState.this.maxMana ? HumanState.this.maxMana : tempMana; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;.start(); &#125; @Override protected void handleQ() &#123; this.modMana(this.skillQ.cost); &#125; @Override protected void handleW() &#123; this.modMana(this.skillW.cost); &#125; @Override protected void handleE() &#123; this.modMana(this.skillE.cost); double loseHealthRate = 1.0 - this.nidalee.getHealthRate(); double addHealthBase = 115 + (230 - 115) * loseHealthRate; double addHealthAP = this.nidalee.ap * (0.325 + (0.65 - 0.325) * loseHealthRate); int tempHealth = this.nidalee.health + (int)(addHealthBase + addHealthAP); this.nidalee.health = tempHealth &gt;= this.nidalee.maxHealth ? this.nidalee.maxHealth : tempHealth; &#125; private void modMana(int cost) &#123; if (this.mana &lt; cost) return; int tempMana = this.mana - cost; this.mana = tempMana &gt; 0 ? tempMana : 0; &#125;&#125; 奈德丽的人形态。我们可以看到，MP相关的操作都在这个类中。 LeopardState类 123456789101112131415161718192021package design19.model;public class LeopardState extends NidaleeState &#123; LeopardState(Nidalee nidalee) &#123; super(nidalee); this.type = &quot;leopard&quot;; this.skillQ = new Skill(5000L, 0); this.skillW = new Skill(3500L, 0); this.skillE = new Skill(6000L, 0); &#125; @Override protected void handleQ() &#123;&#125; @Override protected void handleW() &#123;&#125; @Override protected void handleE() &#123;&#125;&#125; handle Q/W/E方法都是空的，这意味着这些技能不会产生什么效果。实际中当然不会这样，因此这样写程序其实并没有问题。 介绍完了HumanState与LeopardState，我想说的是，很多时候，表征状态的类通常都是单例的，因为状态本就是一个相对抽象的东西。只不过，在本程序中，状态还和很多特有的属性(例如MP，技能恢复CD)挂钩，因此不能声明为单例。 View类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178package design19.view;import java.awt.Color;import java.awt.Frame;import java.awt.Graphics;import java.awt.Image;import java.awt.event.KeyAdapter;import java.awt.event.KeyEvent;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;import java.awt.image.BufferedImage;import java.io.IOException;import javax.imageio.ImageIO;import design19.model.Hero;import design19.model.Nidalee;public class View extends Frame &#123; private static final long serialVersionUID = 1L; private Hero nidalee = new Nidalee(); public void launchFrame() &#123; super.setLocation(500, 200); super.setSize(330, 713); new Thread(this.new RepaintRunnable()).start(); super.addWindowListener( new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125; &#125; ); super.addKeyListener( new KeyAdapter() &#123; @Override public void keyReleased(KeyEvent e) &#123; switch(e.getKeyCode()) &#123; case KeyEvent.VK_Q: View.this.nidalee.useQ(); break; case KeyEvent.VK_W: View.this.nidalee.useW(); break; case KeyEvent.VK_E: View.this.nidalee.useE(); break; case KeyEvent.VK_R: View.this.nidalee.useR(); break; case KeyEvent.VK_X: View.this.nidalee.damage(1000); break; &#125; &#125; &#125; ); super.setVisible(true); &#125; @Override public void paint(Graphics g) &#123; // 基本参数 int leftBar = 11; int aboveBar = 45; int imgWidth = 308; int imgHeight = 560; int skillWidth = 308 / 4; // 血条蓝条 int slotHeight = 10; g.setColor(this.getHealthColor()); g.fillRect(leftBar, aboveBar, (int)(imgWidth * this.nidalee.getHealthRate()), slotHeight); if (this.nidalee.ifHaveMana()) &#123; g.setColor(Color.BLUE); g.fillRect(leftBar, aboveBar + slotHeight, (int)(imgWidth * this.nidalee.getManaRate()), slotHeight); &#125; // 图片 g.drawImage(this.loadImgWeaken(this.nidalee.getImgKeyWord() + &quot;.jpg&quot;), leftBar, aboveBar + 2 * slotHeight, null); // 技能图标 int skillH = aboveBar + 2 * slotHeight + imgHeight; g.drawImage(this.loadImgWeaken(this.nidalee.getImgKeyWord() + &quot;Q.jpg&quot;), leftBar, skillH, null); g.drawImage(this.loadImgWeaken(this.nidalee.getImgKeyWord() + &quot;W.jpg&quot;), leftBar + skillWidth, skillH, null); g.drawImage(this.loadImgWeaken(this.nidalee.getImgKeyWord() + &quot;E.jpg&quot;), leftBar + skillWidth * 2, skillH, null); g.drawImage(this.loadImgWeaken(&quot;R.jpg&quot;), leftBar + skillWidth * 3, skillH, null); // 技能冷却 g.setColor(Color.BLACK); int qCDHeight = (int)(this.nidalee.remainQ() * skillWidth); g.fillRect(leftBar, skillH + skillWidth - qCDHeight, skillWidth, qCDHeight); int wCDHeight = (int)(this.nidalee.remainW() * skillWidth); g.fillRect(leftBar + skillWidth, skillH + skillWidth - wCDHeight, skillWidth, wCDHeight); int eCDHeight = (int)(this.nidalee.remainE() * skillWidth); g.fillRect(leftBar + skillWidth * 2, skillH + skillWidth - eCDHeight, skillWidth, eCDHeight); int rCDHeight = (int)(this.nidalee.remainR() * skillWidth); g.fillRect(leftBar + skillWidth * 3, skillH + skillWidth - rCDHeight, skillWidth, rCDHeight); // 阵亡文字 if (this.nidalee.isDeath()) g.drawImage(this.loadImg(&quot;death.png&quot;), leftBar + 35, aboveBar + 250, null); &#125; private class RepaintRunnable implements Runnable &#123; @Override public void run() &#123; while (true) &#123; try &#123; View.this.repaint(); Thread.sleep(40); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; @Override public void update(Graphics g) &#123; Image bImage = super.createImage(this.getWidth(), this.getHeight()); Graphics bg = bImage.getGraphics(); this.paint(bg); bg.dispose(); g.drawImage(bImage, 0, 0, this); &#125; private BufferedImage loadImg(String name) &#123; BufferedImage bImage = null; try &#123; bImage = ImageIO.read(View.class.getClassLoader().getResource(&quot;design19/img/&quot; + name)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return bImage; &#125; private BufferedImage loadImgWeaken(String name) &#123; BufferedImage bufferedImage = this.loadImg(name); if (!this.nidalee.isDeath()) return bufferedImage; final int width = 1; boolean ifShowY = true; int nowY = 0; for (int y = 0; y &lt; bufferedImage.getHeight(); y++) &#123; if (!ifShowY) &#123; for (int x = 0; x &lt; bufferedImage.getWidth(); x++) bufferedImage.setRGB(x, y, 0); &#125; else &#123; boolean ifShowX = true; int nowX = 0; for (int x = 0; x &lt; bufferedImage.getWidth(); x++) &#123; if(!ifShowX) bufferedImage.setRGB(x, y, 0); nowX++; if (nowX == width) &#123; nowX = 0; ifShowX = !ifShowX; &#125; &#125; &#125; nowY++; if (nowY == width) &#123; nowY = 0; ifShowY = !ifShowY; &#125; &#125; return bufferedImage; &#125; private Color getHealthColor() &#123; int red; int green; if (this.nidalee.getHealthRate() &gt;= 0.5) &#123; green = 255; red = (int)(255 * (1.0 - this.nidalee.getHealthRate()) * 2); &#125; else &#123; red = 255; green = (int)(255 * this.nidalee.getHealthRate() * 2); &#125; return new Color(red, green, 0); &#125;&#125; 代码很长，不过其中大多是Java AWT套路话的东西，需要说的只有以下几点。 首先，为了代码书写简单，我写了很多硬编码。通常这种涉及面板参数的操作，都会写得更灵活，例如支持面板整体的缩放等。其次，在加载图片时，我其实是每刷新一次面板就重新加载了一次，这显然是很浪费CPU的，通常来说都会在一个地方将需要用的图片加载入内存，形成静态字段。 其次，就是两个小算法啦。先来说第一个：血条绿-黄-红的渐变。这个功能主要写在getHealthColor()方法中。本质上来说，这个算法就是通过控制RGB中RED-GREEN-BLUE三个分量的值来调制出需要的颜色。对于RGB颜色而言： 绿：(0,255,0) 黄：(255,255,0) 红：(255,0,0) 假如我们将HP的变化趋势考虑为递减(递增其实也同理，相当于是逆过程)： 首先，无论如何，蓝色分量均为0。 在HP由100%-50%的过程中，绿色分量始终为255，而红色分量由0逐渐增加至255。 当血量达到50%时，RGB颜色为(255,255,0)，即标准的黄色。 随后，在HP由50%-0的过程中，红色分量始终为255，而绿色分量则由255逐渐减少为0。 然后再来说第二个：也就是图片虚化效果的实现。功能代码在loadImgWeaken()方法中，实现的效果就是行与列均是每隔一个像素点输出一个，形成网格效果。同时，由于输出的像素点变少，图片整体也会变暗。具体的算法逻辑可参见Java AWT-以像素为单位操纵图片。 Main类 12345678910package design19;import design19.view.View;public class Main &#123; public static void main(String[] args) &#123; new View().launchFrame(); &#125;&#125; 运行后，即可按需求输出结果。 用到的图片 最后，贴一下本程序用到的图片。 人形态立绘human.jpg 豹形态立绘leopard.jpg 人形态Q技能humanQ.jpg 人形态W技能humanW.jpg 人形态E技能humanE.jpg 豹形态Q技能leopardQ.jpg 豹形态W技能leopardW.jpg 豹形态E技能leopardE.jpg R技能R.jpg 死亡文字提示death.png 登场角色上面的示例程序介绍了State模式的Java实现，下面咱们试着跳出语言层面，抽象出State模式中登场的角色。 State(状态) 在示例程序中，由NidaleeState类扮演这个角色。 ConcreteState(具体的状态) 在示例程序中，由HumanState及LeopardState联袂扮演这个角色。 Context(上下文) 实际就是拥有State的宿主，在示例程序中，由Nidalee类扮演这个角色。 下面是抽象后，无关语言的类图： 较之示例程序，本类图少了不少类。其原因就在于，从本质上来说。State模式就是在将State角色自Context角色中分离出去。因此核心角色其实就只有这两个。 此外，示例程序中的NidaleeState是一个抽象类，而本类图中的State是一个接口。之所以会产生这种不同，是因为State只要表示的含义是一个抽象的状态即可，具体的形式应依具体使用场景而定。 易于增加xx，难以xx在State模式中，增加一个新的State相对容易，我们只需要让它实现上层的抽象类或接口，然后按约束编写代码即可。而在上层的抽象类或接口中增加一个新的方法则相对费事：这需要每一个State都增加这个新的方法。因为代码相对分散，每个State的编码思路可能大不相同，所以写起来会麻烦得多。 仔细回忆此前写过的设计模式相关的博客，这种”易于xx，难以xx”其实已经出现过很多次了。例如，在8.Abstract Factory模式中我们就曾说过，Abstract Factory模式”易于扩展具体的工厂，难以增加新的零件”。 其实这种特性源于继承或是实现。按照抽象的上层的约束写成新的下层相对容易，因为这遵循开闭原则。此时只需增加新代码，而无需对原有代码做出修改。而在抽象的上层中添加新功能则相对困难，因为这相当于所有已有的下层类都需要修改，违背了开闭原则。]]></content>
      <categories>
        <category>Java 设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 设计模式-18.Memento模式]]></title>
    <url>%2F2018%2F08%2F30%2FJava%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-18Memento%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在《图解设计模式》一书中，Observer模式被归入了第8部分管理状态。在GoF原书中，Observer模式则被归入了行为型设计模式。 综述大多数的文本编辑软件，都会支持撤销操作：我们可以通过该操作将文本恢复为之前的版本。而且这种撤销通常可以进行不止一次，即我们能够通过反复撤销将文本恢复为很久以前的版本。 如果打算使用面向对象的语言实现这个功能的话，该怎么做呢？ 首先，既然要恢复，就必须将此前的状态保存下来。那么到底该如何进行这个保存操作呢？比较容易想到的方案就是在哪里变更，就在变更之前进行保存。但是既然要保存对象，就必须能够访问对象内部的数据结构才行，如果需要保存的地方有多处，就会使得访问内部数据结构的逻辑散落在代码的多个位置，不利于程序的维护。在编程领域，这被称为”破坏了封装性”。 因此我们引入了Memento模式。Memento有”遗物，纪念品”的含义。顾名思义，它会将对象某个时间点需保存的属性记录下来，形成快照。然后在需要时再拿来使用。这样对对象状态的封装就被封装进了一个个Memento实例中。当外界需要快照时，就调用对象相关的方法生成Memento实例。而当需要恢复为某个Memento实例的状态时，就将该Memento实例传递给对象，让对象自行恢复到以前的状态(颇有些游戏存档-读档的意思)。这样，对于外部而言，对象内部的数据结构依然是黑盒的。 在这里要明确的是，Memento实例和它所记录的对象实例是不同的。这种不同一方面当然来自时间性上，对象本身是有时间维度的，它可能会随着时间的推进变更内部存储的值，而Memento实例则是记录某个时间点上对象的状态，仿佛就是一张定格的照片，是静态的。另一方面，Memento实例也并非是某个时间点上对对象属性的完全复制(拍照片还有失真呢)，当然我们也可以做到完全复制，不过这通常是没有意义的。我们往往只会将我们关心的，又会随时间变化的属性记录下来，用于恢复。 说到这里，大家有没有想到些什么呢？对啦！就是Java的序列化(java.io.Serializable接口)功能。实现了该接口的类就有能力保存自身在某个时间点上的状态，以供后续的恢复。其基本思路和Memento模式还是很像的。只不过，二者的应用目标还是不同的，Java的序列化主要是为了空间上的便利性：即在A地生成的对象，可以通过序列化存储至磁盘上，然后经由网络等通路传递至B地，再恢复为原对象。这是一个完整的对象打包再解包的过程，因此序列化通常会保存对象的所有核心属性(不管是否随时间变化的都会保存)。 示例程序下面我们来看一个应用了Memento模式的小例子。作为一个demo小程序，我们当然不会实现一个记事本。在此我们用Java AWT实现了一个小窗体。小窗体上只有一个数字，表示得分： 该程序会监听键盘事件： 上箭头：加1分 下箭头：减1分 左箭头：撤销一次之前的加/减操作 右箭头：显示当前存储的快照 其他按键：无 下面就赶快来看代码吧~首先是类图： 本程序中的所有代码将被统一置于design18包下，结构如下： 其中Main.java是测试代码，并没有出现在类图中。 下面将逐个贴出每个类的源码。 Subject类 首先是待保存状态的对象： 1234567891011121314151617181920212223242526272829303132package design18;public class Subject &#123; private int score; private String name; public Subject(String name) &#123; this.name = name; &#125; public int getScore() &#123; return score; &#125; public void setScore(int score) &#123; this.score = score; &#125; public String getName() &#123; return name; &#125; public Memento createSnapshot() &#123; return new Memento(this.score); &#125; public void recovery(Memento memento) &#123; this.score = memento.getScore(); &#125;&#125; Memento类 12345678910111213141516171819package design18;public class Memento &#123; private int score; Memento(int score) &#123; this.score = score; &#125; int getScore() &#123; return score; &#125; @Override public String toString() &#123; return &quot;Memento [score=&quot; + score + &quot;]&quot;; &#125;&#125; 虽然代码比较短，但毫无疑问，从名字上也能看出，Memento类就是Memento模式最重要的一个类了。在本示例中，它记录了Subject对象的状态。关于这个类，有如下几点需要说明： 单从本文的代码来看，Memento与Subject似乎毫无关联。但实际上，Memento完全附属于Subject。因此实际情况下我们通常会将Memento写为Subject的内部类，或是非public类。本文将Memento单独提取出一个文件，主要是为了能使类图更清晰，便于理解。 Subject中有name和score两个属性，但是name是不会随时间变化的，因此Memento中就只记录了score。 除了toString()之外，Memento中的所有字段和方法的最高访问权限都只到无修饰符，也就是同包下可访问。说实话这个权限还是给大了，因为我们其实希望只有Subject类能访问到这些字段和方法，这也算是没有将Memento写为Subject的内部类的另一个后遗症吧，使得权限控制变得有些混乱了。 接最后一小点。其实我们可以再扩展一下。在面向对象编程中，我们可以按访问权限将方法分为两类，需要注意的是，下文中说的接口指得其实是广义上的方法API，而非狭义上Java中的接口： wide interface(宽接口)：暴露大量内部信息的接口，通常只供比较”亲密”的内部人员调用。 narrow interface(窄接口)：只保留少量非核心的信息，供外部调用。 这样做可以很好的划定模块间的界限，防止对象的封装性被破坏。显然，对于Memento而言，构造函数以及getScore()均是窄接口，而toString()则是宽接口。 View类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package design18;import java.awt.Font;import java.awt.Frame;import java.awt.Graphics;import java.awt.Image;import java.awt.event.KeyAdapter;import java.awt.event.KeyEvent;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;import java.util.ArrayList;import java.util.List;public class View extends Frame &#123; private static final long serialVersionUID = 1L; private Subject subject; private List&lt;Memento&gt; snapshotList = new ArrayList&lt;Memento&gt;(); public View(Subject subject) &#123; this.subject = subject; &#125; public void launchFrame() &#123; super.setLocation(700, 300); super.setSize(200, 150); super.setTitle(this.subject.getName()); new Thread(this.new RepaintRunnable()).start(); super.addWindowListener( new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125; &#125; ); super.addKeyListener( new KeyAdapter() &#123; @Override public void keyReleased(KeyEvent e) &#123; switch(e.getKeyCode()) &#123; case KeyEvent.VK_UP: System.out.println(&quot;上箭头被按下，加分。&quot;); View.this.snapshotList.add(View.this.subject.createSnapshot()); View.this.subject.setScore(View.this.subject.getScore() + 1); break; case KeyEvent.VK_DOWN: System.out.println(&quot;下箭头被按下，减分。&quot;); View.this.snapshotList.add(View.this.subject.createSnapshot()); View.this.subject.setScore(View.this.subject.getScore() - 1); break; case KeyEvent.VK_LEFT: System.out.println(&quot;左箭头被按下，撤销上一次操作。&quot;); if (View.this.snapshotList.size() &gt; 0) &#123; Memento lastMemento = View.this.snapshotList.get(View.this.snapshotList.size() - 1); View.this.snapshotList.remove(View.this.snapshotList.size() - 1); View.this.subject.recovery(lastMemento); &#125; break; case KeyEvent.VK_RIGHT: System.out.println(&quot;右箭头被按下，在控制台中打印当前存储的快照。&quot;); System.out.println(&quot;============================&quot;); for (int i = 0; i &lt; View.this.snapshotList.size(); i++) System.out.println(i + &quot;---&quot; + View.this.snapshotList.get(i)); System.out.println(&quot;============================&quot;); break; default: System.out.println(&quot;非法按键，键值=&quot; + e.getKeyCode()); &#125; &#125; &#125; ); super.setVisible(true); &#125; @Override public void paint(Graphics g) &#123; g.setFont(new Font(null, Font.BOLD, 30)); g.drawString(&quot;&quot; + View.this.subject.getScore(), 50, 100); &#125; private class RepaintRunnable implements Runnable &#123; @Override public void run() &#123; while (true) &#123; try &#123; View.this.repaint(); Thread.sleep(40); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; @Override public void update(Graphics g) &#123; Image bImage = super.createImage(this.getWidth(), this.getHeight()); Graphics bg = bImage.getGraphics(); this.paint(bg); bg.dispose(); g.drawImage(bImage, 0, 0, this); &#125;&#125; 代码看起来比较长，不过大部分都是Java AWT中模板化的东西。和本文最相关的那部分逻辑被封装在了launchFrame()方法的super.addKeyListener()中。从代码中我们可以看到，View对快照的生成过程是完全黑盒的，它只是调用了Subject的createSnapshot()方法，然后将其存储到自身管理的快照列表snapshotList中。而后在需要显示和恢复时，直接使用即可。不过即便是恢复，View也仅仅是将需要恢复为的那份Memento通过Subject的recovery()方法传递给Subject而已，这个过程依然是黑盒的。 Main类 12345678package design18;public class Main &#123; public static void main(String[] args) &#123; new View(new Subject(&quot;博丽灵梦&quot;)).launchFrame(); &#125;&#125; 执行该类后，程序即可按照规定的由键盘控制分数的加减。在此输出部分最初的在控制台中打印的文字： 1234567891011121314151617181920212223242526272829303132333435上箭头被按下，加分。右箭头被按下，在控制台中打印当前存储的快照。============================0---Memento [score=0]============================上箭头被按下，加分。上箭头被按下，加分。上箭头被按下，加分。上箭头被按下，加分。下箭头被按下，减分。右箭头被按下，在控制台中打印当前存储的快照。============================0---Memento [score=0]1---Memento [score=1]2---Memento [score=2]3---Memento [score=3]4---Memento [score=4]5---Memento [score=5]============================左箭头被按下，撤销上一次操作。左箭头被按下，撤销上一次操作。右箭头被按下，在控制台中打印当前存储的快照。============================0---Memento [score=0]1---Memento [score=1]2---Memento [score=2]3---Memento [score=3]============================左箭头被按下，撤销上一次操作。左箭头被按下，撤销上一次操作。右箭头被按下，在控制台中打印当前存储的快照。============================0---Memento [score=0]1---Memento [score=1]============================ 登场角色上面的示例程序介绍了Observer模式的Java实现，下面咱们试着跳出语言层面，抽象出Observer模式中登场的角色。 Originator(生成者) Originator能够生成某时刻表示自身当前状态的Memento角色。也能根据传入的Memento恢复到此前的状态。在示例程序中，由Subject类扮演这个角色。 Memento(纪念品) 在示例程序中，由Memento类扮演这个角色。 Caretaker(负责人) Caretaker相当于外部调用人。在需要时它会要求Originator生成Memento，并存储该Memento。不过Caretaker只能调用Memento提供的窄接口，更直白的说，相当于Originator及Memento对Caretaker而言依然还是黑盒的。在合适的时机，Caretaker会将此前的某个Memento传递给Originator，以让Originator恢复为当时的状态。在示例程序中，由View类扮演这个角色。 下面是抽象后，无关语言的类图： Memento的过期在前文的分析中，我们说Java提供的序列化在空间上提供备份，Memento模式在时间上提供备份。这样说其实并不完善。从本质上来说，Memento模式就是保存对象某个时间点的快照，以供以后操作。事实上，Memento模式照下的快照也不总是在内存中的。最常见的就是游戏的存档，当游戏退出时，存档通常是会作为存档文件被保存在磁盘上的，下次启动或是需要的时候再读取某个档(SL大法万岁！)。 将快照保存为静态文件提高了程序的灵活性，却也增加了新的风险：我们要注意快照的过期。即随着程序的升级，如果对象的数据结构发生了较大的变化，新程序中的对象可能会无法读取之前版本的快照，此时就会导致快照”过期”。 Memento的存储技巧本文示例程序中每个Memento对象需要存储的信息很少。但是很多时候，比如前文提到的游戏存档，每个Memento可能都会占用大量的内存和磁盘空间。最基本的解决办法自然是使用各种压缩技术。不过在此之上，我们还有什么其他的好办法吗？ 我们可以参考一下git管理代码的技术。git可以很方便的将代码恢复为之前的版本，从本质上来说实现的基本功能和Memento对象是类似的。只不过，假设我们在git上提交了一次代码，导致代码库由版本1升至了版本2。此时git并不是将版本1全部拍为快照，而是只记录快照间的变化情况。这样在恢复时只需要反向的追溯这种变化即可。在编程领域，这是少有的用时间换空间的例子。 类似的，虽然普通场景下两个连续的快照间的关联没有那么强，但是如果两次变动间绝大多数的数据都没有变化，那么我们也可以只记录发生变化的值，进而构建变化链，达到类似的节省空间的效果。]]></content>
      <categories>
        <category>Java 设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 设计模式-17.Observer模式]]></title>
    <url>%2F2018%2F08%2F28%2FJava%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-17Observer%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在《图解设计模式》一书中，Observer模式被归入了第8部分管理状态。在GoF原书中，Observer模式则被归入了行为型设计模式。 综述Observer的含义是”观察者”，既然有观察者，那么自然就要有”观察对象”。在Observer模式中，观察者可以通过某种手段感知到观察对象某些状态的变化，进而做出相应的决策。 示例程序下面我们来看一个应用了Observer模式的示例程序。该程序的观察对象会定时产生随机数，而观察者在感知到随机数变化后会在控制台打印出数值的变化情况。 首先是类图： 本程序中的所有代码将被统一置于design17包下，结构如下： 其中Main.java是测试代码，并没有出现在类图中。 下面将逐个贴出每个类的源码。 Model类 12345678910111213141516171819202122232425262728293031323334353637package design17;import java.util.Random;public class Model implements Runnable &#123; int number; long sleepTime; private View view; private int numberRange; public Model(long sleepTime, int numberRange) &#123; this.sleepTime = sleepTime; this.numberRange = numberRange; &#125; @Override public void run() &#123; Random random = new Random(); while (true) &#123; this.number = random.nextInt(this.numberRange); this.view.needUpdate.set(true); try &#123; Thread.sleep(this.sleepTime); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public void setView(View view) &#123; this.view = view; &#125;&#125; View类 1234567891011121314151617181920212223242526272829303132333435package design17;import java.util.concurrent.atomic.AtomicBoolean;public class View implements Runnable &#123; AtomicBoolean needUpdate = new AtomicBoolean(); private Model model; private long sleepTime; private int lastNumber; public View(Model model) &#123; this.model = model; this.sleepTime = this.model.sleepTime / 10; &#125; @Override public void run() &#123; while (true) &#123; if (this.needUpdate.get()) &#123; System.out.println(this.lastNumber + &quot; --&gt; &quot; + this.model.number); this.lastNumber = this.model.number; this.needUpdate.set(false); &#125; try &#123; Thread.sleep(this.sleepTime); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; Main类 123456789101112package design17;public class Main &#123; public static void main(String[] args) &#123; Model model = new Model(1000L, 50); View view = new View(model); model.setView(view); new Thread(view).start(); new Thread(model).start(); &#125;&#125; 执行本类后，会不停的每隔1秒打印一个[0,49]之间的随机整数。截取部分最初的输出如下： 12345678910110 --&gt; 3030 --&gt; 4646 --&gt; 33 --&gt; 2323 --&gt; 1515 --&gt; 4949 --&gt; 4040 --&gt; 2929 --&gt; 4444 --&gt; 3939 --&gt; 11 程序的代码和功能都很简单。不过还是有一些需要说明的点： Model与View 在示例程序中，Model类是观察对象，View是观察者。阅读代码后就不难发现，Observer模式与MVC是如此的相似：观察对象对应MVC中的M(model)，观察者对应MVC中的V(view)。这也是本例中类名的用意。 声明为线程 在编写设计模式的示例程序时，核心目的是为了介绍设计模式的基本功能点，因此这些设计模式业务逻辑大多非常简单，很少会用到多线程，一般都是单线程跑到底。 而本例的代码虽然简单，却起了共计3个线程： main线程 model线程 view线程 之所以这么做，是为了模拟通信。如果我们不使用多线程，其实也可以实现看起来差不多的功能：观察对象发生变化后，通知观察者，观察者做出应对。 但是这样仅仅就只能是看起来差不多了。在真正的并发环境下，观察对象发出讯息后工作就结束了，他可以继续做其他事情，也就是说，此时的消息是异步的，这也是现实中实际上发生的情况。而如果只有一个线程，这就仅仅只是看起来发出了一个消息而已，因为此时的消息逻辑是同步的，观察对象必须要等观察者处理完才能做其他事情。 此外，Java其实提供了一套完整的synchronized-wait()-notify()通讯机制，可以更好的完成通讯的功能。不过它隐藏了一些通讯的细节，所以为了更好的描述消息的传递，本示例通过设置flag实现了一个简单的通讯机制(不能由model直接调用view的更新方法，因为这样的话消息又是同步的了)。 抽象层级 示例程序并没有将代码分层，之所以这样做，是因为分层是一个基础性的思路了，并不是Observer模式要讨论的重点。在实际应用中，观察对象与观察者均可以分层： 观察者的分层是比较常见的。MVC模式中的V通常都会有多个，在接到相同M发来的消息后做出不同的应对。 相对来说，观察对象的分层就比较少见了。不过如果业务需要，我们只要设计好观察对象统一的对外接口及消息，一个观察者用相同的套路观察多个同一类的观察对象也是可以的。 最后，当然我们也可以设计出多观察者对多观察对象的代码。不过通常是不会有这样的需求的，就算有也要尽量避免，因为这会导致代码层次过于复杂，使人混乱。 观察对象与观察者的相互感知 首先，既然叫做观察者，那么观察者必须要知道自己观察的是谁才行。其次，因为观察对象要将自己的变化通知给观察者，因此观察对象也必须能够感知到观察者。反映到代码中，就是我们在main方法中做的model与view的绑定了。 在本示例中，这种对绑定的需求是很明显的，如果我们用了Java提供的synchronized-wait()-notify()通讯机制，这种需求看似是变弱了，但实际上它们只是被封装起来而已。这其实是很好理解的：双向沟通的前提当然是要互相知道对方是谁才行。 这个逻辑其实是有些怪的。因为按照正常的思路来看，观察者需要知道自身观察的对象是理所当然的。但是观察对象其实是无需知道有谁在观察自身的。说明白点，”我就是我，你爱看不看。我变化了也没有义务要通知你”。从更宏观的角度来讲，这其实是因为底层无需对上层负责，就好比父类无需感知到子类那样。 示例程序2在上一个示例程序最后，我们提到了观察对象通知观察者自身变动逻辑上的问题。因此我们会在示例程序2种修改这个逻辑：观察对象无需在意观察者，观察者需要自行想办法获取观察对象的变动情况。本示例将采取观察者轮询观察对象的方式。这也是MVC模式下GUI程序中View最常采取的一种方式。为了使得示例程序更贴近实际情境(或者说更像一个真正的产品)，本示例将使用Java AWT技术来编写可视化的View。 首先是类图： 本程序中的所有代码将被统一置于design17_2包下，结构如下： 其中Main.java是测试代码，并没有出现在类图中。 下面将逐个贴出每个类的源码。 Model类 123456789101112131415161718192021222324252627282930package design17_2;import java.util.Random;public class Model implements Runnable &#123; int number; long sleepTime; private int numberRange; public Model(long sleepTime, int numberRange) &#123; this.sleepTime = sleepTime; this.numberRange = numberRange; &#125; @Override public void run() &#123; Random random = new Random(); while (true) &#123; this.number = random.nextInt(this.numberRange); try &#123; Thread.sleep(this.sleepTime); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 较之前例，Model类并没有什么太大的变化，只是去掉了与View的关联。即，此时的观察对象已无需感知到观察者。 View类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package design17_2;import java.awt.Font;import java.awt.Frame;import java.awt.Graphics;import java.awt.Image;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;public class View extends Frame &#123; private static final long serialVersionUID = 1L; private Model model; private long sleepTime; private int lastNumber; private int nowNumber; public View (Model model) &#123; this.model = model; this.sleepTime = this.model.sleepTime / 10; &#125; public void launchFrame() &#123; super.setLocation(700, 300); super.setSize(300, 150); new Thread(this.new RepaintRunnable()).start(); super.addWindowListener( new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125; &#125; ); super.setVisible(true); &#125; @Override public void paint(Graphics g) &#123; g.setFont(new Font(null, Font.BOLD, 30)); if (this.nowNumber != this.model.number) &#123; this.lastNumber = this.nowNumber; this.nowNumber = this.model.number; &#125; g.drawString(this.lastNumber + &quot; --&gt; &quot; + this.nowNumber, 100, 100); &#125; private class RepaintRunnable implements Runnable &#123; @Override public void run() &#123; while (true) &#123; try &#123; View.this.repaint(); Thread.sleep(View.this.sleepTime); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; @Override public void update(Graphics g) &#123; Image bImage = super.createImage(this.getWidth(), this.getHeight()); Graphics bg = bImage.getGraphics(); this.paint(bg); bg.dispose(); g.drawImage(bImage, 0, 0, this); &#125;&#125; 相较之下，View变得就复杂得多了。不过这里大部分都是Java AWT的代码，与Observer模式无关。虽然可能会不太明显，不过Java AWT起了独立线程RepaintRunnable类的实例每隔一段时间定时刷新面板，我们也正是借此完成了观察者对观察对象主动的轮询。 Main类 12345678910package design17_2;public class Main &#123; public static void main(String[] args) &#123; Model model = new Model(1000L, 50); new Thread(model).start(); new View(model).launchFrame(); &#125;&#125; 执行后输出这样的一个面板： 面板上的数字会依逻辑实时变动。 登场角色Observer(观察者) 在两个示例程序中，均由View类扮演这个角色。 Subject(观察对象) 在两个示例程序中，均由Model类扮演这个角色。 因为Observer模式中的观察者与观察对象间的关系灵活且相对简单，因此就不给出无关语言的通用的类图了。 观察者也可以兼任改变者在本文的两个小例子，以及标准的MVC的定义中，观察者的职责是很明确的：它就仅仅负责观察被观察对象，并不会对被观察对象做出修改。不过有些情境下，观察对象在观测到被观察对象发生变化后，或者是其他条件的变化，可能会需要改变观察对象的某些属性。此时观察者相当于兼任了修改者的工作。 我们并不能说这种做法有错。只不过这会导致程序混乱，并且增大程序出错的可能。例如此时稍有不慎，就可能造成无休止的循环： 观察对象变化 –&gt; 观察者观测到这种变化 –&gt; 观察者修改观察对象，导致观察对象再次变化 –&gt; 观察者观测到这种变化… 当然，我们可以通过代码避免这种循环，比如不会对因自身造成的变化进行处理等。不过这样终究是平添了代码逻辑的复杂性，依然不能算是优雅的代码。究其原因，还是因为角色身份的混乱。如果我们实在要实现类似的功能。也应再创建一个修改者的角色，然后通过观察者与修改者的交互达到目的。而观察者依然只有观察这一个使命，保证角色功能的单一性。 观察与通知依笔者的拙见，Observer模式的标准样式应该是示例程序2那样的。然而，在GoF书官方给出的介绍中，示例程序1才是Observer模式的标准调用方式。示例程序2顶多算是Observer模式的变种。对此我是不太服气的，不过争论这些其实也没什么意义(正如一再提到的，设计模式其实没什么标准可言)，日常应用中其实还是示例程序2那种的多见一些。 针对示例程序1那样实现的Observer模式，我们还给它起了一个别名：Publish-Subscribe(发布-订阅)模式。私以为这个命名才是比较贴切的。从我个人的理解来看，我会将示例程序1认为是Publish-Subscribe模式，而将示例程序2认为是Observer模式。二者是同一个大的思路下很相近的两种设计模式。 Java API对Observer模式的应用Java API提供了java.util.Observer接口： 123456package java.util;public interface Observer &#123; void update(Observable o, Object arg);&#125; 很显然这是Observer模式中的观察者。而java.util.Observable则是观察对象，这个类就有些复杂了，我们只给出类定义： 1public class Observable 不幸的是，看来Java API的开发人员与我的意见是相左的，他们使用的也是示例程序1的那种方式(不如说好像只有我一个人的想法不一样。看来关于这件事真的就是私下认为一下得了，对外和人沟通时还是采取示例程序1的思路)。观察者的update()方法除了接收观察对象本身之外，还会接收一个附加信息。 不过说实话，Java API提供的这套代码挺鸡肋的。究其原因，还是因为Observable被声明为了一个类，这样的好处自然是Java API的开发人员可以在其中封装很多逻辑，在要求不高的情况下，直接使用也是可以的。只不过Java是单继承的语言，这意味着如果要使用Observer-Observable，观察对象就不能再继承其他父类，不得不说这个限制还是很大的。]]></content>
      <categories>
        <category>Java 设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 设计模式-16.Mediator模式]]></title>
    <url>%2F2018%2F08%2F23%2FJava%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-16Mediator%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在《图解设计模式》一书中，Mediator模式被归入了第7部分简单化。在GoF原书中，Mediator模式则被归入了行为型设计模式。 综述假设有这样一个开发小组，组内共有10位程序员，每人负责一个模块，共同开发一个项目。既然同属一个项目，各模块自然需要协同工作。通常来说，每个模块都需对接多个其他的模块，显然这违反了最少知识法则(迪米特法则)，使得各模块间耦合得比较严重。不仅如此，每个程序员都会自然而然的更偏向于自己负责的模块，例如要添加一个需求时，我们很可能会听到如下对话： 小张：”这个需求不能放在我这做，因为这会导致我这的时间复杂度大幅提升。这是不能接受的，小王你负责的那个模块也能做吧。” 小王：”这可不行，放在我这边的话我的功能层次结构就乱了，从逻辑上来讲就不该我做。” 小张：”那用户响应慢10倍？这谁能接受？” 小王：”实际功能问题能和架构问题比吗？架构乱了还怎么维护？而且性能这种东西总是可以通过代码优化提升的，你代码写的有问题吧！” 小张：”you can you up啊，什么玩意就说提升就提升。。。” 就这样，每个人都考虑着自己模块的局部最优，进而指挥别人，导致整个项目组的气氛一点也不好，同时项目进度也会非常缓慢。 针对这个问题，一个有效的解决方案就是再为这个小组配备一个”调停者”。调停者并不负责具体的模块，也并不会细致的研究每个模块的技术细节，但是他会比较全面的了解所有模块的功能特点，从而起到调停小组中各组员的作用。 现在，小组中的各组员之间不会互相沟通，说得极端一些，他们都不需要知道彼此的存在(此时就遵循最少知识法则了)。在遇到问题时，他们都会把自身的看法告诉给调停者，调停者在汇聚所有人的想法后，会站在项目整体的角度上权衡利弊，选择出最合理的方案，并将该方案告知所有组员，即便违背了组员局部最优的利益，组员也会无条件的遵循调停者的指示。 由此演化而来的设计模式就是Mediator模式。其中Mediator是”调停者”的意思，自然就是Mediator模式中最核心的角色了。此外，继承上文的例子，该模式的另一个重要角色被称为Colleague，也就是”组员”。很显然，组员会有很多个，而调停者通常只会有1位。 在此我们可以再举一个更常见的例子：电脑。一台电脑若要正常工作，需要它的所有组件：CPU，内存，显卡，各种IO设备等协同工作，而且这种协同关系往往是很复杂的。对此，我们并没有将所有原件错综复杂的连接在一起，而是准备了一张主板，主板并不承担具体的功能，它的作用就是让所有的原件插到自己身上。这样某原件会通过主板向外界传递信息，同时也会从主板那里接到指令。这样整个系统的关系就从各器件间错综复杂的勾连进化到了大家都只和主板交互。显然，在这个例子中，主板就是调停者，而各器件则是组员。 下面我们不妨考虑一种极端的情况：假设有n个Colleague，它们两两之间都需要双向通信，那么共需要通路n(n-1)条。而引入Mediator模式后，同样的需求下只需要2n的通路，通路的复杂度相当于降低了一个量级。在n越大，连接关系越复杂时，Mediator模式对通路的优化效果越大。 如果我们站在一个更大的视角上来看待问题的话，调停者担任的其实是统筹全局的角色。在过去已经介绍过的设计模式中，类似作用的角色其实很常见了，例如3.Template Method模式中的AbstractClass(抽象类)，4.Factory Method模式中的Creator(创建者)，7.Builder模式中的Designer(设计者)等。 示例程序下面我们来看一个应用了Mediator模式的示例程序。这是一个使用Java AWT制作的登录窗： 作为一个登录框，我们希望它具备如下功能： 任何时候，取消(Cancel)按钮均会放开，点击该按钮会导致登录窗关闭，其效果和点击右上角的叉相同。 第一行是一个二选一，我们可以选择采用游客(Guest)模式或是登陆(Login)模式登入。 如果选择游客模式，用户名(Username)及密码(Password)文本框均会置灰。同时放开登陆(OK)按钮，点击该按钮后会直接以游客身份登入，登录框关闭。 如果选择登陆模式，用户名文本框会被放开，若此时用户名文本框中没有文字，则密码文本框及登陆按钮均会置灰。只有当用户名文本框中有文字后，密码文本框才会被放开，此时若密码文本框中没有文字，则登陆按钮依然置灰，反之，登陆按钮放开。此时若点击登陆按钮，若用户名密码匹配，则会以该身份登入，登录框关闭。反之，不做任何操作(会在控制台打印一句提示语句)。 如果是这样掰开了揉碎了仔细分析的话，小小的登陆框的逻辑其实还是挺复杂。通常我们会将每个组件都声明为一个实例： Guest选框 Login选框 Username文本框 Password文本框 OK按钮 Cancel按钮 按照上文的需求，这些实例之间的关系错综复杂(这么说有点过了哈，稍微夸张一下)，此时就可以使用Mediator模式啦。很显然，我们应该将这些组件视为Colleague。而Mediator则让承载这些组件的Frame担任。如此看来，Java AWT中的Frame的作用其实就是相当于计算机中的主板，本身不承载具体的功能，而是负责组件的安插及沟通。 说了这么多需求，下面就来看看具体的代码吧。首先是类图： 本程序中的所有代码将被统一置于design16包下，结构如下： 其中Main.java是测试代码，并没有出现在类图中。 下面将逐个贴出每个类的源码。 Mediator接口 123456package design16;public interface Mediator &#123; void colleagueChanged(Colleague colleague);&#125; 该接口内部只有一个方法，是供Colleague调用告知自身情况的。依本示例的需求，Colleague会把自身作为参数传递给调停者。实际应用时该方法可以是任何形式，甚至可以不是一个方法而是一组方法，只要目的不变即可。 Colleague接口 123456package design16;public interface Colleague &#123; void setColleagueEnabled(boolean enabled);&#125; 该接口内部同样只有一个方法，是供Mediator调用向各组员下达命令的。同上文的colleagueChanged()方法，该方法的组织形式依然多种多样，只要达到目的即可。 至此我们可以稍微总结一下了。Mediator作为调停者，提供了一个供组员调用报告自身情况的方法。同样Colleague作为组员，也提供了一个供调停者调用下达命令的方法。这样才能保证调停者与组员间信息沟通的通畅。在实际应用中，我们自然可以依据需要为Mediator或Colleague添加更多的代码，也可以改变colleagueChanged()及setColleagueEnabled()这两个方法的形式，不过这两个方法所代表的功能却是构成Mediator模式的基本要素，是一定要有的。 ColleagueButton类 123456789101112131415161718192021222324252627package design16;import java.awt.Button;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;public class ColleagueButton extends Button implements ActionListener, Colleague &#123; private static final long serialVersionUID = 1L; private Mediator mediator; public ColleagueButton(Mediator mediator, String caption) &#123; super(caption); this.mediator = mediator; &#125; @Override public void setColleagueEnabled(boolean enabled) &#123; this.setEnabled(enabled); &#125; @Override public void actionPerformed(ActionEvent e) &#123; this.mediator.colleagueChanged(this); &#125;&#125; 具体的组员之一，前文需求中的OK按钮及Cancel按钮就是它的实例。 既然Mediator设置了一个colleagueChanged()方法供组员调用，那么这里隐含的前提条件就是组员要知道自己的调停者是谁才行。因此ColleagueButton中添加了mediator字段，用以记录自身的调停者。本程序是以构造函数传入调停者的，实际使用时自然也可以在其他时机传入，只要用的时候有就行。 其实不仅仅ColleagueButton，在后文中我们会看到，所有的组员都需要做类似的操作。很显然，这是重复代码。那么既然如此，我们为什么不将mediator提到更高的层级呢？其原因就在于，Java是单继承的，这就使得Colleague只能被声明为接口，无法承载记录mediator的功能。 ColleagueCheckbox类 12345678910111213141516171819202122232425262728package design16;import java.awt.Checkbox;import java.awt.CheckboxGroup;import java.awt.event.ItemEvent;import java.awt.event.ItemListener;public class ColleagueCheckbox extends Checkbox implements ItemListener, Colleague &#123; private static final long serialVersionUID = 1L; private Mediator mediator; public ColleagueCheckbox(Mediator mediator, String caption, CheckboxGroup group, boolean state) &#123; super(caption, group, state); this.mediator = mediator; &#125; @Override public void setColleagueEnabled(boolean enabled) &#123; this.setEnabled(enabled); &#125; @Override public void itemStateChanged(ItemEvent e) &#123; this.mediator.colleagueChanged(this); &#125;&#125; 具体的组员之一，前文需求中的Guest选框及Login选框就是它的实例。 ColleagueTextField类 1234567891011121314151617181920212223242526272829package design16;import java.awt.Color;import java.awt.TextField;import java.awt.event.TextEvent;import java.awt.event.TextListener;public class ColleagueTextField extends TextField implements TextListener, Colleague &#123; private static final long serialVersionUID = 1L; private Mediator mediator; public ColleagueTextField(Mediator mediator, String text, int columns) &#123; super(text, columns); this.mediator = mediator; &#125; @Override public void setColleagueEnabled(boolean enabled) &#123; this.setEnabled(enabled); this.setBackground(enabled ? Color.WHITE : Color.LIGHT_GRAY); &#125; @Override public void textValueChanged(TextEvent e) &#123; this.mediator.colleagueChanged(this); &#125;&#125; 具体的组员之一，前文需求中的Username文本框及Password文本框就是它的实例。 LoginFrame类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151package design16;import java.awt.CheckboxGroup;import java.awt.Color;import java.awt.Frame;import java.awt.GridLayout;import java.awt.Label;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;import java.util.HashMap;import java.util.Map;public class LoginFrame extends Frame implements Mediator &#123; private static final long serialVersionUID = 1L; private static Map&lt;String, String&gt; USERS = new HashMap&lt;String, String&gt;(); private ColleagueCheckbox checkGuest; private ColleagueCheckbox checkLogin; private ColleagueTextField textUser; private ColleagueTextField textPassword; private ColleagueButton buttonOK; private ColleagueButton buttonCancel; static &#123; LoginFrame.USERS.put(&quot;reimu&quot;, &quot;reimuwang&quot;); &#125; public LoginFrame() &#123; super(&quot;登陆窗口&quot;); this.setBackground(Color.LIGHT_GRAY); this.setLayout(new GridLayout(4, 2)); // 生成并初始化设置各组件 CheckboxGroup group = new CheckboxGroup(); this.checkGuest = new ColleagueCheckbox(this, &quot;Guest&quot;, group, true); this.checkLogin = new ColleagueCheckbox(this, &quot;Login&quot;, group, false); int textTotalLength = 10; this.textUser = new ColleagueTextField(this, &quot;&quot;, textTotalLength); this.textUser.setColleagueEnabled(false); this.textPassword = new ColleagueTextField(this, &quot;&quot;, textTotalLength); this.textPassword.setEchoChar(&apos;*&apos;); this.textPassword.setColleagueEnabled(false); this.buttonOK = new ColleagueButton(this, &quot;OK&quot;); this.buttonCancel = new ColleagueButton(this, &quot;Cancel&quot;); // 设置Listener this.checkGuest.addItemListener(this.checkGuest); this.checkLogin.addItemListener(this.checkLogin); this.textUser.addTextListener(this.textUser); this.textPassword.addTextListener(this.textPassword); this.buttonOK.addActionListener(this.buttonOK); this.buttonCancel.addActionListener(this.buttonCancel); // 调停者记录自身需要管理哪些组员 this.add(this.checkGuest); this.add(this.checkLogin); this.add(new Label(&quot;Username:&quot;)); this.add(this.textUser); this.add(new Label(&quot;Password:&quot;)); this.add(this.textPassword); this.add(this.buttonOK); this.add(this.buttonCancel); // 设置点击关闭时需执行的操作 super.addWindowListener( new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125; &#125; ); // 显示 this.pack(); this.setVisible(true); &#125; @Override public void colleagueChanged(Colleague colleague) &#123; String mode = this.checkGuest.getState() ? &quot;游客模式&quot; : &quot;登陆模式&quot;; if (colleague == this.checkGuest) &#123; System.out.println(&quot;切换至游客模式，用户名输入框被关闭，密码输入框被关闭&quot;); this.textUser.setColleagueEnabled(false); this.textPassword.setColleagueEnabled(false); return; &#125; if (colleague == this.checkLogin) &#123; System.out.print(&quot;切换至登陆模式，用户名输入框被放开。&quot;); this.textUser.setColleagueEnabled(true); this.controlUser(); System.out.println(); return; &#125; if (colleague == this.textUser) &#123; System.out.print(mode + &quot;下向用户名输入框中键入文字。&quot;); // 其实只可能是登陆模式，姑且记录下 this.controlUser(); System.out.println(); return; &#125; if (colleague == this.textPassword) &#123; System.out.print(mode + &quot;下向密码输入框中键入文字。&quot;); // 其实只可能是登陆模式，姑且记录下 this.controlPassword(); System.out.println(); return; &#125; if (colleague == this.buttonOK) &#123; System.out.print(mode + &quot;下OK按钮被按下。&quot;); if (this.checkGuest.getState()) &#123; System.out.println(&quot;以游客的身份进入成功，窗体退出&quot;); System.exit(0); &#125; else &#123; if (this.textPassword.getText().equals(LoginFrame.USERS.get(this.textUser.getText()))) &#123; System.out.println(&quot;登陆成功，窗体退出&quot;); System.exit(0); &#125; else System.out.println(&quot;用户名与密码不比配&quot;); &#125; return; &#125; if (colleague == this.buttonCancel) &#123; System.out.println(&quot;取消按钮被按下，窗体退出&quot;); System.exit(0); &#125; System.out.println(colleague); &#125; private void controlUser() &#123; if (this.textUser.getText().length() &gt; 0) &#123; System.out.print(&quot;用户名输入框中有文字，密码输入框被放开。&quot;); this.textPassword.setColleagueEnabled(true); this.controlPassword(); &#125; else &#123; System.out.print(&quot;用户名输入框中没有文字，密码输入框，OK按钮关闭。&quot;); this.textPassword.setColleagueEnabled(false); this.buttonOK.setColleagueEnabled(false); &#125; &#125; private void controlPassword() &#123; if (this.textPassword.getText().length() &gt; 0) &#123; System.out.print(&quot;密码输入框中有文字，OK按钮被放开。&quot;); this.buttonOK.setColleagueEnabled(true); &#125; else &#123; System.out.print(&quot;密码输入框中没有文字，OK按钮关闭。&quot;); this.buttonOK.setColleagueEnabled(false); &#125; &#125;&#125; 终于来到最重要的Mediator了。很明显，因为程序主体的控制逻辑都在调停者中，因此它的代码看起来比组员要长得多，也复杂得多。这其实可以看作Mediator模式的一个特征，由于Mediator角色需要掌控全局，因此控制逻辑都会集中到Mediator中，这会导致Mediator相对来说不易维护，同时更容易产生bug。不过这其实是可以接受的，正所谓两害相权取其轻，如果我们将控制逻辑分散在各个组员中，那么一旦产生bug，调试起来将更为困难，因为我们不得不梳理分散在各处的代码。在编程领域，我们将这种情况称为”分散灾难”。 类似于我们在讨论组员时分析过的，既然组员提供了setColleagueEnabled()方法供调停者调用，那么调停者就一定要知道它管理的组员有哪些才行。本示例直接将各组员作为调停者的字段记录在调停者中了，这算是最见到的做法了，具体使用时依情况不同也可以采用其他方式。 另外，在本示例中，组员的生成也是由调停者完成的，这是由Java AWT的特性(通常我们在用Java AWT写控件时，组件都是直接在面板内生成的)决定的，实际上，组员的生成及设置并不归调停者管。更常见的例子时，调停者与组员的生成都是独立的，二者需要做的仅仅是完成绑定关系。 Main类 12345678package design16;public class Main &#123; public static void main(String[] args) &#123; new LoginFrame(); &#125;&#125; 该类的代码很简单，执行该类后，即可显示窗体，并按需求约束的那样工作。 登场角色上面的示例程序介绍了Mediator模式的Java实现，下面咱们试着跳出语言层面，抽象出Mediator模式中登场的角色。 Mediator(调停者) 在示例程序中，由Mediator接口扮演这个角色，该角色会提供一个渠道供Colleague报告自身的情况。 ConcreteMediator(具体的调停者) 在示例程序中，由LoginFrame类扮演这个角色。通常，该角色只会有一个。 Colleague(同事) 在示例程序中，由Colleague接口扮演这个角色，该角色会提供一个渠道接收Mediator的指令。 ConcreteColleague(具体的同事) 在示例程序中，由ColleagueButton，ColleagueCheckbox，ColleagueTextField联袂扮演这个角色。通常，该角色不止一个。 下面是抽象后，无关语言的类图：]]></content>
      <categories>
        <category>Java 设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 设计模式-15.Facade模式]]></title>
    <url>%2F2018%2F08%2F13%2FJava%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-15Facade%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在《图解设计模式》一书中，Facade模式被归入了第7部分简单化。在GoF原书中，Facade模式则被归入了结构型设计模式。 综述程序终归是会越来越大的，无论我们所采用的架构多么的整洁清晰，代码之间的关系也会越来越复杂(因为业务逻辑本身就是这么复杂)，这是不可避免的。作为调用者，如果我们要使用某个模块，或者是某几个某块联合提供的某个功能是，我们显然是不希望也不需要了解它们内部的调用逻辑的，通常来说，我们需要的就是提出一个请求：我要这个。然后等待收到结果就好了。 基于这种需求，诞生的设计模式就是Facade模式。Facade这个单词源自法语，它的含义是”建筑物的正面”。因此Facade模式也可被翻译为”门面模式”。顾名思义，就是某系统将对外提供的功能都封装在一个门面中，外部请求只和这个门面交互，而无需关心系统内部的复杂逻辑。显然，这是对最少知识法则(迪米特法则)的应用。 示例程序本文将复用Abstract Factory模式的示例。在Abstract Factory模式的示例中，Main.java的代码是这样的： 123456789101112131415161718192021222324252627282930313233343536package design8;import java.io.IOException;import design8.factory.Factory;import design8.factory.Page;import design8.factory.Tray;public class Main &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException, IOException &#123; Factory factory = Factory.getListFactory(); // 创建页面 Tray tray = factory.createTray(null); Page page = factory.createPage(&quot;网页导航&quot;, tray); // 视频网站 Tray videoTray = factory.createTray(&quot;视频网站&quot;); tray.add(videoTray); Tray twoVideoTray = factory.createTray(&quot;二次元&quot;); Tray threeVideoTray = factory.createTray(&quot;三次元&quot;); videoTray.add(twoVideoTray); videoTray.add(threeVideoTray); twoVideoTray.add(factory.createLink(&quot;哔哩哔哩 (゜-゜)つロ 干杯~-bilibili&quot;, &quot;https://www.bilibili.com/&quot;)); twoVideoTray.add(factory.createLink(&quot;AcFun弹幕视频网&quot;, &quot;http://www.acfun.cn/&quot;)); threeVideoTray.add(factory.createLink(&quot;腾讯视频&quot;, &quot;https://v.qq.com/&quot;)); threeVideoTray.add(factory.createLink(&quot;爱奇艺&quot;, &quot;http://vip.iqiyi.com/firstsix-new-pc.html&quot;)); threeVideoTray.add(factory.createLink(&quot;优酷&quot;, &quot;http://www.youku.com/&quot;)); // 搜索引擎 Tray searchTray = factory.createTray(&quot;搜索引擎&quot;); tray.add(searchTray); searchTray.add(factory.createLink(&quot;百度&quot;, &quot;https://www.baidu.com/&quot;)); searchTray.add(factory.createLink(&quot;谷歌&quot;, &quot;http://www.google.cn/&quot;)); // 打印页面 page.createFile(&quot;D:&quot;); &#125;&#125; 作为Main.java，它承载的其实是调用者的角色。很显然，此时的调用者要了解大量关于抽象工厂的实现细节： 需要通过getListFactory()拿到具体的工厂，如果具体的工厂不止一个，还要了解每个工厂的实现细节，自己做出甄别。 需要了解各个零件的含义及它们彼此间的关系。 需要自己组装零件，设计产品。 在总结Abstract Factory模式时，我们说Abstract Factory模式仅仅只是提供了一套设备齐全的厂房及完成基本零件的工人，但是并没有提供设计产品的厂长。在上文的示例中，这个设计者的工作显然是让调用者来做了。这就导致调用者必须了解大量的抽象工厂的实现细节。而这往往是调用者不希望的。作为调用者我们的愿望通常是这样的： 从最简洁的调用方式来说，我们就只调用一个方法，然后工厂为我们生产出默认的定制化的产品。简单来说，就是把main()中的内容全部封装在门面中，供调用者直接调用。 退一步来讲，工厂应在门面中提供几种样板样式，比如最终组装好的产品类型1,2,3。或者是接到定制化需求后定制新的产品。调用者拿到的是最终的产品，它们根本不关心这个产品都用了什么零件，这些零件该以何种方式组装，更不会关心具体是哪个工厂生产的零件。 总结一下，抽象工厂就是拥有复杂类关系及业务逻辑的系统，而Facade模式则为它添加了门面，使得调用者无需了解抽象工厂内部的组织关系，直接拿到自己想要的产品。 登场角色上面的示例程序介绍了Facade模式的Java实现，下面咱们试着跳出语言层面，抽象出Facade模式中登场的角色。 Facade(门面) 在示例程序中，由Main.java提取出的门面功能组成该角色。 复杂的系统 在示例程序中，由抽象工厂的主体组成该角色。 一些说明可能大家已经注意到了，在登场角色这一小节中，我们并没有给出无关语言的类图。 之所以这样做，是因为Facade模式的类关系过于抽象，是无法通过一张具体的类图来描述的。 简单来说，应用Facade模式需要有两个前提： 复杂的系统 调用者不希望了解系统内部的实现逻辑 此时我们就可以为系统加上一个对外的门面，进而形成Facade模式。 Facade模式是非常灵活的。针对调用方的不同，一个系统可以形成多个门面。同时当多个系统协作构成更大的系统时，我们可以将这些系统的门面(因为门面就相当于是系统的API，外界在满足功能的前提下是无需了解系统的内部实现的)组合起来，此时这些门面又会形成新的，复杂的代码关系。我们便又可以基于这些门面形成新的门面，来作为这个新的大系统对外的接口。从而使得整个程序形成递归的门面结构，让代码逻辑更为清晰。]]></content>
      <categories>
        <category>Java 设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 设计模式-14.Chain of Responsibility模式]]></title>
    <url>%2F2018%2F08%2F13%2FJava%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-14Chain%20of%20Responsibility%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在《图解设计模式》一书中，Chain of Responsibility模式被归入了第6部分访问数据结构。在GoF原书中，Chain of Responsibility模式则被归入了行为型设计模式。 综述假设我们要去某公司领取材料。首先我们去公司的”前台”，”前台”告诉说去问”营业窗口”。到了”应该窗口”后又被告知要去”售后部门”，而后”售后部门”又说应该去”资料中心”，最后我们终于在”资料中心”取到了数据。 在上文的小例子中，我们被像皮球一样在各部门之间踢来踢去。对于取资料的人而言，公司的做法是推卸责任，显然是很不友好的。但是从公司的角度而言，这样做却是有其正面意义的：这样做可以明确各个部分的职责，同时控制对外暴露的模块。在上例中，对外暴露的仅仅就只有”前台”，我们之所以知道下一步要去”营业窗口”，那是”前台”告知的。如果”前台”告知的是别的地方，那么我们就会去别的被告知的地方。后续所有的模块所做的工作都是一样的，直到我们在”资料中心”拿到资料。 在编程领域中，这种处理问题的方式被称为”责任链”。由此发展而来的设计模式即为Chain of Responsibility模式。在这种模式下，责任链上的节点对自身能处理的问题是很明确的，一旦接到责任链上游传递过来的问题后，会首先判断自身能否处理，如果不能处理，则传递给下游。 示例程序下面我们给出一个小例子，首先是类图： 本程序中的所有代码将被统一置于design14包下，结构如下： 其中Main.java是测试代码，并没有出现在类图中。 下面将逐个贴出每个类的源码。 Trouble类 12345678910111213141516171819package design14;public class Trouble &#123; private int number; public Trouble(int number) &#123; this.number = number; &#125; public int getNumber() &#123; return number; &#125; @Override public String toString() &#123; return &quot;[Trouble &quot; + this.number + &quot;]&quot;; &#125;&#125; Handler类 12345678910111213141516171819202122232425262728293031323334353637383940package design14;public abstract class Handler &#123; private String name; private Handler next; public Handler(String name) &#123; this.name = name; &#125; public Handler setNext(Handler next) &#123; this.next = next; return this.next; &#125; public static final Handler init() &#123; Handler result = new NoHandler(); result.setNext(new SpecialHandler(5)).setNext(new LimitHandler(20)).setNext(new OddHandler()); return result; &#125; public final void handle(Trouble trouble) &#123; if (this.resolve(trouble)) System.out.println(trouble + &quot;is resolved by&quot; + this); else if (null != this.next) &#123; System.out.println(this + &quot; can&apos;t resolve &quot; + trouble + &quot;,pass to next handler:&quot; + this.next); this.next.handle(trouble); &#125; else System.out.println(&quot;all handler can&apos;t resolve &quot; + trouble); &#125; protected abstract boolean resolve(Trouble trouble); @Override public String toString() &#123; return &quot;[Handler &quot; + this.name + &quot;]&quot;; &#125;&#125; 说明 setNext()方法返回Handler的目的是可以像链接一样在一个语句内一直set下去。思路类似于StringBuilder的append()方法。 handle()中应用了3.Template Method模式，resolve()就是需要子类实现的抽象方法。 责任链的初始化被作为静态方法放到了Handler中。实际应用时可依需求灵活调整。 显然，责任链不是一成不变的，我们可以依需求灵活的调整节点的顺序及功能，从而形成各种各样的责任链。 接下来的4个类是具体的解决问题的子类： NoHandler类 12345678910111213141516package design14;/** * 不处理任何问题 */public class NoHandler extends Handler &#123; public NoHandler() &#123; super(&quot;NoHandler&quot;); &#125; @Override protected boolean resolve(Trouble trouble) &#123; return false; &#125;&#125; SpecialHandler类 123456789101112131415161718package design14;public class SpecialHandler extends Handler &#123; private int number; public SpecialHandler(int number) &#123; super(&quot;SpecialHandler-&quot; + number); this.number = number; &#125; @Override protected boolean resolve(Trouble trouble) &#123; if (trouble.getNumber() == this.number) return true; return false; &#125;&#125; LimitHandler类 1234567891011121314151617181920package design14;/** * 只处理编号小于特定值的问题 */public class LimitHandler extends Handler &#123; private int limit; public LimitHandler(int limit) &#123; super(&quot;LimitHandler-&quot; + limit); this.limit = limit; &#125; @Override protected boolean resolve(Trouble trouble) &#123; if (trouble.getNumber() &lt; this.limit) return true; return false; &#125;&#125; OddHandler类 1234567891011121314151617package design14;/** * 只处理编号为奇数的问题 */public class OddHandler extends Handler &#123; public OddHandler() &#123; super(&quot;OddHandler&quot;); &#125; @Override protected boolean resolve(Trouble trouble) &#123; if (trouble.getNumber() % 2 == 1) return true; return false; &#125;&#125; Main类 12345678910package design14;public class Main &#123; public static void main(String[] args) &#123; Handler handler = Handler.init(); for (int i = 0; i &lt; 30; i++) handler.handle(new Trouble(i)); &#125;&#125; 输出： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899[Handler NoHandler] can&apos;t resolve [Trouble 0],pass to next handler:[Handler SpecialHandler-5][Handler SpecialHandler-5] can&apos;t resolve [Trouble 0],pass to next handler:[Handler LimitHandler-20][Trouble 0]is resolved by[Handler LimitHandler-20][Handler NoHandler] can&apos;t resolve [Trouble 1],pass to next handler:[Handler SpecialHandler-5][Handler SpecialHandler-5] can&apos;t resolve [Trouble 1],pass to next handler:[Handler LimitHandler-20][Trouble 1]is resolved by[Handler LimitHandler-20][Handler NoHandler] can&apos;t resolve [Trouble 2],pass to next handler:[Handler SpecialHandler-5][Handler SpecialHandler-5] can&apos;t resolve [Trouble 2],pass to next handler:[Handler LimitHandler-20][Trouble 2]is resolved by[Handler LimitHandler-20][Handler NoHandler] can&apos;t resolve [Trouble 3],pass to next handler:[Handler SpecialHandler-5][Handler SpecialHandler-5] can&apos;t resolve [Trouble 3],pass to next handler:[Handler LimitHandler-20][Trouble 3]is resolved by[Handler LimitHandler-20][Handler NoHandler] can&apos;t resolve [Trouble 4],pass to next handler:[Handler SpecialHandler-5][Handler SpecialHandler-5] can&apos;t resolve [Trouble 4],pass to next handler:[Handler LimitHandler-20][Trouble 4]is resolved by[Handler LimitHandler-20][Handler NoHandler] can&apos;t resolve [Trouble 5],pass to next handler:[Handler SpecialHandler-5][Trouble 5]is resolved by[Handler SpecialHandler-5][Handler NoHandler] can&apos;t resolve [Trouble 6],pass to next handler:[Handler SpecialHandler-5][Handler SpecialHandler-5] can&apos;t resolve [Trouble 6],pass to next handler:[Handler LimitHandler-20][Trouble 6]is resolved by[Handler LimitHandler-20][Handler NoHandler] can&apos;t resolve [Trouble 7],pass to next handler:[Handler SpecialHandler-5][Handler SpecialHandler-5] can&apos;t resolve [Trouble 7],pass to next handler:[Handler LimitHandler-20][Trouble 7]is resolved by[Handler LimitHandler-20][Handler NoHandler] can&apos;t resolve [Trouble 8],pass to next handler:[Handler SpecialHandler-5][Handler SpecialHandler-5] can&apos;t resolve [Trouble 8],pass to next handler:[Handler LimitHandler-20][Trouble 8]is resolved by[Handler LimitHandler-20][Handler NoHandler] can&apos;t resolve [Trouble 9],pass to next handler:[Handler SpecialHandler-5][Handler SpecialHandler-5] can&apos;t resolve [Trouble 9],pass to next handler:[Handler LimitHandler-20][Trouble 9]is resolved by[Handler LimitHandler-20][Handler NoHandler] can&apos;t resolve [Trouble 10],pass to next handler:[Handler SpecialHandler-5][Handler SpecialHandler-5] can&apos;t resolve [Trouble 10],pass to next handler:[Handler LimitHandler-20][Trouble 10]is resolved by[Handler LimitHandler-20][Handler NoHandler] can&apos;t resolve [Trouble 11],pass to next handler:[Handler SpecialHandler-5][Handler SpecialHandler-5] can&apos;t resolve [Trouble 11],pass to next handler:[Handler LimitHandler-20][Trouble 11]is resolved by[Handler LimitHandler-20][Handler NoHandler] can&apos;t resolve [Trouble 12],pass to next handler:[Handler SpecialHandler-5][Handler SpecialHandler-5] can&apos;t resolve [Trouble 12],pass to next handler:[Handler LimitHandler-20][Trouble 12]is resolved by[Handler LimitHandler-20][Handler NoHandler] can&apos;t resolve [Trouble 13],pass to next handler:[Handler SpecialHandler-5][Handler SpecialHandler-5] can&apos;t resolve [Trouble 13],pass to next handler:[Handler LimitHandler-20][Trouble 13]is resolved by[Handler LimitHandler-20][Handler NoHandler] can&apos;t resolve [Trouble 14],pass to next handler:[Handler SpecialHandler-5][Handler SpecialHandler-5] can&apos;t resolve [Trouble 14],pass to next handler:[Handler LimitHandler-20][Trouble 14]is resolved by[Handler LimitHandler-20][Handler NoHandler] can&apos;t resolve [Trouble 15],pass to next handler:[Handler SpecialHandler-5][Handler SpecialHandler-5] can&apos;t resolve [Trouble 15],pass to next handler:[Handler LimitHandler-20][Trouble 15]is resolved by[Handler LimitHandler-20][Handler NoHandler] can&apos;t resolve [Trouble 16],pass to next handler:[Handler SpecialHandler-5][Handler SpecialHandler-5] can&apos;t resolve [Trouble 16],pass to next handler:[Handler LimitHandler-20][Trouble 16]is resolved by[Handler LimitHandler-20][Handler NoHandler] can&apos;t resolve [Trouble 17],pass to next handler:[Handler SpecialHandler-5][Handler SpecialHandler-5] can&apos;t resolve [Trouble 17],pass to next handler:[Handler LimitHandler-20][Trouble 17]is resolved by[Handler LimitHandler-20][Handler NoHandler] can&apos;t resolve [Trouble 18],pass to next handler:[Handler SpecialHandler-5][Handler SpecialHandler-5] can&apos;t resolve [Trouble 18],pass to next handler:[Handler LimitHandler-20][Trouble 18]is resolved by[Handler LimitHandler-20][Handler NoHandler] can&apos;t resolve [Trouble 19],pass to next handler:[Handler SpecialHandler-5][Handler SpecialHandler-5] can&apos;t resolve [Trouble 19],pass to next handler:[Handler LimitHandler-20][Trouble 19]is resolved by[Handler LimitHandler-20][Handler NoHandler] can&apos;t resolve [Trouble 20],pass to next handler:[Handler SpecialHandler-5][Handler SpecialHandler-5] can&apos;t resolve [Trouble 20],pass to next handler:[Handler LimitHandler-20][Handler LimitHandler-20] can&apos;t resolve [Trouble 20],pass to next handler:[Handler OddHandler]all handler can&apos;t resolve [Trouble 20][Handler NoHandler] can&apos;t resolve [Trouble 21],pass to next handler:[Handler SpecialHandler-5][Handler SpecialHandler-5] can&apos;t resolve [Trouble 21],pass to next handler:[Handler LimitHandler-20][Handler LimitHandler-20] can&apos;t resolve [Trouble 21],pass to next handler:[Handler OddHandler][Trouble 21]is resolved by[Handler OddHandler][Handler NoHandler] can&apos;t resolve [Trouble 22],pass to next handler:[Handler SpecialHandler-5][Handler SpecialHandler-5] can&apos;t resolve [Trouble 22],pass to next handler:[Handler LimitHandler-20][Handler LimitHandler-20] can&apos;t resolve [Trouble 22],pass to next handler:[Handler OddHandler]all handler can&apos;t resolve [Trouble 22][Handler NoHandler] can&apos;t resolve [Trouble 23],pass to next handler:[Handler SpecialHandler-5][Handler SpecialHandler-5] can&apos;t resolve [Trouble 23],pass to next handler:[Handler LimitHandler-20][Handler LimitHandler-20] can&apos;t resolve [Trouble 23],pass to next handler:[Handler OddHandler][Trouble 23]is resolved by[Handler OddHandler][Handler NoHandler] can&apos;t resolve [Trouble 24],pass to next handler:[Handler SpecialHandler-5][Handler SpecialHandler-5] can&apos;t resolve [Trouble 24],pass to next handler:[Handler LimitHandler-20][Handler LimitHandler-20] can&apos;t resolve [Trouble 24],pass to next handler:[Handler OddHandler]all handler can&apos;t resolve [Trouble 24][Handler NoHandler] can&apos;t resolve [Trouble 25],pass to next handler:[Handler SpecialHandler-5][Handler SpecialHandler-5] can&apos;t resolve [Trouble 25],pass to next handler:[Handler LimitHandler-20][Handler LimitHandler-20] can&apos;t resolve [Trouble 25],pass to next handler:[Handler OddHandler][Trouble 25]is resolved by[Handler OddHandler][Handler NoHandler] can&apos;t resolve [Trouble 26],pass to next handler:[Handler SpecialHandler-5][Handler SpecialHandler-5] can&apos;t resolve [Trouble 26],pass to next handler:[Handler LimitHandler-20][Handler LimitHandler-20] can&apos;t resolve [Trouble 26],pass to next handler:[Handler OddHandler]all handler can&apos;t resolve [Trouble 26][Handler NoHandler] can&apos;t resolve [Trouble 27],pass to next handler:[Handler SpecialHandler-5][Handler SpecialHandler-5] can&apos;t resolve [Trouble 27],pass to next handler:[Handler LimitHandler-20][Handler LimitHandler-20] can&apos;t resolve [Trouble 27],pass to next handler:[Handler OddHandler][Trouble 27]is resolved by[Handler OddHandler][Handler NoHandler] can&apos;t resolve [Trouble 28],pass to next handler:[Handler SpecialHandler-5][Handler SpecialHandler-5] can&apos;t resolve [Trouble 28],pass to next handler:[Handler LimitHandler-20][Handler LimitHandler-20] can&apos;t resolve [Trouble 28],pass to next handler:[Handler OddHandler]all handler can&apos;t resolve [Trouble 28][Handler NoHandler] can&apos;t resolve [Trouble 29],pass to next handler:[Handler SpecialHandler-5][Handler SpecialHandler-5] can&apos;t resolve [Trouble 29],pass to next handler:[Handler LimitHandler-20][Handler LimitHandler-20] can&apos;t resolve [Trouble 29],pass to next handler:[Handler OddHandler][Trouble 29]is resolved by[Handler OddHandler] 登场角色上面的示例程序介绍了Chain of Responsibility模式的Java实现，下面咱们试着跳出语言层面，抽象出Chain of Responsibility模式中登场的角色。 Handler(处理者) 抽象父类，在示例程序中，由Handler类扮演这个角色。 ConcreteHandler(具体的处理者) 在示例程序中，由NoHandler，SpecialHandler，LimitHandler，OddHandler类联袂扮演这个角色。 下面是抽象后，无关语言的类图： 从最本源的角度上来讲，Chain of Responsibility模式其实是不需要一个抽象的父类的，也就是不需要Handler：只要ConcreteHandler之间能形成链即可。不过通常来说，穿在同一个链子上的ConcreteHandler所能处理的问题终归是一个类型的，因此会再抽象出一个层级。 使用Chain of Responsibility模式可以弱化调用者及处理者之间的关联，也不需要有一个统筹全局的角色决定某问题究竟该由哪个ConcreteHandler处理，问题会沿着设定好的链子走下去，直到解决或者链子结束(不过话说回来，统筹全局的角色其实还是存在的，决定链子如何拼接其实就是一种全局的工作，只不过这种做法是静态的)。 较之有一个特定的决策者决定问题的处理人，使用Chain of Responsibility模式会增大处理问题的时间陈本，在对效率要求较高的场合应谨慎使用(话是这么说没错啦，不过推卸责任时通常仅仅只是判断一下自身能不能处理，一般是不会花费太多时间的)。]]></content>
      <categories>
        <category>Java 设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 设计模式-13.Visitor模式]]></title>
    <url>%2F2018%2F08%2F08%2FJava%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-13Visitor%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在《图解设计模式》一书中，Visitor模式被归入了第6部分访问数据结构。在GoF原书中，Visitor模式则被归入了行为型设计模式。简单来说，Visitor模式可以被描述为：将数据结构的存储与处理分离开。 综述所谓数据结构，就是指以某种特定结构存储的数据，不过显然，存储并不是目的，使用与处理才是。通常，我们会将处理数据结构的代码直接写在描述数据结构的代码中，这样的好处是直观简单，坏处则是违背了开闭原则，因为只要设计得得当，通常我们是不会修改数据结构的存储结构本身的，我们会做的往往只是添加操作它的方法。因此随着时间的增加，我们对该数据结构的操作会越来越多，越来越复杂，还将存储与操作集中在一个位置显然不利于代码的维护。 Visitor模式应运而生。Visitor是”访问者”的意思。简单来说，在这种模式下，数据结构是静态的仓库，只用于数据的存储。相应的，数据处理的功能被转移至访问者，从而实现了数据结构存储与处理的分离。当我们需要增加新的处理方法时，无需修改数据结构的代码本身，只需要增加新的访问者即可。 示例程序下面我们给出一个小例子，首先是类图： 本程序中的所有代码将被统一置于design13包下，结构如下： 其中Main.java是测试代码，并没有出现在类图中。 下面将逐个贴出每个类的源码。 Warrior类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package design13;public class Warrior &#123; private String name; private String race; private int attack; private int defense; public Warrior(String name, String race, int attack, int defense) &#123; this.name = name; this.race = race; this.attack = attack; this.defense = defense; &#125; public void show(Visitor visitor) &#123; visitor.show(this); &#125; /** * 随机增强或减弱 * @param max int, 增强或减弱的上限 */ public void change(Visitor visitor, int max) &#123; visitor.change(this, max); &#125; public String getName() &#123; return name; &#125; public String getRace() &#123; return race; &#125; public int getAttack() &#123; return attack; &#125; public void setAttack(int attack) &#123; this.attack = attack; &#125; public int getDefense() &#123; return defense; &#125; public void setDefense(int defense) &#123; this.defense = defense; &#125;&#125; Visitor类 12345678910111213141516171819202122232425package design13;import java.util.Random;public class Visitor &#123; private Random random = new Random(); public void show(Warrior warrior) &#123; System.out.println(&quot;[&quot; + warrior.getName() + &quot;][&quot; + warrior.getRace() + &quot;][攻击力：&quot; + warrior.getAttack() + &quot;][防御力：&quot; + warrior.getDefense() + &quot;]&quot;); &#125; public void change(Warrior warrior, int max) &#123; int flag = this.random.nextInt(2); if (flag == 0) &#123; System.out.println(&quot;恭喜~属性增强！所有属性提高&quot; + max); warrior.setAttack(warrior.getAttack() + max); warrior.setDefense(warrior.getDefense() + max); &#125; else &#123; System.out.println(&quot;真不幸~属性降低！所有属性减少&quot; + max); warrior.setAttack(warrior.getAttack() - max); warrior.setDefense(warrior.getDefense() - max); &#125; &#125;&#125; Main类 123456789101112package design13;public class Main &#123; public static void main(String[] args) &#123; Warrior warrior = new Warrior(&quot;博丽灵梦&quot;, &quot;人类&quot;, 97, 85); Visitor visitor = new Visitor(); warrior.show(visitor); warrior.change(visitor, 10); warrior.show(visitor); &#125;&#125; 执行后，可能的输出为： 123[博丽灵梦][人类][攻击力：97][防御力：85]恭喜~属性增强！所有属性提高10[博丽灵梦][人类][攻击力：107][防御力：95] 登场角色上面的示例程序介绍了Visitor模式的Java实现，下面咱们试着跳出语言层面，抽象出Visitor模式中登场的角色。 Structure(数据结构) 在示例程序中，由Warrior类扮演这个角色。 Visitor(访问者) 在示例程序中，由Visitor类扮演这个角色。 下面是抽象后，无关语言的类图： 一些说明在GoF的23种设计模式中，Visitor模式确实是比较特殊的。这从它的类图就能看出来，Visitor模式中只有两个角色(这倒没什么)，而这两个角色之间是没有直接的关联的：不仅没有继承这种强联系，甚至连委托这种弱关系也没有。 那么Visitor模式的调用关系是什么样子的呢？ 以示例程序中Warrior类的change()方法为例，该方法的作用是修改Warrior的属性。从调用者Main的角度来看，它是这样做的： 1warrior.change(visitor, 10); 也就是说，在它看来，问题依然还是warrior这个数据结构本身处理的，它并不知道有”数据结构的存储和操作分离”这回事(它也不care这事)。不过和最简单的调用相比，它还是多传入了一个visitor。而在change()方法内部，实际进行数据处理的是visitor，而由于被处理的对象是warrior，warrior还需把visitor处理问题时需要的数据传递给visitor(示例程序采用的是比较粗暴的方式，直接将this，也就是warrior本身传递给visitor了。实际情况往往只需要传递warrior的子集数据即可)。 不得不说，这和委托很像：调用者想要处理Structure，但是Structure本身没有处理能力，调用者也没有这个处理能力。因此调用者就找来了具有处理能力的Visitor，让它来协助Structure。从调用者来看，处理数据的依然是Structure，只不过在它的内部，实际的处理工作被委托给了Visitor。而Visitor如果想处理数据，往往又需要Structure提供必要的信息。 当然，这又不是委托。因为Structure同Visitor之间没有任何关系：Structure中并没有一个字段是Visitor类型的。在编程领域，这种调过来又调过去的做法被称为双重分发。 那么为什么使用双重分发而非委托呢？这是因为双重分发更为灵活。此时Visitor并没有与Structure绑定，这意味着我们在需要的时候可以很灵活的替换Visitor，通常来说，我们会声明一个抽象的Visitor，限定一下Visitor必须要遵循的规范，当想要进行新的操作时，只需要编写新的Visitor即可，而Structure则无需做任何修改，显然，这是遵循开闭原则的。 话说回来，Visitor模式相当于是将通常的Structure一分为二：即只有存储功能的Structure，和负责操作数据的Visitor。上文讨论了Visitor的替换，下面再来说说Structure的替换：相对而言，Structure的替换和修改就不那么容易了，因为如果要替换Structure，那么所有已有的Visitor都需要修改。这又是一个老问题了，我们在8.Abstract Factory模式也讨论过类似的困境。 因此，我们通常只会修改和新增Visitor，而不会动Structure。这是因为Structure是基础，所有的Visitor都是附属于Structure的。所谓”皮之不存毛将焉附”。其实从广义的角度来讲，虽然具体架构迥异，但是1.Iterator模式也算是一种Visitor模式的一种了。之所以这么说，是因为Visitor模式的核心点其实只有一个，那就是”将数据结构的存储与操作分离”，而Iterator模式的目标实际就是在将迭代操作自容器结构中分离出去。 提到分离，我们不禁又会想到另一种以分离为目标的设计模式：9.Bridge模式，二者在各个方面均差异巨大，不过其本源的思想却是一致的，那就是将复杂的结构和操作尽量的分解，从而让逻辑变得清晰。 相关设计模式1.Iterator模式 从广义的角度来讲，Iterator模式是Visitor模式的特例。 Visitor模式的目的是将处理自数据结构中分离出来，而Iterator模式的目的则是将迭代操作自容器结构中分离出来。 8.Abstract Factory模式 二者均既遵循又违背了开闭原则。 Abstract Factory模式易于扩展具体的工厂，此时遵循开闭原则。难以增加新的零件，此时违背开闭原则。 Visitor模式易于增加新的Visitor，此时遵循开闭原则。难以修改Structure，此时违背开闭原则。 9.Bridge模式 二者的核心思想均为”分离”。]]></content>
      <categories>
        <category>Java 设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 设计模式-12.Decorator模式]]></title>
    <url>%2F2018%2F08%2F06%2FJava%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-12Decorator%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在《图解设计模式》一书中，Decorator模式被归入了第5部分一致性。在GoF原书中，Decorator模式则被归入了结构型设计模式。简单来说，Decorator模式可以被描述为：使装饰边框与被装饰物具有一致性。 综述假设有一块蛋糕，它可以增加食用者的饱腹度及幸福感。当然，我们可以给这块蛋糕加一些装饰：比如，如果我们把草莓放在蛋糕上，那么它就变为了草莓蛋糕；如果我们在蛋糕外面淋上巧克力，那么它就变为了巧克力蛋糕，等等。当然，这些装饰是可以叠加的：比如，如果我们既在蛋糕外面淋上巧克力，又在蛋糕上面放了草莓，那么它就变为了草莓巧克力蛋糕(把自己写饿了…)。 不过，不管我们如何添加装饰，它本质上还是一块蛋糕，它的核心功能并没有变，依然还是增加食用者的饱腹度及幸福感，只不过具体增加的数值会依装饰物的不同而有所变化。 类比到编程领域，由这种思路演化而来的设计模式就是Decorator模式(decorator的含义是装饰物)。在Decorator模式中，首先会有一个被装饰物，它提供了核心的功能(或者说API)，然后我们对其添加装饰物，正如蛋糕放上草莓后依然还是蛋糕那样，被装饰物经过装饰后种类没有变，依然还是原被装饰物。这样，当我们需要添加新的装饰时，就可以在此基础上依同样的方法进行操作。从而在不改变最初的被装饰物代码的前提下，丰富它的功能。 示例程序下面我们将综述中草莓蛋糕的小例子扩展为程序，从而说明Decorator模式的用法。 首先我们定义一个抽象类Dessert，用以表示甜点的概念，作为Decorator模式中的被装饰物。 然后我们定义具体的两种甜点： 蛋糕：Cake 冰淇淋：IceCream 然后我们再定义抽象类Decorator，顾名思义，它表示用来装饰甜点的添加物的概念。下面重点来了：Decorator中有一个Dessert类型的字段，这样它就可以通过委托的方式调用自身装饰的被装饰物的功能。同时Decorator又继承了Dessert，这样它在装饰完自己要装饰的被装饰物后，自身同样可以作为被装饰物再被其他的装饰物装饰(艾玛好绕)。 下面定义两个具体的装饰物： 巧克力：Chocolate 草莓：Strawberry 下面来详细介绍代码。首先给出类图： 本程序中的所有代码将被统一置于design12包下，结构如下： 其中Main.java是测试代码，并没有出现在类图中。 下面将逐个贴出每个类的源码。 Dessert类 123456789101112131415161718192021package design12;public abstract class Dessert &#123; /** * 饱腹感 */ protected abstract int getSatiety(); /** * 幸福度 */ protected abstract int getHappiness(); protected abstract String name(); @Override public String toString() &#123; return &quot;成分：&quot; + this.name() + &quot;\n饱腹感：&quot; + this.getSatiety() + &quot;，幸福度：&quot; + this.getHappiness(); &#125;&#125; 这里的toString()方法应用了3.Template Method模式。 Cake类 12345678910111213141516171819package design12;public class Cake extends Dessert &#123; @Override protected int getSatiety() &#123; return 10; &#125; @Override protected int getHappiness() &#123; return 5; &#125; @Override protected String name() &#123; return &quot;[蛋糕]&quot;; &#125;&#125; IceCream类 12345678910111213141516171819package design12;public class IceCream extends Dessert &#123; @Override protected int getSatiety() &#123; return 5; &#125; @Override protected int getHappiness() &#123; return 10; &#125; @Override protected String name() &#123; return &quot;[冰淇淋]&quot;; &#125;&#125; Decorator类 12345678910package design12;public abstract class Decorator extends Dessert &#123; protected Dessert dessert; protected Decorator(Dessert dessert) &#123; this.dessert = dessert; &#125;&#125; Chocolate类 1234567891011121314151617181920212223package design12;public class Chocolate extends Decorator &#123; public Chocolate(Dessert dessert) &#123; super(dessert); &#125; @Override protected int getSatiety() &#123; return this.dessert.getSatiety() + 3; &#125; @Override protected int getHappiness() &#123; return this.dessert.getHappiness() + 3; &#125; @Override protected String name() &#123; return this.dessert.name() + &quot;[巧克力]&quot;; &#125;&#125; Strawberry类 1234567891011121314151617181920212223package design12;public class Strawberry extends Decorator &#123; public Strawberry(Dessert dessert) &#123; super(dessert); &#125; @Override protected int getSatiety() &#123; return this.dessert.getSatiety() + 2; &#125; @Override protected int getHappiness() &#123; return this.dessert.getHappiness() + 2; &#125; @Override protected String name() &#123; return this.dessert.name() + &quot;[草莓]&quot;; &#125;&#125; Main.java 首先，我们测试只有被装饰物的情况： 123456789package design12;public class Main &#123; public static void main(String[] args) &#123; Dessert cake = new Cake(); System.out.println(cake); &#125;&#125; 输出： 12成分：[蛋糕]饱腹感：10，幸福度：5 然后我们可以给这个蛋糕加一些装饰： 123456789package design12;public class Main &#123; public static void main(String[] args) &#123; Dessert cake = new Strawberry(new Chocolate(new Cake())); System.out.println(cake); &#125;&#125; 输出： 12成分：[蛋糕][巧克力][草莓]饱腹感：15，幸福度：10 首先，虽然具体new的东西变了，但是引用类型并没有变，依然还是Dessert，或者更具体的说，因为最底层的被修饰物是蛋糕，因此最终得到的依然还是蛋糕。上例中我们先给蛋糕装饰了巧克力，后装饰了草莓。当然我们也可以先装饰草莓，后装饰巧克力： 123456789package design12;public class Main &#123; public static void main(String[] args) &#123; Dessert cake = new Chocolate(new Strawberry(new Cake())); System.out.println(cake); &#125;&#125; 输出： 12成分：[蛋糕][草莓][巧克力]饱腹感：15，幸福度：10 在这个小例子中，这样的变换似乎意义不大。不过在很多场景中，交换装饰顺序是能在很大程度上影响最终效果的。 当然啦，我们也可以将被装饰物由蛋糕换为同为甜点的冰淇淋。所有的操作都是一样的，在此仅给出一个小例子： 123456789package design12;public class Main &#123; public static void main(String[] args) &#123; Dessert cake = new Chocolate(new Strawberry(new IceCream())); System.out.println(cake); &#125;&#125; 输出： 12成分：[冰淇淋][草莓][巧克力]饱腹感：10，幸福度：15 登场角色上面的示例程序介绍了Decorator模式的Java实现，下面咱们试着跳出语言层面，抽象出Decorator模式中登场的角色。 Component(抽象的被装饰物) 在示例程序中，由Dessert类扮演这个角色。 ConcreteComponent(具体的被装饰物) 在示例程序中，由Cake类及IceCream类联袂扮演这个角色。 Decorator(抽象的装饰物) Decorator模式的核心角色。它内部保存了Component，这样就可以通过委托调用被装饰物的功能。同时它又继承了被装饰物，这样它又可以作为被装饰物再被其他装饰物装饰，即被装饰物的API并不会因装饰物而隐藏，在编程领域，这被称为API的透明性。在示例程序中，由Decorator类扮演这个角色。 ConcreteDecorator(具体的装饰物) 在示例程序中，由Chocolate类及Strawberry类联袂扮演这个角色。 在Decorator模式中，虽然核心功能来源于Component，但我们却可以通过Decorator很方便的为Component增加功能，这是Decorator模式的优点，不过这样做会增加许多功能类似的很小的类(也就是ConcreteDecorator)，算是白璧微瑕。 下面是抽象后，无关语言的类图： 相关设计模式11.Composite模式 二者均保证了不同类间的一致性，从而可以以递归的方式去操作它们。 java.io包对Decorator模式的应用在使用java.io包时，我们可以按如下方式生成一个读取文件的实例： 1Reader reader = new FileReader(&quot;a.txt&quot;); 下面我们来分析下这条语句，在分析过程出现的类或接口，除了特殊说明以外，均位于java.io包中。 首先是FileReader，它的类定义如下： 1public class FileReader extends InputStreamReader 而这个InputStreamReader的类定义为： 1public class InputStreamReader extends Reader 果然，它继承了Reader类，因此我们才能将FileReader的实例赋给Reader。而Reader的类定义为： 1public abstract class Reader implements Readable, Closeable 这个Reader就是本次讨论的顶点类了，相当于Decorator模式中的Component。而FileReader及InputStreamReader则均属于Decorator模式中的ConcreteComponent。 按照这种方法，我们可以得到一个比较基本的读取文件的实例。在此基础上，如果我们想增加一些功能，例如在读取文件时将其放入缓冲区，那么可以这样做： 1Reader reader = new BufferedReader(new FileReader(&quot;a.txt&quot;)); 显然，这个BufferedReader应该就是Decorator模式中的ConcreteDecorator了。我们来看一下它的类定义： 1public class BufferedReader extends Reader 这里需要注意一下，BufferedReader直接继承了Reader，也就是说此时是没有Decorator这个角色的，关于这一点，此前我们在讨论其他设计模式时已经说过很多次了：设计模式并非是一个死的标准，在使用时应根据具体情况做灵活的变通。具体这本场景，业务逻辑并没有那么复杂，即便去掉Decorator这一层代码结构依然很清晰，不存在Decorator也是很合理的做法。 而在BufferedReader类中，我们果不其然的找到了这样的字段： 1private Reader in; 很显然，这就是被委托的被装饰物了。为了印证这一点，我们不妨看一下所调用的构造函数的源码： 123public BufferedReader(Reader in) &#123; this(in, defaultCharBufferSize);&#125; 它内部调用的那个构造函数的源码为： 12345678public BufferedReader(Reader in, int sz) &#123; super(in); if (sz &lt;= 0) throw new IllegalArgumentException(&quot;Buffer size &lt;= 0&quot;); this.in = in; cb = new char[sz]; nextChar = nChars = 0;&#125; 与我们的预期相符。 当然，ConcreteDecorator一般不会只有一个，如果我们还需要增加管理行号的功能，那么可以这样做： 1Reader reader = new LineNumberReader(new BufferedReader(new FileReader(&quot;a.txt&quot;))); 而这个LineNumberReader的类定义为： 1public class LineNumberReader extends BufferedReader 哦，原来它是BufferedReader的子类，这里就不再赘述了。]]></content>
      <categories>
        <category>Java 设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 设计模式-11.Composite模式]]></title>
    <url>%2F2018%2F08%2F03%2FJava%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-11Composite%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在《图解设计模式》一书中，Composite模式被归入了第5部分一致性。在GoF原书中，Composite模式则被归入了结构型设计模式。简单来说，Composite模式可以被描述为：使容器与内容具有一致性，以便于以同等的，递归的方式操作容器与内容。 综述在计算机的文件系统中，有名为”文件夹”的概念(也可称为目录)。相对的，还会有名为”文件”的概念。二者的不同之处在于，文件夹是容器，其内部还可放入文件夹或文件。而文件中则无法再放入其他东西了。 不过对于更上层的结构而言，文件夹和文件其实是一回事：例如我们将文件1及文件夹A放入文件夹B中。那么对于文件夹B而言，文件1与文件夹A其实是一类东西：都是文件夹B自身内部存储的内容。此时文件1与文件夹A均可被称为”目录条目”(directory entry)，可以使用相同的策略递归的进行操作。 扩展来说，基本所有的树状结构都可以采用这种思维方式进行组织，例如在视窗系统中，视窗中可以包含子视窗，也可以直接包含内容。GoF将其抽象为了一种设计模式，并命名为Composite模式(composite有”混合物，复合物”的含义)。 示例程序8.Abstract Factory模式的示例程序中应用了完整的Composite模式，因此我们依然使用该示例程序介绍Composite模式。 具体的示例程序细节请参看8.Abstract Factory模式，在此我们仅再贴一下类图： 这张类图看起来挺复杂的，不过其中绝大多数的内容都是用于Abstract Factory模式的。如果要研究Composite模式，只需要关注Item,Link,Tray就可以了。 Link代表链接，而Tray代表托盘。托盘中的content字段是一个列表，其中既可以存放其他托盘，也可以直接存放链接。为了能用一个字段同等对待，我们又定义了更抽象的概念Item，从而将Link及Tray统一起来。如图所示，content中存储的实际是Item，至于具体是Link还是Tray，则可依需求而定。 在示例程序中，Item,Link,Tray均是抽象类。不过这是Abstract Factory模式所致。如果只应用Composite模式的话，Item代表的是一个相对抽象的概念，因此往往还会是抽象类，而Link及Tray通常就是可以直接实例化的非抽象类了。 我们可以将Tray视为容器，Link视为内容。使用Composite模式可以使容器与内容具有一致性，也可以称其为多个和单个的一致性，即将多个对象结合在一起，当做一个对象进行处理。 此外，我还想说说类图中Tray内部的add()方法。add()方法的作用为向content中添加Item，只有Tray才需要它。它的可行的定义方式有如下4种： 1.定义在Item中，抛出异常 将add()定义在Item中并抛出异常，Link中不进行重写，Tray中依实际功能需求进行重写。 这样做的好处在于，对于调用者而言，可以采用一种统一方式，即只使用Item的实例就可以调用add()方法。示例程序中的Main.java是这样写的： 123456789101112131415161718192021222324252627282930313233343536package design8;import java.io.IOException;import design8.factory.Factory;import design8.factory.Page;import design8.factory.Tray;public class Main &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException, IOException &#123; Factory factory = Factory.getListFactory(); // 创建页面 Tray tray = factory.createTray(null); Page page = factory.createPage(&quot;网页导航&quot;, tray); // 视频网站 Tray videoTray = factory.createTray(&quot;视频网站&quot;); tray.add(videoTray); Tray twoVideoTray = factory.createTray(&quot;二次元&quot;); Tray threeVideoTray = factory.createTray(&quot;三次元&quot;); videoTray.add(twoVideoTray); videoTray.add(threeVideoTray); twoVideoTray.add(factory.createLink(&quot;哔哩哔哩 (゜-゜)つロ 干杯~-bilibili&quot;, &quot;https://www.bilibili.com/&quot;)); twoVideoTray.add(factory.createLink(&quot;AcFun弹幕视频网&quot;, &quot;http://www.acfun.cn/&quot;)); threeVideoTray.add(factory.createLink(&quot;腾讯视频&quot;, &quot;https://v.qq.com/&quot;)); threeVideoTray.add(factory.createLink(&quot;爱奇艺&quot;, &quot;http://vip.iqiyi.com/firstsix-new-pc.html&quot;)); threeVideoTray.add(factory.createLink(&quot;优酷&quot;, &quot;http://www.youku.com/&quot;)); // 搜索引擎 Tray searchTray = factory.createTray(&quot;搜索引擎&quot;); tray.add(searchTray); searchTray.add(factory.createLink(&quot;百度&quot;, &quot;https://www.baidu.com/&quot;)); searchTray.add(factory.createLink(&quot;谷歌&quot;, &quot;http://www.google.cn/&quot;)); // 打印页面 page.createFile(&quot;D:&quot;); &#125;&#125; 我们在定义Tray实例的引用时，是不能使用Item的，因为此时Item中并没有add()方法。这样的代码抽象度相对较低。而如果我们将add()方法定义在Item中，就可以完美的解决这个问题，只需要在调用时做好异常处理即可。 事实上，这算是相对最优的解决方案了。在Java API的集合框架中，也运用了这个思想：首先贴出AbstractCollection类中的add()方法： 123public boolean add(E e) &#123; throw new UnsupportedOperationException();&#125; 抛出异常，表示不支持添加。而在它的子类AbstractList中，该方法被重写： 1234public boolean add(E e) &#123; add(size(), e); return true;&#125; 2.定义在Item中，并声明为抽象方法 将add()定义在Item中并声明为抽象方法，所有子类依需求决定如何重写。具体来说Link抛出异常，而Tray则写具体的业务逻辑。 本方案的效果与方案1差不多。从易于理解的角度考虑，本方案的思路甚至还要更漂亮一些。不过较之方案1，本方案有一个强制的约束条件：因为我们要将add()方法声明为抽象方法，那么Item就必须为抽象类。这限制了该方案的使用范围。 3.定义在Item中，并声明为空方法 将add()定义在Item中并声明为空方法，Link中不进行重写，Tray中依实际功能需求进行重写。 这是很糟糕的做法，虽然这样做也能在调用add()方法时使用Item引用，但是调用者却无法得到足够的反馈：所有的添加仿佛都成功了，即便是不存在添加功能的Item及Link。事实上，如果真实类型不是Tray的话，再调用add()方法，从业务逻辑的角度来讲就是一种异常情况了，要让调用者能感知到才是健壮的代码。 4.只定义在Tray中 这也是实例程序中的做法。如果不在乎前几种方案中提到的引用问题(当然我们也可以进行强制类型转换，不过那就太糟了，尽量不要那么做)，那么这是思路最清晰的做法。 登场角色上面的示例程序介绍了Composite模式的Java实现，下面咱们试着跳出语言层面，抽象出Composite模式中登场的角色。 Content(内容) 该角色中无法存入其他角色，在示例程序中，由Link类负责扮演。 Container(容器) 该角色中可以存入Component角色(具体来说，可以存入Content角色及Container角色)，在示例程序中，由Tray类负责扮演。 Component(零件) 该角色是Content角色及Container角色的父类。它的作用是将Content角色及Container角色统一起来。通常来说，Component只是一个概念，是无法实例化的。在示例程序中，由Item类负责扮演。 下面是抽象后，无关语言的类图。关于add()方法，将采用方案1： 相关设计模式8.Abstract Factory模式 正如示例程序所体现的，实现Abstract Factory模式的零件时往往会用到Composite模式。 12.Decorator模式 二者均保证了不同类间的一致性，从而可以以递归的方式去操作它们。]]></content>
      <categories>
        <category>Java 设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 设计模式-10.Strategy模式]]></title>
    <url>%2F2018%2F07%2F27%2FJava%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-10Strategy%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在《图解设计模式》一书中，Strategy模式被归入了第4部分分开考虑。在GoF原书中，Strategy模式则被归入了行为型设计模式。简单来说，Strategy模式可以被描述为：整体的，便捷的替换解决同一个问题的不同算法。 综述strategy的含义是”策略，战略”。在编程领域，我们可以将其理解为算法。Strategy模式可以整体的替换算法的实现部分，能让我们依场景灵活的使用不同算法解决同一个问题。 示例程序下面我们给出一个应用Strategy模式的小例子。它可以使用不同的算法进行排序。 首先给出类图： 本程序中的所有代码将被统一置于design10包下，结构如下： 其中Main.java是测试代码，Utils.java是工具类，并没有出现在类图中。 下面将逐个贴出每个类的源码。 Utils类 1234567891011121314151617package design10;public class Utils &#123; private Utils() &#123;&#125; public static void swap(int[] a, int i, int j) &#123; int temp = a[i]; a[i] = a[j]; a[j] = temp; &#125; public static void check(int[] a) &#123; if (null == a) throw new NullPointerException(&quot;a is null&quot;); &#125;&#125; Sort接口 123456package design10;public interface Sort &#123; void sort(int[] a);&#125; BubbleSort类 1234567891011121314package design10;public class BubbleSort implements Sort &#123; @Override public void sort(int[] a) &#123; Utils.check(a); for (int i = 0; i &lt; a.length - 1; i++) &#123; for (int j = 0; j &lt; a.length - 1 - i; j++) &#123; if (a[j] &gt; a[j + 1]) Utils.swap(a, j, j + 1); &#125; &#125; &#125;&#125; QuickSort类 123456789101112131415161718192021222324252627282930package design10;public class QuickSort implements Sort &#123; @Override public void sort(int[] a) &#123; Utils.check(a); QuickSort.quickSort(a, 0, a.length - 1); &#125; private static void quickSort(int[] a, int low, int high) &#123; if (low &gt;= high) return; int keyIndex = partition(a, low, high); quickSort(a, low, keyIndex - 1); quickSort(a, keyIndex + 1, high); &#125; private static int partition(int[] a, int low, int high) &#123; int left = low, right = high; int keyValue = a[low]; while (left &lt; right) &#123; while (right &gt; left &amp;&amp; a[right] &gt;= keyValue) right--; while (left &lt; right &amp;&amp; a[left] &lt;= keyValue) left++; if (left &lt; right) Utils.swap(a, left, right); &#125; a[low] = a[left]; a[left] = keyValue; return left; &#125;&#125; Main类 首先测试一下BubbleSort： 1234567891011121314package design10;import java.util.Arrays;public class Main &#123; public static void main(String[] args) &#123; int[] a = &#123;5, 1, 4, 3, 2, 1&#125;; Sort sort = new BubbleSort(); sort.sort(a); System.out.println(Arrays.toString(a)); &#125;&#125; 输出： 1[1, 1, 2, 3, 4, 5] 然后将算法整体替换为QuickSort： 1234567891011121314package design10;import java.util.Arrays;public class Main &#123; public static void main(String[] args) &#123; int[] a = &#123;5, 1, 4, 3, 2, 1&#125;; Sort sort = new QuickSort(); sort.sort(a); System.out.println(Arrays.toString(a)); &#125;&#125; 输出： 1[1, 1, 2, 3, 4, 5] 登场角色上面的示例程序介绍了Strategy模式的Java实现，下面咱们试着跳出语言层面，抽象出Strategy模式中登场的角色。 Strategy(抽象的策略) Strategy角色负责制定具体的策略必须实现的规范。在示例程序中，由Sort类扮演这个角色。 ConcreteStrategy(具体的策略) ConcreteStrategy是实现了Strategy角色的约束的具体的策略。在示例程序中，由BubbleSort类及QuickSort类联袂扮演这个角色。 下面是抽象后，无关语言的类图： 一些说明很显然，Strategy模式与Java中的多态思想一脉相承。所不同的是，多态的重点在于”同一种行为的不同表现”。例如同样是”吃”，狗的吃与羊的吃所表现出的现象就完全不同。而Strategy模式则是”以不同的手段达成同一种表现”。 相关设计模式3.Template Method模式 Template Method模式与Strategy模式均与Java中多态的思想一脉相承。]]></content>
      <categories>
        <category>Java 设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 设计模式-9.Bridge模式]]></title>
    <url>%2F2018%2F07%2F13%2FJava%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-9Bridge%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在《图解设计模式》一书中，Bridge模式被归入了第4部分分开考虑。在GoF原书中，Abstract Factory模式则被归入了创建型设计模式。简单来说，Bridge模式可以被描述为：将类的功能层次结构与实现层次结构分离。 综述Bridge是桥梁中的意思，就像在现实生活中，桥梁的作用是将河两岸的土地连接在一起那样，Bridge模式的作用也是将两样东西连接在一起，这两样东西是： 类的功能层次结构 类的实现层次结构 在讲解Bridge模式之前，有必要先介绍下这两种层次结构。 类的两种层次结构类的功能层次结构 假设我们现在有名为Something的类，我们希望在不破坏Something的结构，即不修改Something代码的前提下基于Something类扩展出新的功能，或者更具体的说，希望能加入一个新的方法。那么最常见的做法自然就是写一个子类继承Something，比如名为SomethingGood，并将新的方法添加到SomethingGood中。当然如果我们想继续扩展，比如在SomethingGood的基础上再加点什么，那么我们可以再写一个SomethingGood的子类SomethingBetter，依次类推下去。当然，为了维护和理解的便利性，这种继承的层级不应过深。 这就是为了增加新功能而产生的层级结构，即：父类中具备基本功能，然后在子类中扩展新的功能。通常，我们会将这种层级结构称为”类的功能层次结构”。 类的实现层次结构 在Template Method模式中，父类定义了整体的流程，而具体的实现则没有定义，它们会以抽象方法的形式被声明，进而约束子类必须去实现。这种层级结构的设计目的显然就不是为了添加新功能了，反过来说，在这种层级结构中添加新功能会非常麻烦，因为要在父类中添加一个新的抽象方法，所有已有的子类都必须修改一遍。 那么这种层级结构的优势是什么呢？很显然，添加一个新的实现是非常容易的：此时无需修改任何已有代码，只要按照父类的约束生成新的子类即可。我们说Abstract Factory模式”易于扩展具体的工厂，难以增加新的零件”其实也是一样的道理。 这种层级结构就被称为”类的实现层次结构”。 反之，显然，类的功能层次结构虽然易于增加新的功能，却难以添加新的实现：因为新功能下沉到了下面的层级，导致上层的功能并不丰富，在我们想添加新的实现时，可能不得不添加重复的代码或者做较大的代码调整：例如将已沉在下层的功能提升到上层。 两种层次结构的混合使用 通过上文的分析，我们知道了这两种层次结构是不相容的：一个的优势就是另一个的劣势。但是我们的日常需求大多都不是单一的：绝大多数时候，我们会既希望增加新功能，又增加新实现。 Bridge模式就是为了解决这一矛盾而诞生的：它会将类的功能层次结构与类的实现层次结构分离，并在二者之间搭建桥梁。即在保证实现需求的前提下，优化代码层级关系。 示例程序下面我们给出一个应用Bridge模式的小例子，该例子的作用是”显示一些东西”。这么说似乎有些抽象，不过具体看例子就很容易理解了。 首先给出类图： 本程序中的所有代码将被统一置于design9包下，结构如下： 其中Main.java是测试代码，并没有出现在类图中。 下面将逐个贴出每个类的源码。 首先是类的功能层次结构： Display类 12345678910111213141516package design9;public class Display &#123; protected DisplayImpl impl; public Display(DisplayImpl impl) &#123; this.impl = impl; &#125; public final void display() &#123; this.impl.open(); this.impl.print(); this.impl.close(); &#125;&#125; CountDisplay类 1234567891011121314package design9;public class CountDisplay extends Display &#123; public CountDisplay(DisplayImpl impl) &#123; super(impl); &#125; public void multiDisplay(int times) &#123; this.impl.open(); for(int i = 0; i &lt; times; i++) this.impl.print(); this.impl.close(); &#125;&#125; 然后是类的实现层次结构： DisplayImpl类 12345678910package design9;public abstract class DisplayImpl &#123; abstract void open(); abstract void print(); abstract void close();&#125; StringDisplayImpl类 12345678910111213141516171819202122232425262728293031323334package design9;public class StringDisplayImpl extends DisplayImpl &#123; private String str; public StringDisplayImpl(String str) &#123; this.str = str; &#125; @Override void open() &#123; this.printLine(); &#125; @Override void print() &#123; String ch = &quot;|&quot;; System.out.println(ch + this.str + ch); &#125; @Override void close() &#123; this.printLine(); &#125; private void printLine() &#123; String ch = &quot;+&quot;; System.out.print(ch); for (int i = 0; i &lt; this.str.length(); i++) System.out.print(&quot;-&quot;); System.out.println(ch); &#125;&#125; 最后是测试类： Main类 12345678910package design9;public class Main &#123; public static void main(String[] args) &#123; DisplayImpl displayImpl = new StringDisplayImpl(&quot;ReimuWang&quot;); Display display = new Display(displayImpl); display.display(); &#125;&#125; 运行后输出： 123+---------+|ReimuWang|+---------+ 如果我们将代码变为： 12345678910package design9;public class Main &#123; public static void main(String[] args) &#123; DisplayImpl displayImpl = new StringDisplayImpl(&quot;ReimuWang&quot;); Display display = new CountDisplay(displayImpl); display.display(); &#125;&#125; 再次运行后，结果显然是不会变的。 如果我们将代码变为： 12345678910package design9;public class Main &#123; public static void main(String[] args) &#123; DisplayImpl displayImpl = new StringDisplayImpl(&quot;ReimuWang&quot;); CountDisplay display = new CountDisplay(displayImpl); display.multiDisplay(5); &#125;&#125; 此时输出为： 1234567+---------+|ReimuWang||ReimuWang||ReimuWang||ReimuWang||ReimuWang|+---------+ 关于示例程序的说明继承是强关联，例如示例程序中的Display与CountDisplay，DisplayImpl与StringDisplayImpl。 委托是弱关联，例如示例程序中的Display与DisplayImpl。对于调用者而言，他们只知道Display，而实际上，在Display内部，所有具体的工作都被委托给了DisplayImpl。 而Bridge模式的桥梁正是通过这种委托实现的。这有些类似于Builder模式(仅仅只是类似，其实还是有不小差别的)：功能层次结构这一侧类似于设计者，负责对外提供功能，而实现层次结构这一侧则类似于建造者，负责具体的细节。 这样，正像例子中演示的那样。如果我们想添加一个新的功能，我们就可以在功能层次结构这一侧定义一个子类CountDisplay，然后将我们需要添加的新功能作为一个方法multiDisplay写进去。因为实现方法的”小积木”在实现层次结构这一侧都已经做好了，我们只需要拼接出一个新的功能即可。这样本次改动仅仅就只是在功能层次结构这一侧增添了一个新的子类，而无需任何其他改动。 当然，这样说其实是默认了一个前提，就是构成新功能的”小积木”在实现层次结构都已经做好(这也是给实现层次结构提出的要求，所有功能都要尽量小，尽量单一，这样复用性才高)，但事实上，无论如何做准备，也无法预知到未来所需的一切功能：总会有”小积木”没有做好的时候，此时的改动量就要大一些了。因为除了要在功能层次结构这边增加一个子类之外，还需在实现层次结构那边的所有实现中补上欠缺的”小积木”。相对而言，在实现层次结构中增加新的实现就要简单很多了：无论如何，我们都只需要增加一个新的实现即可。 登场角色上面的示例程序介绍了Bridge模式的Java实现，下面咱们试着跳出语言层面，抽象出Bridge模式中登场的角色。 FunAbstract(功能层次结构中的父类) 示例中，由Display类扮演这个角色。 FunConcrete(功能层次结构中的子类) 示例中，由CountDisplay类扮演这个角色。 ImplAbstract(实现层次结构中的父类) 示例中，由DisplayImpl类扮演这个角色。 ImplConcrete(实现层次结构中的子类) 示例中，由StringDisplayImpl类扮演这个角色。 下面是抽象后，无关语言的类图： 相关设计模式7.Builder模式 正如前文所分析的，二者有很多相似之处。 13.Visitor模式 二者的核心思想均为”分离”。]]></content>
      <categories>
        <category>Java 设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 设计模式-8.Abstract Factory模式]]></title>
    <url>%2F2018%2F07%2F09%2FJava%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-8Abstract%20Factory%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在《图解设计模式》一书中，Abstract Factory模式被归入了第3部分生成实例。在GoF原书中，Abstract Factory模式则被归入了创建型设计模式。简单来说，Abstract Factory模式可以被描述为：像在工厂中将各个零件组装成产品那样生成实例。 综述Abstract Factory的含义为”抽象工厂”。顾名思义，程序会被划分为两层： 第一层：抽象工厂将抽象零件组装成抽象产品。 第二层：具体工厂将具体零件组装成具体产品。 示例程序下面我们给出一个应用Abstract Factory模式的小例子，该例子会创建一个具有层次结构的输出链接集合的html页面。 首先给出类图： 本程序中的所有代码将被统一置于design8包下，结构如下： 其中Main.java是测试代码，并没有出现在类图中。 下面将逐个贴出每个类的源码。 首先是抽象层，统一位于design8.factory包下： Item类 1234567891011121314package design8.factory;import java.util.List;public abstract class Item &#123; protected String caption; Item(String caption) &#123; this.caption = caption; &#125; public abstract List&lt;String&gt; makeHtml();&#125; Link类 1234567891011121314package design8.factory;/** * 抽象零件：链接 */public abstract class Link extends Item &#123; protected String url; protected Link(String caption, String url) &#123; super(caption); this.url = url; &#125;&#125; Tray类 123456789101112131415161718192021222324package design8.factory;import java.util.ArrayList;import java.util.List;/** * 抽象零件：托盘。 * 其中保存着托盘或者链接 */public abstract class Tray extends Item &#123; protected List&lt;Item&gt; content = new ArrayList&lt;Item&gt;(); /** * @param caption, 为null则表示该tray是最大的那一个托盘 */ protected Tray(String caption) &#123; super(caption); &#125; public void add(Item item) &#123; this.content.add(item); &#125;&#125; Page类 123456789101112131415161718192021222324252627282930313233343536package design8.factory;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.PrintStream;import java.util.List;/** * 抽象产品：页面 * 产品也可被视为一种零件，或者反过来说也成立。因为此时已经是一种一对一的关系了(该产品只由一种零件构成) * 其中保存着网页基本信息及存储主体内容的托盘 */public abstract class Page extends Item &#123; protected Tray tray; protected Page(String caption, Tray tray) &#123; super(caption); this.tray = tray; &#125; public void createFile(String outPutPath) throws ClassNotFoundException, NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException, IOException &#123; FileOutputStream fos = null; PrintStream ps = null; try &#123; fos = new FileOutputStream(new File(outPutPath + File.separator + this.caption + &quot;.html&quot;)); ps = new PrintStream(fos); List&lt;String&gt; strList = this.makeHtml(); for (String str : strList) ps.println(str); &#125; finally &#123; ps.close(); fos.close(); &#125; &#125;&#125; Factory类 12345678910111213141516171819package design8.factory;import design8.listfactory.ListFactory;/** * 抽象工厂 */public abstract class Factory &#123; public static Factory getListFactory() &#123; return ListFactory.getInstance(); &#125; public abstract Link createLink(String caption, String url); public abstract Tray createTray(String caption); public abstract Page createPage(String caption, Tray tray);&#125; 然后是实现层，统一位于design8.listfactory包下： ListLink类 1234567891011121314151617181920package design8.listfactory;import java.util.ArrayList;import java.util.List;import design8.factory.Link;public class ListLink extends Link &#123; ListLink(String caption, String url) &#123; super(caption, url); &#125; @Override public List&lt;String&gt; makeHtml() &#123; List&lt;String&gt; result = new ArrayList&lt;String&gt;(); result.add(&quot;&lt;li&gt;&lt;a href=\&quot;&quot; + this.url + &quot;\&quot;&gt;&quot; + this.caption + &quot;&lt;/a&gt;&lt;/li&gt;&quot;); return result; &#125;&#125; ListTray类 123456789101112131415161718192021222324252627282930313233package design8.listfactory;import java.util.ArrayList;import java.util.List;import design8.factory.Item;import design8.factory.Tray;public class ListTray extends Tray &#123; ListTray(String caption) &#123; super(caption); &#125; @Override public List&lt;String&gt; makeHtml() &#123; List&lt;String&gt; result = new ArrayList&lt;String&gt;(); if (null == this.caption) this.addLi(result); else &#123; result.add(&quot;&lt;li&gt;&quot;); result.add(this.caption); this.addLi(result); result.add(&quot;&lt;/li&gt;&quot;); &#125; return result; &#125; private void addLi(List&lt;String&gt; result) &#123; result.add(&quot;&lt;ul&gt;&quot;); for (Item item : this.content) result.addAll(item.makeHtml()); result.add(&quot;&lt;/ul&gt;&quot;); &#125;&#125; ListPage类 1234567891011121314151617181920212223242526package design8.listfactory;import java.util.ArrayList;import java.util.List;import design8.factory.Page;import design8.factory.Tray;public class ListPage extends Page &#123; protected ListPage(String caption, Tray tray) &#123; super(caption, tray); &#125; @Override public List&lt;String&gt; makeHtml() &#123; List&lt;String&gt; result = new ArrayList&lt;String&gt;(); result.add(&quot;&lt;html&gt;&quot;); result.add(&quot;&lt;head&gt;&lt;title&gt;&quot; + this.caption + &quot;&lt;/title&gt;&lt;/head&gt;&quot;); result.add(&quot;&lt;body&gt;&quot;); result.addAll(this.tray.makeHtml()); result.add(&quot;&lt;/body&gt;&quot;); result.add(&quot;&lt;/html&gt;&quot;); return result; &#125;&#125; ListFactory类 1234567891011121314151617181920212223242526272829303132package design8.listfactory;import design8.factory.Factory;import design8.factory.Link;import design8.factory.Page;import design8.factory.Tray;public class ListFactory extends Factory &#123; private static ListFactory SINGLETON = new ListFactory(); private ListFactory() &#123;&#125; public static ListFactory getInstance() &#123; return ListFactory.SINGLETON; &#125; @Override public Link createLink(String caption, String url) &#123; return new ListLink(caption, url); &#125; @Override public Tray createTray(String caption) &#123; return new ListTray(caption); &#125; @Override public Page createPage(String caption, Tray tray) &#123; return new ListPage(caption, tray); &#125;&#125; Main类 123456789101112131415161718192021222324252627282930313233343536package design8;import java.io.IOException;import design8.factory.Factory;import design8.factory.Page;import design8.factory.Tray;public class Main &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException, IOException &#123; Factory factory = Factory.getListFactory(); // 创建页面 Tray tray = factory.createTray(null); Page page = factory.createPage(&quot;网页导航&quot;, tray); // 视频网站 Tray videoTray = factory.createTray(&quot;视频网站&quot;); tray.add(videoTray); Tray twoVideoTray = factory.createTray(&quot;二次元&quot;); Tray threeVideoTray = factory.createTray(&quot;三次元&quot;); videoTray.add(twoVideoTray); videoTray.add(threeVideoTray); twoVideoTray.add(factory.createLink(&quot;哔哩哔哩 (゜-゜)つロ 干杯~-bilibili&quot;, &quot;https://www.bilibili.com/&quot;)); twoVideoTray.add(factory.createLink(&quot;AcFun弹幕视频网&quot;, &quot;http://www.acfun.cn/&quot;)); threeVideoTray.add(factory.createLink(&quot;腾讯视频&quot;, &quot;https://v.qq.com/&quot;)); threeVideoTray.add(factory.createLink(&quot;爱奇艺&quot;, &quot;http://vip.iqiyi.com/firstsix-new-pc.html&quot;)); threeVideoTray.add(factory.createLink(&quot;优酷&quot;, &quot;http://www.youku.com/&quot;)); // 搜索引擎 Tray searchTray = factory.createTray(&quot;搜索引擎&quot;); tray.add(searchTray); searchTray.add(factory.createLink(&quot;百度&quot;, &quot;https://www.baidu.com/&quot;)); searchTray.add(factory.createLink(&quot;谷歌&quot;, &quot;http://www.google.cn/&quot;)); // 打印页面 page.createFile(&quot;D:&quot;); &#125;&#125; 执行后，会在D盘根目录下生成网页导航.html： 12345678910111213141516171819202122232425262728293031323334&lt;html&gt;&lt;head&gt;&lt;title&gt;网页导航&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt;&lt;li&gt;视频网站&lt;ul&gt;&lt;li&gt;二次元&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/&quot;&gt;哔哩哔哩 (゜-゜)つロ 干杯~-bilibili&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://www.acfun.cn/&quot;&gt;AcFun弹幕视频网&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;三次元&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://v.qq.com/&quot;&gt;腾讯视频&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://vip.iqiyi.com/firstsix-new-pc.html&quot;&gt;爱奇艺&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://www.youku.com/&quot;&gt;优酷&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;搜索引擎&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://www.baidu.com/&quot;&gt;百度&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://www.google.cn/&quot;&gt;谷歌&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 没进行缩进处理~就这样吧。使用浏览器打开的效果为： 登场角色上面的示例程序介绍了Abstract Factory模式的Java实现，下面咱们试着跳出语言层面，抽象出Abstract Factory模式中登场的角色。 Abstract Factory模式将程序分为了两层。首先是抽象层： AbstractComponent(抽象零件) 之所以使用AbstractComponent而非AbstractProduct，是因为Abstract Factory模式的核心思想之一就是”将复杂的产品拆分为复数个零件，然后再在需要时将零件组装为产品”。当然，我们也可将AbstractProduct视为AbstractComponent的特例：如果某种产品只分解为了1个零件，那么此时零件与产品便是等价的了。 在例子中。抽象零件首先被分为两层。其次第二层又同时包含了身为零件的link，tray及由这两个零件及其他要素组成的最终产品page。本质上其实它们都是同一个角色。 AbstractFactory(抽象工厂) AbstractFactory用于生产AbstractComponent。在示例程序中，由Factory类扮演这个角色。 ConcreteComponent(具体零件) 继承AbstractComponent。在例子中，由ListLink类，ListTray类及ListPage类共同扮演这个角色。 ConcreteFactory(具体工厂) ConcreteFactory继承AbstractFactory并生产ConcreteComponent。在例子中，由ListFactory类扮演这个角色。 下面是抽象后，无关语言的类图： 如此的组织结构导致Abstract Factory模式具有如下特点： 易于扩展具体的工厂：遵照AbstractFactory中约束的继承规范，再结合本次的需求，扩展出一个新的工厂是很容易的事情。只需要增加新代码，无需对原有代码做任何改变。遵守开闭原则。 难以增加新的零件：增加一个新的零件，需要自AbstractFactory起，向下直至所有已有的ConcreteFactory都需要修改。违背了开闭原则。 相关设计模式3.Template Method模式4.Factory Method模式7.Builder模式 面试时，我们经常会遇到这样的问题：Factory Method模式与Abstract Factory模式有何异同点？ 之所以这样问，是因为二者本就很相近，再加上应用场景的重叠，很多时候我们往往既会使用Factory Method模式，又会使用Abstract Factory模式。再加上二者名称又很相似，引发这样的问题其实也是可以理解的。 在解答这个问题之前，首先需要强调的是，将不同设计模式间的界限分得那么清楚的意义其实不大，这个问题颇有些”茴香豆的茴字有几种写法”的意思。 不过如果我们就是要较真的话，那么其实不应该仅仅局限在这两种设计模式中，而是应该统合以下四种设计模式一起分析： Template Method模式 Factory Method模式 Builder模式 Abstract Factory模式 首先，这4种设计模式最终的目的其实是一样的，就是通过某种策略，将一个复杂的问题变得条理清晰并易于扩展。 Template Method模式试图从时间的角度入手解决这个问题：父类中定义方法执行的流程(即从时间上将复杂事件分为很多小段)，子类中负责具体的实现(即具体实现推迟至子类中)。例如父类指定完成一个复杂事件需要经过如下3个步骤： m1() m2() m3() 父类并不会真正的实现这3个方法，具体的实现交给子类。然后通过不同子类间的多态使得代码产出不同的结果。不过，虽然所有的细节(即m1,m2,m3的实现)均是子类完成的。但是子类却没有整个事件的主导权。所有子类无论如何实现m1,m2,m3，它们执行这3个方法的顺序是不能变的。 Factory Method模式则是Template Method模式的特例，它将父类执行的流程限定为了”生成实例”这件事。本质上与Template Method模式是相同的。 而Builder模式则采用了另一种视角，它试图从空间上将一个复杂的产品拆分为各种细小的零件。Builder模式有如下两个角色：设计者及建造者。例如我们要制造一个复杂物体A，它由1个零件B及两个零件C组装而成。那么最基本的，建造者会提供如下方法： 生产一个零件B 生产一个零件C 将传入的零件按要求组装起来 建造者拥有构建复杂物体A所有技术细节的能力。不过单单有建造者是无法构建A的，因为它只能生产零件，却没有设计产品的能力。我们说A是由”1个零件B及两个零件C组装而成”，为什么是这样的零件组合以及如何组装，这些全局上的东西都是设计者的工作。 此外，Template Method模式采用的是ISA的架构，父类与子类间是有层级关系的。而Builder模式采用的则是HASA的架构。设计者与建造者是平级的，我们不能说建造者是设计者的一种，反之亦然。设计者只是能指挥建造者去工作。 虽然Template Method模式与Builder模式采取的策略不同，不过二者之间却有一个共同点：那就是主视角是生产产品，或推动事件的人。在这两个模式的内部，均有负责统筹规划整体思路的角色。对于Template Method模式而言是父类，对于Builder模式而言是设计者。之所以要强调这一点，是为了体现Abstract Factory模式的不同之处。 而Abstract Factory模式，则是基于Template Method模式及Builder模式，结合工厂生产零件这类需求，诞生出的一种更高层级的设计模式。基本上，它是以Builder模式为基础的：工厂生产零件，然后将零件组装成产品。同时它又有着Template Method模式的影子：工厂生产零件与产品的方法被自父类抽象工厂推迟到了子类具体工厂。 不过我认为Abstract Factory模式与Template Method模式及Builder模式有着本质的不同，也就是视角的不同。Template Method模式及Builder模式的主视角是”工人”，并且正如前文已经提到的，不仅视角是”工人”，还会有统筹全局的”大将型”工人，这样在模式内部就可以完成一个完整的需求。而Abstract Factory模式的视角是工厂，工厂是死的，是没有主观能动性的，模式内部也不存在一个统筹全局的工人。正如前文的例子展示的那样，类似统筹全局的工作是在模式外部，也就是main方法中进行的。换句话说，Abstract Factory模式帮助我们构建出了一套完整的，高扩展性的厂房，厂房中虽然配备了工人，却没有设置统筹全局的领导。 5.Singleton模式 正如前文的例子中展示的，Abstract Factory模式在创建具体工厂时可能会用到Singleton模式。 11.Composite模式 正如示例程序所体现的，实现Abstract Factory模式的零件时往往会用到Composite模式。 13.Visitor模式 二者均既遵循又违背了开闭原则。 Abstract Factory模式易于扩展具体的工厂，此时遵循开闭原则。难以增加新的零件，此时违背开闭原则。 Visitor模式易于增加新的Visitor，此时遵循开闭原则。难以修改Structure，此时违背开闭原则。]]></content>
      <categories>
        <category>Java 设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 设计模式-7.Builder模式]]></title>
    <url>%2F2018%2F07%2F05%2FJava%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-7Builder%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在《图解设计模式》一书中，Builder模式被归入了第3部分生成实例。在GoF原书中，Builder模式则被归入了创建型设计模式。简单来说，Builder模式可以被描述为：通过各个阶段的处理以组装出复杂的实例。 综述在英语中，build通常用来指建造大型的建筑物。对于这种具有复杂建筑结构的大型物体而言，很难做到一蹴而就。我们往往需要分模块的建造各个部分，然后在合适的时机将它们组装到一起。将这种思想延伸到编程领域，诞生的就是Builder模式。 示例程序下面我们给出一个应用Builder模式的小例子，该例子会根据需求打印出txt或html两种样式的文档。 首先给出类图： 本程序中的所有代码将被统一置于design7包下，结构如下： 其中Main.java是测试代码，并没有出现在类图中。 下面将逐个贴出每个类的源码。 Builder类 1234567891011121314151617181920212223242526272829303132333435363738394041package design7;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.PrintStream;import java.lang.reflect.Field;import java.util.ArrayList;import java.util.List;public abstract class Builder &#123; protected List&lt;String&gt; result = new ArrayList&lt;String&gt;(); public abstract void bulidHead(String head); public abstract void bulidTitle(String title); public abstract void bulidString(String str); public abstract void bulidItems(String[] items); public abstract void bulidTail(); public void createFile(String pathPre) throws ClassNotFoundException, NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException, IOException &#123; Field filed = this.getClass().getDeclaredField(&quot;FILE_TYPE&quot;); filed.setAccessible(true); String fileType = (String)filed.get(null); String outPutPath = pathPre + &quot;.&quot; + fileType; FileOutputStream fos = null; PrintStream ps = null; try &#123; fos = new FileOutputStream(new File(outPutPath)); ps = new PrintStream(fos); for (String str : this.result) ps.println(str); &#125; finally &#123; ps.close(); fos.close(); &#125; &#125;&#125; TextBuilder类 123456789101112131415161718192021222324252627282930313233package design7;public class TextBuilder extends Builder &#123; @SuppressWarnings(&quot;unused&quot;) private static String FILE_TYPE = &quot;txt&quot;; @Override public void bulidHead(String head) &#123; String decorate = &quot;====================&quot;; this.result.add(decorate + head + decorate); &#125; @Override public void bulidTitle(String title) &#123; String decorate = &quot;#&quot;; this.result.add(decorate + title + decorate); &#125; @Override public void bulidString(String str) &#123; this.result.add(str); &#125; @Override public void bulidItems(String[] items) &#123; for (String item : items) this.result.add(&quot; · &quot; + item); &#125; @Override public void bulidTail() &#123;&#125;&#125; HtmlBuilder类 1234567891011121314151617181920212223242526272829303132333435363738394041424344package design7;public class HtmlBuilder extends Builder &#123; @SuppressWarnings(&quot;unused&quot;) private static String FILE_TYPE = &quot;html&quot;; @Override public void bulidHead(String head) &#123; this.result.add(&quot;&lt;html&gt;&quot;); this.result.add(this.indent(1) + &quot;&lt;head&gt;&lt;title&gt;&quot; + head + &quot;&lt;/title&gt;&lt;/head&gt;&quot;); this.result.add(this.indent(1) + &quot;&lt;body&gt;&quot;); &#125; @Override public void bulidTitle(String title) &#123; this.result.add(this.indent(2) + &quot;&lt;h1&gt;&quot; + title + &quot;&lt;/h1&gt;&quot;); &#125; @Override public void bulidString(String str) &#123; this.result.add(this.indent(2) + &quot;&lt;p&gt;&quot; + str + &quot;&lt;/p&gt;&quot;); &#125; @Override public void bulidItems(String[] items) &#123; this.result.add(this.indent(2) + &quot;&lt;ul&gt;&quot;); for (String item : items) this.result.add(this.indent(3) + &quot;&lt;li&gt;&quot; + item + &quot;&lt;/li&gt;&quot;); this.result.add(this.indent(2) + &quot;&lt;/ul&gt;&quot;); &#125; @Override public void bulidTail() &#123; this.result.add(this.indent(1) + &quot;&lt;/body&gt;&quot;); this.result.add(&quot;&lt;/html&gt;&quot;); &#125; private String indent(int level) &#123; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; level; i++) sb.append(&quot; &quot;); return sb.toString(); &#125;&#125; Designer类 1234567891011121314151617181920212223242526272829303132333435363738package design7;import java.io.IOException;public class Designer &#123; public void construct(Builder builder, String path, String title) throws ClassNotFoundException, NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException, IOException &#123; builder.bulidHead(title); builder.bulidTitle(&quot;红魔馆&quot;); builder.bulidString(&quot;红魔馆（こうまかん/Koumakan）是蕾米莉亚·斯卡雷特拥有的一间房子。它位于雾之湖的边缘。从外面可以看见深红色的窗户，但是窗户并不多，因为吸血鬼不喜欢阳光。里面也有很多没有窗户的房间。屋顶上有一个钟楼，但钟只在晚上敲响。红魔馆内部比外面看起来大得多。&quot;); builder.bulidString(&quot;主要成员：&quot;); builder.bulidItems(new String[] &#123; &quot;蕾米莉亚·斯卡雷特（レミリア·スカーレット/Remilia Scarlet）&quot;, &quot;芙兰朵露·斯卡雷特（フランドール·スカーレット/Flandre Scarlet）&quot;, &quot;十六夜咲夜（いざよい さくや/Sakuya Izayoi）&quot;, &quot;帕秋莉·诺蕾姬（パチュリー·ノーレッジ/Patchouli Knowledge）&quot;, &quot;小恶魔（リートル デビッル/Little Devil）&quot;, &quot;红美铃（ホン メイリン/Hong Meirin）&quot; &#125;); builder.bulidTitle(&quot;永远亭&quot;); builder.bulidString(&quot;永远亭是《东方project》中位于迷途竹林深处的一座日式建筑，是八意永琳、蓬莱山辉夜、因幡帝和铃仙·优昙华院·因幡的居住地。首次出现在《东方永夜抄》。&quot;); builder.bulidString(&quot;主要成员：&quot;); builder.bulidItems(new String[] &#123; &quot;蓬莱山辉夜（ほうらいさん かぐや/Houraisan Kaguya）&quot;, &quot;八意永琳(やごころ えいりん/Eirin Yagokoro)&quot;, &quot;铃仙·优昙华院·因幡（レイセン・うどんげいん・イナバ/Reisen Udongein Inaba）&quot;, &quot;因幡帝（いなば てゐ/Tewi Inaba）&quot; &#125;); builder.bulidTitle(&quot;白玉楼&quot;); builder.bulidString(&quot;白玉楼（はくぎょくろう/Hakugyokurou）是《东方project》中位于冥界的一座有着庭院的屋子，是西行寺幽幽子和魂魄妖梦的居住地。首次出现在《东方妖妖梦》。&quot;); builder.bulidString(&quot;主要成员：&quot;); builder.bulidItems(new String[] &#123; &quot;西行寺幽幽子（さいぎょうじ ゆゆこ/Saigyouji Yuyuko）&quot;, &quot;魂魄 妖梦(こんぱく ようむ/Youmu Konpaku)&quot; &#125;); builder.createFile(path + title); &#125;&#125; Main类 1234567891011121314package design7;import java.io.File;import java.io.IOException;public class Main &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException, IOException &#123; String path = &quot;D:&quot; + File.separator; String title = &quot;东方幻想乡&quot;; new Designer().construct(new TextBuilder(), path, title); new Designer().construct(new HtmlBuilder(), path, title); &#125;&#125; 执行后，会在D盘根目录下生成东方幻想乡.txt及东方幻想乡.html两个文件。 东方幻想乡.txt的内容为： 12345678910111213141516171819202122====================东方幻想乡====================#红魔馆#红魔馆（こうまかん/Koumakan）是蕾米莉亚·斯卡雷特拥有的一间房子。它位于雾之湖的边缘。从外面可以看见深红色的窗户，但是窗户并不多，因为吸血鬼不喜欢阳光。里面也有很多没有窗户的房间。屋顶上有一个钟楼，但钟只在晚上敲响。红魔馆内部比外面看起来大得多。主要成员： · 蕾米莉亚·斯卡雷特（レミリア·スカーレット/Remilia Scarlet） · 芙兰朵露·斯卡雷特（フランドール·スカーレット/Flandre Scarlet） · 十六夜咲夜（いざよい さくや/Sakuya Izayoi） · 帕秋莉·诺蕾姬（パチュリー·ノーレッジ/Patchouli Knowledge） · 小恶魔（リートル デビッル/Little Devil） · 红美铃（ホン メイリン/Hong Meirin）#永远亭#永远亭是《东方project》中位于迷途竹林深处的一座日式建筑，是八意永琳、蓬莱山辉夜、因幡帝和铃仙·优昙华院·因幡的居住地。首次出现在《东方永夜抄》。主要成员： · 蓬莱山辉夜（ほうらいさん かぐや/Houraisan Kaguya） · 八意永琳(やごころ えいりん/Eirin Yagokoro) · 铃仙·优昙华院·因幡（レイセン・うどんげいん・イナバ/Reisen Udongein Inaba） · 因幡帝（いなば てゐ/Tewi Inaba）#白玉楼#白玉楼（はくぎょくろう/Hakugyokurou）是《东方project》中位于冥界的一座有着庭院的屋子，是西行寺幽幽子和魂魄妖梦的居住地。首次出现在《东方妖妖梦》。主要成员： · 西行寺幽幽子（さいぎょうじ ゆゆこ/Saigyouji Yuyuko） · 魂魄 妖梦(こんぱく ようむ/Youmu Konpaku) 东方幻想乡.html的内容为： 123456789101112131415161718192021222324252627282930&lt;html&gt; &lt;head&gt;&lt;title&gt;东方幻想乡&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;红魔馆&lt;/h1&gt; &lt;p&gt;红魔馆（こうまかん/Koumakan）是蕾米莉亚·斯卡雷特拥有的一间房子。它位于雾之湖的边缘。从外面可以看见深红色的窗户，但是窗户并不多，因为吸血鬼不喜欢阳光。里面也有很多没有窗户的房间。屋顶上有一个钟楼，但钟只在晚上敲响。红魔馆内部比外面看起来大得多。&lt;/p&gt; &lt;p&gt;主要成员：&lt;/p&gt; &lt;ul&gt; &lt;li&gt;蕾米莉亚·斯卡雷特（レミリア·スカーレット/Remilia Scarlet）&lt;/li&gt; &lt;li&gt;芙兰朵露·斯卡雷特（フランドール·スカーレット/Flandre Scarlet）&lt;/li&gt; &lt;li&gt;十六夜咲夜（いざよい さくや/Sakuya Izayoi）&lt;/li&gt; &lt;li&gt;帕秋莉·诺蕾姬（パチュリー·ノーレッジ/Patchouli Knowledge）&lt;/li&gt; &lt;li&gt;小恶魔（リートル デビッル/Little Devil）&lt;/li&gt; &lt;li&gt;红美铃（ホン メイリン/Hong Meirin）&lt;/li&gt; &lt;/ul&gt; &lt;h1&gt;永远亭&lt;/h1&gt; &lt;p&gt;永远亭是《东方project》中位于迷途竹林深处的一座日式建筑，是八意永琳、蓬莱山辉夜、因幡帝和铃仙·优昙华院·因幡的居住地。首次出现在《东方永夜抄》。&lt;/p&gt; &lt;p&gt;主要成员：&lt;/p&gt; &lt;ul&gt; &lt;li&gt;蓬莱山辉夜（ほうらいさん かぐや/Houraisan Kaguya）&lt;/li&gt; &lt;li&gt;八意永琳(やごころ えいりん/Eirin Yagokoro)&lt;/li&gt; &lt;li&gt;铃仙·优昙华院·因幡（レイセン・うどんげいん・イナバ/Reisen Udongein Inaba）&lt;/li&gt; &lt;li&gt;因幡帝（いなば てゐ/Tewi Inaba）&lt;/li&gt; &lt;/ul&gt; &lt;h1&gt;白玉楼&lt;/h1&gt; &lt;p&gt;白玉楼（はくぎょくろう/Hakugyokurou）是《东方project》中位于冥界的一座有着庭院的屋子，是西行寺幽幽子和魂魄妖梦的居住地。首次出现在《东方妖妖梦》。&lt;/p&gt; &lt;p&gt;主要成员：&lt;/p&gt; &lt;ul&gt; &lt;li&gt;西行寺幽幽子（さいぎょうじ ゆゆこ/Saigyouji Yuyuko）&lt;/li&gt; &lt;li&gt;魂魄 妖梦(こんぱく ようむ/Youmu Konpaku)&lt;/li&gt; &lt;/ul&gt; 用浏览器打开东方幻想乡.html的效果为： 登场角色上面的示例程序介绍了Builder模式的Java实现，下面咱们试着跳出语言层面，抽象出Builder模式中登场的角色。 Builder(建造者) 在构造复杂事物时，Builder是每一个具体细节的制造者，但却不负责整体的规划。换句话说，如果我们把要构建的事物拆散了来看，每一个小零件其实都是Builder制造的，但是Builder并不知道它到底造了个什么，也没能力建造出一个完整的事物。 以前文的小例子来说，如果我们把最后输出的文章视为待构造的复杂事物的话，Builder负责生成一篇文章的所有细节： 123456789public abstract void bulidHead(String head);public abstract void bulidTitle(String title);public abstract void bulidString(String str);public abstract void bulidItems(String[] items);public abstract void bulidTail(); 但是只有这些是无法形成一篇文章的，关键是如何组合这些细节，以及填入什么内容。这些就是下面马上就要介绍的Designer的工作了。 在例子中，由Builder，TextBuilder及HtmlBuilder共同扮演了Builder这个角色。当然，这种将角色分层的做法并不是Builder模式所关注的核心。 Designer(设计者) 在构造复杂事物时，Designer负责整体的设计，并不负责具体每个零件的实现。具体实现会交给Builder。在例子中，Designer类扮演了Designer这个角色。 某些时候，我们也会将Designer与Builder合二为一，形成超级工人(也就是老板最喜欢的那种)：既能做设计，又能具体动手实现。不过这样会导致一个角色承载的功能过多，不利于程序架构的划分，在程序规模不大，不容易引起混乱时可以使用。 下面是抽象后，无关语言的类图： 相关设计模式3.Template Method模式4.Factory Method模式8.Abstract Factory模式 关于这4个设计模式间的联系与区别，详见8.Abstract Factory模式。]]></content>
      <categories>
        <category>Java 设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 设计模式-6.Prototype模式]]></title>
    <url>%2F2018%2F06%2F25%2FJava%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-6Prototype%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在《图解设计模式》一书中，Prototype模式被归入了第3部分生成实例。在GoF原书中，Prototype模式则被归入了创建型设计模式。简单来说，Prototype模式可以被描述为：复制已有实例以生成新的实例。 综述在Java中，如果我们想要获得一个实例，最通常的做法就是找到这个实例所属的类，然后通过new关键字生成。这种基于模版生成实例的做法最符合思维逻辑，但某些情境下却不大方便。 下面我们就来举一个这种”不大方便”的小例子吧。 假设我们用Java写了一个画图程序，然后我们用该程序画了一个圆。站在编程的角度考虑，我们画出的圆是实例，程序中会有一个名为”圆”的类作为模版来生成它。要描述一个圆，假定需要如下参数： 圆心位置 半径 是否填充颜色，如果是，填充的颜色是什么 边线粗细(如果为0代表无边线) 边线颜色 边线是否为虚线，如果是，虚线的样式是什么样的？ 当我们第一次绘制这个圆的时候，自然是要用new关键字基于模版创建的。但如果我们要复制这个实例呢？ 比较容易想到的方式自然就是再用相同的参数new一个新的圆啦！不过这样就需要我们把描述这个实例的参数都记录下来，或者是能做到从待复制实例中提取出来。在参数较多的时候，比如我们要复制的不是一个圆，而是用户绘制的一幅复杂的图画，这样的设计既繁琐又不利于维护。 不过话说回来，既然我们都打算把属性从实例中提取出来了，那么为什么不在复制时跳过模版这一层，直接复制实例以得到新的实例呢？我们当然可以这样做，由这种想法延伸出来的设计模式就是Prototype模式。 Prototype的含义是”原型”，也就是待复制的实例。我们可以这样来理解：传统的基于类生成实例的方式就好比打印机，它需要切实了解文档的内容，这样才能从无到有的打印出文档。而Prototype模式则好比是复印机，首先我们需要拿到一份文档实例，如果我们想复印它，那么我们并不需要了解它的内容，也不需要知道它是如何生成的，我们只需要原样复印即可。 当然，使用复印机必须先获得待复印的文档，而这第一份文档还是需要打印机生成的。上文中关于”圆”的那个例子也是这样：第一个圆的实例还是需要通过new关键字来生成。 幸运的是，Java API为我们提供了Cloneable接口，直接使用即可实现实例的复制。这里多说一句，Java API提供的是浅克隆(shallow copy)，也被叫做字段对字段的复制(field-to-field-copy)。即只会克隆一层。例如我们有对象a，a中有B类型字段b。假设我们通过克隆生成了对象a1，那么a1中的类型为B的字段已经是复制后的了，我们可以将它命名为b1，它与a中的b是两个不同的引用。不过二者指向的实体却没有变。这件事的道理和Java中的值传递与址传递类似(Java中只有值传递哦)，算是老生常谈的问题了。 如果我们想要实现N层拷贝，或者是真正意义上的深拷贝，那就只能重写clone()方法自己实现了。 另外，需要注意的是，Java API提供的复制只是基于原实例中的字段生成新的实例，并不会调用构造函数。 示例程序下面我们给出一个更具体的小例子，来加深一下对Prototype模式的理解。该示例程序的功能为给字符串加上修饰符，修饰符可能是环绕文字的符号，也有可能是下划线。 首先给出类图： 本程序中的所有代码将被统一置于design6包下，结构如下： 其中Initialize.java及Main.java是测试代码，并没有出现在类图中。 下面将逐个贴出每个类的源码。 Product接口 1234567891011121314package design6;public interface Product extends Cloneable &#123; /** * 具体的打印逻辑 */ void use(String str); /** * 复制自身 */ Product createClone() throws CloneNotSupportedException;&#125; Manager类 1234567891011121314151617package design6;import java.util.HashMap;import java.util.Map;public class Manager &#123; private Map&lt;String, Product&gt; showcase = new HashMap&lt;String, Product&gt;(); public void register(String name, Product proto) &#123; this.showcase.put(name, proto); &#125; public Product create(String name) throws CloneNotSupportedException &#123; return this.showcase.get(name).createClone(); &#125;&#125; MessageBox类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package design6;/** * 在字符串周围加上环绕字符 */public class MessageBox implements Product &#123; /** * 用于环绕字符串的修饰字符 */ private char decochar; /** * 字符串距左右修饰字符的间隙 */ private int padding; public MessageBox(char decochar, int padding) &#123; this.decochar = decochar; this.padding = padding; &#125; @Override public void use(String str) &#123; this.printLine(str); System.out.print(this.decochar); for (int i = 0; i &lt; this.padding; i++) System.out.print(&quot; &quot;); System.out.print(str); for (int i = 0; i &lt; this.padding; i++) System.out.print(&quot; &quot;); System.out.print(this.decochar); System.out.println(); this.printLine(str); &#125; @Override public Product createClone() throws CloneNotSupportedException &#123; return (MessageBox)this.clone(); &#125; private void printLine(String str) &#123; for (int i = 0; i &lt; str.length() + (this.padding + 1) * 2; i++) System.out.print(decochar); System.out.println(&quot;&quot;); &#125;&#125; UnderlinePen类 1234567891011121314151617181920212223242526272829package design6;/** * 在字符串下方加上下划线 */public class UnderlinePen implements Product &#123; /** * 组成下划线的字符 */ private char ulchar; public UnderlinePen(char ulchar) &#123; this.ulchar = ulchar; &#125; @Override public void use(String str) &#123; System.out.println(str); for (int i = 0; i &lt; str.length(); i++) System.out.print(this.ulchar); System.out.println(); &#125; @Override public Product createClone() throws CloneNotSupportedException &#123; return (UnderlinePen)this.clone(); &#125;&#125; Initialize类 12345678910111213package design6;public class Initialize &#123; public static Manager initialize() &#123; Manager manager = new Manager(); manager.register(&quot;big box&quot;, new MessageBox(&apos;$&apos;, 5)); manager.register(&quot;small box&quot;, new MessageBox(&apos;=&apos;, 2)); manager.register(&quot;strong underLine&quot;, new UnderlinePen(&apos;*&apos;)); manager.register(&quot;weak underLine&quot;, new UnderlinePen(&apos;-&apos;)); return manager; &#125;&#125; 其实Initialize与Main都是测试代码，和Prototype模式本身无关。之所以分成两个类是为了表达以下含义：原型的生成通常只会在系统初始化时进行一次。而原型的复制则是在每次需要时进行。 Main类 首先测试一下”大盒子”： 12345678910package design6;public class Main &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; Manager manager = Initialize.initialize(); Product bigBox = manager.create(&quot;big box&quot;); bigBox.use(&quot;ReimuWang&quot;); &#125;&#125; 输出： 123$$$$$$$$$$$$$$$$$$$$$$ ReimuWang $$$$$$$$$$$$$$$$$$$$$$ 稍微改造一下，再来看看”小盒子”： 12345678910package design6;public class Main &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; Manager manager = Initialize.initialize(); Product smallBox = manager.create(&quot;small box&quot;); smallBox.use(&quot;ReimuWang&quot;); &#125;&#125; 输出： 123================ ReimuWang ================ 然后是强下划线： 12345678910package design6;public class Main &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; Manager manager = Initialize.initialize(); Product strongUnderLine = manager.create(&quot;strong underLine&quot;); strongUnderLine.use(&quot;ReimuWang&quot;); &#125;&#125; 输出： 12ReimuWang********* 最后是弱下划线： 12345678910package design6;public class Main &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; Manager manager = Initialize.initialize(); Product weakUnderLine = manager.create(&quot;weak underLine&quot;); weakUnderLine.use(&quot;ReimuWang&quot;); &#125;&#125; 输出： 12ReimuWang--------- 针对示例程序的说明原型与单例 在Prototype模式中，作为原型的那个实例自然是唯一的。但并不意味着原型实例所属的那个类就要是单例的，因为同一个类可能会产生多个原型(例如上文示例中的big box与small box)，而且我们的目的就是对原型进行复制。 如果必要，我们还会修改复制出的结果。这点在上例中并不明显。因为我们都是拿到原型的克隆体后直接就用了。但是实际上，原型可以被理解为一个默认值，很多时候我们在拿到克隆体后是需要修改的。那么有人可能要问了，既然都要改了为什么不直接生成一个新的呢？那是因为我们需要的实例还是基于原型生成的，绝大多数的属性都与原型类似，因此在原型的基础上修改还是比生成一个新的实例容易。例如最开始的那个”圆”的例子，当我们拿到复制的圆后，也可以微调圆的形状。 进一步来说，原型到底是个什么东西呢？ 我认为，原型是介于类与实例之间的一个东西。以上例的big box及small box为例，它们有一定的通用性，我们通常会希望像使用样式模版那样使用它们。但是它们又不足以作为一个类：毕竟它们仅仅只是一个样式而已，如果我们将这些样式都设计为类，那么系统中的类就会太多了。例子中是只设计了两种盒子，但是我们可以通过简单的参数调整就设计出无数个盒子：大大盒子，小小盒子等等。显然这是不利于维护的。 使用与具体的实现解耦 严格来说，这个特性并不是Prototype模式的核心特性。Prototype模式的核心特性其实就是”直接复制原型生成新的实例”。只不过，原型作为一种实例，量还是比较大的。因此对原型的管理也是很现实的问题。 首先，来看Product与 UnderlinePen/MessageBox。显然，如果原型逻辑比较简单，仅仅就是需要一种大的样式：例如只需要环绕字符串或者加下划线，也能够确定后续不会再扩展什么别的处理样式，那么完全可以不用设计这层抽象的Product。不过正如我们下文要论述的，这样不利于框架与实现的解耦，而且”确定后续不会再扩展什么别的处理样式”云云说得确实也太绝对了，没人能准确的预知未来的事情，因此花费少许的代价(多定义一层抽象的结构)，换得程序架构的清晰及后续的可扩展性还是很值得的。 然后观察上例中的Main.java及Initialize.java，我们可以发现两个特点： 第一，在Main中做调用时，只出现了作为框架的类Manager及Product，没有出现任何具体的实现类。显然，这样可以做到”高内聚，低耦合”，让使用与生成解耦。 第二，进一步的，Main中的使用者不仅不需要使用具体的实现类，他们甚至都不需要知道实现类到底是如何组织的。对于他们而言，他们只知道系统提供了四种修饰字符串的样式： big box small box strong underLine weak underLine 虽然从底层实现的角度来说，big box及small box这两种原型是基于MessageBox类生成的，而strong underLine及weak underLine这两种原型是基于UnderlinePen类生成的。但是如果使用者不需要知道这些细节，他们完全可以把这四种样式视为并列独立的，只管按名字调用即可。 也就是说，虽然系统提供的是原型，但使用者在使用时却仿佛在使用类。 登场角色上面的示例程序介绍了Prototype模式的Java实现，下面咱们试着跳出语言层面，抽象出Prototype模式中登场的角色。 Prototype(原型) Prototype提供了生成原型，复制原型以及对外提供克隆体的能力。在示例程序中，它首先被一分为二：管理原型及对外提供原型克隆体的功能被放入了Manager类中。而Product/UnderlinePen/MessageBox这一系则负责Prototype的核心功能：即原型的提供及复制。在这一系的内部，Product接口负责扮演抽象的框架的那一层(当然，不仅仅是接口，依需求不同，抽象类，甚至是非抽象类，都可以扮演这一层的角色)， UnderlinePen/MessageBox 类负责扮演具体实现的那一层。 可能有人会觉得Prototype模式的角色有些少，怎么会只有一个呢？但是从本质上来讲，Prototype模式的角色真的就只有Prototype这一个，示例程序中出现的其他的所有角色不过是为了让程序更好而做的补充。它们并不是Prototype模式所关注的重点。而且这些外围角色所承载的功能是需要依需求的不同灵活变化的。例如示例程序中Manager这个类，它只管理了Product这一系的原型。如果我们需要定义完全不同的另一系原型，那么我们依然可以将它们交由Manager管理。 这其实给了我们很好的启示：设计模式并不是孤立的，也并非一成不变的。说实话，当我们使用某个设计模式时，使用方式是否规范并不重要(话说回来，设计模式本来就是经验的总结，其实没什么规范可言)，基于需求做出最合理的应对才是最重要的。这也就是所谓的”黑猫白猫，抓到老鼠就是好猫”。因此，在研究设计模式时，应尽可能的探究它的理论内核，而不应被一些表象上的条条框框限制住。这样才能在需要时做出最佳的变通及组合。 进一步来说，我们研究设计模式，虽然明面上有什么23种GoF设计模式这一说，但这23种设计模式其实仅仅是供我们探究设计模式的跳板。当我们研习完这23种设计模式，如果仅仅是把它们背了下来，意义其实并不大(可能也就面试的时候忽悠一下面试官吧)，关键是透过现象看本质，找到这些设计模式中共通的”思想”。一旦领悟到这一层，其实就没有什么特定的设计模式可言了。基于需求，我们可以很自然的将几种设计模式组合变形，形成最适用当前环境的新的设计模式。 在[倚天屠龙记]中，张三丰在教授张无忌太极剑法时，曾反复问张无忌忘了多少剑招了，直到张无忌说全忘记了，老道才在众人的一片懵逼中笑道：”不坏不坏，忘得真快”。因为剑招其实都是次要的，剑意才是最重要的。如果硬要从技术的角度分析，太极剑法只有一招:那就是不断的画圈，大圈套小圈，正圈套斜圈。但是1招中却又蕴含着无穷多招，正所谓太极圆缺，无使断绝，无招胜有招。 说了这么多题外话，我想表述的就是在学习设计模式时，具体的设计模式都是招式，我们学会了可以快速上手运用，但是更重要的还是通过这些招式领会背后的”思想”。一旦融汇贯通，其实也就没什么23种设计模式可言了。对我们而言，设计模式其实只有一种，那就是”基于当前环境，生成的那种最恰当的设计模式”。而因为我们可能面对的环境有无穷多种，我们可用的设计模式自然也无穷无尽。 下面是抽象后，无关语言的类图：]]></content>
      <categories>
        <category>Java 设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 设计模式-5.Singleton模式]]></title>
    <url>%2F2018%2F06%2F19%2FJava%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-5Singleton%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在《图解设计模式》一书中，Singleton模式被归入了第3部分生成实例。在GoF原书中，Singleton模式则被归入了创建型设计模式。简单来说，Singleton模式可以被描述为：只允许生成一个实例。 综述类作为模版，在程序运行时通常会生成许多个实例。例如Java中的java.lang.String类与字符串就是一一对应的关系：即如果我们声明了1000个不同的字符串，那么系统中就会有1000个String类的实例与之对应。 但是，有时我们也会有这样的需求：某个类的实例只会有一个。例如东方Project中的八云紫，她的种族是隙间妖怪，属于这个种族的妖怪只有她一个(厉害了我的紫婆婆)。再比如对应于程序配置文件的类，因为配置文件只有一个(假设程序只有一个配置文件)，那么与之对应的代表配置文件的类的实例自然只应该有一个。 为达成这个目的，其实我们可以什么也不用做。只要具体生成实例的代码具备自律性，即对于只需要一个实例的类，我们只调用一次new即可。 这样做的优点是简单，而缺点则是系统健壮性低：设计系统架构是最开始时打下的基础，而new实例这种操作则会随着时间的推进无休止的添加。也许一开始new实例的代码可以保证唯一性，但是随着时间的流逝，new实例的位置越来越多，犯错误的风险自然会越来越大。 类似的例子还有父类方法的重写。如果父类希望所有它的子类都能重写自己的方法m1()，它其实是可以什么都不用做的：只要子类们都自觉重写即可。但是这并非是强制的，如果未来某一天，某个子类决定不重写了，父类将无能为力。因此，为了保证强制力，父类可能会将自身声明为抽象类，进而可以将m1()声明为抽象方法，此时子类再继承该类时，就必须重写方法m1()了。 在保证某类实例的唯一性这个问题上，我们也可以通过某种手段强制保证这点。由此演化而成的设计模式就是Singleton模式。Singleton的含义是”只含有一个元素的集合”，也就是所谓的单例。 示例程序首先给出类图： 本程序中的所有代码将被统一置于design5包下，结构如下： 其中Main.java是测试代码，并没有出现在类图中。 下面将逐个贴出每个类的源码。 Singleton类 123456789101112package design5;public class Singleton &#123; private static Singleton SINGLETON = new Singleton(); private Singleton() &#123;&#125; public static Singleton getInstance() &#123; return Singleton.SINGLETON; &#125;&#125; Singleton的构造函数的方法体是空的，显式声明它的唯一目的就是为了将它的访问权限标志为private。这样就将Singleton能够实例化的位置限定在自身类的内部了。 外部是通过静态方法getInstance()来获取Singleton的实例的。虽然没有强制的规定，不过通常我们都会将单例模式中获取实例的方法命名为getInstance()。该方法会返回Singleton的类变量SINGLETON。由于SINGLETON的访问权限是private，这样外部就只能通过getInstance()方法来获取它了，进而实现了单例的功能。 在上例中，SINGLETON在声明时直接就初始化了，也就是说，SINGLETON会在类初始化的时候跟着一同初始化。这样的好处是SINGLETON在一开始就会处于一个随时可用的状态，但坏处则是有的时候这是一种浪费，尤其是在SINGLETON占用空间较大时：直到真正需要SINGLETON之前，这部分空间实际上都是浪费的，因此有的时候我们也会这样写单例： 1234567891011121314package design5;public class Singleton &#123; private static Singleton SINGLETON; private Singleton() &#123;&#125; public static Singleton getInstance() &#123; if (null == Singleton.SINGLETON) Singleton.SINGLETON = new Singleton(); return Singleton.SINGLETON; &#125;&#125; 很显然，这又是程序员们熟悉的老话题了。也就是时间和空间上的权衡。 例子1一开始SINGLETON就是可用的，但是却会有一段SINGLETON无用却占用空间的时期。例子2则是每次在需要SINGLETON时去检查它是否初始化，节省了空间却增加了时间上的开销：每次获取实例都要多判断一次if。 例子1因为会在类初始化时就初始化SINGLETON，因此它先天就是线程安全的。而例子2则是线程不安全的，如果需在并发环境下使用，还需对getInstance()方法进行并发控制，例如如下的做法： 1234567891011121314package design5;public class Singleton &#123; private static Singleton SINGLETON; private Singleton() &#123;&#125; public static synchronized Singleton getInstance() &#123; if (null == Singleton.SINGLETON) Singleton.SINGLETON = new Singleton(); return Singleton.SINGLETON; &#125;&#125; 在单例模式中，例子1被称作”饿汉单例”–调用者很饿，调用者不能等，必须尽快返回结果；而例子2则被称作”懒汉单例”–生产者很懒，能拖就拖，不到万不得已不生产。 再扩展来说，”饿”与”懒”在编程领域其实是一组很常见的概念(例如懒加载等)。其核心基本都不出上文论述的藩篱：也就是到底是用时间换空间，还是用空间换时间的问题。 Main类 12345678910package design5;public class Main &#123; public static void main(String[] args) &#123; Singleton s1 = Singleton.getInstance(); Singleton s2 = Singleton.getInstance(); System.out.println(s1 == s2); &#125;&#125; 输出： 1true 说明我们通过多次调用getInstance()方法得到的实例确实是单例的。 登场角色上面的示例程序介绍了Singleton模式的Java实现，下面咱们试着跳出语言层面，抽象出Singleton模式中登场的角色。 Singleton Singleton模式中只有Singleton这一个角色。它可以保证自身只生成一个实例。在示例程序中，由Singleton类来扮演这个角色。 下面是抽象后，无关语言的类图： 相关设计模式Singleton模式算是一个比较底层与基础的设计模式，只要是需要确保仅有一个实例的场合，都可以使用单例模式。例如，在以下模式中，很多角色一般都只需要生成一个实例： 4.Factory Method模式 8.Abstract Factory模式 7.Builder模式 15.Facade模式]]></content>
      <categories>
        <category>Java 设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 设计模式-4.Factory Method模式]]></title>
    <url>%2F2018%2F06%2F14%2FJava%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-4Factory%20Method%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在《图解设计模式》一书中，Factory Method模式被归入了第2部分交给子类。在GoF原书中，Factory Method模式则被归入了创建型设计模式。简单来说，Factory Method模式可以被描述为：在抽象的父类工厂中定义生成抽象的父类产品的逻辑，然后由具体的子类工厂生产出具体的子类产品。也就是所谓的”将实例的生成交给子类”。 综述简单来说，我们可以认为Factory Method模式是3.Template Method模式的特例。Template Method模式是指父类定义流程，却不负责具体的实现。而Factory Method模式则是进一步将流程限定为”实例的生成”。 因此，后文在介绍Factory Method模式时，基本都会对照着Template Method模式来说。 示例程序本程序会分种族的使用工厂创建东方Project的角色，下面先给出类图： 本程序中的所有代码将被统一置于design4包下，结构如下： 其中Main.java是测试代码，并没有出现在类图中。 下面将逐个贴出每个类的源码。 RoleFactory类 12345678910package design4;public abstract class RoleFactory &#123; public Role create(String name) &#123; return this.createRole(name); &#125; protected abstract Role createRole(String name);&#125; 其中，create()方法就是Template Method模式中的模版方法，而createRole()方法则是Template Method模式中需子类实现的抽象方法。 Role类 1234567891011121314151617package design4;public abstract class Role &#123; private String name; protected Role(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;我叫&quot; + this.name + &quot;，我的种族是&quot; + this.race(); &#125; protected abstract String race();&#125; HumanFactory类 123456789package design4;public class HumanFactory extends RoleFactory &#123; @Override protected Role createRole(String name) &#123; return new Human(name); &#125;&#125; Human类 12345678910111213package design4;public class Human extends Role &#123; protected Human(String name) &#123; super(name); &#125; @Override protected String race() &#123; return &quot;人类&quot;; &#125;&#125; VampireFactory类 123456789package design4;public class VampireFactory extends RoleFactory &#123; @Override protected Role createRole(String name) &#123; return new Vampire(name); &#125;&#125; Vampire类 12345678910111213package design4;public class Vampire extends Role &#123; protected Vampire(String name) &#123; super(name); &#125; @Override protected String race() &#123; return &quot;吸血鬼&quot;; &#125;&#125; Main类 12345678910111213141516171819package design4;import java.util.ArrayList;import java.util.List;public class Main &#123; public static void main(String[] args) &#123; List&lt;Role&gt; roleList = new ArrayList&lt;Role&gt;(5); RoleFactory roleFactory = new HumanFactory(); roleList.add(roleFactory.create(&quot;博丽灵梦&quot;)); roleList.add(roleFactory.create(&quot;雾雨魔理沙&quot;)); roleList.add(roleFactory.create(&quot;十六夜咲夜&quot;)); roleFactory = new VampireFactory(); roleList.add(roleFactory.create(&quot;蕾米莉亚·斯卡雷特&quot;)); roleList.add(roleFactory.create(&quot;芙兰朵露·斯卡蕾特&quot;)); for (Role role : roleList) System.out.println(role); &#125;&#125; 执行Main.java后输出： 12345我叫博丽灵梦，我的种族是人类我叫雾雨魔理沙，我的种族是人类我叫十六夜咲夜，我的种族是人类我叫蕾米莉亚·斯卡雷特，我的种族是吸血鬼我叫芙兰朵露·斯卡蕾特，我的种族是吸血鬼 登场角色上面的示例程序介绍了Factory Method模式的Java实现，下面咱们试着跳出语言层面，抽象出Factory Method模式中登场的角色。 Creator(创建者) Creator对应于Template Method模式中的抽象父类，其中至少应包含两个方法，首先是create()方法，它对应于Template Method模式中的模版方法，用来控制”生成实例”这个业务流程。然后是factoryMethod()方法，它对应于Template Method模式中的抽象方法，需要子类角色ConcreteCreator去具体的实现。 在示例程序中，抽象类RoleFactory扮演了这个角色。 Product(产品) Product是Creator创建出的实例所属的类。当然，Creator是抽象的工厂，是无法创建实例的。因此Product是抽象的产品。 Creator与Product均是抽象上的概念，它们之间是互相对应的，不承载具体的业务逻辑。Creator就是抽象的生成产品的工厂，至于具体是生成什么产品的，它不知道。而Product是抽象意义上的产品，它不是某种具体的产品，它代表的是”产品”这个概念。 在示例程序中，抽象类Role扮演了这个角色。当然啦，在示例程序中，因为Role类中包含抽象方法race()，因此必须要被声明为抽象的。但实际上，Product中并非必须要包含抽象方法，所以仅从Java语言规范的角度来讲，此时Product也可以是非抽象的。 至于是否要将Product声明为抽象的，则要依具体的情境而定。如果Product非常抽象，真的就只是代表一个概念，绝不会被实例化，那么建议大家将Product声明为抽象的(即便其中没有抽象方法)，从语法的角度上讲，这可以保证Product不会被new出实例。更重要的是，这表明了一种态度：Product代表的是抽象的”产品”这一概念，而不是某个具体的产品。反之，如果Product虽然也代表”产品”这个概念，但是它却没有那么抽象，我们甚至可以实例化一个代表”产品”的实例出来，那么自然就不能声明为抽象的了。 ConcreteCreator(具体的创建者) ConcreteCreator对应于Template Method模式中的子类，它会实现其抽象父类Creator中的抽象方法。在示例程序中，HumanFactory及VampireFactory均饰演这个角色。作为工厂它们分别负责生成具体的产品Human及Vampire。 之所以创建了两个工厂，是为了说明抽象与具体之间的关系：抽象角色(Creator,Product)是唯一的，Creator代表”工厂”这个概念，而”Product”代表”产品”这个概念，概念自然是唯一的。但是属于这个概念的个体则是无穷多个的，在本程序中，就有生产人类的工厂及生产吸血鬼的工厂。如果我们需要，还可以很轻松的添加其他的工厂：诸如生产魔法使的工厂及生产神的工厂等。 ConcreteProduct(具体的产品) ConcreteProduct与ConcreteCreator是一一对应的。什么样的工厂就会生产什么样的产品。在示例程序中，Human及Vampire均扮演了这个角色。 下面是抽象后，无关语言的类图： Factory Method模式的变种除了实例代码中的RoleFactory类之外，Creator这个角色其实还可以这样写： 12345678910public class TestFactory &#123; public TestProduct create() &#123; return this.createTest(); &#125; protected TestProduct createTest() &#123; return new TestProduct(); &#125;&#125; 较之前文中的示例程序，这段代码中的Creator角色其实就不完全遵循Template Method模式了。此时的Factory Method模式(假设我们还认为这样的变种算是Factory Method模式的话)就不再是Template Method模式的特例了，因为createTest()方法不再是抽象的了。相应的，因为需要切实的实例化，作为抽象产品的TestProduct类自然不能再被声明为abstract的了，这也就是前文我们在介绍Product角色时提到的”不那么抽象的情况”。 这样做的好处和坏处都是显而易见的。从好的角度来讲，此时抽象工厂实际上是有生产能力的了，所以从严格的意义上讲，TestFactory不应该被叫做抽象工厂，而应该被叫做默认工厂。相应的，Product也应该被叫做默认产品。在子类没有什么特殊需要的情况下，它们直接用父类提供的统一规格的产品就行。如果它们有特殊的需求，那么重写createTest()方法就好。 而从坏的角度上讲，这相当于是”坏了规矩”。此时的Creator及Product不再代表一个概念了，必须是非抽象的了，因为无论它们被声明的多通用化，它们都是有实体的了，是要产生实例的。而子类由重写父类抽象方法到重写父类非抽象方法，其强制力也进一步降低：前者是非做不可，而后者则是可做可不做。 说”坏了规矩”，貌似是个挺严重的事。不过在实际编程中，规矩有时也没那么重要，根据实际的情况，做出最合理的应对才是最重要的。事实上，并不仅仅是Factory Method模式，所有的设计模式说穿了都是经验的总结，并不是规范性的东西，因此一切设计模式，其实都应该根据实际情况做出灵活的应对。 相关设计模式3.Template Method模式7.Builder模式8.Abstract Factory模式 关于这4个设计模式间的联系与区别，详见8.Abstract Factory模式。 5.Singleton模式 Creator与ConcreteCreator这个角色通常都是唯一的。Creator的唯一性比较好理解，表示”工厂”的概念只有一个，Creator自然只需要一个就够了。需要进一步解释一下的是ConcreteCreator这个角色。具体的工厂可以有多个类型，但是每个类型的工厂通常只需要一个。例如我们可以同时创建生产桔子与生产苹果的工厂。从总数上说，扮演ConcreteCreator角色的实例有两个，但具体到每种特定的类型，则只会有一个。 正因为这种唯一性，Creator与ConcreteCreator通常都会应用单例模式来确保单一性。实际上，并不仅仅是这两个角色，也不仅仅是局限在Factory Method模式，任何需要从逻辑上确保单一性的角色都可以应用单例模式。 当然，我们的示例程序仅仅只是举例，因此不想弄得太复杂，自然就没使用单例模式啦。 1.Iterator模式 我们可以应用Factory Method模式来实现Iterator模式。角色对应如下： Creator：生产”迭代器”这个概念的抽象工厂。 Product：代表”迭代器”这个概念的抽象类。 ConcreteCreator：生成具体迭代器的工厂。 ConcreteProduct：具体的迭代器，例如链表的迭代器，数组的迭代器等。]]></content>
      <categories>
        <category>Java 设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 设计模式-3.Template Method模式]]></title>
    <url>%2F2018%2F06%2F12%2FJava%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-3Template%20Method%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在《图解设计模式》一书中，Template Method模式被归入了第2部分交给子类。在GoF原书中，Template Method模式则被归入了行为型设计模式。简单来说，Template Method模式可以被描述为：在父类中定义处理框架，在子类中进行具体处理。也就是所谓的”将具体处理交给子类”。 综述template这个单词的含义为”模版”，在介绍Template Method模式之前，我们有必要先介绍一下模版。 模版是指带有镂空文字的薄薄的塑料板，只要用笔在模版的镂空处进行临摹，即使是手写也能写出整齐的文字。不过，虽然写出的文字的样式都是相同的，但是具体的感觉则是依赖于具体的笔：使用铅笔的话写出的就是铅笔字，使用钢笔的话写出的就是钢笔字。 本文要介绍的Template Method模式就是带有模版功能的模式。作为模版的方法被定义在父类中，它就像镂空的那张模版，只规定样式，因此是抽象的。而具体的实现，也就是到底是铅笔还是钢笔，则被定义在了子类中。 像这样在父类中定义处理流程的框架，在子类中实现具体处理的模式就是Template Method模式。 按照这个定义来说，Template Method模式与多态极为类似。甚至可以认为就是由多态演化出的设计模式。因为在Java中，多态就是同一个行为具有多个不同表现形式或形态的能力。而要称之为多态，则需要3个必要条件：继承，重写，父类引用指向子类对象。很显然，这与Template Method模式的定义完美契合。 当然，多态只是Template Method模式演化的基础，作为一个模式，Template Method模式较之多态还是要复杂一些的：在Template Method模式中，父类里除了有会被子类继承的抽象方法之外，还会有作为模版功能存在的，描述业务流程的非抽象方法存在。 示例程序本程序会将字符或字符串重复输出5次，下面先给出类图： 本程序中的所有代码将被统一置于design3包下，结构如下： 其中Main.java是测试代码，并没有出现在类图中。 下面将逐个贴出每个类的源码。 AbstractDisplay类 1234567891011121314151617181920212223package design3;public abstract class AbstractDisplay &#123; private int times; protected AbstractDisplay(int times) &#123; this.times = times; &#125; public final void display() &#123; this.open(); for (int i = 0; i &lt; this.times; i++) this.print(); this.close(); &#125; protected abstract void open(); protected abstract void print(); protected abstract void close();&#125; 其中，display()是控制业务流程的模版方法。而open()，print()，close()则是交由子类去实现的具体方法。 需要注意的是，display()被强硬的声明为了final，通常来说，这在Template Method模式中是必须的。这其实就是AbstractDisplay作为父类在告诉子类：继承我可以，但是除了必须实现我未实现的抽象方法之外，还不能修改我制定的业务流程。 open()，print()，close()均被声明为了protected，不过这个就没什么强制性了。只不过通常来说，抽象方法就是用来被子类继承的，让外人看到也没用，使用protected只是一个编程时的好习惯。 CharDisplay类 1234567891011121314151617181920212223242526package design3;public class CharDisplay extends AbstractDisplay &#123; private char ch; public CharDisplay(char ch, int times) &#123; super(times); this.ch = ch; &#125; @Override protected void open() &#123; System.out.print(&quot;&lt;&lt;&quot;); &#125; @Override protected void print() &#123; System.out.print(this.ch); &#125; @Override protected void close() &#123; System.out.println(&quot;&gt;&gt;&quot;); &#125;&#125; StringDisplay类 123456789101112131415161718192021222324252627282930313233package design3;public class StringDisplay extends AbstractDisplay &#123; private String str; public StringDisplay(String str, int times) &#123; super(times); this.str = str; &#125; @Override protected void open() &#123; this.printLine(); &#125; @Override protected void print() &#123; System.out.println(&quot;|&quot; + this.str + &quot;|&quot;); &#125; @Override protected void close() &#123; this.printLine(); &#125; private void printLine() &#123; System.out.print(&quot;+&quot;); for (int i = 0; i &lt; this.str.length(); i++) System.out.print(&quot;-&quot;); System.out.println(&quot;+&quot;); &#125;&#125; Main.java 123456789101112package design3;public class Main &#123; public static void main(String[] args) &#123; int times = 5; AbstractDisplay adChar = new CharDisplay(&apos;蓬&apos;, times); adChar.display(); AbstractDisplay adStr = new StringDisplay(&quot;I am the bone of my sword&quot;, times); adStr.display(); &#125;&#125; 在使用中，AbstractDisplay类型的引用分别指向了其子类CharDisplay及StringDisplay的实例，这里是里氏替换原则的应用。 执行后输出： 12345678&lt;&lt;蓬蓬蓬蓬蓬&gt;&gt;+-------------------------+|I am the bone of my sword||I am the bone of my sword||I am the bone of my sword||I am the bone of my sword||I am the bone of my sword|+-------------------------+ 登场角色上面的示例程序介绍了Template Method模式的Java实现，下面咱们试着跳出语言层面，抽象出Template Method模式中登场的角色。 AbstractClass(抽象类) AbstractClass会定义非抽象的模版方法及需由子类角色ConcreteClass具体去实现的抽象方法。在示例程序中，由AbstractDisplay类负责扮演这个角色。 ConcreteClass(具体类) 该角色负责实现AbstractClass角色中定义的抽象方法，这些方法将由AbstractClass角色的模版方法调用。在示例程序中，由CharDisplay类及StringDisplay类联袂扮演这个角色。 下面是抽象后，无关语言的类图： InputStream对Template Method模式的应用Java API中的抽象类java.io.InputStream应用了Template Method模式。 InputStream的核心的读取流的方法为： 12345678910111213141516171819202122232425262728public int read(byte b[], int off, int len) throws IOException &#123; if (b == null) &#123; throw new NullPointerException(); &#125; else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) &#123; throw new IndexOutOfBoundsException(); &#125; else if (len == 0) &#123; return 0; &#125; int c = read(); if (c == -1) &#123; return -1; &#125; b[off] = (byte)c; int i = 1; try &#123; for (; i &lt; len ; i++) &#123; c = read(); if (c == -1) &#123; break; &#125; b[off + i] = (byte)c; &#125; &#125; catch (IOException ee) &#123; &#125; return i;&#125; 对于输入流的读取而言，无论是什么流，其实质都是由二进制的字节组成的有序集合：二进制字节仿佛水流一样流过。在上面的方法中我们也能看到，其最核心的读取字节的方法是read()，它每次会从特定位置向后再读一个字节。它在InputStream类中的源码为： 1public abstract int read() throws IOException; 至此事情就很清晰了：首先介绍的那个非抽象read()方法是模版方法，其中规定了流程：一个一个取字节，直到取够数为止。而后面介绍的那个抽象的read()方法就是具体的”一个一个取字节”的方法，将由具体的子类实现。 相关设计模式4.Factory Method模式7.Builder模式8.Abstract Factory模式 关于这4个设计模式间的联系与区别，详见8.Abstract Factory模式。 10.Strategy模式 Strategy模式与Template Method模式均与Java中多态的思想一脉相承。]]></content>
      <categories>
        <category>Java 设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 设计模式-2.Adapter模式]]></title>
    <url>%2F2018%2F06%2F08%2FJava%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2Adapter%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在《图解设计模式》一书中，Adapter模式被归入了第1部分适应设计模式。在GoF原书中，Adapter模式则被归入了结构型设计模式。简单来说，Adapter模式可以被描述为：连接具有不同接口(API)的类。也就是所谓的加个”适配器”以便于复用。 综述Adapter这个单词的释义为”使…相互适应的东西”。在计算机领域，它被翻译为”适配器”。 其实不仅仅是计算机领域，适配器在我们的生活中是很常见的东西。例如老式的电脑只能以VGA接口连接显示器，而时下的显示器很有可能已经取消VGA这个过时的接口了，而只有HDMI和DI接口。这种情况下电脑与显示器是无法连接的，换掉其中一方以适配又很浪费(毕竟它们都还是挺贵的)。这个时候相对来说便宜很多的”转接头”(这是通俗的叫法，其实就是适配器)就派上用场了：例如VGA-HDMI转接口，顾名思义，它的一端连接VAG接口，另一端连接HDMI接口。这样不同接口的电脑与显示器就可以相互连接了。 在程序世界中，适配器的作用大抵也是如此。例如我们经常会遇到现有的程序无法直接使用，需要做适当的变换之后才能使用的情况。这种用于填补”现有的程序”与”所需的程序”之间差异的设计模式就是Adapter模式。 Adapter模式也被称作Wrapper模式。Wrapper的含义是”包装器”。就像用精美的包装纸将普通商品包装成礼物那样，Wrapper会替我们把某样东西包起来，使其能够用于其他用途。 Adapter模式有以下两种具体的实现： 模式一：类适配器模式(使用继承的适配器)。 模式二：对象适配器模式(使用委托的适配器)。 本文将依次介绍这两种模式。 模式一：类适配器模式(使用继承的适配器)示例程序首先，给出给出本程序的类图： 在介绍程序之前，我们不妨再更详细的分析一下本文开篇时提到的”显示器连接电脑”的问题。在这个问题中，一共出现了4个角色： 电脑：待显示内容的提供者。负责提供数据。 显示器：与人类交互的接口。也就是说，显示器显示了一个画面，这个画面在电脑内部肯定是以某种形式存储的，然后显示器解析这个数据并将之转换为了易于人类理解的画面。显示器不实际生产数据，它只是向人类展现数据。对于人类而言，在显示画面这个需求上，他是不需要知道电脑的存在的，他只需要看显示器提供的画面即可。 适配器：如果电脑与显示器不是适配的，即电脑传输的数据显示器无法解析，那么就需要适配器将该数据转换为显示器能理解的格式。 人类：观看显示器展现的画面。 类似的，本程序也有4个一一对应的角色： Banner类：对应于电脑。负责实际的功能。它内部包含两个方法。其中showWithParen()方法会为字符串加上()。showWithAster()方法会为字符串加上**。 Print接口：对应于显示器。不实际生产数据。但却是本程序中负责与观察者(即人类，或main函数)交互的组件。它内部包含两个方法。其中printWeak()方法会弱化字符串。printStrong()方法会强调字符串。 PrintBanner类：对应于适配器。 Main类：对应于观看屏幕的人。其中包含main方法，是程序的入口。会对本程序的功能进行调用。 总结来说，就是Main类使用PrintBanner类以期实现Print接口所约束的功能。而该功能在PrintBanner类内部实际是通过Banner类实现的。 本程序中的所有代码将被统一置于design2包下，结构如下： 下面就来逐一看下具体的代码吧。 Banner类 123456789101112131415161718package design2;public class Banner &#123; private String str; public Banner(String str) &#123; this.str = str; &#125; public void showWithParen() &#123; System.out.println(&quot;(&quot; + this.str + &quot;)&quot;); &#125; public void showWithAster() &#123; System.out.println(&quot;*&quot; + this.str + &quot;*&quot;); &#125;&#125; Print接口 12345678package design2;public interface Print &#123; void printWeak(); void printStrong();&#125; PrintBanner类 123456789101112131415161718package design2;public class PrintBanner extends Banner implements Print &#123; public PrintBanner(String str) &#123; super(str); &#125; @Override public void printWeak() &#123; super.showWithParen(); &#125; @Override public void printStrong() &#123; super.showWithAster(); &#125;&#125; 这里适配器直接调用了Banner类的方法。实际上，两个待适配的组件是不会匹配得这么好的(否则也不用适配了)，内容还是那些内容，不过适配器通常都要做一些组合和转换。 Main类 12345678910package design2;public class Main &#123; public static void main(String[] args) &#123; Print print = new PrintBanner(&quot;ReimuWang&quot;); print.printStrong(); print.printWeak(); &#125;&#125; 运行Main.java后输出： 12*ReimuWang*(ReimuWang) 本例中，为了简单起见，我们将PrintBanner类的声明放到了main函数中。但事实上，调用者是完全不需要知道PrintBanner的。对于使用者而言，它只管拿到一个实例，这个实例实现了Print接口，多数情况下，这个实例都是外部传递给调用者的，它根本不用操心这个实例是怎么来的，内部实现是什么样子的，它就只需要利用这个实例来调用Print接口约束的功能就可以了。 模式二：对象适配器模式(使用委托的适配器)示例程序在介绍对象适配器模式之前，有必要先简要介绍一下委托。 简单来说，委托就是”交给其他人”。比如我们需要去领取一份材料，但恰好没有时间。此时我们就可以委托他人代为领取。当然，如果这份材料足够重要的话(例如新办理好的身份证)，还需要我们出具一份委托书，大意就是”本人委托xx代我领取xx材料”。在编程语言中，委托的含义也是大抵如此，就是指将某个方法中的实际业务处理交付给另一个方法。 所谓适配器，最重要的一个特征就是要能同时兼容待适配的所有组件，如果无法做到这一点，那么后续一切的适配都将无从谈起。在电脑连接显示器的小例子中，转接头一端可以连接电脑，另一端可以连接显示器。而在上文介绍的类适配器模式的示例程序中，PrintBanner继承了Banner类，同时实现了Print接口。不过细心的朋友们想必已经注意到了，这种模式的局限性是比较大的，如果Print不是一个接口，而是一个类的话，该怎么办呢？Java是单继承的语言，我们是无法同时继承Banner类与Print类的。 这就可以使用本小节欲介绍的对象适配器模式了。照例先给出示例程序的类图： 较之前例，Banner类没有发生任何变化。不同的是，Print由接口变成了一个类。当然，它是一个抽象类，里面的方法printWeak()与printStrong()也均为抽象方法，没有具体的实现。 PrintBanner自然也要做出相应的更改。因为Java是单继承的，PrintBanner无法同时继承Print与Banner。权衡之下，PrintBanner最终还是选择继承了Print，因为从业务层面来说，PrintBanner还是与Print更为接近。对于使用者而言，虽然他实际用的是PrintBanner，但他一直都是当做Print在用的。而Banner更像是为PrintBanner实现功能提供技术支持，因此PrintBanner与Banner之间的关系变为了聚合：Banner成为了PrintBanner的一个成员变量。这样PrintBanner就能使用Banner提供的功能了。 说得简单些，就是Print要求Banner提供功能。Banner一看，发现虽然要的东西自己都有，但是格式却无法完全对上，而它又不想为了这一个单独的功能修改自身。因此它就委托了第三方PrintBanner，并把自己能提供的东西都交给它。PrintBanner并不会添加新的业务逻辑，它只会对Banner提供的东西做出组合和格式上的修改，然后把符合Print要求的内容交给Print。 当然这个委托关系也可以反着理解。Print要求PrintBanner提供功能。PrintBanner本身并没有实现功能，本质上它就相当于一个中间商。它会把需求委托给第三方Banner。当然，Banner并不是专为Print存在的，虽然Print要的东西Banner都有，基本需求也能满足，但是格式并不能完全对上。而PrintBanner则负责这个转换对接的工作。 两种对委托的理解方式本质上是一样的，只是视角不同而已。 本程序中的所有代码将被统一置于design2_2包下，结构如下： 下面来看具体的代码。 Banner类 123456789101112131415161718package design2_2;public class Banner &#123; private String str; public Banner(String str) &#123; this.str = str; &#125; public void showWithParen() &#123; System.out.println(&quot;(&quot; + this.str + &quot;)&quot;); &#125; public void showWithAster() &#123; System.out.println(&quot;*&quot; + this.str + &quot;*&quot;); &#125;&#125; Banner类较之前例没有变化，在此再次贴出。 Print类 12345678package design2_2;public abstract class Print &#123; public abstract void printWeak(); public abstract void printStrong();&#125; PrintBanner类 1234567891011121314151617181920package design2_2;public class PrintBanner extends Print &#123; private Banner banner; public PrintBanner(String str) &#123; this.banner = new Banner(str); &#125; @Override public void printWeak() &#123; this.banner.showWithParen(); &#125; @Override public void printStrong() &#123; this.banner.showWithAster(); &#125;&#125; Main类 12345678910package design2_2;public class Main &#123; public static void main(String[] args) &#123; Print print = new PrintBanner(&quot;ReimuWang&quot;); print.printStrong(); print.printWeak(); &#125;&#125; Main类较之前例没有变化，依然原样贴出。 运行Main.java后输出： 12*ReimuWang*(ReimuWang) 登场角色Adapter模式中有以下角色登场： Target(对象) 对请求者可见的供请求的对象。在”电脑连接显示器”这个例子中，显示器扮演了这个角色。在上文的两段示例程序中，Print 接口/类 扮演了这个角色。 Client(请求者) 向Target提出功能申请的请求者。在”电脑连接显示器”这个例子中，观看显示器的人扮演了这个角色。在上文的两段示例程序中，Main类扮演了这个角色。 Adaptee(被适配) 提供实际功能的对象。在”电脑连接显示器”这个例子中，电脑扮演了这个角色。在上文的两段示例程序中，Banner类扮演了这个角色。 Adapter(适配) 提供Target-Adaptee之间内容格式的转换。在”电脑连接显示器”这个例子中，转接头扮演了这个角色。在上文的两段示例程序中，PrintBanner类扮演了这个角色。 下面给出抽象后，无关语言的类图。 首先是模式一：类适配器模式(使用继承的适配器)： 然后是模式二：对象适配器模式(使用委托的适配器)： Adapter模式的应用场景针对欲实现的新功能，当前程序已有部分的代码积累 针对这种情况，除了使用本文介绍的Adapter模式之外，还可以有如下两种做法： 完全无视已有的，类似功能的代码，重新写一套新的。尤其是当已有代码不是自己写的的时候，做出这种选择的程序员的比例会特别的高。因为没人愿意读其他人的代码，绝大多数时候，读他人的代码，进而理解他人的代码，其成本是远高于自己重新写一份的。不过这并不是一种负责的做法，从短期的角度来看，功能的实现是没问题的，开发工作量的减少导致工期得到缩短，上线后出bug的概率也会降低。不过从长远的角度来看，这显然不利于程序的维护。如果负责某个项目的程序员们更倾向于以这种方式管理代码，那么程序中冗余的东西将会越来越多，程序也将越来越难于理解，修改，或增加新功能。直到某一天，程序达到了临界点，不得不进行重构。这仿佛是在击鼓传炸弹，大家都只考虑眼前凑合写着，在谁手上炸算谁倒霉。而且这不仅仅是某几个程序员倒霉的问题，因为这种情况导致的强制重构会耗费大量的人力物力，严重提高程序的维护成本。 修改现有的代码，让它既能满足现在已有的需求，又能满足新的需求。这是我最不推荐的一种方式。因为这意味着这次需求所影响的将不再是它本身了，现在在线上正常运行的功能也会受到影响。那么本次上线需要测试的范围将大幅增加。更糟的是，很多时候，这种影响是无法评估的。很有可能，新功能上线后，一个完全意想不到的地方会报错，好不容易查出来，改好了，另一个地方又错了，进而陷入无休止的解线上bug的噩梦中。 综上，在当前程序已有部分代码积累的情况下，推荐优先使用Adapter模式。 当前程序并没有新功能相关的代码积累 针对这种情况，首先我们需要对这次的新功能做出评估，分解抽象出它所需用到的功能点。如果这些功能点很特殊，换句话说，在我们可以预期的未来里，不会再有别的需求可能会复用到这些功能点了，那么就没必要使用Adapter模式，直接写就好了。 反之，如果这些功能点还挺常用的，以后很有可能会有类似的需要这些功能点的需求，那么这些功能点就不要写得太特殊，即不要与本次需求耦合得太紧。我们可以写出一个相对通用的功能点后再使用一个适配器将其特殊化，以完美匹配本次需求。这样，当再有类似需要来了，需要用到这个功能点时，我们就可以再写一个新的适配器，实现代码的复用。 典型场景：历史版本兼容 对于各种软件，尤其是客户端软件而言，历史版本的兼容是最基本的需求之一。例如某手机软件，最初客户端的版本是1.0，对应的服务端的版本同样也是1.0。过了一段时间，客户端与服务端的版本均升级为了2.0。服务端是唯一的，握在软件公司手里，因此服务端的升级可以由软件公司自由控制。然而，客户端却是复数个装在用户手机上的，其升级时机完全由用户自身控制。当然，软件公司可以要求用户强制升级：即如果还想用我们的软件，那么必须升级到最新版本才行。不过这有些过于粗暴了，通常只会在跨度特别大的版本更新时才会偶尔使用。如果总是这样做的话，会让用户觉得非常不方便，降低用户对软件的评价。 因此，绝大多数时候，都需要同时向前兼容很多个客户端软件的版本。以上文中版本1.0 –&gt; 版本2.0为例，我们给出示例图。 为了让模型尽可能的简单，我们不妨假设只有1个服务端及两个客户端。最开始大家都是1.0版本时的情况如下图所示： 随后服务端及客户端1都升级为2.0版本，但客户端2并未升级，仍是1.0版本： 这样便起到了兼容历史版本的效果。 应用Adapter模式以调用Properties本程序将统一置于design2_test2包中，结构如下： Java API中的java.util.Properties类为我们提供了管理键值对的方法。作为一个供所有Java程序员使用的基础组件，它自然不可能照顾到程序员所有的需求。因此我们可以让它扮演Adapter模式中的Adaptee角色。 然后我们可以设计一个FileIO接口以扮演Target的角色： 123456789101112131415package design2_test2;import java.io.IOException;import java.util.Date;public interface FileIO &#123; void readFromFile(String filename) throws IOException; void writeToFile(String filename) throws IOException; void setTime(); Date getTime();&#125; 每一个FileIO接口的实现的实例都负责管理一个Properties类的实例。Properties类中提供了大量的用于管理键值对的方法。不过本次需求中只会用到最基础的那一部分，同时由于需求的特殊性，还需要写一些特殊化的方法。 首先介绍一下该程序正常的使用流程： setTime()方法会向Properties实例中以键值对的方式写入当前时间。Key包括year,month,day,hour,minute,second。 writeToFile()方法会将设置好的Properties实例写入文件中。 readFromFile()方法会读取文件并将其中的内容写入Properties实例。 getTime()方法会得到当前Properties实例中存储的时间。 因为只是一个简单的示例程序，因此就不写非正常流程下的容错机制啦。 既然我们将Target角色设计为了一个接口，那么显然，我们是要使用类适配器模式了(当然啦，这也得要Adaptee角色，也就是Properties类允许继承才行)。 然后就是Adapter模式的重点，也就是Adapter角色的扮演者啦： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package design2_test2;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.util.Calendar;import java.util.Date;import java.util.Properties;public class FileProperties extends Properties implements FileIO &#123; private static final long serialVersionUID = -2256749719985770822L; @Override public void readFromFile(String filename) throws IOException &#123; super.load(new FileInputStream(filename)); &#125; @Override public void writeToFile(String filename) throws IOException &#123; super.store(new FileOutputStream(filename), &quot;write by FileProperties&quot;); &#125; @Override public void setTime() &#123; Calendar calendar = Calendar.getInstance(); super.setProperty(&quot;year&quot;, calendar.get(Calendar.YEAR) + &quot;&quot;); super.setProperty(&quot;month&quot;, calendar.get(Calendar.MONTH) + &quot;&quot;); super.setProperty(&quot;week&quot;, calendar.get(Calendar.WEEK_OF_MONTH) + &quot;&quot;); super.setProperty(&quot;day&quot;, calendar.get(Calendar.DAY_OF_MONTH) + &quot;&quot;); super.setProperty(&quot;hour&quot;, calendar.get(Calendar.HOUR_OF_DAY) + &quot;&quot;); super.setProperty(&quot;minute&quot;, calendar.get(Calendar.MINUTE) + &quot;&quot;); super.setProperty(&quot;second&quot;, calendar.get(Calendar.SECOND) + &quot;&quot;); &#125; @Override public Date getTime() &#123; Calendar calendar = Calendar.getInstance(); calendar.set(Calendar.YEAR, Integer.parseInt(super.getProperty(&quot;year&quot;))); calendar.set(Calendar.MONTH, Integer.parseInt(super.getProperty(&quot;month&quot;))); calendar.set(Calendar.WEEK_OF_MONTH, Integer.parseInt(super.getProperty(&quot;week&quot;))); calendar.set(Calendar.DAY_OF_MONTH, Integer.parseInt(super.getProperty(&quot;day&quot;))); calendar.set(Calendar.HOUR_OF_DAY, Integer.parseInt(super.getProperty(&quot;hour&quot;))); calendar.set(Calendar.MINUTE, Integer.parseInt(super.getProperty(&quot;minute&quot;))); calendar.set(Calendar.SECOND, Integer.parseInt(super.getProperty(&quot;second&quot;))); return calendar.getTime(); &#125;&#125; 最后是扮演Client角色的Main.java。首先我们先来写一个写入文件的需求： 12345678910111213package design2_test2;import java.io.File;import java.io.IOException;public class Main &#123; public static void main(String[] args) throws IOException &#123; FileIO fileIO = new FileProperties(); fileIO.setTime(); fileIO.writeToFile(&quot;D:&quot; + File.separator + &quot;test.txt&quot;); &#125;&#125; 执行该代码，会在D盘下生成新文件test.txt： 123456789#write by FileProperties#Tue Jun 12 16:32:28 CST 2018hour=16day=12second=28week=3year=2018month=5minute=32 注释方面，除了咱们自己指定的字符串”write by FileProperties”之外，Java API还默认的为我们添加了写入文件时的系统时间。 随后我们再来写一个读取文件的需求，待读取的文件自然就是刚刚生成的那个啦： 12345678910111213package design2_test2;import java.io.File;import java.io.IOException;public class Main &#123; public static void main(String[] args) throws IOException &#123; FileIO fileIO = new FileProperties(); fileIO.readFromFile(&quot;D:&quot; + File.separator + &quot;test.txt&quot;); System.out.println(fileIO.getTime()); &#125;&#125; 执行该代码后输出如下： 1Tue Jun 12 16:32:28 CST 2018]]></content>
      <categories>
        <category>Java 设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 设计模式-1.Iterator模式]]></title>
    <url>%2F2018%2F06%2F05%2FJava%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1Iterator%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在《图解设计模式》一书中，Iterator模式被归入了第1部分适应设计模式。在GoF原书中，Iterator模式则被归入了行为型设计模式。简单来说，Iterator模式可以被描述为：从含有多个元素的集合中将各个元素逐一取出来。也就是所谓的”一个一个遍历”。 综述迭代输出数组中的元素是很常见的需求，在Java中，我们通常会这样做： 12for (int i = 0; i &lt; arr.length; i++) System.out.println(arr[i]); 如果我们将循环变量i的作用抽象化通用化，再将数组扩展为任意其他的集合性质的容器，就可以形成一种模式，GoF书将其称为Iterator模式。该模式的目的就是按照要求的顺序在集合中遍历元素。 iterate这个单词的含义是”反复做某件事”。在计算机领域，它的含义是”迭代”。自然而言的，iterator被称作”迭代器”。 示例程序本示例程序会模拟一个书架(BookShelf)，书本(Book)会被放置到书架上。 首先，我们来总览一下本程序的类图： 本程序中的所有代码将被统一置于design1包下，结构如下： 其中，Main.java是用来测试的类，并未出现在类图中。 BookShelfIterator作为非public类存在于BookShelf.java文件中。 下面将逐个贴出每个类的源码。 Aggregate接口 1234567891011121314package design1;/** * Aggregate有&quot;使聚合，集合&quot;的意思 * 顾名思义，实现了该接口的类将成为一个可以保存多个元素的集合 */public interface Aggregate&lt;E&gt; &#123; /** * 生成并返回一个用于遍历集合的迭代器 * @return Iterator&lt;E&gt; */ Iterator&lt;E&gt; iterator();&#125; Iterator接口 Iterator接口用于遍历集合中的元素，其作用相当于本文开篇中介绍的for循环中的那个i： 12345678910111213141516171819package design1;public interface Iterator&lt;T&gt; &#123; /** * 若iterator游标当前所指向的位置还有元素则返回true，反之返回false * 若在本方法返回false时继续调用next()方法，则next()方法会抛出异常 * @return boolean, true - 存在下一个元素 * false - 不存在下一个元素 */ boolean hasNext(); /** * 返回iterator游标当前所指向的元素，随后游标后移一位 * * @throws NoSuchElementException iterator游标当前所指向的位置已无元素 */ T next();&#125; Book类 1234567891011121314package design1;public class Book &#123; private String name; public Book(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125;&#125; BookShelf类 123456789101112131415161718192021222324252627282930313233343536373839404142package design1;import java.util.NoSuchElementException;public class BookShelf&lt;E&gt; implements Aggregate&lt;E&gt; &#123; private Book[] books; /** * int, 书架上已有书数 */ private int last; public BookShelf(int maxsize) &#123; if (maxsize &lt; 0) throw new IllegalArgumentException(&quot;bookShelf &apos;s maxsize &lt; 0&quot;); this.books = new Book[maxsize]; &#125; public void appendBook(Book book) &#123; if (null == book) throw new NullPointerException(&quot;book is null&quot;); if (this.last == this.books.length) throw new IllegalStateException(&quot;bookShelf is full&quot;); this.books[last++] = book; &#125; @Override public Iterator&lt;E&gt; iterator() &#123; return new BookShelfIterator&lt;E&gt;(this); &#125; int getLength() &#123; return this.last; &#125; Book getBookAt(int index) &#123; if (index &lt; 0 || index &gt;= books.length) throw new IllegalArgumentException(&quot;index &lt; 0 || index &gt;= bookShelf &apos;s length&quot;); return this.books[index]; &#125;&#125; BookShelfIterator类 BookShelfIterator作为非public类存在于BookShelf.java文件中： 1234567891011121314151617181920212223242526class BookShelfIterator&lt;E&gt; implements Iterator&lt;E&gt; &#123; private BookShelf&lt;E&gt; bookShelf; /** * int, 迭代器当前游标指向的位置，即下一次调用next()方法时返回的元素的索引 */ private int index; BookShelfIterator(BookShelf&lt;E&gt; bookShelf) &#123; this.bookShelf = bookShelf; &#125; @Override public boolean hasNext() &#123; return this.bookShelf.getLength() &gt; this.index; &#125; @SuppressWarnings(&quot;unchecked&quot;) @Override public E next() &#123; if (!this.hasNext()) throw new NoSuchElementException(&quot;no more element for bookShelf&quot;); return (E)this.bookShelf.getBookAt(index++); &#125;&#125; Main类 12345678910111213141516package design1;public class Main &#123; public static void main(String[] args) &#123; BookShelf&lt;Book&gt; bookShelf = new BookShelf&lt;Book&gt;(5); bookShelf.appendBook(new Book(&quot;秀逗魔导士&quot;)); bookShelf.appendBook(new Book(&quot;9S&quot;)); bookShelf.appendBook(new Book(&quot;为美好的世界献上祝福&quot;)); bookShelf.appendBook(new Book(&quot;犬神&quot;)); bookShelf.appendBook(new Book(&quot;钢铁白兔骑士团&quot;)); Iterator&lt;Book&gt; iterator = bookShelf.iterator(); while (iterator.hasNext()) System.out.println(iterator.next().getName()); &#125;&#125; 执行Main.java，输出： 12345秀逗魔导士9S为美好的世界献上祝福犬神钢铁白兔骑士团 登场角色上面的示例程序介绍了Iterator模式的Java实现，下面咱们试着跳出语言层面，抽象出Iterator模式中登场的角色。 Iterator(迭代器) 该角色负责制定按特定顺序逐个遍历集合中的元素的功能的约束，不针对特定的集合，也不提供具体的实现。在示例程序中，由Iterator接口扮演这个角色，并提供了出演这个角色须达到的最低标准：即对外提供hasNext()与next()这两个方法。其中hasNext()方法负责判断是否仍有下一个元素(即控制迭代何时结束)，next()负责切实的取到当前迭代出的元素。 ConcreteIterator(具体的迭代器) 该角色负责针对特定的集合，提供定制化的Iterator的实现。在示例程序中，由BookShelfIterator类扮演这个角色。它是专门为了迭代BookShelf这个集合而定制的Iterator，因为它只用于迭代BookShelf，因此也可被称为”BookShelf的专属迭代器”，可以被视为BookShelf的附属。因此在编写代码时，并没有为BookShelfIterator类专门创建一个文件，而是将其作为非public类放到了BookShelf.java中。 一个BookShelf实例可以创建多个BookShelfIterator实例，而对于每个BookShelfIterator实例而言，终其一生将只为一个BookShelf实例服务。因此在BookShelfIterator类的构造函数中，我们会传入BookShelf实例。并且当BookShelf类的代码发生变化时，BookShelfIterator也要做出相应的调整。 BookShelfIterator在实现了Iterator后，并未增加新的方法。也就是说只提供向后迭代(具体来说，是沿着数组索引增大的方向迭代)。事实上，对于特定的迭代器实现而言，可以根据具体的待迭代的集合的实现，设计不同的迭代方式。例如我们还可以提供向前迭代方法previous()，此时迭代将顺着索引减小的方式进行，相应的我们还要提供判断向前迭代结束条件的方法hasPrevious()。 Aggregate(集合) 该角色负责制定作为一个集合该有的基本约束，并不提供具体的实现。换句话说，某个具体的类只要实现了该角色，我们就可以将该类称为集合了。在示例程序中，由Aggregate接口扮演这个角色，并提供了出演这个角色须达到的最低标准：即提供iterator()方法。该方法返回一个从属于本集合的迭代器，我们可以通过它对集合完成迭代。 ConcreteAggregate(具体的集合) 该角色负责根据Aggregate这个角色的约束条件，结合具体的需求，生成一个特定的集合类。因为它满足了Aggregate这个角色的约束，因此它会实现iterator()方法，该方法返回的迭代器自然就是ConcreteIterator。在示例程序中，由BookShelf类负责扮演这个角色，它的iterator()方法返回的迭代器是BookShelfIterator。 下面是抽象后，无关语言的类图： 为什么要使用Iterator模式在示例程序中，具体的集合类BookShelf底层是以数组存储元素的，那么为何不像开篇介绍的那样，直接使用for循环遍历呢？ 一个重要的原因就是，引入了Iterator模式后，我们便可以将遍历与实现分离开来。 举个例子，假如我们将BookShelf中的books字段的权限放开，那么此时可以这样遍历： 12for (int i = 0; i &lt; books.length; i++) System.out.println(books[i].getName()); 这样确实代码量更少，BookShelf也不用费心设计什么属于自己的迭代器了。但是这样做的问题在于，一旦我们改变了BookShelf底层的存储方式，比如我们改用链表作为数据的存储结构，那么调用者就必须要了解BookShelf内部的数据结构，然后做出相应的改动。 反观我们在示例程序中的迭代方式： 123Iterator&lt;Book&gt; iterator = bookShelf.iterator();while (iterator.hasNext()) System.out.println(iterator.next().getName()); 对于这种迭代方式而言，不论BookShelf底层的存储结构如何修改，只要它还实现Aggregate接口，即提供符合Iterator接口约束条件的迭代器，那么对于迭代操作而言，调用者的代码就无需做任何修改，也不需要关注BookShelf到底做了什么样的改动。 举一个实际的例子，books作为一个数组，一旦设定了maxsize就不可扩展了。假如我们现在需要书架是可扩展的了，那么我们就可以考虑使用ArrayList来作为底层存储结构。修改后的BookShelf类为： 12345678910111213141516171819202122232425262728293031323334353637package design1;import java.util.ArrayList;import java.util.List;import java.util.NoSuchElementException;public class BookShelf&lt;E&gt; implements Aggregate&lt;E&gt; &#123; private List&lt;Book&gt; books; public BookShelf(int initsize) &#123; if (initsize &lt; 0) throw new IllegalArgumentException(&quot;bookShelf &apos;s initsize &lt; 0&quot;); this.books = new ArrayList&lt;Book&gt;(initsize); &#125; public void appendBook(Book book) &#123; if (null == book) throw new NullPointerException(&quot;book is null&quot;); this.books.add(book); &#125; @Override public Iterator&lt;E&gt; iterator() &#123; return new BookShelfIterator&lt;E&gt;(this); &#125; int getLength() &#123; return this.books.size(); &#125; Book getBookAt(int index) &#123; if (index &lt; 0 || index &gt;= books.size()) throw new IllegalArgumentException(&quot;index &lt; 0 || index &gt;= bookShelf &apos;s size&quot;); return this.books.get(index); &#125;&#125; 这样书架就变成可扩展的了。Main.java的输出保持不变，此时即便添加了超出初始容量的书籍，代码也不会报错了。值得注意的是，因为此前books就没有暴露给BookShelfIterator，因此BookShelfIterator虽然是BookShelf的附属迭代器，但是我们同样无需修改它，只需要修改BookShelf就可以啦。 更进一步的来讲，即便我们将BookShelf整体的换掉，例如，我们不使用书架来存放书了，而改用书包，即Schoolbag类来存放书本，那么对于这段迭代调用的代码而言，依然无需做任何改动，调用者也无需了解Schoolbag到底是个什么东西，只要Schoolbag依然还实现着Aggregate接口，即还是一个符合约束的集合就行。这也是为什么我们在迭代时使用Iterator作为引用，而非BookShelfIterator的原因。其实，并不仅仅是Iterator模式，对于所有设计模式而言，使用抽象的抽象类和接口，而不是具体的实现类作为组件间沟通的桥梁是至关重要的(六原则中的依赖倒转原则)。 这在设计模式领域有着非凡的意义。因为设计模式的一个非常重要的目标就是编写”可复用”的”高内聚低耦合”的组件。这样一旦某一个组件发生变化，那么被它影响的组件将尽可能少，且即便是被它影响的组件，需要改动的地方也会尽可能的少(六原则中的单一职责原则)。 Java集合框架对Iterator模式的应用Java的集合框架使用Iterator模式完成对集合中的元素的迭代。下面我们以具体的实现类ArrayList为例，来看看它到底是怎么做的。 下面给出类图。类图中只记述与迭代操作相关的字段及方法： 相关设计模式13.Visitor模式 从广义的角度来讲，Iterator模式是Visitor模式的特例。 Visitor模式的目的是将处理自数据结构中分离出来，而Iterator模式的目的则是将迭代操作自容器结构中分离出来。]]></content>
      <categories>
        <category>Java 设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 设计模式-UML]]></title>
    <url>%2F2018%2F06%2F04%2FJava%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-UML%2F</url>
    <content type="text"><![CDATA[什么是UMLUML(Unified Modeling Language，即统一建模语言)是让系统可视化，让规格和设计文档化的表现方法。 通常我们会用UML来描述设计模式中类和接口的关系。本文将使用Java语言为例来介绍UML，因此本文出现的术语其实都是Java中的术语，而非原生的，无关语言特性的标准UML术语。例如我们会用Java中的字段(field)取代UML中的属性(attribute)，用Java中的方法(method)取代UML中的操作(operation)。 类图UML中的类图(Class Diagram)用于表示类与接口之间的静态关系。虽然名字叫作类图，但是类图中并不只有类。 类与层次结构 首先，我们来看一段示例代码： 123456789101112131415161718abstract class ParentClass &#123; int field1; static char field2; abstract void methodA(); double methodB() &#123;return 0.0;&#125;&#125;class ChildClass extends ParentClass &#123; @Override void methodA() &#123;&#125; static void methodC() &#123;&#125;&#125; 然后，我们给出它所对应的类图： 该图展示了ParentClass与ChildClass两个类之间的关系，其中的空心箭头表明了两者之间的层次关系：箭头由子类指向父类。换言之，这是表示继承(extends)的箭头，即表示ParentClass是ChildClass的父类。之所以箭头方向是从子类指向父类，实际上表示的是一种继承的感知：子类继承父类，说明子类在父类的下层，那么子类一定要能感知到父类才行，反映到图上就是子类能通过箭头的指引找到父类。相反，父类作为上层类并不需要感知到子类的存在。 图中的长方形表示类。长方形内部被两条线段自上至下分为了3部分： 类名 字段名 方法名 因为ChildClass中没有定义新的字段，因此它的第二部分是空的。 有时，表示类的长方形中还会写出其他信息(可见性，方法的参数个数参数顺序参数类型等)。在最为严谨的场合下，类图与代码是一一对应的：即我们可以通过类图无歧义的生成唯一的一份代码。不过通常，我们绘制UML只是为了说明代码的结构关系，并不需要表示的那么详细，因此都会做出一些删减。我们给出的实例采用的是最为精简的模式，即只提供了必需要有的那3个基本信息(类名，字段名，方法名)，没有附加任何其他信息。当然，这个时候我们就无法基于这张类图还原出源代码了。 关于这3个基本信息，我们还有一些更为详细的设定： 虽然官方并没有明确设定，但是通常，我们都会将类名加粗表示，例如图中的ParentClass，ChildClass。 所有抽象的(即被abstract所修饰的)元素都以斜体表示。例如抽象类ParentClass，抽象方法methodA。 所有静态的(即被static所修饰的)元素都会加上下划线。例如静态字段field2，静态方法methodC。 父类的字段与方法，只要没在子类中被修改或重写，就无需在子类中再写一遍(对于字段而言，只要不是在字段声明时修改就不算修改)。 前文已经提到了，本文在介绍UML时，使用的是Java的术语，而非UML规范中无关语言的通用的术语。事实上，每个语言都会有自身的术语，例如Java中的字段在C++中被称为成员变量(其实Java中也可以这样叫啦，毕竟Java算是脱胎自C++)，Java中的方法在C++中被称为成员函数。 接口与实现 下面我们继续来看下一段示例代码： 123456789101112interface Printable &#123; int FIELD1 = 1; void method1();&#125;class PrintClass implements Printable &#123; @Override public void method1() &#123;&#125;&#125; 然后给出它的类图： 上例描述的是实现接口的类图。对于接口而言，它与前文介绍的类的类图有很多相似之处： 以长方形表示接口，和类一样，内部也以两条横线分为3部分：接口名，字段名，方法名。 虽然官方并没有明确设定，但是通常，我们都会将接口名加粗表示。 接口名上方会默认添加&lt;&lt;interface&gt;&gt;以表示这是一个接口。 接口默认隐含了修饰符abstract。因此如果严格来说，接口名都应该是斜体的。不过由于这是所有接口都有的特性，所以有时候也会不使用斜体。通常我们会保留斜体。上例类图中我们就是这么做的。 虚线空心箭头表示PrintClass实现了接口Printable。箭头之所以是从实现类指向接口的原因与前文介绍的类在继承时箭头的方向的原因类似：实现类必须能感知到它所要实现的接口才行，反映到类图中就是实现类可以顺着箭头的方向找到它欲实现的接口。而接口则不需要知道哪些类实现了它。 接口中的字段默认隐含了修饰符public static final，而接口中的方法则默认隐含了public abstract。因此如果严格来说，字段都应被加上下划线，而方法都应是斜体的。不过依然因为这是所有接口都遵循的规则，因此有时也会不应用下划线或斜体。比如上例中我们保留了斜体，省略了下划线(因为下划线看着挺乱的。其实，在可以省略的情况下，我们一般都会保留斜体，而省略下划线)。 与继承的定义类似，接口中定义的方法需在实现类的长方形中再写一遍，因为实现类会重写接口中定义的方法(除非实现类是抽象类，方法是抽象方法，此时较之接口相当于依然没有发生变化，不用在实现类中重写)。而接口中的字段因为是final的，则无需在实现类中再次书写。 聚合 看下一段代码： 1234567891011class Color &#123;&#125;class Fruit &#123; Color color;&#125;class Basket &#123; Fruit[] fruits;&#125; 就算没有文档，这段代码所要表达的含义也是一目了然的：篮子里装了好多个水果，每个水果都有其自身的颜色。它可能的一种类图如下： 首先借用本例补充一个小知识点：如果某类或接口中没有任何需要记录的字段或方法，那么就可以省略那两道横线，一如本例中的Color(事实上，Color作为Java API中的类，其中自然会有很多内容，但它们却不是本类图需要关注的，因此均被省略)。 前文介绍的类与接口之间的关系(继承，实现)是在系统中有强约束且唯一的。而本小节所介绍的聚合(aggregation)则更多表现的是一种逻辑与思路上的关系，它不再表示从属，其表示的是”持有”。同样一段代码，依想表述重点的不同，可以画出很多种表示不同聚合关系的类图。在上例中，聚合关系其实只有一种：篮子-水果-颜色。但实际上，篮子里可能不止有水果，Basket类中可能还有一个字段叫toys，顺着这条聚合的线，我们可以导出一条完全不同的聚合线路：篮子-玩具-材料。我们画类图是为了介绍代码，而每次介绍其实并不需要介绍全貌，而只是根据需求介绍听者感兴趣的部分，这意味着，也许我们只需要画其中一条聚合线的类图就足够了。这样就可以抛除掉本次叙述不关心的点，使得讲解更易于理解。 也就是说，聚合可供发挥的空间其实很大，我们可以根据需求自由的画出类图，从自己的角度去理解和分析代码，阐述自身的观点。 我们使用空心菱形为起点的箭头表示聚合，假如A持有B，那么箭头的方向就是自A指向B。其箭头方向的缘由与前文一脉相承：A持有B，那么A就要能够顺着箭头的方向找到B才行，反之，B作为被持有者，则无需知道A的存在。 可见性(访问控制) 看下一段代码吧DAZE~： 123456789101112131415161718class Something &#123; private int privateField; int packageField; protected int protectedField; public int publicField; private void privateMethod() &#123;&#125; void packageMethod() &#123;&#125; protected void protectedMethod() &#123;&#125; public void publicMethod() &#123;&#125;&#125; 这段代码的类图为： 该图主要展示了类图对于可见性的标记方式： 接口中的字段与方法均隐含了(且只能是)默认的访问权限(public)，因此我们通常不会在类图中显式指定。 内部类 Java语法允许内部类的存在，此时基本的类图将再多出一格，最后一格描述内部类。先来看示例代码： 1234class Out &#123; private class In &#123;&#125;&#125; 它的类图为： 如图所示，内部类的描述被置于外部类的第四部分。同时我们用一条起点为圆圈十字线的箭头由外部类指向内部类。 通常，为了使得内部类的所属能看得更清楚，我们在叙述内部类的类名时，会采用”外部类$内部类”的方式。形如本例中的”Out$In”。 字段与方法的详细描述 在前面的例子中，当我们记述字段与方法时，只描述了它们的名称。这往往是不够的(不过在画一些无关语言的伪代码性质的类图时够用了，而且那种情况下基本也画不出更具体的东西)，尤其对于方法而言，这样是无法分辨重载方法的。因此，在多数时候，我们都需要记述更详细的信息。 下面来看一个例子： 123456789101112class Something &#123; private int privateField; public Something(char ch) &#123;&#125; double packageMethod(int i, String s) &#123; return 0.0; &#125; private void privateMethod(String str) &#123;&#125;&#125; 它的类图为： 有如下几点说明： 构造函数出现在方法的最前边，它们默认与类名相同，因此无需写方法名。且因其没有返回值，也不需要在最后补上冒号及返回值。 若方法的返回值为void，则只需在最后写上冒号即可。 包继承关系 首先来看代码： 123package com.test;public class Test &#123;&#125; 如果想要表达Test.java在test包内，那么可以这样来画类图： 类的关联 上文中我们介绍了聚合，这其实已经是一种很灵活的类图绘制方法了，不过此时我们依然还是基于代码的。其实UML还为我们提供了更为灵活的描述类之间关系的方式，例如： Client使用Target： Factory生成Product： Subject向Observer发送消息： 这种类图引入了更多的文字描述，可以表述的含义也更为丰富。其中黑色的实心三角代表了文字关系的传递方向。以”Client使用Target”为例，小三角与箭头均是自Client指向Target。 时序图UML的时序图(sequence diagram)用来表示程序在工作时其内部方法的调用顺序，以及事件的发生顺序。 类图描述的是”不因时间流逝而发生变化的关系”，也就是所谓的”静态关系”。而时序图则恰恰相反，它描述的是”随时间发生变化的东西”，也就是所谓的”动态行为”。 依然先来看代码： 12345678910111213141516171819202122232425262728class Client &#123; Server server; void work() &#123; this.server.open(); this.server.print(&quot;ReimuWang&quot;); this.server.close(); &#125;&#125;class Server &#123; Device device; void open() &#123;&#125; void print(String s) &#123; this.device.write(s); &#125; void close() &#123;&#125;&#125;class Device &#123; void write(String s) &#123;&#125;&#125; 该代码模拟了一个非常简单的客户端请求服务端，服务端进而请求底层设备输出一句话的功能。它的时序图如下所示： 最上方的3个长方形表示实例。从本质上来说，时序图描述的其实就是实例随着时间推进做出的行为。实例中的信息都会加上下划线。而通常来说，实例的描述格式为： 1实例名:类名 上图采用的就是这种标准的格式。当然啦，实例名仅仅只是一个名字而已，其实并没有那么重要，因此很多时候我们也会不记录实例名，变为： 1:类名 如果用这种简化的规则的话，那么上图变为： 每个实例都会有一条自其下边起始，纵向垂直向下延伸的虚线段，在UML中，这条虚线被称为”生命线”。顾名思义，实例将随着虚线的出现而诞生，随着虚线的停止而死亡。 现在就颇有一些AOP的意味在其中了：很显然，由于生命线的这种设定规则，时间的流逝方向将是垂直向下的。水平线则表示某个时间点上发生的事件。 阅读时序图时，我们不妨将其想象为动态的，即将生命线想象为时间本身，随着它垂直自上而下流动来阅读时序图。在生命线流动过程中，可能会变为细长的矩形，实例处于细长矩形状态时表明实例正在进行某种活动，比如正在执行实例中的某个方法等。一旦活动结束，实例的生命线将脱离细长矩形的状态，恢复虚线状态。 了解了大致的规则后，我们不妨按照时间流逝的顺序读一下上例中的时序图。 首先，实例client因其方法work()被调用进入活跃状态，如图所示，方法的调用将采用水平的实线表示，箭头方向指向生命线，实线上仅写了方法名。方法调用后，实例client立刻进入细长矩形状态，直到图的最下端细长矩形结束，表示work()方法退出，实例client的生命线又恢复为虚线状态。在细长矩形结束时，会绘制一条水平虚线，表明方法的退出。虚线的箭头将从生命线向外指出。 在work()方法调用期间，具体又发生了以下事件： server实例的open()方法被调用，相应的，server实例的生命线马上转为细长矩形状态，open()方法执行完后又转回虚线状态。 server实例的print()方法被调用，而其内部又调用了device实例的write()方法。 server实例的close()方法被调用。 最后需要说明的是，表示方法返回的水平虚线箭头其实是可以省略的，因为它和表示方法调用的水平实线箭头不同，水平实线箭头上是会写明方法名称的，而水平虚线箭头除了虚线本身之外不会附加任何信息，而纯粹从逻辑需求来讲，这条虚线其实是不用存在的：实例的生命线自细长矩形状态变回虚线状态自然就说明方法退出了，它仅会起到一个对齐的视觉效果。因此，在要求不严谨，或是图很复杂，不想那么多线看着心烦时，不画这条水平虚线也是很常见的。]]></content>
      <categories>
        <category>Java 设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 设计模式-综述]]></title>
    <url>%2F2018%2F06%2F01%2FJava%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%BC%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[近年来，IT业界发生了翻天覆地的变化，各种开源框架层出不穷，机器学习大行其道。但是，在面向对象编程中，设计模式的重要性却不曾改变。在大规模的企业系统开发中，设计模式可以帮助我们实现系统结构化，很好的支撑起系统的稳定性和可扩展性。 GoF提起面向对象的设计模式，首先不得不说的就是由GoF联合编制的《Design Patterns: Elements of Reusable Object-Oriented Software》一书，中文译名为《设计模式：可复用面向对象软件的基础》(后文将简称为《设计模式》或GoF书)，它介绍了23种经典的设计模式，可谓是设计模式领域的”圣经”与基石(较真的说，该书介绍的仅仅只是面向对象编程的设计模式，面向过程的设计模式不在该书讨论的范畴之内。不过后文将不再纠结这个问题，除非特别声明，否则提到设计模式时默认均是指面向对象编程的设计模式)，有着极其重要的意义。 所谓GoF，实际是Gang of Four的缩写，也就是所谓的”四人组”(这命名颇有些F4，小虎队之类偶像团体的意思，不过这四个人确实也是计算机领域受万民敬仰的超级偶像了)，这四位大神分别是： Erich Gamma Richard Helm Ralph Johnson John Vlissides GoF于1995年联合写成了《设计模式》一书，因此该书也被称作”GoF书”。 GoF书虽然有着重要的历史地位，但却存在两个阻碍初学者探究设计模式的小障碍： 该书实际上是基于这4位大佬的博士论文整理而成的，因此学术性较强，初学者很难看懂书中想要表述的意思。 虽说设计模式是超脱于语言的存在，但是为了演示举例，终归还是需要一种实际的语言将其落到实处。GoF书采用的是C++与Smalltalk，这就使得对这两种语言不是很熟悉的程序员更加难以理解。 因此，比起GoF书，对于设计模式的初学者而言，更为推荐的是对GoF书的二次解读。例如，对于Java程序员而言，我推荐结城浩编著的《图解设计模式》一书： 设计模式是什么想必大家在编写程序的时候，都曾遇到过这样的情况：接到了一个新的需求，虽然需求是新的，但对程序员而言，其实”并不是什么新东西”。此时，我们就可以将过往的经验应用到这个新的需求上，使得开发更为顺畅。随着工作经验的增长，尤其是当我们善于总结的时候，这种情况将出现得越来越频繁，新需求虽然千变万化，但是经过抽象建模与问题分解后，基本都能找到相对固定，经过时间检验的解决对策，也就是所谓的”套路”，或者我们可以换一个更严谨的名称：设计模式。所以通俗的说，设计模式就是指针对软件开发过程中重复发生的问题的解决办法。 GoF为常用的23种设计模式赋予了”名字”，并按类型对它们进行了整理，最终产出的就是那本大名鼎鼎的《设计模式》。这本书的意义是里程碑式的，之所以这么说，是因为它不仅仅是一本”武功秘籍”，可以快速的提高程序员的水平，更重要的是，它提供了一种标准。在GoF书诞生之前，设计模式其实是一直存在的：其实自打第一句Hello World被打印出来时设计模式就相应的存在了，每个程序员在编程中都会有意或无意的积累属于自己的”套路”，但是此时的设计模式仅仅只能是技术，它存在于每个程序员的心中，却无法成为科学：因为并没有一个统一的标准说这种”套路”就叫这种设计模式，虽然对于不同的程序员而言，随着编程能力的进步，在大的思路上，解决同一个问题的套路总是趋向于殊途同归，但是在细节上却终归是有着差距，这是无法避免的。 《设计模式》一书的诞生解决了这个问题，它所介绍的23种设计模式被所有主流程序员所学习与认同，这样，当两个程序员在讨论一个问题的解决策略时，如果一个程序员说出：我认为可以用GoF书中的4.Factory Method模式解决这个问题，那么另一个程序员马上就可以理解他想表达的是什么而不会产生歧义，这在需要多人参与开发的复杂项目中有着非凡的意义。不仅如此，GoF书通过介绍那23种设计模式还普及开了一套科学的描述设计模式的方法(主要是UML图)，因为实际需求总是有其特殊性的，我们不可能用这23种设计模式涵盖天下所有的需求，很多时候，我们需要使用某种设计模式的变种，或者组合某几种设计模式，甚至是创造出一种全新的设计模式，此时沟通的作用就更为重要了：如何从零让别人理解你的想法？如何从零理解别人的想法？在两人想法不同时，如何进行讨论？设计模式为开发人员提供了有益且丰富的词汇，让开发人员可以更容易的理解对方所要表达的意思。 GoF书中所介绍的23种设计模式并不是孤立的，而是互相关联的。设计模式不需要死记硬背，因为一个东西并不是成为了”套路”才是正确的，而是因为它是正确的，它是有用的，才能成为”套路”。因此学习设计模式，最重要的是多实践，多练习。在阅读代码时识别设计模式，在编写代码时运用设计模式。这一切都应是自然而然，水到渠成的。归根结底一句话：让GoF书中介绍的那23种设计模式成为属于自己的套路才是最重要的。 设计模式与模式严格地说，设计模式是模式的子概念。 不论是在什么领域，给”在某种场景下重复发生的问题的解决办法”赋予名字，并整理而成的东西一般都被称为”模式”。 设计模式是适用于软件设计和开发领域的模式，它是模式中的一种。 不过，有时候在软件领域也会将”设计模式”简称为”模式”(设计模式是模式的子概念，当然可以这样简称，是没有歧义的)。 例如，我们在介绍设计模式时，因为有一个很明确的范围，所以有时也会以”模式”来代指”设计模式”。比如，我们说”GoF书中介绍了23种模式”实际指得就是”GoF书中介绍了23种设计模式”。再比如，我们给这23种设计模式命名时，也会将其简称为xx模式。例如1.Iterator模式实际上指得就是”Iterator设计模式”。 设计模式与算法设计模式与算法是两个不同的概念，不过二者之间有着很深的联系。 算法(algorithm)是指根据输入数据获取输出数据的一系列机械的步骤。算法必须在有限的时间内结束。二分查找算法和快速排序算法等都是经典的算法。 我们也可以将算法看作是”解决问题的办法”，在不太严谨的场合，也可以将其视为设计模式，但是算法并不等同于设计模式。 设计模式不仅与算法有关，它还与习语(idiom)有关。习语是指编程时经常使用的固定语法(惯用语)。通常，习语具有”高度依赖于编程语言”的特征。与算法一样，习语也可以被看作是”解决问题的办法”，在不太严谨的场合，同样可以将其视为设计模式，但是习语依然并不等同于设计模式。 通常，我们在使用设计模式时，最终都会落实到具体的算法，进而落实到特定语言的实现(习语)。但是设计模式其实并非具体的实现，它是更抽象的东西：实现背后的思考方式和解决方法才是设计模式。 接口和API在描述设计模式时，我们常会提起两个关键词：”接口”与”API”(Application Programming Interface，即应用程序编程接口)。 一般而言，在提到”某个类的接口”时，多是指该类所持有的方法的集合，在这种语境下，”接口”和”API”的含义基本是等同的，都是指类暴露给外部的功能。 不过对于Java程序员而言，”接口”指得就是”被interface关键字声明的代码”，而”API”则和通常的理解相同，指类暴露给外部的功能。 因为我将以Java来介绍设计模式，因此会以Java的规则严格区分”接口”与”API”。 面向对象的”六原则一法则”从具体的使用层面来讲，我们可以将设计模式分为多种(例如GoF就将设计模式分为了23种)，这就好比具体的武功，例如天山折梅手，六脉神剑之类的。而从更抽象的层面来讲，设计模式有着一些类似于原则或是法则之类的东西，它们不是具体的设计模式，但是具体的设计模式却是这些法则的具现。这就好比武学要义，例如”天下武功，唯快不破”。或者说，这些法则是指导思想，政治精神，而设计模式则是基于指导思想制定的具体策略。 在面向对象领域，它们被总结为了”六原则一法则”： 首先是六原则： 单一职责原则：模块内部高内聚，实现的功能尽量保证单一纯粹。模块之间低耦合，系统中某模块的替换对系统的影响尽可能的小。 开闭原则(The Open-Closed Principle,OCP)：该原则由勃兰特·梅耶提出，而后RobertC.Martin在C++ Report(1996年1月)中的Engineering NoteBook专栏里对其进行了总结。简单来说，该原则可以被描述为：对扩展(extension)开放(open)，对修改(modification)关闭(close)。即：增加新功能时，尽量只需派生新类而无需修改已有代码。要点有二：1.设计好系统主线的继承关系。2.使用接口及抽象类抽象核心功能。 依赖倒转原则：即面向接口编程。声明方法的参数类型、方法的返回类型、变量的引用类型时，尽可能使用抽象类型而不用具体类型。 里氏替换原则( Liskov Substitution Principle,LSP)：任何时候，能用父类型的地方就一定能使用其子类型进行替换。换句话说，无论父类类型的引用具体指向的是它的哪个子类实例，程序都应该能正常运行。该原则常用于判断继承关系是否合理。例如，3.Template Method模式就是该原则的具体应用。 接口隔离原则：接口应高内聚。其所表示的能力应尽量保证单一纯粹。 合成聚合复用原则：类与类之间有三种关系：继承(Is-A)，关联(Has-A)，依赖(Use-A)。其中，关联根据其关联的强度又可以进一步划分为关联、聚合和合成。本原则的要义是优先使用关联/依赖而非继承复用代码。例如，任何时候都不要继承工具类：你使用工具，你并不是工具。 然后是一法则： 最少知识法则(迪米特法则)：一个对象应当对其他对象有尽可能少的了解。即不要和陌生人打交道，如果真的需要，找一个自己的朋友，让他替你和陌生人打交道。该法则是低耦合的体现，例如，15.Facade模式就是该法则的具体应用。 GoF书中的23种设计模式(《图解设计模式》一书中的划分方式)GoF书将它所介绍的那23种设计模式分为了3大类。从学习者的角度来看，这个划分稍显宽泛了些。个人更偏爱《图解设计模式》中的划分方式，该书将这23种设计模式划分为了10个部分： 第1部分：适应设计模式 该部分的设计模式相对而言都很易于理解，可以帮助初学者快速的适应设计模式的一些基本术语和概念。 1.Iterator模式 2.Adapter模式 第2部分：交给子类 该部分将介绍与类的继承相关的设计模式。 3.Template Method模式 4.Factory Method模式 第3部分：生成实例 该部分将介绍与生成实例相关的设计模式。 5.Singleton模式 6.Prototype模式 7.Builder模式 8.Abstract Factory模式 第4部分：分开考虑 将易变得杂乱无章的处理分开考虑。 9.Bridge模式 10.Strategy模式 第5部分：一致性 让两个看上去不同的对象的操作变得统一。 11.Composite模式 12.Decorator模式 第6部分：访问数据结构 该部分将介绍优化数据结构处理的设计模式。 13.Visitor模式 14.Chain of Responsibility模式 第7部分：简单化 让类与类之间的关系变得简单。 15.Facade模式 16.Mediator模式 第8部分：管理状态 该部分将介绍与状态相关的设计模式。 17.Observer模式 18.Memento模式 19.State模式 第9部分：避免浪费 该部分将介绍避免浪费，提高处理效率的设计模式。 20.Flyweight模式 21.Proxy模式。 第10部分：用类来表现 用类来表现特殊的东西。 22.Command模式 23.Interpreter模式 GoF书中的23种设计模式(原书中的划分方式)我们不妨将GoF书中原有的对23种设计模式的3种划分方式也贴出来： 创建型设计模式：对类的实例化过程的抽象化 8.Abstract Factory模式 4.Factory Method模式 5.Singleton模式 7.Builder模式 6.Prototype模式 结构型设计模式：描述如何将类或对象结合在一起形成更大的结构 2.Adapter模式 11.Composite模式 15.Facade模式 21.Proxy模式 9.Bridge模式 12.Decorator模式 20.Flyweight模式 行为型设计模式：对在不同的对象之间划分责任和算法的抽象化 14.Chain of Responsibility模式 23.Interpreter模式 16.Mediator模式 17.Observer模式 10.Strategy模式 13.Visitor模式 22.Command模式 1.Iterator模式 18.Memento模式 19.State模式 3.Template Method模式 Java API中用到的设计模式Java标准类库其实也是普通的基于Java语法实现特定功能的代码，其中自然也运用了大量的设计模式，有很多就包含在GoF所介绍的那23种设计模式之中。我们不妨举几个例子： java.util.Iterator是用于遍历元素集合的接口。这里使用了1.Iterator模式。 java.util.Observer是用于观察对象状态变化的接口，这里使用了17.Observer模式。 以下方法中使用了4.Factory Method模式： java.util.Calendar类的getInstance()方法。 java.security.SecureRandom类的getInstance()方法。 java.text.NumberFormat类的getInstance()方法。 java.awt.Component与java.awt.Container这两个类使用了11.Composite模式。]]></content>
      <categories>
        <category>Java 设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode Algorithms-21.Merge Two Sorted Lists]]></title>
    <url>%2F2018%2F05%2F30%2FLeetcode%20Algorithms-21MergeTwoSortedLists%2F</url>
    <content type="text"><![CDATA[问题地址Merge Two Sorted Lists - LeetCode 问题描述 解法思路 注意在迭代的过程中不要将链表弄断即可。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; ListNode l1Current = l1; ListNode l2Current = l2; if (null == l1Current) return l2Current; if (null == l2Current) return l1Current; ListNode head = null; if (l1Current.val &lt; l2Current.val) &#123; head = l1Current; l1Current = l1Current.next; &#125; else &#123; head = l2Current; l2Current = l2Current.next; &#125; ListNode current = head; while (null != l1Current &amp;&amp; null != l2Current) &#123; if (l1Current.val &lt; l2Current.val) &#123; current.next = l1Current; l1Current = l1Current.next; &#125; else &#123; current.next = l2Current; l2Current = l2Current.next; &#125; current = current.next; &#125; if (null == l1Current) current.next = l2Current; if (null == l2Current) current.next = l1Current; return head; &#125;&#125;class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode Algorithms</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Leetcode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode Algorithms-26.Remove Duplicates from Sorted Array]]></title>
    <url>%2F2018%2F05%2F30%2FLeetcode%20Algorithms-26Remove%20DuplicatesfromSortedArray%2F</url>
    <content type="text"><![CDATA[问题地址Remove Duplicates from Sorted Array - LeetCode 问题描述 解法代码 123456789101112public class Solution &#123; public int removeDuplicates(int[] nums) &#123; if (null == nums || nums.length == 0) return 0; int lastIndex = 0; for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[lastIndex] == nums[i]) continue; nums[++lastIndex] = nums[i]; &#125; return lastIndex + 1; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode Algorithms</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Leetcode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode Algorithms-20.Valid Parentheses]]></title>
    <url>%2F2018%2F05%2F30%2FLeetcode%20Algorithms-20ValidParentheses%2F</url>
    <content type="text"><![CDATA[问题地址Valid Parentheses - LeetCode 问题描述 解法思路 利用Java API提供的栈完成匹配 代码 1234567891011121314151617181920212223242526272829303132import java.util.HashMap;import java.util.Map;import java.util.Stack;public class Solution &#123; private static final Map&lt;String, String&gt; MAP = new HashMap&lt;String, String&gt;(); static &#123; Solution.MAP.put(&quot;)&quot;, &quot;(&quot;); Solution.MAP.put(&quot;&#125;&quot;, &quot;&#123;&quot;); Solution.MAP.put(&quot;]&quot;, &quot;[&quot;); &#125; public boolean isValid(String s) &#123; if (null == s) throw new NullPointerException(&quot;s is null&quot;); if (&quot;&quot;.equals(s)) return true; Stack&lt;String&gt; stack = new Stack&lt;String&gt;(); for (int i = 0; i &lt; s.length(); i++) &#123; String now = s.substring(i, i + 1); if (!Solution.MAP.containsKey(now)) stack.push(now); else &#123; if (stack.size() == 0) return false; String last = stack.pop(); if (!Solution.MAP.get(now).equals(last)) return false; &#125; &#125; return stack.size() == 0; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode Algorithms</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Leetcode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode Algorithms-14.Longest Common Prefix]]></title>
    <url>%2F2018%2F05%2F24%2FLeetcode%20Algorithms-14LongestCommonPrefix%2F</url>
    <content type="text"><![CDATA[问题地址Longest Common Prefix - LeetCode 问题描述 解法思路 首先，找到strs[0]与strs[1]之间的最长公共前缀，不妨命名为x。 而后再找到x与strs[2]之间的最长公共前缀，将x赋值为新找到的前缀。 … 依此类推，直至结束。 过程中任何时候x为””则停止循环，因为此时已不可能再找到更短的最长公共前缀了。 代码 123456789101112131415public class Solution &#123; public String longestCommonPrefix(String[] strs) &#123; if (null == strs || strs.length == 0) return &quot;&quot;; if (strs.length == 1) return strs[0]; String model = strs[0]; for (int i = 1; i &lt; strs.length; i++) &#123; String now = strs[i]; while (!now.startsWith(model)) model = model.substring(0, model.length() - 1); if (&quot;&quot;.equals(model)) break; &#125; return model; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode Algorithms</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Leetcode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode Algorithms-13.Roman to Integer]]></title>
    <url>%2F2018%2F05%2F24%2FLeetcode%20Algorithms-13RomantoInteger%2F</url>
    <content type="text"><![CDATA[问题地址Roman to Integer - LeetCode 问题描述 解法思路 此题考校的是将一个不太熟悉的(一般大家都不会深究罗马数字的计算规则)概念抽象为代码的能力，正确理解题意即可。 代码 12345678910111213141516171819202122232425262728293031import java.util.HashMap;import java.util.Map;public class Solution &#123; private static Map&lt;Character, Integer&gt; ROMAN_TO_ARAB = new HashMap&lt;Character, Integer&gt;(); static &#123; Solution.ROMAN_TO_ARAB.put(&apos;M&apos;, 1000); Solution.ROMAN_TO_ARAB.put(&apos;D&apos;, 500); Solution.ROMAN_TO_ARAB.put(&apos;C&apos;, 100); Solution.ROMAN_TO_ARAB.put(&apos;L&apos;, 50); Solution.ROMAN_TO_ARAB.put(&apos;X&apos;, 10); Solution.ROMAN_TO_ARAB.put(&apos;V&apos;, 5); Solution.ROMAN_TO_ARAB.put(&apos;I&apos;, 1); &#125; public int romanToInt(String s) &#123; if (null == s || s.length() == 0) throw new IllegalArgumentException(&quot;s is empty&quot;); int result = 0; for(int i = 0; i &lt; s.length() - 1; i++) &#123; if(Solution.ROMAN_TO_ARAB.get(s.charAt(i)) &lt; Solution.ROMAN_TO_ARAB.get(s.charAt(i + 1))) result -= Solution.ROMAN_TO_ARAB.get(s.charAt(i)); else result += Solution.ROMAN_TO_ARAB.get(s.charAt(i)); &#125; result += Solution.ROMAN_TO_ARAB.get(s.charAt(s.length() - 1)); return result; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode Algorithms</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Leetcode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-异或运算]]></title>
    <url>%2F2018%2F05%2F24%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[基本定义异或(exclusive OR)是一种二元位运算运算符，计算机学中的常用缩写为xor，计算时的符号为^。 参与位运算的数字只有0,1两种，而异或又是一种二元运算符，因此所有的运算情况只有如下4种： 12340^0=01^0=10^1=11^1=0 用自然语言描述一下就是：相同的返回0，不同的返回1。这也是”异或”这个名称的由来。 性质异或满足交换率 穷举法即可： 1230^0=0^0=01^0=0^1=11^1=1^1=0 任何数抑或0后保持不变 证明： 穷举法即可： 120^0=01^0=1 任何数抑或1后取反 证明： 穷举法即可： 120^1=11^1=0 任何数抑或自身后变为0 证明： 穷举法即可： 120^0=01^1=0 应用：原地交换两个整数需求：现有两个整数a,b。需交换它们之中存储的值。 最简单，也是最易于想到的方法自然就是再声明一个临时的中转变量了： 123int temp = a;a = b;b = temp; 不过这种做法并不是原地的，我们还使用了额外的空间存储temp。 如果想要原地完成这个需求，可以使用异或操作： 123a = a ^ b;b = a ^ b;a = a ^ b; 经过这样的操作后，a与b中的值就被交换过来了。 看起来挺玄乎的。下面我们具体来求证一下。 首先是第一步： 1a = a ^ b; 经过这步操作后a变为了a^b，b依然还是b。如果我们以原值来算的话，第二步的运算其实是这样的： 1b = a ^ b ^ b 因异或满足交换律，如果我们将a看作一个整体，b^b看作一个整体的话，上式可变为： 1b = b ^ b ^ a 又因为任何数抑或自身后变为0，因此上式可进一步化简为： 1b = 0 ^ a = a ^ 0 又因为任何数抑或0后保持不变，则最终可化简为： 1b = a 即经过第二步的运算后，b中存储的值已经是a了。 然后我们再来看第三步，此时实际的运算是： 1a = a ^ b ^ a = a ^ a ^ b = 0 ^ b = b ^ 0 = b 证明思路与第二步时类似，我们就不写具体的推导过程了。 至此，a与b完成了值的交换。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>异或</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode Algorithms-476.Number Complement]]></title>
    <url>%2F2018%2F05%2F24%2FLeetcode%20Algorithms-476NumberComplement%2F</url>
    <content type="text"><![CDATA[问题地址Number Complement - LeetCode 问题描述 解法思路 Integer.highestOneBit(i)的作用是求出i的最高位1的位置，然后将它的后续都以0填充。例如5=101，传入本函数后输出100=4。 本思路利用了异或运算的一个特性：任何数异或1都相当于取反。 说是任何数，听起来比较吓人，其实一共也就两个数，我们完全可以穷举： 0^1=1,1^1=0 相当于对原数进行取反。 关于异或的其他特性可详见数据结构-异或运算。 代码 12345678public class Solution &#123; public int findComplement(int num) &#123; if (num &lt;= 0) throw new IllegalArgumentException(&quot;num &lt;= 0&quot;); return num ^ ((Integer.highestOneBit(num) &lt;&lt; 1) - 1); &#125;&#125;]]></content>
      <categories>
        <category>Leetcode Algorithms</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Leetcode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 并发-哲学家就餐问题]]></title>
    <url>%2F2018%2F05%2F23%2FJava%20%E5%B9%B6%E5%8F%91-%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在Java 并发-并发级别一文中，我们讨论过多线程的活跃性问题。其中最严重的一种情况就是死锁。关于死锁，在那篇文章中我们做过简要的描述，现摘录如下： 死锁 简单的小例子：线程A持有资源x而欲请求资源y。线程B持有资源y而欲请求资源x。不巧的是x，y均为临界区。如果现状得不到改善(AB均不愿意放弃已到手的资源)，那么死锁将一直进行下去，永远看不到解决的希望。因此死锁是活跃性问题中最糟糕的情况：它会直接导致被锁住的线程卡死。 哲学家就餐问题就是一个用于描述死锁的经典案例： 假设有5位哲学家围坐在1张圆桌旁，他们从不沟通，且只会做以下两件事之一：吃饭或者思考。并且吃饭的时候不思考，思考的时候不吃饭。餐桌正中有1大盘意大利面，每个哲学家左右手边各有一把叉子，因为1把餐叉很难吃到面，因此设定哲学家必须同时取到左右手的餐叉才能吃到面，并且我们还设定哲学家只会使用他所临近的那两把叉子。 5位哲学家，保险起见应该有10把叉子才行。但是现在只有5把叉子。这就存在着死锁的可能性了，例如每个哲学家都拿起来他们左手边的叉子，又都不愿意放下已获得的叉子，这样大家都吃不到饭，导致全部饿死。 我们也可以简化一下这个问题，即将哲学家减少至两人，相对的叉子也就只有两把了。问题的本质还是一样的，依然会有死锁的可能。下面我们就以两位哲学家的情况为例编码验证一下，假设双方均拿起了左手边的叉子，触发死锁： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.test;public class Test extends Thread &#123; private static final Object FORK1 = new Object(); private static final Object FORK2 = new Object(); private Object tool; private Test(Object tool) &#123; this.tool = tool; if (this.tool == Test.FORK1) this.setName(&quot;哲学家1&quot;); if (this.tool == Test.FORK2) this.setName(&quot;哲学家2&quot;); &#125; @Override public void run() &#123; if (&quot;哲学家1&quot;.equals(this.getName())) &#123; synchronized (Test.FORK1) &#123; try &#123; Thread.sleep(500); synchronized (Test.FORK2) &#123; System.out.println(this.getName() + &quot;获得所需的两把叉子，开始吃饭&quot;); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; if (&quot;哲学家2&quot;.equals(this.getName())) &#123; synchronized (Test.FORK2) &#123; try &#123; Thread.sleep(500); synchronized (Test.FORK1) &#123; System.out.println(this.getName() + &quot;获得所需的两把叉子，开始吃饭&quot;); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; Test t1 = new Test(Test.FORK1); Test t2 = new Test(Test.FORK2); t1.start(); t2.start(); &#125;&#125; 运行后，程序无法结束，陷入死锁。 在实际的生产工作中，如果某程序的相关进程不再工作，且CPU占用率为0或大幅下降(陷入死锁的线程是不会占用CPU的)，就要考虑是否有陷入死锁的可能性了。具体来说，我们可以使用JDK提供的一些小工具来检测死锁。 在JVM-JDK自带JVM工具一文中，我们曾经详细介绍过这些小工具，现在以上文哲学家死锁的代码为例，再次温习下它们的使用方法吧。 首先，我们使用jps获得进程的核心数据(主要是LVMID): 12345wangyikai1@5CD6227DBW MINGW64 /d/work/java/jdk/bin$ ./jps -l7540 sun.tools.jps.Jps1312 D:\work\eclipse\\plugins/org.eclipse.equinox.launcher_1.3.0.v20140415-2008.jar2244 com.test.Test 显然，其中的 12244 com.test.Test 就是我们要检测的进程啦！而2244是它的LVMID。 然后使用jstack来获得该进程的线程信息： 12wangyikai1@5CD6227DBW MINGW64 /d/work/java/jdk/bin$ ./jstack -l 2244 &gt; /e/1.txt 此时线程信息被我重定向到了/e/1.txt中，赶紧来看下它里面的内容吧： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151162018-05-24 10:38:44Full thread dump Java HotSpot(TM) 64-Bit Server VM (24.80-b11 mixed mode):&quot;DestroyJavaVM&quot; prio=6 tid=0x000000000253e800 nid=0x179c waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE Locked ownable synchronizers: - None&quot;哲学家2&quot; prio=6 tid=0x000000000c2a1800 nid=0x1a20 waiting for monitor entry [0x000000000cf3f000] java.lang.Thread.State: BLOCKED (on object monitor) at com.test.Test.run(Test.java:36) - waiting to lock &lt;0x00000007d5d9b028&gt; (a java.lang.Object) - locked &lt;0x00000007d5d9b038&gt; (a java.lang.Object) Locked ownable synchronizers: - None&quot;哲学家1&quot; prio=6 tid=0x000000000c29f000 nid=0x14ac waiting for monitor entry [0x000000000cd5f000] java.lang.Thread.State: BLOCKED (on object monitor) at com.test.Test.run(Test.java:24) - waiting to lock &lt;0x00000007d5d9b038&gt; (a java.lang.Object) - locked &lt;0x00000007d5d9b028&gt; (a java.lang.Object) Locked ownable synchronizers: - None&quot;Service Thread&quot; daemon prio=6 tid=0x000000000c284800 nid=0x870 runnable [0x0000000000000000] java.lang.Thread.State: RUNNABLE Locked ownable synchronizers: - None&quot;C2 CompilerThread1&quot; daemon prio=10 tid=0x000000000c282800 nid=0x1b54 waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE Locked ownable synchronizers: - None&quot;C2 CompilerThread0&quot; daemon prio=10 tid=0x000000000aea9000 nid=0x4c4 waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE Locked ownable synchronizers: - None&quot;Attach Listener&quot; daemon prio=10 tid=0x000000000aecf000 nid=0xe10 waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE Locked ownable synchronizers: - None&quot;Signal Dispatcher&quot; daemon prio=10 tid=0x000000000aeca000 nid=0x11f0 runnable [0x0000000000000000] java.lang.Thread.State: RUNNABLE Locked ownable synchronizers: - None&quot;Finalizer&quot; daemon prio=8 tid=0x000000000ae52800 nid=0xcdc in Object.wait() [0x000000000c13f000] java.lang.Thread.State: WAITING (on object monitor) at java.lang.Object.wait(Native Method) - waiting on &lt;0x00000007d5d04858&gt; (a java.lang.ref.ReferenceQueue$Lock) at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:135) - locked &lt;0x00000007d5d04858&gt; (a java.lang.ref.ReferenceQueue$Lock) at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:151) at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:209) Locked ownable synchronizers: - None&quot;Reference Handler&quot; daemon prio=10 tid=0x000000000ae51000 nid=0x18e8 in Object.wait() [0x000000000bf3f000] java.lang.Thread.State: WAITING (on object monitor) at java.lang.Object.wait(Native Method) - waiting on &lt;0x00000007d5d04470&gt; (a java.lang.ref.Reference$Lock) at java.lang.Object.wait(Object.java:503) at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:133) - locked &lt;0x00000007d5d04470&gt; (a java.lang.ref.Reference$Lock) Locked ownable synchronizers: - None&quot;VM Thread&quot; prio=10 tid=0x000000000ae4e000 nid=0xab8 runnable &quot;GC task thread#0 (ParallelGC)&quot; prio=6 tid=0x000000000258d000 nid=0x1bb4 runnable &quot;GC task thread#1 (ParallelGC)&quot; prio=6 tid=0x000000000258e800 nid=0x1be4 runnable &quot;GC task thread#2 (ParallelGC)&quot; prio=6 tid=0x0000000002590800 nid=0x19f8 runnable &quot;GC task thread#3 (ParallelGC)&quot; prio=6 tid=0x0000000002592000 nid=0x1b60 runnable &quot;VM Periodic Task Thread&quot; prio=10 tid=0x000000000c29d800 nid=0x13a4 waiting on condition JNI global references: 107Found one Java-level deadlock:=============================&quot;哲学家2&quot;: waiting to lock monitor 0x000000000ae5d1e8 (object 0x00000007d5d9b028, a java.lang.Object), which is held by &quot;哲学家1&quot;&quot;哲学家1&quot;: waiting to lock monitor 0x000000000ae5bd48 (object 0x00000007d5d9b038, a java.lang.Object), which is held by &quot;哲学家2&quot;Java stack information for the threads listed above:===================================================&quot;哲学家2&quot;: at com.test.Test.run(Test.java:36) - waiting to lock &lt;0x00000007d5d9b028&gt; (a java.lang.Object) - locked &lt;0x00000007d5d9b038&gt; (a java.lang.Object)&quot;哲学家1&quot;: at com.test.Test.run(Test.java:24) - waiting to lock &lt;0x00000007d5d9b038&gt; (a java.lang.Object) - locked &lt;0x00000007d5d9b028&gt; (a java.lang.Object)Found 1 deadlock. 很显然，我们成功检测到了死锁，并且详细列出了死锁的具体情况。]]></content>
      <categories>
        <category>Java 并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 并发-SynchronousQueue]]></title>
    <url>%2F2018%2F05%2F22%2FJava%20%E5%B9%B6%E5%8F%91-SynchronousQueue%2F</url>
    <content type="text"><![CDATA[在Java 并发-线程池中，我们提到了一个线程池常用的阻塞队列：SynchronousQueue。当时对它的描述很简略，在这里再次摘录如下： SynchronousQueue 即直接提交队列。其实这已经不能算作一种队列了：它并没有容量，即容量为0。换句话说，任何一个对SynchronousQueue的写需要等待一个对SynchronousQueue的读，反之亦然。因此，SynchronousQueue与其说是一个队列，更像是一个数据的中转站。 虽然当时没有细说，不过这实在是一个很奇特的队列了，那么它是如何实现的呢？ SynchronousQueue内部使用了大量的无锁(CAS)操作来进行并发控制，作为一个队列，外部最关心也最常用的自然就是它的put()和take()方法了： 123456789101112131415public void put(E o) throws InterruptedException &#123; if (o == null) throw new NullPointerException(); if (transferer.transfer(o, false, 0) == null) &#123; Thread.interrupted(); throw new InterruptedException(); &#125;&#125;public E take() throws InterruptedException &#123; Object e = transferer.transfer(null, false, 0); if (e != null) return (E)e; Thread.interrupted(); throw new InterruptedException();&#125; 实在是有趣！两个功能完全相反的方法内部调用的核心方法居然是同一个(正所谓殊途同归)，即transferer.transfer()方法。而transferer是SynchronousQueue的成员变量： 1private transient volatile Transferer transferer; 而Transferer是SynchronousQueue的静态内部类，它的代码很短，全部代码如下： 1234567891011abstract static class Transferer &#123; /** * @param e, 若e==null，说明这是一次take()操作 * 若e!=null，说明这是一次put()操作 * @param timed, 是否存在timeout时间 * @param nanos, 在timed==true的前提下，表示timeout的最大容忍时长 * @return 为null表示本次操作失败(超时或者中断) * 反之操作成功：take()时为取到的元素；put()时为新放入的元素 */ abstract Object transfer(Object e, boolean timed, long nanos);&#125; 这是一个抽象类，要想真的能new出实例，自然还需要非抽象的子类，我们来看一下SynchronousQueue的transferer是怎么new的，按照我们已有的经验，这种重要的成员变量的初始化一般都会在构造函数中，因此我们不妨看一下SynchronousQueue的构造函数： 1234567891011public SynchronousQueue() &#123; this(false);&#125;/** * fair, true - 线程等待队列为公平队列，即遵循FIFO * false - 线程排序不定 */public SynchronousQueue(boolean fair) &#123; transferer = fair ? new TransferQueue() : new TransferStack();&#125; 这里提到了一个线程等待队列，后文将详述。很显然，SynchronousQueue针对这个线程等待队列是否公平设计了两种实现，我想这就是为什么Transferer被设计为抽象类的原因吧，显然，这两个类都应是Transferer的子类。这两个类也均为SynchronousQueue的静态内部类，这里只贴出它们的类定义： 123static final class TransferQueue extends Transfererstatic final class TransferStack extends Transferer 接下来，就让我们详细说说这个线程等待队列吧！ 简单来说，我们可以认为SynchronousQueue实际上维护的就是这个线程等待队列，只不过它因为一些限制，使得外部观测者认为这个队列的容量为零。 我们可以这样认为，线程等待队列中的元素是线程的请求。我们不妨举一个小例子，假设有如下线程等待队列： 元素1：线程1请求写入数据1 元素2：线程2请求写入数据2 元素3：线程3请求写入数据3 元素4：线程4请求写入数据4 元素5：线程4请求写入数据5 此时来了一个新的请求，例如线程5请求写入数据5。它与队首元素1的请求类型相同，不符合SynchronousQueue的基本规定(任何一个对SynchronousQueue的写需要等待一个对SynchronousQueue的读，反之亦然)，线程5就会被存入线程等待队列的队首， 元素1：线程5请求写入数据5 元素2：线程1请求写入数据1 元素3：线程2请求写入数据2 元素4：线程3请求写入数据3 元素5：线程4请求写入数据4 然后又来了一个新的请求：线程6请求读取数据。这与队首的元素1就不冲突了。此时元素1会被弹出，构成元素1-新请求的请求对，然后处理这个请求对。经过该步，线程等待队列变为: 元素1：完成状态请求对：线程5请求写入数据5-线程6请求读取数据 元素2：线程1请求写入数据1 元素3：线程2请求写入数据2 元素4：线程3请求写入数据3 元素5：线程4请求写入数据4 请求对处理完成后，线程等待队列变为： 元素1：线程1请求写入数据1 元素2：线程2请求写入数据2 元素3：线程3请求写入数据3 元素4：线程4请求写入数据4 介绍完核心思想，我们再以具体的实现TransferStack.transfer()为例，看看具体的源码是如何实现的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869Object transfer(Object e, boolean timed, long nanos) &#123; SNode s = null; // 封装当前请求的元素 int mode = (e == null) ? REQUEST : DATA; for (;;) &#123; SNode h = head; // 线程等待队列中的队首元素 if (h == null || h.mode == mode) &#123; // 队列为空，或队首元素与当前请求的类型相同(均为读，或均为写) if (timed &amp;&amp; nanos &lt;= 0) &#123; // 不进行等待 if (h != null &amp;&amp; h.isCancelled()) // 当前队首元素处于取消状态的话，帮助队首元素处理它的取消行为 casHead(h, h.next); else return null; // 直接判定为失败，新请求无法进入队列 &#125; else if (casHead(h, s = snode(s, e, h, mode))) &#123; // 将新请求生成为元素，并插入到队首且插入成功 // awaitFulfill()方法会进行自旋，若自旋结束后也未出现新的匹配请求(即当前元素为读的话，出现了为写的请求；或当前元素为写的话，出现了读的请求)，则会挂起线程 // 当匹配请求出现后，线程被唤醒 SNode m = awaitFulfill(s, timed, nanos); if (m == s) &#123; // 其他线程已帮助该元素完成了它的工作，后续流程取消 clean(s); return null; &#125; // 继续向下走了，说明没有接到别人的帮助 if ((h = head) != null &amp;&amp; h.next == s) // 帮助临近的后续元素 casHead(h, s.next); return (mode == REQUEST) ? m.item : s.item; &#125; &#125; else if (!isFulfilling(h.mode)) &#123; // 队首元素与当前请求的类型不同 if (h.isCancelled()) // 若该队首元素已在其他线程的帮助下被取消了 casHead(h, h.next); // 弹出当前队首，并重试 // 能进入下面的else if说明当前已能构成请求对 else if (casHead(h, s=snode(s, e, h, FULFILLING|mode))) &#123; // 以当前请求对生成一个新的元素 // 将它置为完成态 // 并置于队首 for (;;) &#123; // 除非队列为空，否则一直检测匹配者 SNode m = s.next; // 设置m(原队列队首)为s(当前请求元素)的匹配者 if (m == null) &#123; // 循环到最后也没找到匹配者 casHead(s, null); s = null; break; &#125; SNode mn = m.next; // tryMatch()会激活一个等待线程，并将m传递给那个线程 if (m.tryMatch(s)) &#123; // 设置成功，数据投递完成 // s,m均可弹出了 casHead(s, mn); return (mode == REQUEST) ? m.item : s.item; &#125; else // 设置失败 // 说明已有其他线程帮助完成了该工作 // 弹出m即可 s.casNext(m, mn); &#125; &#125; &#125; else &#123; // 头部元素恰好是完成态 // 说明此时恰有一个线程处于上一个else if中的匹配过程中 // 那么对于当前线程而言，比起处理目前手中已有的新进请求 // 更优先的事项是帮助其他线程完成这个完成态的元素 SNode m = h.next; if (m == null) casHead(h, null); else &#123; SNode mn = m.next; if (m.tryMatch(h)) casHead(h, mn); else h.casNext(m, mn); &#125; &#125; &#125;&#125; 值得关注的是，上文中有很多线程间互助的操作，例如： 第10行：当前队首元素处于取消状态的话，帮助队首元素处理它的取消行为 第18行：其他线程已帮助该元素完成了它的工作，后续流程取消 第23行：帮助临近的后续元素 第56行：更优先的事项是帮助其他线程完成这个完成态的元素 由此可知，在SynchronousQueue中，线程间不再仅仅只是竞争关系了，还体现着一种协作：线程进入线程等待队列意味着被挂起，那么那些没挂起的，还尚有余力的线程就可以帮助其他线程完成任务，这种模式可以更大程度上减少饥饿的可能，提高系统整体的并行性。]]></content>
      <categories>
        <category>Java 并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>SynchronousQueue</tag>
        <tag>无锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java AWT-以像素为单位操纵图片]]></title>
    <url>%2F2018%2F05%2F20%2FJava%20AWT-%E4%BB%A5%E5%83%8F%E7%B4%A0%E4%B8%BA%E5%8D%95%E4%BD%8D%E6%93%8D%E7%BA%B5%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[我们先准备一张示例图片，将其命名为0.jpg并放在D盘根目录下： 通过Windows属性查看器，可以看到该图片的属性信息中有如下描述： 这也就是咱们常说的图片的宽与高。那么从本质上讲，它们到底是什么呢？ 简单来说，我们看到的绝大多数图片都是RGB图片。而从本质上讲，RGB图片是一个二维数组。数组中的元素是RGB像素点(Red-Green-Blue三基色调和而成)。也就是说，图片本质上是离散的，但是如果像素点足够密集的话，便可以欺骗人的眼睛，让其看起来是连续的。 回到本例，本例中的图片其实就是一个这样的二维数组：数组有711行，每行有1280个像素点。 那么，如果我们想操作图片，最底层，也是灵活性最高的做法自然就是以像素点为单位了，这样，我们就可以很容易的做到任何我们能想到的和图片相关的操作了。 下面给出一个小例子： 123456789101112131415161718192021import java.awt.image.BufferedImage;import java.io.File;import java.io.IOException;import javax.imageio.ImageIO;public class Test &#123; public static void main(String[] args) throws IOException &#123; String oldPath = new StringBuilder(&quot;D:&quot;).append(File.separator) .append(&quot;0.jpg&quot;) .toString(); File oldFile = new File(oldPath); BufferedImage bufferedImage = ImageIO.read(oldFile); String newPath = new StringBuilder(&quot;D:&quot;).append(File.separator) .append(&quot;1.jpg&quot;) .toString(); File newFile = new File(newPath); ImageIO.write(bufferedImage, &quot;jpg&quot;, newFile); &#125;&#125; 执行该代码后，D盘下将生成1.jpg，因为我们将内存中的bufferedImage原样输出了，因此它与原有的0.jpg一模一样。 下面我们来看下bufferedImage中的像素点： 123456789101112131415161718192021222324252627282930import java.awt.image.BufferedImage;import java.io.File;import java.io.IOException;import javax.imageio.ImageIO;public class Test &#123; public static void main(String[] args) throws IOException &#123; String oldPath = new StringBuilder(&quot;D:&quot;).append(File.separator) .append(&quot;0.jpg&quot;) .toString(); File oldFile = new File(oldPath); BufferedImage bufferedImage = ImageIO.read(oldFile); for (int y = 0; y &lt; bufferedImage.getHeight(); y++) &#123; for (int x = 0; x &lt; bufferedImage.getWidth(); x++) &#123; int p = bufferedImage.getRGB(x, y); int r = (p &amp; 0xff); int g = (p &amp; 0xff00) &gt;&gt; 8; int b = (p &amp; 0xff0000) &gt;&gt; 16; System.out.println(&quot;[R,G,B]=[&quot; + r + &quot;,&quot; + g + &quot;,&quot; + b + &quot;]&quot;); &#125; &#125; String newPath = new StringBuilder(&quot;D:&quot;).append(File.separator) .append(&quot;1.jpg&quot;) .toString(); File newFile = new File(newPath); ImageIO.write(bufferedImage, &quot;jpg&quot;, newFile); &#125;&#125; 图片输出依然没变，不过这次我们还逐行打印了该图片所有像素点的RGB值，它的部分输出如下： 1234567891011[R,G,B]=[172,148,136][R,G,B]=[172,149,134][R,G,B]=[174,147,133][R,G,B]=[171,144,130][R,G,B]=[166,140,126][R,G,B]=[162,136,122][R,G,B]=[155,131,119][R,G,B]=[147,125,114][R,G,B]=[139,115,109][R,G,B]=[133,108,104][R,G,B]=[121,100,99] 接着我们需要稍微补充一些RGB的基础知识了。 常见的图片中的RGB都是8位真彩色。也就是分别用8位来表示一种单色，因为2^8=256，即有256种红色，256种绿色，256种蓝色。这三种基色再进行调和，共可以得到2^24种颜色，这其实已经是一个足够大的数字了，临近的两种离散的颜色的色差其实已经很小了，用来欺骗我们的眼睛基本是足够了。正如上文的输出结果所证实的，RGB像素点每一个分量的值均在[0,255]的范围内。 然后我们再简要介绍下Java中RGB像素点的存储方式。Java是使用一个整型数据来存储一个RGB像素点的。1个整型数据长32位，RGB像素点只使用最后的24位。在这24位中：首先是8位的B，然后是8位的G，最后是8位的R。这也是上文代码的取值依据。 知道了这些，再要操作图片就容易了： 12345678910111213141516171819202122232425262728import java.awt.image.BufferedImage;import java.io.File;import java.io.IOException;import javax.imageio.ImageIO;public class Test &#123; public static void main(String[] args) throws IOException &#123; String oldPath = new StringBuilder(&quot;D:&quot;).append(File.separator) .append(&quot;0.jpg&quot;) .toString(); File oldFile = new File(oldPath); BufferedImage bufferedImage = ImageIO.read(oldFile); for (int y = 0; y &lt; bufferedImage.getHeight(); y++) &#123; for (int x = 0; x &lt; bufferedImage.getWidth(); x++) &#123; int p = bufferedImage.getRGB(x, y); int r = p &amp; 0xff; int g = (p &amp; 0xff00) &gt;&gt; 8; int b = (p &amp; 0xff0000) &gt;&gt; 16; int newP = (255 - r) | ((255 - g) &lt;&lt; 8) | ((255 - b) &lt;&lt; 16); bufferedImage.setRGB(x, y, newP); &#125; &#125; String newPath = new StringBuilder(&quot;D:&quot;).append(File.separator) .append(&quot;1.jpg&quot;) .toString(); File newFile = new File(newPath); ImageIO.write(bufferedImage, &quot;jpg&quot;, newFile); &#125;&#125; 例如，上述代码将1.jpg中的每个像素点都置为了0.jpg对应位置像素点的反色，即： 再比如： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.awt.image.BufferedImage;import java.io.File;import java.io.IOException;import javax.imageio.ImageIO;public class Test &#123; public static void main(String[] args) throws IOException &#123; String oldPath = new StringBuilder(&quot;D:&quot;).append(File.separator) .append(&quot;0.jpg&quot;) .toString(); File oldFile = new File(oldPath); BufferedImage bufferedImage = ImageIO.read(oldFile); final int width = 2; boolean ifShowY = true; int nowY = 0; for (int y = 0; y &lt; bufferedImage.getHeight(); y++) &#123; if (!ifShowY) &#123; for (int x = 0; x &lt; bufferedImage.getWidth(); x++) bufferedImage.setRGB(x, y, 0); &#125; else &#123; boolean ifShowX = true; int nowX = 0; for (int x = 0; x &lt; bufferedImage.getWidth(); x++) &#123; if(!ifShowX) bufferedImage.setRGB(x, y, 0); nowX++; if (nowX == width) &#123; nowX = 0; ifShowX = !ifShowX; &#125; &#125; &#125; nowY++; if (nowY == width) &#123; nowY = 0; ifShowY = !ifShowY; &#125; &#125; String newPath = new StringBuilder(&quot;D:&quot;).append(File.separator) .append(&quot;1.jpg&quot;) .toString(); File newFile = new File(newPath); ImageIO.write(bufferedImage, &quot;jpg&quot;, newFile); &#125;&#125; 上述代码实现了一种网格化效果，每个小网格的大小位2*2。因为有3/4的点没有输出，因此图片显得很暗：]]></content>
      <categories>
        <category>Java AWT</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>GUI</tag>
        <tag>AWT</tag>
        <tag>图片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java AWT-播放音乐]]></title>
    <url>%2F2018%2F05%2F20%2FJava%20AWT-%E6%92%AD%E6%94%BE%E9%9F%B3%E4%B9%90%2F</url>
    <content type="text"><![CDATA[使用Maven管理jar包，首先在pom.xml中导入所需jar： 12345&lt;dependency&gt; &lt;groupId&gt;com.googlecode.soundlibs&lt;/groupId&gt; &lt;artifactId&gt;jlayer&lt;/artifactId&gt; &lt;version&gt;1.0.1.4&lt;/version&gt;&lt;/dependency&gt; 然后准备一首mp3格式的音乐作为例子： 1DiGiTAL WiNG - 恋ノ蟲.mp3 下面给出使用示例： 123456789101112131415161718192021222324252627import java.io.BufferedInputStream;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import javazoom.jl.decoder.JavaLayerException;import javazoom.jl.player.Player;public class Test &#123; public static void main(String[] args) throws JavaLayerException, IOException &#123; String path = new StringBuilder(&quot;D:&quot;).append(File.separator) .append(&quot;DiGiTAL WiNG - 恋ノ蟲.mp3&quot;) .toString(); File file = new File(path); try (FileInputStream fis = new FileInputStream(file);) &#123; try (BufferedInputStream bis = new BufferedInputStream(fis);) &#123; Player player = new Player(bis); try &#123; player.play(); &#125; finally &#123; player.close(); &#125; &#125; &#125; &#125;&#125; 歌曲播放完成后程序退出。]]></content>
      <categories>
        <category>Java AWT</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>GUI</tag>
        <tag>AWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 并发-无锁的Vector实现]]></title>
    <url>%2F2018%2F05%2F17%2FJava%20%E5%B9%B6%E5%8F%91-%E6%97%A0%E9%94%81%E7%9A%84Vector%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[java.util.Vector是Java API提供的容器，它可以被看作是线程安全的java.util.ArrayList。该Vector是以synchronized来保证容器的线程安全性的。在Java 并发-无锁中，我们介绍一些Java API中基础的，利用CAS做并发控制的小例子。下面，让我们跳出Java API，来分析一种第三方类库提供的Vector的无锁(即使用CAS做并发控制)实现。 该第三方jar包被称为Amino框架，它是一个采用无锁方式实现并行计算的框架。遗憾的是，我并未在Maven仓库或网上其他地方找到这个jar包，也无法找到它的源码。因此本文中的源码和分析完全来自于[实战Java高并发程序设计]一书。 在Amino框架中，该Vector被称作LockFreeVector。它的特点是可以根据需求动态扩展其内部的空间。其实际用于存储的数据结构为： 1private final AtomicReferenceArray&lt;AtomicReferenceArray&lt;E&gt;&gt; buckets; 值得注意的是，该变量是final的，而Vector内存储的数据显然又需要是可变的，这就说明不变的仅仅是引用指向buckets这一点，buckets内部还是需要变化的。 另外，较之普通的Java API中的集合类的容器，buckets的数据结构是比较复杂的：它是一个数组，其元素又是一个数组(也就是我们常说的二维数组)。而且这些数组全部都是AtomicReferenceArray，这样从最底层的存储数据的容器开始，LockFreeVector就获得了一定的线程安全能力。 那么问题来了，我们都知道Vector实际存储的数据是一维的。那么为什么要用一个二维的数据结构呢？简单来说，这是为了便于容器的动态扩展(下文将进行详述，算法很巧妙，也很有趣)。我们可以稍稍回顾下AtomicReferenceArray内部用于存储数据的数据结构： 1private final Object[] array; 它只是一个不可变的普通数组，如果只使用一维的AtomicReferenceArray的话，扩展将会非常麻烦。 此外，为了能对数组进行更有序的读写，还定义了一个名为Descriptor的类。它的作用是使用CAS操作写入新数据。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162static class Descriptor&lt;E&gt; &#123; /** * 整个Vector的长度 */ public int size; /** * 负责实际的写入 */ volatile WriteDescriptor&lt;E&gt; writeop; public Descriptor(int size, WriteDescriptor&lt;E&gt; writeop) &#123; this.size = size; this.writeop = writeop; &#125; /** * 写入 */ public void completeWrite() &#123; WriteDescriptor&lt;E&gt; tmpOp = writeop; if (tmpOp != null) &#123; tmpOp.doIt(); writeop = null; &#125; &#125;&#125;static class WriteDescriptor&lt;E&gt; &#123; /** * 期望值 */ public E oldV; /** * 待写入的新值 */ public E newV; /** * 需修改的原子数组 */ public AtomicReferenceArray&lt;E&gt; addr; /** * 数组需修改的索引位置 */ public int addr_ind; public WriteDescriptor(AtomicReferenceArray&lt;E&gt; addr, int addr_ind, E oldV, E newV) &#123; this.addr = addr; this.addr_ind = addr_ind; this.oldV = oldV; this.newV = newV; &#125; public void doIt() &#123; addr.compareAndSet(addr_ind, oldV, newV); &#125;&#125; 在构造LockFreeVector的实例时，显然需要初始化它的核心组件buckets及descriptor： 1234567public LockFreeVector() &#123; buckets = new AtomicReferenceArray&lt;AtomicReferenceArray&lt;E&gt;&gt;(N_BUCKET); buckets.set(0, new AtomicReferenceArray&lt;E&gt;(FIRST_BUCKET_SIZE)); // 在Descriptor外又包装了一层AtomicReference // 初始时Vector长度为0。未指定WriteDescriptor descriptor = new AtomicReference&lt;Descriptor&lt;E&gt;&gt;(new Descriptor&lt;E&gt;(0, null));&#125; 其中N_BUCKET及FIRST_BUCKET_SIZE均为常量值： 12N_BUCKET = 30;FIRST_BUCKET_SIZE = 8; 这里需要注意的是，buckets是final的，这意味着对于通过该构造函数生成的LockFreeVector实例而言，终其一生buckets的长度只能是30了。 同时，该构造函数还初始化了buckets的第一个元素，并将其的长度设为了8。而AtomicReferenceArray内部用于存储数据的数据结构为： 1private final Object[] array; 它也是final的。这就说明第一个元素，也就是第一个数组的长度固定为8。 如果我们以此为依据推断的话，假设buckets的后续元素的长度也都是8，那么buckets岂不是只能存储240个数据吗？不管怎么说，这都实在是太少了点。 我们先来回顾下Vector的扩展逻辑，在不显式指定扩展规则的情况下，默认每次容量翻倍(多说一句，ArrayList无法显式指定，只能按默认方式扩展，默认每次容量变为原来的1.5倍)。其实LockFreeVector的思路也类似：buckets的第二维数组存储数据本身，第一维数组以冗余的方式存储扩展。后一个元素就是前一个元素下一次的扩展，扩展默认每次翻倍，也就是说，buckets中元素的长度其实是这样的： 12345元素0：长度2^3元素1：长度2^4元素2：长度2^5...元素29：长度2^32 因此，buckets能存储的元素总数其实是： 12^3 + 2^4 + 2^5 + ... + 2^32 这已经是一个非常巨大的数字了，通常的需求都可以满足。 这里还有一个需要注意的点，无论是Vector还是ArrayList，同一个时间点维护的容器只有1份，也就是说进行扩展后，上一个容器就丢掉了。之前已有的数据还要复制到新容器中，可用容量的上限也是新容器的长度。但是，对于LockFreeVector而言，每次扩展后，老容器不会被抛弃，仍可继续，此时就没有将老容器中的元素复制到新容器中的必要了。buckets容积的上限为所有已有容器的和。 当有一个新元素需加入LockFreeVector时，会调用它的push_back()方法。该方法会将待添加元素放到LockFreeVector的末尾。对于Vector或是ArrayList，这是一个很简单的操作，直接将新元素丢到最后一个元素之后即可，如果容量不够就扩展。但是对于LockFreeVector而言，问题就要稍微复杂一些了。在丢元素之前我们需要先确定新元素的位置：即它位于第几个数组的第几号索引。 前文我们介绍过负责写入的类Descriptor，它有一个名为size的字段。其含义是当前LockFreeVector已有元素的个数。我们会用它来计算新元素的位置。 我们先来确定新元素位于第几个数组。 我们不妨模拟一个情景，当前已使用了4个数组，且4个数组都恰好装满(也就是说，我们要找的LockFreeVector的最后一个元素就是第4个数组的最后一个元素)，我们不妨用二进制的int型来表示这4个数组的长度： 1234数组1：00000000 00000000 00000000 00001000 = 2 ^ 3， 28个前导零数组2：00000000 00000000 00000000 00010000 = 2 ^ 4， 27个前导零数组3：00000000 00000000 00000000 00100000 = 2 ^ 5， 26个前导零数组4：00000000 00000000 00000000 01000000 = 2 ^ 6， 25个前导零 此时的size自然是这4个数字的和了，也就是 1size = 00000000 00000000 00000000 01111000 如果我们想要引起1次进位，那么最小需要加的数字就是1000，也就是8了。加后值为： 1size = 00000000 00000000 00000000 10000000 这刚好进入了第5个数组的领域，即新元素会位于第5个数组。 如果添加前元素没有装满呢？ 因为此时已使用了4个数组，这就说明前3个数组均是装满了的，只有第4个数组还有空缺。在此前提下数组4已有元素肯定是小于它的最大容量的，即小于： 100000000 00000000 00000000 01000000 此时如果我们再求size，它的值肯定也是小于上文的最大值的，即小于： 100000000 00000000 00000000 01111000 如果我们依然按照上文的方式加二进制的1000，那么肯定是不会引起进位的。进而可以确认新元素依然还在第四个数组的范围内。 上文我们都是以最高位1为判断依据的，事实上，为了更为方便，我们还可以使用最高位1前有几个零来判断(本质上二者是一回事)。例如落于第4个数组中时前导零个数为25。落入第5个数组中时前导零个数为24。 确定了位于哪个数组后，我们再来确定新元素在该数组中的位置。 很显然，将最高位1置为0后，剩余数字就是新元素在数组中的位置。我们依然以第一个恰好填满4个数组的临界状态来分析。此时，新元素的加入导致了一次进位，即创建了一个新的数组，该新元素称为了新数组的第一个元素，即索引为0。我们还以第5个数组为例： 100000000 00000000 00000000 10000000 它共可容纳2^7个元素，此时如果我们不看代表第5个数组的最高位的这个1，它后面的这7位就是它内部元素的索引，且该规律不仅仅是针对初始为0000000时有效，只要没引起进位，直到1111111其实都是有效的。 推广下去，不管是第几个数组，其实都是这个道理。而如果数组没有装满，这不过是代表它在前面介绍的0000000-1111111增长变化的路上，依然符合规律。 说了这么多，我们总结以下使用size(现有元素数)求新元素位置的方法： 位于哪个数组：加二进制的1000后，根据前导零个数推断。在数组中的索引：将最高位1置为0后的值。 分析结束，下面我们来看一下push_back()方法的源码： 123456789101112131415161718192021public void push_back(E e) &#123; Descriptor&lt;E&gt; desc; Descriptor&lt;E&gt; newd; do &#123; desc = descriptor.get(); desc.completeWrite(); int pos = desc.size + FIRST_BUCKET_SIZE; int zeroNumPos = Integer.numberOfLeadingZeros(pos); int bucketInd = zeroNumFirst - zeroNumPos; if (buckets.get(bucketInd) == null) &#123; int newLen = 2 * buckets.get(bucketInd - 1).length(); if (debug) System.out.println(&quot;New Length is:&quot; + newLen); buckets.compareAndSet(bucketInd, null, new AtomicReferenceArray&lt;E&gt;(newLen)); &#125; int idx = (0x80000000&gt;&gt;&gt;zeroNumPos) ^ pos; newd = new Descriptor&lt;E&gt;(desc.size() + 1, new WriteDescriptor&lt;E&gt;(buckets.get(bucketInd), idx, null, e)); &#125; while (!descriptor.compareAndSet(desc, newd)); descriptor.get().completeWrite();&#125; 最后，同理，让我们再来看下LockFreeVector的get()方法的源码。push_back()需要确定的是新元素需插入的位置，而get()需要确定的是待查询元素的位置： 12345678@Overridepublic E get(int index) &#123; int pos = index + FIRST_BUCKET_SIZE; int zeroNumPos = Integer.numberOfLeadingZeros(pos); int bucketInd = zeroNumFirst - zeroNumPos; int idx = (0x80000000&gt;&gt;&gt;zeroNumPos) ^ pos; return buckets.get(bucketInd).get(idx);&#125;]]></content>
      <categories>
        <category>Java 并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>无锁</tag>
        <tag>Vector</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 并发-无锁]]></title>
    <url>%2F2018%2F05%2F11%2FJava%20%E5%B9%B6%E5%8F%91-%E6%97%A0%E9%94%81%2F</url>
    <content type="text"><![CDATA[在Java 并发-并发级别中，我们曾对无锁有过简要的介绍。本文将对其做更为具体的讲解。 CAS无锁是一种非阻塞的并发级别。它所采用的策略为比较交换(Compare And Swap, CAS)。 简单来说，CAS的模型是这样的： 1CAS(V, E, N) 其中： V: 欲更新的变量 E: 对欲更新变量的预期值 N: 对欲更新变量要赋的新值 换句话说，V是变量，而E,N是V可能为的值。若欲将V赋值为N，会在赋值之前检查V当前的值，当且仅当当前值仍为E时，即说明并未有其他线程修改V时，才会将V赋值为N。否则将什么都不做。然后无论此前做了什么，CAS都会返回V的当前值。 其实更较真的来说，当前值仍为E其实并不能说明在此期间就没有其他线程修改V。很有可能的是，V的值经历了很多次的修改，恰好在该线程检查时值又被赋回了E。不过这其实并不重要：因为我们只关注结果，只要在线程需要修改V时，它的值仍是期望值即可。 至于如果修改失败，线程打算做什么，那就不是CAS关注的事情了，会完全交给线程自身去判断：如果线程接受失败，那么就放弃这次并发操作。反之，它就再次尝试，直到成功为止。 在硬件层面，大部分的现代处理器都会支持原子化的CAS指令。自JDK1.5起，JVM会直接使用这些指令来实现部分的并发操作和并发数据结构。很显然，这样做的性能是远高于使用锁及同步的。举个小例子，我们在Java 并发-ConcurrentLinkedQueue中介绍过的ConcurrentLinkedQueue就是一个基于无锁实现的线程安全的容器。在此我们不妨再次贴出其中核心类Node的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455private static class Node&lt;E&gt; &#123; // item,next支撑起了Node作为链表的节点的基础 volatile E item; // 节点中存储的数据值 volatile Node&lt;E&gt; next; // 下一个节点 Node(E item) &#123; NSAFE.putObject(this, itemOffset, item); &#125; /** * 设置节点中存储的数据值 * 利用CAS保证线程安全性： * 设置时当前值与期望值相同则设置为目标值 * @param cmp E, 期望值 * @param val E, 目标值 * @return boolean, true--设置成功，false--设置失败 */ boolean casItem(E cmp, E val) &#123; return UNSAFE.compareAndSwapObject(this, itemOffset, cmp, val); &#125; void lazySetNext(Node&lt;E&gt; val) &#123; UNSAFE.putOrderedObject(this, nextOffset, val); &#125; /** * 设置本节点的下一个节点 * 利用CAS保证线程安全性： * 设置时当前值与期望值相同则设置为目标值 * @param cmp Node&lt;E&gt;, 期望值 * @param val Node&lt;E&gt;, 目标值 * @return boolean, true--设置成功,false--设置失败 */ boolean casNext(Node&lt;E&gt; cmp, Node&lt;E&gt; val) &#123; return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val); &#125; private static final sun.misc.Unsafe UNSAFE; private static final long itemOffset; private static final long nextOffset; static &#123; try &#123; UNSAFE = sun.misc.Unsafe.getUnsafe(); Class k = Node.class; itemOffset = UNSAFE.objectFieldOffset (k.getDeclaredField(&quot;item&quot;)); nextOffset = UNSAFE.objectFieldOffset (k.getDeclaredField(&quot;next&quot;)); &#125; catch (Exception e) &#123; throw new Error(e); &#125; &#125;&#125; CAS操作在Java API中很常见，不过调用方式都是大同小异，核心围绕的都是UNSAFE.compareAndSwapObject()。这个方法是属于UNSAFE类的，也就是说它是不对外开放的，只供Java API内部使用。官方下载的JDK中也没有附带它的源码，不过我们可以通过它的接收参数以及功能很明显的看出这就是一个CAS。只不过它的返回值是boolean，看来方法内部对原生的CAS做了包装。其实这是更符合我们的调用思维的：调用者其实并不太关心当前V的值，而是更关心此次修改是否成功。 AtomicInteger为了让Java程序员能直接受益于CAS等CPU指令，JDK提供了如下包： 1java.util.concurrent.atomic 该包中实现了一些直接使用CAS操作的线程安全的类型。下面我们介绍一下其中最常用的类：AtomicInteger。它的类定义如下： 1public class AtomicInteger extends Number implements java.io.Serializable 简单来说，AtomicInteger可以被视为一个32位的整数，但与Integer不同的是，AtomicInteger是可变的，并且是线程安全的。它的任何并发操作，都是基于CAS指令进行的(也就是说AtomicInteger使用无锁进行并发控制)。我们先来简单概述一下AtomicInteger常用的方法，对于其他的原子类，操作也是非常类似的： 12345678910public final int get() // 取得当前值public final void set(int newValue) // 设置当前值public final int getAndSet(int newValue) // 设置新值，并返回旧值public final boolean compareAndSet(int expect, int update) // 如果当前值为expect，则设置为updatepublic final int getAndIncrement() // 当前值加1，返回旧值public final int getAndDecrement() // 当前值减1，返回旧值public final int getAndAdd(int delta) // 当前值增加delta，返回旧值public final int incrementAndGet() // 当前值加1，返回新值public final int decrementAndGet() // 当前值减1，返回新值public final int addAndGet(int delta) // 当前值增加delta，返回新值 AtomicInteger类中最核心的成员变量为： 1private volatile int value; value中存储的值就是AtomicInteger的当前实际取值。此外还有一个字段： 1private static final long valueOffset; 该字段为value的偏移量，它是AtomicInteger进行并发控制的关键。 我们先来看一个小例子： 123456789101112131415161718192021import java.util.concurrent.atomic.AtomicInteger;public class Test &#123; private static AtomicInteger AI = new AtomicInteger(); public static void main(String[] args) throws InterruptedException &#123; Runnable r = new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10000; i++) Test.AI.incrementAndGet(); &#125; &#125;; int threadCount = 10; Thread[] threadArray = new Thread[threadCount]; for (int i = 0; i &lt; threadCount; i++) threadArray[i] = new Thread(r); for (int i = 0; i &lt; threadCount; i++) threadArray[i].start(); for (int i = 0; i &lt; threadCount; i++) threadArray[i].join(); System.out.println(Test.AI); &#125;&#125; 输出： 1100000 显然，AtomicInteger很好的进行了并发控制。接下来让我们来看一下incrementAndGet()的源码： 12345678public final int incrementAndGet() &#123; for (;;) &#123; int current = get(); int next = current + 1; if (compareAndSet(current, next)) return next; &#125;&#125; 它内部调用的get()方法很简单： 123public final int get() &#123; return value;&#125; 类似于AtomicInteger，AtomicLong对应于long型，AtomicBoolean对应于boolean，AtomicReference对应于引用。 Unsafe接上一小节AtomicInteger，我们在分析它的incrementAndGet()方法的源码时并未看其中的核心方法compareAndSet()，现在我们具体的来看一下： 123public final boolean compareAndSet(int expect, int update) &#123; return unsafe.compareAndSwapInt(this, valueOffset, expect, update);&#125; 而unsafe是AtomicInteger的类变量： 1private static final Unsafe unsafe = Unsafe.getUnsafe(); 果然，它仅仅做了一个封装，其内部调用的依然是我们在介绍CAS时提到的UNSAFE类。 现在就让我们来具体介绍一下这个类吧。 如前文所述，JDK并不希望程序员直接调用Unsafe类，因此也没有提供它的源码。不过我们依然可以查到它所属的包为： 1sun.misc 顾名思义，Unsafe类中应该是封装了一些不安全的操作(这样的话，不希望程序员们调用也就可以理解了)，那么什么是不安全的操作呢？ 在 C/C++ 中，有一个很重要的数据结构，名为指针。众所周知，指针是不安全的，这也是Java不准程序员显式定义和使用指针的原因。 请注意上文中的措辞，Java只是不准程序员显式的定义及使用指针，并不意味着Java移除了指针。事实上，指针所实现的功能是无可替代的：我们总要用一个数据结构去指向变量。如果不是特别较真的话，我们可以把引用看作Java中的指针，然而引用是非常上层的东西了，它并不会真正导致指针会造成的那些错误：例如，数组越界。如果是指针的话，那么当真就是在系统底层指到了数组外面。而如果是引用，则是JVM内部的行为，它会在内部”计算”是否越界，如果越界了那么返回异常，并没有实际在底层进行操作，相当于只进行了一次预先演算。这样便规避了实际运行时可能会产生的风险。 然而，终归是要实际运行的。我们此前也提到，指针的功能是无可替代的。事实上，Java将指针大部分的功能封装在了Unsafe类中。换句话说，与引用相比，说Unsafe是Java的指针要更准确一些(仅仅只是更准确一些，Unsafe也无法完全代替指针)。 我们继续来分析compareAndSwapInt()。虽然官网上下载不到源码，但我们总是有搞到源码的渠道的： 12345678910/** * o 待操作对象 * offset 对象内的偏移量 * 是一个字段到对象头部的偏移量 * 通过这个偏移量可以快速定位字段 * expected 期望值 * x 要设置的值 * 若有当前值等于expected，则设置为x */public final native boolean compareAndSwapInt(Object o, long offset, int expected, int x); 原来是native方法，不过这也与我们在前文中的推测相符：直接调用底层的CAS指令，无需再用Java代码做什么了。 此外，从名字上我们就不难推测出，compareAndSwapInt()方法是处理int型数据的，而我们在前文(开篇CAS那一小节)中提到的compareAndSwapObject()方法自然就是服务于Object对象的了。类比下去，常用的数据类型，long，double等应该也都会有特定的一族方法。 在此我们以int型为例，看看Unsafe还提供了哪些其他功能的方法： 123456789101112// 获得o在偏移量offset上的字段的int值public native int getInt(Object o, long offset);// 设定o在偏移量offset上的字段的int值public native void putInt(Object o, long offset, int x);// 获得字段在对象中的偏移量public native long objectFieldOffset(Field f);// 使用volatile语义，设定o在偏移量offset上的字段的int值public native void putIntVolatile(Object o, long offset, int x);// 使用volatile语义，获得o在偏移量offset上的字段的int值public native int getIntVolatile(Object o, long offset);// 在putIntVolatile()的基础上，还要求被操作字段就是volatile的public native void putOrderedInt(Object o, long offset, int x); 为了继续分析Unsafe类，我们不妨将上文中Node的代码再贴一遍： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455private static class Node&lt;E&gt; &#123; // item,next支撑起了Node作为链表的节点的基础 volatile E item; // 节点中存储的数据值 volatile Node&lt;E&gt; next; // 下一个节点 Node(E item) &#123; NSAFE.putObject(this, itemOffset, item); &#125; /** * 设置节点中存储的数据值 * 利用CAS保证线程安全性： * 设置时当前值与期望值相同则设置为目标值 * @param cmp E, 期望值 * @param val E, 目标值 * @return boolean, true--设置成功，false--设置失败 */ boolean casItem(E cmp, E val) &#123; return UNSAFE.compareAndSwapObject(this, itemOffset, cmp, val); &#125; void lazySetNext(Node&lt;E&gt; val) &#123; UNSAFE.putOrderedObject(this, nextOffset, val); &#125; /** * 设置本节点的下一个节点 * 利用CAS保证线程安全性： * 设置时当前值与期望值相同则设置为目标值 * @param cmp Node&lt;E&gt;, 期望值 * @param val Node&lt;E&gt;, 目标值 * @return boolean, true--设置成功,false--设置失败 */ boolean casNext(Node&lt;E&gt; cmp, Node&lt;E&gt; val) &#123; return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val); &#125; private static final sun.misc.Unsafe UNSAFE; private static final long itemOffset; private static final long nextOffset; static &#123; try &#123; UNSAFE = sun.misc.Unsafe.getUnsafe(); Class k = Node.class; itemOffset = UNSAFE.objectFieldOffset (k.getDeclaredField(&quot;item&quot;)); nextOffset = UNSAFE.objectFieldOffset (k.getDeclaredField(&quot;next&quot;)); &#125; catch (Exception e) &#123; throw new Error(e); &#125; &#125;&#125; 其中，得到Unsafe类实例的代码在static代码块中： 1UNSAFE = sun.misc.Unsafe.getUnsafe(); 虽然官方不提供，但我们依然可以从其他渠道拿到它的源码： 123456public static Unsafe getUnsafe() &#123; Class cc = Reflection.getCallerClass(); if (cc.getClassLoader() != null) throw new SecurityException(&quot;Unsafe&quot;); return theUnsafe;&#125; 显然，该方法会检查调用者所属的类，如果该类的ClassLoader不为null，则说明该请求并非来自JDK内部，而正如前文中提到的，Unsafe类被设计成只供JDK内部调用，因此会抛出异常，拒绝响应。 关于能进行这样判断的依据，可详见JVM-类加载器。 AtomicReference从名字上我们就不难推测，AtomicReference与前文介绍的AtomicInteger即为类似。只不过AtomicInteger保证的是整数的线程安全性，而AtomicReference保证得则是普通的对象引用。 在开篇介绍CAS时，我们曾有如下论述： 其实更较真的来说，当前值仍为E其实并不能说明在此期间就没有其他线程修改V。很有可能的是，V的值经历了很多次的修改，恰好在该线程检查时值又被赋回了E。不过这其实并不重要：因为我们只关注结果，只要在线程需要修改V时，它的值仍是期望值即可。 这里说的”其实并不重要”指得是通常情况下，某些时候，该机制是会产生问题的。我们先来看下面的小例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.concurrent.atomic.AtomicReference;public class Test &#123; private static final int STANDARD = 20; private static AtomicReference&lt;Integer&gt; AR = new AtomicReference&lt;Integer&gt;(Test.STANDARD - 1); public static void main(String[] args) &#123; Thread t1 = new Thread() &#123; @Override public void run() &#123; String threadId = &quot;[&quot; + Thread.currentThread().getId() + &quot;]&quot;; Integer value = Test.AR.get(); if (value &lt; Test.STANDARD) &#123; if (Test.AR.compareAndSet(value, value + Test.STANDARD)) &#123; System.out.println(threadId + &quot;当前值=&quot; + value + &quot;,小于&quot; + Test.STANDARD + &quot;，进行修改并修改成功，修改后值=&quot; + Test.AR.get()); &#125; else &#123; System.out.println(threadId + &quot;当前值=&quot; + value + &quot;,小于&quot; + Test.STANDARD + &quot;，进行修改并修改失败，此时值=&quot; + Test.AR.get()); &#125; &#125; else System.out.println(threadId + &quot;当前值=&quot; + value + &quot;,大于等于&quot; + Test.STANDARD + &quot;，无需修改&quot;); &#125; &#125;; t1.start(); Thread t2 = new Thread() &#123; @Override public void run() &#123; String threadId = &quot;[&quot; + Thread.currentThread().getId() + &quot;]&quot;; Integer value = Test.AR.get(); if (value &lt; Test.STANDARD) &#123; if (Test.AR.compareAndSet(value, value + Test.STANDARD)) &#123; System.out.println(threadId + &quot;当前值=&quot; + value + &quot;,小于&quot; + Test.STANDARD + &quot;，进行修改并修改成功，修改后值=&quot; + Test.AR.get()); &#125; else &#123; System.out.println(threadId + &quot;当前值=&quot; + value + &quot;,小于&quot; + Test.STANDARD + &quot;，进行修改并修改失败，此时值=&quot; + Test.AR.get()); &#125; &#125; else System.out.println(threadId + &quot;当前值=&quot; + value + &quot;,大于等于&quot; + Test.STANDARD + &quot;，无需修改&quot;); &#125; &#125;; t2.start(); &#125;&#125; 上面这段代码使用两个线程并发修改AR的值。如果AR的值小于20则会加上20。只会修改1次。运行后输出为： 12[9]当前值=19,小于20，进行修改并修改成功，修改后值=39[10]当前值=39,大于等于20，无需修改 代码是没有问题的。 现在我们再添加线程3，它会减少AR中的值： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.util.concurrent.atomic.AtomicReference;public class Test &#123; private static final int STANDARD = 20; private static AtomicReference&lt;Integer&gt; AR = new AtomicReference&lt;Integer&gt;(Test.STANDARD - 1); public static void main(String[] args) &#123; Thread t1 = new Thread() &#123; @Override public void run() &#123; String threadId = &quot;[&quot; + Thread.currentThread().getId() + &quot;]&quot;; Integer value = Test.AR.get(); if (value &lt; Test.STANDARD) &#123; if (Test.AR.compareAndSet(value, value + Test.STANDARD)) &#123; System.out.println(threadId + &quot;当前值=&quot; + value + &quot;,小于&quot; + Test.STANDARD + &quot;，进行修改并修改成功，修改后值=&quot; + Test.AR.get()); &#125; else &#123; System.out.println(threadId + &quot;当前值=&quot; + value + &quot;,小于&quot; + Test.STANDARD + &quot;，进行修改并修改失败，此时值=&quot; + Test.AR.get()); &#125; &#125; else System.out.println(threadId + &quot;当前值=&quot; + value + &quot;,大于等于&quot; + Test.STANDARD + &quot;，无需修改&quot;); &#125; &#125;; t1.start(); Thread t2 = new Thread() &#123; @Override public void run() &#123; String threadId = &quot;[&quot; + Thread.currentThread().getId() + &quot;]&quot;; Integer value = Test.AR.get(); if (value &lt; Test.STANDARD) &#123; if (Test.AR.compareAndSet(value, value + Test.STANDARD)) &#123; System.out.println(threadId + &quot;当前值=&quot; + value + &quot;,小于&quot; + Test.STANDARD + &quot;，进行修改并修改成功，修改后值=&quot; + Test.AR.get()); &#125; else &#123; System.out.println(threadId + &quot;当前值=&quot; + value + &quot;,小于&quot; + Test.STANDARD + &quot;，进行修改并修改失败，此时值=&quot; + Test.AR.get()); &#125; &#125; else System.out.println(threadId + &quot;当前值=&quot; + value + &quot;,大于等于&quot; + Test.STANDARD + &quot;，无需修改&quot;); &#125; &#125;; t2.start(); Thread t3 = new Thread() &#123; @Override public void run() &#123; String threadId = &quot;[&quot; + Thread.currentThread().getId() + &quot;]&quot;; Integer value = Test.AR.get(); while (true) &#123; if (Test.AR.compareAndSet(value, value - Test.STANDARD)) &#123; System.out.println(threadId + &quot;当前值=&quot; + value + &quot;,成功减少&quot; + Test.STANDARD + &quot;，减少后值=&quot; + Test.AR.get()); break; &#125; &#125; &#125; &#125;; t3.start(); &#125;&#125; 此时输出： 123[9]当前值=19,小于20，进行修改并修改成功，修改后值=39[10]当前值=39,大于等于20，无需修改[11]当前值=39,成功减少20，减少后值=19 依然是没有问题的。 然后我们有意的控制一下这3个线程执行过程中的耗时： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import java.util.concurrent.atomic.AtomicReference;public class Test &#123; private static final int STANDARD = 20; private static AtomicReference&lt;Integer&gt; AR = new AtomicReference&lt;Integer&gt;(Test.STANDARD - 1); public static void main(String[] args) &#123; Thread t1 = new Thread() &#123; @Override public void run() &#123; try &#123; String threadId = &quot;[&quot; + Thread.currentThread().getId() + &quot;]&quot;; Integer value = Test.AR.get(); Thread.sleep(10); if (value &lt; Test.STANDARD) &#123; if (Test.AR.compareAndSet(value, value + Test.STANDARD)) &#123; System.out.println(threadId + &quot;当前值=&quot; + value + &quot;,小于&quot; + Test.STANDARD + &quot;，进行修改并修改成功，修改后值=&quot; + Test.AR.get()); &#125; else &#123; System.out.println(threadId + &quot;当前值=&quot; + value + &quot;,小于&quot; + Test.STANDARD + &quot;，进行修改并修改失败，此时值=&quot; + Test.AR.get()); &#125; &#125; else System.out.println(threadId + &quot;当前值=&quot; + value + &quot;,大于等于&quot; + Test.STANDARD + &quot;，无需修改&quot;); &#125; catch (Exception e) &#123;&#125; &#125; &#125;; t1.start(); Thread t2 = new Thread() &#123; @Override public void run() &#123; try &#123; String threadId = &quot;[&quot; + Thread.currentThread().getId() + &quot;]&quot;; Integer value = Test.AR.get(); Thread.sleep(10); if (value &lt; Test.STANDARD) &#123; Thread.sleep(100); if (Test.AR.compareAndSet(value, value + Test.STANDARD)) &#123; System.out.println(threadId + &quot;当前值=&quot; + value + &quot;,小于&quot; + Test.STANDARD + &quot;，进行修改并修改成功，修改后值=&quot; + Test.AR.get()); &#125; else &#123; System.out.println(threadId + &quot;当前值=&quot; + value + &quot;,小于&quot; + Test.STANDARD + &quot;，进行修改并修改失败，此时值=&quot; + Test.AR.get()); &#125; &#125; else System.out.println(threadId + &quot;当前值=&quot; + value + &quot;,大于等于&quot; + Test.STANDARD + &quot;，无需修改&quot;); &#125; catch (Exception e) &#123;&#125; &#125; &#125;; t2.start(); Thread t3 = new Thread() &#123; @Override public void run() &#123; try &#123; Thread.sleep(20); String threadId = &quot;[&quot; + Thread.currentThread().getId() + &quot;]&quot;; Integer value = Test.AR.get(); while (true) &#123; if (Test.AR.compareAndSet(value, value - Test.STANDARD)) &#123; System.out.println(threadId + &quot;当前值=&quot; + value + &quot;,成功减少&quot; + Test.STANDARD + &quot;，减少后值=&quot; + Test.AR.get()); break; &#125; &#125; &#125; catch (Exception e) &#123;&#125; &#125; &#125;; t3.start(); &#125;&#125; 输出为： 123[9]当前值=19,小于20，进行修改并修改成功，修改后值=39[11]当前值=39,成功减少20，减少后值=19[10]当前值=19,小于20，进行修改并修改成功，修改后值=39 现在便有问题了，AR的值被修改了两次。用语言描述的话，其执行顺序是下面这样的： t1获得AR当前值=19，小于20，判断需要增加20。 t2获得AR当前值=19，小于20，判断需要增加20。 t1成功增加AR，增加后值为39。 t3将AR的值减少20，减少后值变回19。 t2开始进行CAS，因为当前值与期望值相同，故再次增加AR，增加后值为39。 如上所述，AR的值被增加了两次，变成了脏值。 上面的小例子是在控制了苛刻的执行顺序后产生的特例，一般不会发生。但这并不代表着它一定就不会发生。而且这种错误一旦发生，排查起来也是非常困难。因此依然有必要为此找到一个解决策略。而这个解决策略就是下面我们马上要介绍的AtomicStampedReference。 AtomicStampedReference继续上一节，其实并不仅仅是AtomicReference，绝大多数Atomic这一族的类都会有相同的并发问题。归根结底，还是因为这是CAS算法本身的问题。简单来说，这个问题就是：CAS只能判断进行比较时的那一个时间点上的当前值是否与期望值相同，而并非真正的知道在此期间值是否发生了变化。不过既然知道了症结所在，那么解决策略也就很显然了：用某种手段记录下值的变化情况即可。 不过，虽说是要记录值的变化情况，其实也并非就一定是做类似下面这样的详细记录： 线程1将V改为1 线程2将V改为2 线程3将V改为3… 事实上，我们只需要知道在此期间是否有其他线程修改过变量即可。至于它们到底将它改成了什么样子，其实并不重要：因为只要知道已被修改过就足以判断这次修改失败了，不用再需要其他的信息了。 AtomicStampedReference就是Java API给出的解决策略，它的内部不仅维护了对象值，还维护了一个时间戳(并非严格意义上的时间戳，而是一个任意的可以记录修改状态的整数)。若修改成功，不仅仅会修改AtomicStampedReference的值，还需要修改它的时间戳。同理，在进行修改的CAS尝试时，不仅会判断对象值是否满足期望，还会判断时间戳是否满足期望。 较之AtomicReference，AtomicStampedReference增加了一些时间戳相关的方法： 12345678910111213141516/** * expectedReference, 期望值 * newReference, 新值 * expectedStamp, 期望时间戳 * newStamp, 新时间戳 */public boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp)// 获得当前对象引用public V getReference()// 获得当前时间戳public int getStamp()// 设置当前对象引用和时间戳public void set(V newReference, int newStamp) 现在，就让我们用AtomicStampedReference来重写上文中使用AtomicReference时出现错误的代码吧： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import java.util.concurrent.atomic.AtomicStampedReference;public class Test &#123; private static final int STANDARD = 20; // 构造函数传入的两个参数依次为：初始值，初始时间戳 private static AtomicStampedReference&lt;Integer&gt; ASR = new AtomicStampedReference&lt;Integer&gt;(Test.STANDARD - 1, 0); public static void main(String[] args) &#123; Thread t1 = new Thread() &#123; @Override public void run() &#123; try &#123; String threadId = &quot;[&quot; + Thread.currentThread().getId() + &quot;]&quot;; Integer value = Test.ASR.getReference(); int timestamp = Test.ASR.getStamp(); Thread.sleep(10); if (value &lt; Test.STANDARD) &#123; if (Test.ASR.compareAndSet(value, value + Test.STANDARD, timestamp, timestamp + 1)) &#123; System.out.println(threadId + &quot;当前值=&quot; + value + &quot;,小于&quot; + Test.STANDARD + &quot;，进行修改并修改成功，修改后值=&quot; + Test.ASR.getReference()); &#125; else &#123; System.out.println(threadId + &quot;当前值=&quot; + value + &quot;,小于&quot; + Test.STANDARD + &quot;，进行修改并修改失败，此时值=&quot; + Test.ASR.getReference()); &#125; &#125; else System.out.println(threadId + &quot;当前值=&quot; + value + &quot;,大于等于&quot; + Test.STANDARD + &quot;，无需修改&quot;); &#125; catch (Exception e) &#123;&#125; &#125; &#125;; t1.start(); Thread t2 = new Thread() &#123; @Override public void run() &#123; try &#123; String threadId = &quot;[&quot; + Thread.currentThread().getId() + &quot;]&quot;; Integer value = Test.ASR.getReference(); int timestamp = Test.ASR.getStamp(); Thread.sleep(10); if (value &lt; Test.STANDARD) &#123; Thread.sleep(100); if (Test.ASR.compareAndSet(value, value + Test.STANDARD, timestamp, timestamp + 1)) &#123; System.out.println(threadId + &quot;当前值=&quot; + value + &quot;,小于&quot; + Test.STANDARD + &quot;，进行修改并修改成功，修改后值=&quot; + Test.ASR.getReference()); &#125; else &#123; System.out.println(threadId + &quot;当前值=&quot; + value + &quot;,小于&quot; + Test.STANDARD + &quot;，进行修改并修改失败，此时值=&quot; + Test.ASR.getReference()); &#125; &#125; else System.out.println(threadId + &quot;当前值=&quot; + value + &quot;,大于等于&quot; + Test.STANDARD + &quot;，无需修改&quot;); &#125; catch (Exception e) &#123;&#125; &#125; &#125;; t2.start(); Thread t3 = new Thread() &#123; @Override public void run() &#123; try &#123; Thread.sleep(20); String threadId = &quot;[&quot; + Thread.currentThread().getId() + &quot;]&quot;; Integer value = Test.ASR.getReference(); int timestamp = Test.ASR.getStamp(); while (true) &#123; if (Test.ASR.compareAndSet(value, value - Test.STANDARD, timestamp, timestamp + 1)) &#123; System.out.println(threadId + &quot;当前值=&quot; + value + &quot;,成功减少&quot; + Test.STANDARD + &quot;，减少后值=&quot; + Test.ASR.getReference()); break; &#125; &#125; &#125; catch (Exception e) &#123;&#125; &#125; &#125;; t3.start(); &#125;&#125; 输出： 123[9]当前值=19,小于20，进行修改并修改成功，修改后值=39[11]当前值=39,成功减少20，减少后值=19[10]当前值=19,小于20，进行修改并修改失败，此时值=19 可以看到，值只被增加了1次，问题解决了。 AtomicIntegerArrayAtomic一族中还有原子类性的容器，即原子数组，包括：AtomicIntegerArray,AtomicLongArray,AtomicReferenceArray。顾名思义，它们分别代表int型数组，long型数组及普通的对象数组。 这里我们以AtomicIntegerArray为例，介绍下原子数组的使用方式。 从本质上来讲，AtomicIntegerArray是对int[]的线程安全化封装。同其他Atomic一族的类一样，它的内部也是通过Unsafe类的CAS操作实现的。我们先简要介绍几个它的核心方法： 1234567891011121314151617181920// 获得数组索引为i的元素public final int get(int i)// 获得数组的长度public final int length()// 将数组索引为i的元素设置为newValue，并返回旧值public final int getAndSet(int i, int newValue)// 进行CAS操作，若数组索引为i的元素等于期望值(expect)，则将之设置为新值(update)。设置成功后返回true，反之返回falsepublic final boolean compareAndSet(int i, int expect, int update)// 将索引为i的元素加1public final int getAndIncrement(int i)// 将索引为i的元素减1public final int getAndDecrement(int i)// 将索引为i的元素加deltapublic final int getAndAdd(int i, int delta) 下面我们来看一个小例子： 12345678910111213141516171819202122232425import java.util.concurrent.atomic.AtomicIntegerArray;public class Test &#123; public static void main(String[] args) throws InterruptedException &#123; final int arrayLength = 10; final AtomicIntegerArray aia = new AtomicIntegerArray(arrayLength); Runnable r = new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 1000; i++) &#123; for (int j = 0; j &lt; arrayLength; j++) aia.getAndIncrement(j); &#125; &#125; &#125;; Thread[] threadArray = new Thread[arrayLength]; for (int i = 0; i &lt; arrayLength; i++) &#123; threadArray[i] = new Thread(r); threadArray[i].start(); threadArray[i].join(); &#125; System.out.println(aia); &#125;&#125; 输出为： 1[10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000] 符合预期。 最后我想说明的是。AtomicIntegerArray内实际用于存储数据的结构为： 1private final int[] array; 这是一个被final修饰的变量。也就是说，从外观上看，AtomicIntegerArray除了具有线程安全性之外，与普通的数组基本是一致的：声明后自然也是不能动态扩容的。 AtomicIntegerFieldUpdater在Java 并发-容器线程安全化方法中，我们介绍了将线程不安全的容器简单快速的改造为线程安全的容器的方法。同理，对于单独的变量，有时我们也需要能够将其简单的改造为线程安全的变量的方法。 Atomic一族中有一组以Updater结尾的类被用以解决这个需求，它们分别是AtomicIntegerFieldUpdater,AtomicLongFieldUpdater,AtomicReferenceFieldUpdater。顾名思义，它们会以CAS操作分别对int,long及普通对象进行线程安全化处理。 下面我们不妨以AtomicIntegerFieldUpdater为例，来看看具体的使用方法。 我们不妨模拟一个小场景：选举人参与竞选。只要投票人投了某选举人一票，该选举人即获得一分。投票结束后将统计各选举人获得的总分数。显然，这是一个身处并发环境下的问题，不过因为某些原因，得分字段并非是线程安全的，因此便需要使用AtomicIntegerFieldUpdater进行线程安全化处理。 代码如下： 123456789101112131415161718192021222324252627282930313233import java.util.concurrent.atomic.AtomicInteger;import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;public class Test &#123; public static void main(String[] args) throws InterruptedException &#123; final AtomicIntegerFieldUpdater&lt;Candidate&gt; aifu = AtomicIntegerFieldUpdater.newUpdater(Candidate.class, &quot;score&quot;); // 检验AtomicIntegerFieldUpdater是否正确 final AtomicInteger check = new AtomicInteger(0); final Candidate candidate = new Candidate(); Thread[] threadArray = new Thread[10000]; for (int i = 0; i &lt; threadArray.length; i++) &#123; threadArray[i] = new Thread() &#123; @Override public void run() &#123; if (Math.random() &gt; 0.4) &#123; // 约有60%的选民会投该候选人 aifu.incrementAndGet(candidate); check.incrementAndGet(); &#125; &#125; &#125;; threadArray[i].start(); threadArray[i].join(); &#125; System.out.println(&quot;AtomicIntegerFieldUpdater=&quot; + candidate.score); System.out.println(&quot;AtomicInteger=&quot; + check.get()); &#125;&#125;class Candidate &#123; // 得分并非是线程安全的 volatile int score;&#125; 输出： 12AtomicIntegerFieldUpdater=6104AtomicInteger=6104 经过多次重复实验，结果均一致，符合预期。 虽然上文中已证明了AtomicIntegerFieldUpdater可以按照预期完成任务，不过它(其他的Updater也一样)依然存在着一些限制： 第一，本质上来说，Updater是使用反射来获得变量的，因此它只能修改它可见的变量。如果变量不可见，则会出错。例如，如果我们将上文代码中的score的访问权限设置为private，即： 12345678910111213141516171819202122232425262728293031323334353637import java.util.concurrent.atomic.AtomicInteger;import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;public class Test &#123; public static void main(String[] args) throws InterruptedException &#123; final AtomicIntegerFieldUpdater&lt;Candidate&gt; aifu = AtomicIntegerFieldUpdater.newUpdater(Candidate.class, &quot;score&quot;); // 检验AtomicIntegerFieldUpdater是否正确 final AtomicInteger check = new AtomicInteger(0); final Candidate candidate = new Candidate(); Thread[] threadArray = new Thread[10000]; for (int i = 0; i &lt; threadArray.length; i++) &#123; threadArray[i] = new Thread() &#123; @Override public void run() &#123; if (Math.random() &gt; 0.4) &#123; // 约有60%的选民会投该候选人 aifu.incrementAndGet(candidate); check.incrementAndGet(); &#125; &#125; &#125;; threadArray[i].start(); threadArray[i].join(); &#125; System.out.println(&quot;AtomicIntegerFieldUpdater=&quot; + candidate.getScore()); System.out.println(&quot;AtomicInteger=&quot; + check.get()); &#125;&#125;class Candidate &#123; // 得分并非是线程安全的 private volatile int score; public int getScore() &#123; return score; &#125;&#125; 可以通过编译，不过输出时会报异常： 123456789Exception in thread &quot;main&quot; java.lang.RuntimeException: java.lang.IllegalAccessException: Class com.test.Test can not access a member of class com.test.Candidate with modifiers &quot;private volatile&quot; at java.util.concurrent.atomic.AtomicIntegerFieldUpdater$AtomicIntegerFieldUpdaterImpl.&lt;init&gt;(AtomicIntegerFieldUpdater.java:284) at java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater(AtomicIntegerFieldUpdater.java:76) at com.test.Test.main(Test.java:9)Caused by: java.lang.IllegalAccessException: Class com.test.Test can not access a member of class com.test.Candidate with modifiers &quot;private volatile&quot; at sun.reflect.Reflection.ensureMemberAccess(Reflection.java:110) at sun.reflect.misc.ReflectUtil.ensureMemberAccess(ReflectUtil.java:103) at java.util.concurrent.atomic.AtomicIntegerFieldUpdater$AtomicIntegerFieldUpdaterImpl.&lt;init&gt;(AtomicIntegerFieldUpdater.java:280) ... 2 more 显然这是因为反射时访问权限不足导致的。 第二，为了确保变量的修改效果及时得到体现，字段必须是volatile类型的。现在，我们将原正确代码中score的volatile修饰去掉，即变为： 123456789101112131415161718192021222324252627282930313233import java.util.concurrent.atomic.AtomicInteger;import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;public class Test &#123; public static void main(String[] args) throws InterruptedException &#123; final AtomicIntegerFieldUpdater&lt;Candidate&gt; aifu = AtomicIntegerFieldUpdater.newUpdater(Candidate.class, &quot;score&quot;); // 检验AtomicIntegerFieldUpdater是否正确 final AtomicInteger check = new AtomicInteger(0); final Candidate candidate = new Candidate(); Thread[] threadArray = new Thread[10000]; for (int i = 0; i &lt; threadArray.length; i++) &#123; threadArray[i] = new Thread() &#123; @Override public void run() &#123; if (Math.random() &gt; 0.4) &#123; // 约有60%的选民会投该候选人 aifu.incrementAndGet(candidate); check.incrementAndGet(); &#125; &#125; &#125;; threadArray[i].start(); threadArray[i].join(); &#125; System.out.println(&quot;AtomicIntegerFieldUpdater=&quot; + candidate.score); System.out.println(&quot;AtomicInteger=&quot; + check.get()); &#125;&#125;class Candidate &#123; // 得分并非是线程安全的 int score;&#125; 编译通过，输出： 1234Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: Must be volatile type at java.util.concurrent.atomic.AtomicIntegerFieldUpdater$AtomicIntegerFieldUpdaterImpl.&lt;init&gt;(AtomicIntegerFieldUpdater.java:292) at java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater(AtomicIntegerFieldUpdater.java:76) at com.test.Test.main(Test.java:9) 错误很明显，就是由volatile导致的。 从严格意义上讲，这个规定其实是破坏了开闭原则的。因为我们已经无法完全做到在不修改原程序代码的基础上进行字段的线程安全化了。不过好在volatile通常不会对程序逻辑造成什么影响，因此通常这是可以接收的。 第三，同其他的Atomic一族的类一样，Updater底层是以Unsafe类来实现CAS操作的。具体来说，它调用得是Unsafe的objectFieldOffset()，而该方法并不支持类变量。因此，Updater自然也不会支持类变量的修改了。和前文的代码一样，我们将score设置为static的： 123456789101112131415161718192021222324252627282930313233import java.util.concurrent.atomic.AtomicInteger;import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;public class Test &#123; public static void main(String[] args) throws InterruptedException &#123; final AtomicIntegerFieldUpdater&lt;Candidate&gt; aifu = AtomicIntegerFieldUpdater.newUpdater(Candidate.class, &quot;score&quot;); // 检验AtomicIntegerFieldUpdater是否正确 final AtomicInteger check = new AtomicInteger(0); final Candidate candidate = new Candidate(); Thread[] threadArray = new Thread[10000]; for (int i = 0; i &lt; threadArray.length; i++) &#123; threadArray[i] = new Thread() &#123; @Override public void run() &#123; if (Math.random() &gt; 0.4) &#123; // 约有60%的选民会投该候选人 aifu.incrementAndGet(candidate); check.incrementAndGet(); &#125; &#125; &#125;; threadArray[i].start(); threadArray[i].join(); &#125; System.out.println(&quot;AtomicIntegerFieldUpdater=&quot; + candidate.score); System.out.println(&quot;AtomicInteger=&quot; + check.get()); &#125;&#125;class Candidate &#123; // 得分并非是线程安全的 volatile static int score;&#125; 编译通过，输出： 12345Exception in thread &quot;main&quot; java.lang.IllegalArgumentException at sun.misc.Unsafe.objectFieldOffset(Native Method) at java.util.concurrent.atomic.AtomicIntegerFieldUpdater$AtomicIntegerFieldUpdaterImpl.&lt;init&gt;(AtomicIntegerFieldUpdater.java:297) at java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater(AtomicIntegerFieldUpdater.java:76) at com.test.Test.main(Test.java:9) objectFieldOffset()方法报了异常。]]></content>
      <categories>
        <category>Java 并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>无锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 并发-ThreadLocal]]></title>
    <url>%2F2018%2F05%2F02%2FJava%20%E5%B9%B6%E5%8F%91-ThreadLocal%2F</url>
    <content type="text"><![CDATA[模拟一种场景：100个人需要填写个人信息表。有如下两种实施策略： 只准备一支笔，这样做的好处是节省开销，坏处是同时只能有一个人在填表，效率低下，同时还必须花费时间和精力决策这支笔何时给何人使用。 准备100支笔，即做到”人手一支笔”。这样做的好处就是每个人都可以并行的自己填自己的了，效率很高，同时也免去了对笔的调度问题。坏处就是100支笔较之一支笔开销剧增。 JVM中的锁及同步使用的就是第一种思路：即典型的用时间换空间(空间可理解为开销)。而本文欲介绍的ThreadLocal使用的就是第二种思路了：即用空间换时间。ThreadLocal就是”人手一支笔”的管理者。 稍微扩展一下，在并发环境中，通过用空间换时间的做法，将线程不安全的临界区变为线程安全的例子其实还有很多。例如，JVM-堆中对象的创建及布局中所介绍的JVM为实例分配内存时用到的本地线程分配缓冲(Thread Local Allocation Buffer, TLAB)运用的就是这种思想。再比如，Java 并发-读写锁ReadWriteLock的实现思路也是类似的。 ThreadLocal的简单使用ThreadLocal在java.lang包中，其类定义为： 1public class ThreadLocal&lt;T&gt; 我们先来看一段代码： 123456789101112131415161718192021222324252627282930313233343536import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class Test &#123; private static final DateFormat DF = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); private static class Parsedate implements Runnable &#123; private int i; private Parsedate(int i) &#123; this.i = i; &#125; @Override public void run() &#123; try &#123; Date date = Test.DF.parse(&quot;1990-06-05 14:21:&quot; + (this.i % 60)); System.out.println(this.i + &quot;:&quot; + date); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; ExecutorService es = Executors.newFixedThreadPool(10); for (int i = 0; i &lt; 1000; i++) es.execute(new Parsedate(i)); es.shutdown(); &#125;&#125; 执行后输出为： 123456789101112131415161718192021222324252627 at com.test.Test$Parsedate.run(Test.java:25) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615) at java.lang.Thread.run(Thread.java:745)650:Tue Jun 05 14:21:50 CDT 1990651:Tue Jun 05 14:21:51 CDT 1990652:Tue Jun 05 14:21:52 CDT 1990653:Mon Jun 05 14:21:53 CST 9690655:Tue Jun 05 14:21:55 CDT 1990656:Tue Jun 05 14:21:56 CDT 1990Exception in thread &quot;pool-1-thread-231&quot; java.lang.NumberFormatException: empty String at sun.misc.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:1020) at java.lang.Double.parseDouble(Double.java:540) at java.text.DigitList.getDouble(DigitList.java:168) at java.text.DecimalFormat.parse(DecimalFormat.java:1321) at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1793) at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1455) at java.text.DateFormat.parse(DateFormat.java:355) at com.test.Test$Parsedate.run(Test.java:25) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615) at java.lang.Thread.run(Thread.java:745)657:Tue Jun 05 14:21:57 CDT 1990659:Thu May 31 14:21:59 CDT 1990660:Tue Jun 05 14:21:00 CDT 1990663:Tue Jun 05 14:21:03 CDT 1990664:Tue Jun 05 14:21:04 CDT 1990 输出很长，在这里我们只截取其中一部分，因为这就足以说明问题了：很显然，程序获得了部分输出，却也抛出了异常，说明程序是有问题的。其问题就在于SimpleDateFormat的parse()方法不是线程安全的，将其置于并发环境中自然会产生问题。 为了解决这个问题，首先，我们可以使用思路一：即最常见的，使用锁或同步限制线程对临界区的访问： 123456789101112131415161718192021222324252627282930313233343536373839404142import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class Test &#123; private static final DateFormat DF = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); private static Lock LOCK = new ReentrantLock(); private static class Parsedate implements Runnable &#123; private int i; private Parsedate(int i) &#123; this.i = i; &#125; @Override public void run() &#123; try &#123; Test.LOCK.lock(); Date date = Test.DF.parse(&quot;1990-06-05 14:21:&quot; + (this.i % 60)); Test.LOCK.unlock(); System.out.println(this.i + &quot;:&quot; + date); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; ExecutorService es = Executors.newFixedThreadPool(10); for (int i = 0; i &lt; 1000; i++) es.execute(new Parsedate(i)); es.shutdown(); &#125;&#125; 输出依然很长，不过不会有异常发生了。在此我们只截取最开始的那部分： 1234567896:Tue Jun 05 14:21:06 CDT 19905:Tue Jun 05 14:21:05 CDT 19907:Tue Jun 05 14:21:07 CDT 19904:Tue Jun 05 14:21:04 CDT 19903:Tue Jun 05 14:21:03 CDT 19901:Tue Jun 05 14:21:01 CDT 19900:Tue Jun 05 14:21:00 CDT 19902:Tue Jun 05 14:21:02 CDT 19909:Tue Jun 05 14:21:09 CDT 1990 下面我们采取思路二，即使用ThreadLocal： 1234567891011121314151617181920212223242526272829303132333435363738import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class Test &#123; private static ThreadLocal&lt;DateFormat&gt; TL = new ThreadLocal&lt;DateFormat&gt;(); private static class Parsedate implements Runnable &#123; private int i; private Parsedate(int i) &#123; this.i = i; &#125; @Override public void run() &#123; try &#123; if (null == Test.TL.get()) Test.TL.set(new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;)); Date date = Test.TL.get().parse(&quot;1990-06-05 14:21:&quot; + (this.i % 60)); System.out.println(this.i + &quot;:&quot; + date); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; ExecutorService es = Executors.newFixedThreadPool(10); for (int i = 0; i &lt; 1000; i++) es.execute(new Parsedate(i)); es.shutdown(); &#125;&#125; 输出同前文使用锁的代码时一样，就不再赘述了。 ThreadLocal的实现原理虽然使用ThreadLocal成功实现了功能。但是上节中ThreadLocal的Demo代码与我最初的设想却不大一样。我的想法是ThreadLocal既然是为每个线程分配的私有空间。那么应该以线程的成员变量的形式出现。然而它却是一个从属于类的静态变量，是唯一的。看来为每个线程划分空间的操作是在其内部实现的了。而其重点，自然就是set()及get()方法了。 咱们先来看set()方法的源码： 12345678public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) // 懒加载，使用前确认是否真的存在 map.set(this, value); else createMap(t, value);&#125; 哈哈！代码并不长，而且正如我们所推测的，set()内部进行了线程私有空间的划分。显然，ThreadLocalMap类型的变量map正是这个空间。 那么我们具体来看看它到底是个啥吧。首先是getMap(t)的源码： 123ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125; 然后是createMap(t, value)的源码： 123void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue);&#125; 代码都很短，而且我们惊奇的发现，实际所使用的空间居然是线程本身的局部变量threadLocals： 1ThreadLocal.ThreadLocalMap threadLocals = null; ThreadLocalMap居然又是ThreadLocal的一个静态内部类： 1static class ThreadLocalMap 因为ThreadLocal与Thread同在java.lang包中，所以这些类和变量都可自由的访问。 乍看一下，这关系可真够乱的。不过仔细梳理一下，其实还是很有条理的：既然是线程的私有空间，那么理应是存在于线程内部，这就是threadLocals。它的类型是ThreadLocalMap，其可以被理解为一个Map(虽然其实并没有实现Map接口，但是可以这样理解)。既然是Map，那么最核心的自然是key-value。它的key是ThreadLocal，而value则是实际需存储的变量。 依然是有点乱… 不过没关系，我们不妨举一个更具体的小例子：假设有3个ThreadLocal，我们不妨将其命名为t1,t2,t3。然后当前系统中并发工作的线程同样有3个。实际存储线程私有变量的容器是线程的threadLocals。如果需保存的私有变量就是字符串的话，那么某时刻系统的状态可能是这样的： -线程1的threadLocals：{t1:”1-1”,t2:”2-1”,t3:”3-1”}-线程2的threadLocals：{t1:”1-2”,t2:”2-2”,t3:”3-2”}-线程3的threadLocals：{t1:”1-3”,t2:”2-3”,t3:”3-3”} 那么我们为什么会产生之前的误解呢？ 我们回到文首，有这样一段话： JVM中的锁及同步使用的就是第一种思路：即典型的用时间换空间(空间可理解为开销)。而本文欲介绍的ThreadLocal使用的就是第二种思路了：即用空间换时间。ThreadLocal就是”人手一支笔”的管理者 其中说ThreadLocal是”人手一支笔”的管理者，但是我(我想应该不仅仅是我，很多人都会这样想)却理所当然的将ThreadLocal看作是那支笔本身。但实际上ThreadLocal却是笔的记录者，并不是笔本身，笔还是在线程手中。 如果还是有些迷糊，我们不妨将上文中t1,t2,t3的小例子说得更具体一些。即继续扩展文章开头的那个填信息表的小例子： -t1:笔的管理者-t2:修改工具的管理者-t3:纸张的管理者 线程1，2，3则分别对应于答卷人1，2，3。 那么在答卷过程中，某一时刻的资源分配状况可能是这样的： -答卷人1：{拥有的笔:钢笔,拥有的修改工具:胶带,拥有的纸张:A4纸}-答卷人2：{拥有的笔:铅笔,拥有的修改工具:修改液,拥有的纸张:B5纸}-答卷人3：{拥有的笔:圆珠笔,拥有的修改工具:橡皮,拥有的纸张:A3纸} 而t1作为笔的管理者，其可以通过某种渠道查询到所有答卷人对笔的拥有情况。 所以简单来说，ThreadLocal可以被理解为某一类型资源的指针，该类型资源的实体还是存在于线程本身的内部。 然后，我们再来继续看get()方法的源码： 12345678910public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) return (T)e.value; &#125; return setInitialValue();&#125; 有了上文的分析，方法本身其实没什么好说的了。我们可以来看下setInitialValue()，它会在没有查到值时设置并返回一个默认值： 12345678910private T setInitialValue() &#123; T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value;&#125; 基本的代码逻辑与前文介绍的set()方法相似，只是设置的值为默认值，用到了initialValue()方法： 123protected T initialValue() &#123; return null;&#125; 直接返回一个null，简单粗暴。之所以封装为一个方法，推测是为了方便继承时重写，提高代码的灵活度。 通过上文的分析，我们知道了作为线程私有空间的threadLocals是Thread类的一个成员变量，那么我们很容易得出的一个结论就是：只要线程不退出(即Thread对象不被销毁)，threadLocals就不会被回收–因为Thread对象对它的引用将一直存在的。 我们先来说说线程退出时会发生什么。当线程欲退出时，系统会调用Thread对象的exit()方法： 12345678910111213private void exit() &#123; if (group != null) &#123; group.threadTerminated(this); group = null; &#125; target = null; // 加速资源清理 threadLocals = null; inheritableThreadLocals = null; inheritedAccessControlContext = null; blocker = null; uncaughtExceptionHandler = null;&#125; 很常见的套路，基本是将该Thread关联的所有引用都断掉了，其中就包括threadLocals。 而正如上文所分析的，若Thread对象不销毁，其所关联的threadLocals就不会被回收，那么这会导致什么问题呢？ 通常来说，是不会有问题的。 但是Thread却并不是一个通常的类。说它不通常，倒不在这个类本身的代码编写上。而是在人的认识上：通常我们认为的线程被销毁，其实是任务被销毁了，而非线程本身。 举个例子，当我们在使用线程池时，线程池管理的是容器Thread，我们提交的Runnable则是其灵魂。任务完成，灵魂死去，但这并不意味着容器也一定被销毁了(可能被销毁，也可能没有，其结果是不受程序员控制的)。很有可能当下一个Runnable来的时候仍然是在复用上一个Thread。也就是说：我们认为Thead被销毁了，但是其实并没有。而只要Thread对象没有被真正的回收，它所关联的threadLocals就不会被回收，如果此时我们仍误以为上一个任务填入的ThreadLocal这个key已被销毁，就会导致threadLocals越来越大，有内存泄漏的风险。另外，如果读先发生于写的话，此时取出来的将不会是默认的空值，而是上一个任务留下的脏值(这里我们假定线程均共用一个ThreadLocal)。 因此，为了避免这种情况的发生，可以在任务完成时，手动显式的移除已没有用的变量。用到的方法为ThreadLocal中的remove()： 12345public void remove() &#123; ThreadLocalMap m = getMap(Thread.currentThread()); if (m != null) m.remove(this);&#125; 上述做法是建立在ThreadLocal对象还有用的前提下，如果我们确认该ThreadLocal对象已经没用了，或者我们愿意在下次使用前重新new出ThreadLocal对象的值，那其实可以采取更简单的策略：直接将该ThreadLocal对象置为null即可。 先不说”为什么”，咱们先来证明”是不是”： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class Test &#123; private static volatile ThreadLocal&lt;DateFormat&gt; TL = new ThreadLocal&lt;DateFormat&gt;() &#123; @Override protected void finalize() &#123; System.out.println(this.toString() + &quot; is gc&quot;); &#125; &#125;; private static final int CD_LENGTH = 10000; private static volatile CountDownLatch CD = new CountDownLatch(Test.CD_LENGTH); private static class Parsedate implements Runnable &#123; @SuppressWarnings(&quot;serial&quot;) @Override public void run() &#123; try &#123; if (null == Test.TL.get()) &#123; Test.TL.set(new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;) &#123; @Override protected void finalize() &#123; System.out.println(this.toString() + &quot; is gc&quot;); &#125; &#125;); System.out.println(Thread.currentThread().getId() + &quot; create SimpleDateFormat&quot;); &#125; &#125; finally &#123; Test.CD.countDown(); &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; ExecutorService es = Executors.newFixedThreadPool(10); for (int i = 0; i &lt; Test.CD_LENGTH; i++) es.execute(new Parsedate()); Test.CD.await(); System.out.println(&quot;first round complete&quot;); Test.TL = null; System.gc(); System.out.println(&quot;first gc complete&quot;); es.shutdown(); &#125;&#125; 输出如下： 123456789101112139 create SimpleDateFormat13 create SimpleDateFormat11 create SimpleDateFormat18 create SimpleDateFormat14 create SimpleDateFormat16 create SimpleDateFormat17 create SimpleDateFormat12 create SimpleDateFormat15 create SimpleDateFormat10 create SimpleDateFormatfirst round completefirst gc completecom.test.Test$1@261c2628 is gc com.test.Test$1@261c2628其实就是TL，不过因为是匿名内部类，因此看上去名字有些怪。 令我们感到遗憾的是，我们申请的那些SimpleDateFormat并没有被回收。不过不要急，我们对代码稍加修改，再跑一轮： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class Test &#123; private static volatile ThreadLocal&lt;DateFormat&gt; TL = new ThreadLocal&lt;DateFormat&gt;() &#123; @Override protected void finalize() &#123; System.out.println(this.toString() + &quot; is gc&quot;); &#125; &#125;; private static final int CD_LENGTH = 10000; private static volatile CountDownLatch CD = new CountDownLatch(Test.CD_LENGTH); private static class Parsedate implements Runnable &#123; @SuppressWarnings(&quot;serial&quot;) @Override public void run() &#123; try &#123; if (null == Test.TL.get()) &#123; Test.TL.set(new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;) &#123; @Override protected void finalize() &#123; System.out.println(this.toString() + &quot; is gc&quot;); &#125; &#125;); System.out.println(Thread.currentThread().getId() + &quot; create SimpleDateFormat&quot;); &#125; &#125; finally &#123; Test.CD.countDown(); &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; ExecutorService es = Executors.newFixedThreadPool(10); for (int i = 0; i &lt; Test.CD_LENGTH; i++) es.execute(new Parsedate()); Test.CD.await(); System.out.println(&quot;first round complete&quot;); Test.TL = null; System.gc(); System.out.println(&quot;first gc complete&quot;); Test.TL = new ThreadLocal&lt;DateFormat&gt;(); Test.CD = new CountDownLatch(Test.CD_LENGTH); for (int i = 0; i &lt; Test.CD_LENGTH; i++) es.execute(new Parsedate()); Test.CD.await(); System.out.println(&quot;second round complete&quot;); System.gc(); System.out.println(&quot;second gc complete&quot;); es.shutdown(); &#125;&#125; 输出如下： 123456789101112131415161718192021222324252627282930313233343518 create SimpleDateFormat12 create SimpleDateFormat10 create SimpleDateFormat13 create SimpleDateFormat11 create SimpleDateFormat14 create SimpleDateFormat16 create SimpleDateFormat15 create SimpleDateFormat17 create SimpleDateFormat9 create SimpleDateFormatfirst round completefirst gc completecom.test.Test$1@5d3f57b3 is gc15 create SimpleDateFormat9 create SimpleDateFormat17 create SimpleDateFormat18 create SimpleDateFormat10 create SimpleDateFormat11 create SimpleDateFormat16 create SimpleDateFormat13 create SimpleDateFormat12 create SimpleDateFormat14 create SimpleDateFormatsecond round completesecond gc completecom.test.Test$Parsedate$1@4f76f1a0 is gccom.test.Test$Parsedate$1@4f76f1a0 is gccom.test.Test$Parsedate$1@4f76f1a0 is gccom.test.Test$Parsedate$1@4f76f1a0 is gccom.test.Test$Parsedate$1@4f76f1a0 is gccom.test.Test$Parsedate$1@4f76f1a0 is gccom.test.Test$Parsedate$1@4f76f1a0 is gccom.test.Test$Parsedate$1@4f76f1a0 is gccom.test.Test$Parsedate$1@4f76f1a0 is gccom.test.Test$Parsedate$1@4f76f1a0 is gc 很显然，这一次成了。那一串(正好10个)com.test.Test$Parsedate$1就是我们欲回收的第一轮的SimpleDateFormat。 虽然效果达到了，不过我们仍然有两个未解的问题： 为什么第一轮不行，需要再跑一轮才能回收上一轮的资源呢？ 为什么居然能被回收？ 我们先来解释下为什么第二个问题中要用”居然”这个词，也就是依常理来说下，为什么它们不该被回收。 我们在前文中说ThreadLocalMap类似于一个Map，那么我们不妨就以HashMap为例，来看看为什么不会被回收： 1234567891011121314import java.util.HashMap;import java.util.Map;public class Test &#123; public static void main(String[] args) &#123; Map&lt;Object, String&gt; map = new HashMap&lt;Object, String&gt;(); Object o1 = new Object(); Object o2 = o1; map.put(o1, &quot;v&quot;); o1 = null; System.out.println(map.get(o2)); &#125;&#125; 这是一个很适合作为面试笔试题的小程序，它的输出是： 1v o1指向一个Object实例，而后以o1为key将其放入map中，然后再将o1置为null。此时发生变化的仅仅只是o1指向的位置。对其原来指向的Object实例并没有影响。map中依然存在一个该Object实例的key，仅仅只是o1不指向它了而已。本程序中，为了能将该Object实例更容易的输出出来，还定义了另一个指向它的引用o2。事实上即便没有o2这个引用，map与Object实例依然是强引用关系。 因此，如果我们将ThreadLocalMap看作一个普通的Map的话，自然就会产生疑问：因为即便我们将作为key的ThreadLocal置为null，也仅仅是引用的变更，对ThreadLocal实例本身是没影响的，那么在ThreadLocalMap中作为该ThreadLocal实例value的SimpleDateFormat实例自然就不该被回收。 其原因就在于，正如前文所说的，ThreadLocalMap虽然可以被看作一个Map，但它却并非一个Map。硬要说的话，它更类似于WeakHashMap。ThreadLocalMap在其内部又定义了一个静态内部类Entry用以存储它所管理的数据： 12345678static class Entry extends WeakReference&lt;ThreadLocal&gt; &#123; Object value; Entry(ThreadLocal k, Object v) &#123; super(k); value = v; &#125;&#125; 因此，如果说普通的引用关系是强引用的话，ThreadLocalMap所采用的就是弱引用。 我们曾在JVM-垃圾收集中详细讨论过垃圾收集器对各种引用的处理策略。我们不妨将其再次摘录一遍： 从JDK1.2起，Java将引用的概念扩充为4种，强度从强至弱依次为： 强引用(Strong Reference)：即为JDK1.1中的传统意义上的引用。程序中绝大多数的引用(诸如Object o = new Object())均是强引用。垃圾收集器绝不会收集通过强引用可达GC ROOT的对象。 软引用(Soft Reference)：使用SoftReference类实现。该引用即为前文”例如”所描述的那种引用：当某次垃圾收集后内存依然不够用，会进行第二次垃圾收集，此次收集将无视软引用。 弱引用(Weak Reference)：使用WeakReference类实现。也就是所谓的”消耗性引用”：经过一次垃圾收集后，该引用即失效。 虚引用(Phantom Reference)：使用PhantomReference类实现。又名幽灵引用或幻影引用。该引用并不是一个真正的引用，也无法在可达性计算中发挥任何作用，其存在价值仅仅为对象被回收后能发出一个系统通知。 太棒了！ 很显然，它完美的解决了我们的第二个疑问。不仅如此，它还解决了我们的第一个疑问：因为弱引用是消耗性引用，因此它至少还能坚持过一次gc。 引入ThreadLocal的意义在均能实现功能的前提下，锁/同步 与ThreadLocal的选取还是要具体问题具体分析。通常来说，如果线程对临界区的争夺容易产生较大的性能损失，那么就更为推荐使用ThreadLocal了。一个典型的例子就是在并发环境下产生随机数。 话不多说，直接看代码吧： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import java.util.Random;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;public class Test &#123; /** * int, 每个线程产生的随机数个数 */ private static final int GEN_COUNT = 1000_0000; /** * long, 保证计算结果准确，两种计算方式所使用的Random的种子应相同 * 随便定义一个值即可 * 若不设定种子，种子将默认为Random的创建时间 */ private static final long SEED = 777L; /** * Random, 这是一个线程安全的Java类 */ private static final Random RANDOM = new Random(Test.SEED); private static ThreadLocal&lt;Random&gt; T_RANDOW = new ThreadLocal&lt;Random&gt;() &#123; @Override protected Random initialValue() &#123; // 统一赋初值，这样就不用每次都set了 return new Random(Test.SEED); &#125; &#125;; /** * 进行比对的任务类。 * 有两种工作模式： * mode == 0: 使用锁 * mode == 1: 使用ThreadLocal */ private static class RandomTask implements Callable&lt;Long&gt; &#123; private int mode; private RandomTask(int mode) &#123; this.mode = mode; &#125; @Override public Long call() throws Exception &#123; long begin = System.currentTimeMillis(); Random r = null; if (this.mode == 0) r = Test.RANDOM; else if (this.mode == 1) r = Test.T_RANDOW.get(); for (int i = 0; i &lt; Test.GEN_COUNT; i++) r.nextInt(); long end = System.currentTimeMillis(); long cost = end - begin; System.out.println(Thread.currentThread().getId() + &quot; cost &quot; + cost + &quot;ms&quot;); return cost; &#125; &#125; private static void run(ExecutorService es, Future&lt;Long&gt;[] f, int model) throws InterruptedException, ExecutionException &#123; for (int i = 0; i &lt; f.length; i++) f[i] = es.submit(new RandomTask(model)); long totalTime = 0L; for (int i = 0; i &lt; f.length; i++) totalTime += f[i].get(); String keyWord = null; if (model == 0) keyWord = &quot;lock&quot;; else if (model == 1) keyWord = &quot;ThreadLocal&quot;; System.out.println(&quot;use &quot; + keyWord + &quot; cost &quot; + totalTime + &quot;ms&quot;); &#125; @SuppressWarnings(&quot;unchecked&quot;) public static void main(String[] args) throws InterruptedException, ExecutionException &#123; int threadCount = 10; // 线程个数 ExecutorService es = Executors.newFixedThreadPool(threadCount); Future&lt;Long&gt;[] f = new Future[threadCount]; Test.run(es, f, 0); Test.run(es, f, 1); es.shutdown(); &#125;&#125; 输出： 1234567891011121314151617181920212211 cost 4263ms17 cost 5531ms15 cost 6006ms16 cost 7025ms14 cost 7944ms10 cost 7993ms12 cost 8021ms18 cost 8073ms9 cost 8095ms13 cost 8092msuse lock cost 71043ms14 cost 298ms15 cost 331ms11 cost 340ms12 cost 294ms16 cost 367ms10 cost 362ms18 cost 329ms9 cost 340ms17 cost 434ms13 cost 330msuse ThreadLocal cost 3425ms 很显然，此时ThreadLocal的性能要远优于使用锁。]]></content>
      <categories>
        <category>Java 并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>ThreadLocal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 并发-JVM所做的锁优化]]></title>
    <url>%2F2018%2F04%2F27%2FJava%20%E5%B9%B6%E5%8F%91-JVM%E6%89%80%E5%81%9A%E7%9A%84%E9%94%81%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[本文将向大家简单介绍几种JVM内部的”锁”优化策略。 锁偏向锁偏向是一种针对加锁操作的优化手段。它的核心思想为： 如果一个线程获得了锁，那么锁就会进入偏向模式。当这个线程再次请求该锁时，无需再做任何同步操作。 这样便能节省大量有关锁申请的操作，从而提高系统的性能。 对于几乎没有锁竞争的场合，偏向锁的优化效果较好。因为连续多次极有可能是同一个线程请求相同的锁。而对于锁竞争较为激烈的场合，其效果则不佳：最坏的情况下锁不会接到任何连续的来自同一个线程的请求，此时偏向模式等同于失效，其性能还不如不开启偏向锁(准备了一大顿没用上)。 使用JVM参数-XX:+UseBiasedLocking可以开启偏向锁。 轻量级锁锁偏向失败后，JVM仍不会按通常套路为线程申请锁(我们将这种锁称为重量级锁)，而是会为线程申请轻量级锁。简单来说，锁偏向的目的是为了不要申请，而在锁偏向失败后，就不得不申请了，轻量级锁的目的是为了申请的成本低一些：它会在锁对象头部开辟出一片空间，作为指针指向持有该锁的线程，如果这一指向操作成功，则线程成功获得轻量级锁。如果该操作失败，说明此前该指针已指向别的线程了(即有其他线程优先获得了该轻量级锁)，此时对于该线程而言，锁将膨胀为重量级锁。 自旋锁一旦膨胀为重量级锁，说明此时已有其他线程占有了该锁。那么理论上，线程应进入锁的等待队列，并有可能被真实的在操作系统层面挂起：很多时候，这是不太合理的，比如虽然现在尚无法获得锁，但在很短的时间后(比如几个CPU时钟周期)就能获取锁了，那么此时简单粗暴的频繁挂起及恢复线程就不是一个合理的做法。不过话又说回来，谁又能明确知道多久能获得锁呢？万一时间非常久呢？此种情况下，挂起线程，让出它已占据的资源才是合理的做法。 对此，JVM采取了一个折中的方案。当锁膨胀为重量级锁后，线程并不会立即被挂起，而是会做几个空循环(这也是自旋锁名称的由来)，说穿了，这就是在为了避免被立即挂起而争取时间：线程会在自旋结束后再次对锁发起申请，如果仍未获得锁，那么才会真正的进入锁的等待队列，并有可能真实的在操作系统层面被挂起。 锁消除前文我们已讨论了3种优化策略： 锁偏向 轻量级锁 自旋锁 它们都有一个大的前提：那就是默认加锁操作确实是必要的。而锁消除是一种更彻底的优化，它在探讨更深的论题：代码里虽然写了要加锁，但这不过是程序员的主观判断，那么实际上到底是否真的需要加锁呢？对此，JVM在进行JIT编译时，会通过对运行上下文的扫描，去除不可能存在资源竞争的锁。 说到这里，我们不禁会去想，这算不算系统为程序员的不足买单呢？事实上并非完全如此。首先，程序员确实可能会错误的加锁，但是这是很难避免的，很多时候，当我们使用Java API或第三方提供的某些容器时，并不会特别较真的研究它的底层实现，到底哪里加了锁，性能又如何如何，往往功能满足需求即可。当然，知道的话更好，但对广大基层程序员提出那么高的门槛要求是不现实的。此外，我们使用线程安全的容器往往是因为它会身处于并发环境中，但这并不意味着对它所有的请求都是并发的。实际情况往往是并行与串行的请求共存，而只要有并行的请求存在，程序员就会选用线程安全的容器。那些没必要加锁的情景也需要系统的优化。 举一个小例子吧，我们来看如下代码： 123456public Integer[] test() &#123; int length = 10; Vector&lt;Integer&gt; v = new Vector&lt;Integer&gt;(length); for (int i = 0; i &lt; length; i++) v.add(i); return v.toArray(new Integer[length]);&#125; 上例中的Vector是一个线程安全的容器，然而它却只是一个单纯的局部变量，终其一生也没有逃逸出它所属的test()方法。换句话说，它的整个生命周期都是在虚拟机栈的栈帧中读过的，这是一个串行的环境，因此，此时的加锁就是没有必要的。当系统检测到后，就会将相应的锁消除。 因此，判断是否可进行锁消除的最重要的依据就是变量是否逃逸出了串行环境。该技术被称为逃逸分析：即判断某一个变量是否会逃出某一个作用域。在上例中，变量v显然没有逃出test()函数之外，因此JVM才敢于将v内部的加锁操作消除。如果test()函数返回的是v本身，也就是说v逃逸出了当前函数，它就有可能身处于并发的环境中了，进而被其他线程访问到。此时仅以这一个函数所掌握的情报就无法对v进行锁消除了。 使用-XX:+EliminateLocks可开启锁消除。如前所述，若欲开启锁消除，还需开启它所依赖的逃逸分析。逃逸分析只能在-server模式下运行，使用-XX:+DoEscapeAnalysis开启。]]></content>
      <categories>
        <category>Java 并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 并发-提高锁的性能的几个思路]]></title>
    <url>%2F2018%2F04%2F27%2FJava%20%E5%B9%B6%E5%8F%91-%E6%8F%90%E9%AB%98%E9%94%81%E7%9A%84%E6%80%A7%E8%83%BD%E7%9A%84%E5%87%A0%E4%B8%AA%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[“锁”是最常用的同步策略之一。在高并发的环境下，激烈的锁竞争会导致程序的性能下降。所以锁的性能的优化是一个很值得探讨的话题，例如：避免死锁，减小锁粒度，锁分离等。 在多核机器中，较之单线程串行执行，使用多线程可以显著提高系统的性能，却也会增加额外的系统开销。对于单任务或者单线程的应用而言，其资源消耗基本都花费在任务本身上：它既不需要维护并行数据结构间的一致性状态，也不需要为线程的切换及调度花费时间。但对多线程的应用而言，除了需要满足任务本身的需求，还需要额外维护多线程环境的特有信息，例如：线程本身的元数据，线程的调度，线程上下文的切换等。正因为如此，在单核CPU上，采用并行算法的效率通常要低于对应的串行算法。 而对同步策略(也就是本文要探讨的锁)的优化，最重要的目标也就是优化这一部分因引入多线程而增加的”额外操作”，例如进行更合理的任务调度，更充分的压榨每个CPU的性能等等。本文将从比较高的维度介绍几个常用的优化思路。 注意：本文提到的”锁”是广义上的，即同时包含了Lock及synchronized。 减少锁的持有时间无论如何优化加锁操作本身，只要进行加锁就会产生”额外”的系统消耗，那么尽可能的缩小需要加锁的区域，减少每个线程的持锁时间，就是最自然，也是最容易想到的优化思路。 具体来说，我们可以看如下代码： 12345public synchronized void syncMethod() &#123; m1(); // 无需同步控制 syncM(); // 需同步控制 m2(); // 无需同步控制&#125; 很显然，线程在执行m1()及m2()时是无需加锁的。很自然的，我们就可以想到如下优化策略： 1234567public void syncMethod() &#123; m1(); // 无需同步控制 synchronized(this) &#123; syncM(); // 需同步控制 &#125; m2(); // 无需同步控制&#125; JDK的源码中有很多地方都应用了这种优化策略，例如处理正则表达式的java.util.regex.Pattern中就有如下方法： 12345678910public Matcher matcher(CharSequence input) &#123; if (!compiled) &#123; // 只有在表达式未编译时，才会进行局部的加锁 synchronized(this) &#123; if (!compiled) compile(); &#125; &#125; Matcher m = new Matcher(this, input); return m;&#125; 关于这个方法，有一个很有趣的点:if (!compiled)被连续判断了两次。做第一次判断时并未进行并发控制，无额外的开销。而只要进入了同步代码块，就是线程安全的了。但是我们无法保证在第一次判断至进入同步代码块期间(当然，仅从代码来看，二者是紧邻着的)不会发生同步问题：例如恰好有另一个线程利用这段时间完成了一次完成的编译操作。因此，我们有必要在进入同步代码块后再进行一次判断。 那么为什么不在第一次判断外面就包一层同步代码块呢？这样不就只需要一次判断了吗？这就是本小节优化思路的应用了：若if (!compiled) == false，也就是已经编译完了，无需再编译了，那么此时是不需要进行同步控制的，而很显然，在字符串匹配的整个周期中，编译只需要1次，绝大多数时候，当我们调用matcher(CharSequence input)方法时，字符串都是编译好的，因此我们需要缩小需要加锁的范围：只有当确实没编译时才执行加锁操作。这是本思路下比较高级的优化了：加锁范围缩窄的不是具体的代码，而是不同的条件分支。 减小锁粒度在JDK中，本思路的典型应用是java.util.concurrent.ConcurrentHashMap，其类定义如下： 1public class ConcurrentHashMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; implements ConcurrentMap&lt;K, V&gt;, Serializable 作为一个Map，最重要也是最常用的两个方法自然就是get()与put()了。而ConcurrentHashMap作为一个线程安全的容器，这种修改操作自然是要进行并发控制的。而最容易想到的并发策略自然就是对整个容器加锁。但这样做，我们就认为加锁的粒度太大了：因此ConcurrentHashMap在内部进一步的又被分为若干个小的Map，称之为段(Segment)，默认情况下，一个ConcurrentHashMap会被分为16段(额外多说一句，这种分段加锁的思想的应用还有Java 并发-ConcurrentSkipListMap)。 如果要在ConcurrentHashMap中增加一个新的元素，并不需要对整个容器加锁，而是首先根据元素的hashcode值计算出该元素应该被存放在哪个段中，然后只对该段加锁，随后完成put()操作。这样，在并发环境中，如果有多个线程同时进行put()操作，只要被加入的元素不在同一个段中，就无需进行并发控制。由于默认有16个段，那么ConcurrentHashMap最多可供16个线程同时插入。 下面我们贴出put()方法的具体代码： 1234567891011public V put(K key, V value) &#123; Segment&lt;K,V&gt; s; if (value == null) throw new NullPointerException(); int hash = hash(key); int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask; if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) s = ensureSegment(j); return s.put(key, hash, value, false);&#125; 但是，减小锁粒度会引入一个新的问题：当系统需要取得容器的全局锁时，反而会变得麻烦。具体来说，如果要将整个容器都锁住，那么就需要将所有段的锁都拿在手里才行。比如说size()方法： 12345678910111213141516171819202122232425262728293031323334353637public int size() &#123; final Segment&lt;K,V&gt;[] segments = this.segments; int size; boolean overflow; long sum; long last = 0L; int retries = -1; try &#123; for (;;) &#123; if (retries++ == RETRIES_BEFORE_LOCK) &#123; // 为所有段加锁 for (int j = 0; j &lt; segments.length; ++j) ensureSegment(j).lock(); &#125; sum = 0L; size = 0; overflow = false; for (int j = 0; j &lt; segments.length; ++j) &#123; Segment&lt;K,V&gt; seg = segmentAt(segments, j); if (seg != null) &#123; sum += seg.modCount; int c = seg.count; if (c &lt; 0 || (size += c) &lt; 0) overflow = true; &#125; &#125; if (sum == last) break; last = sum; &#125; &#125; finally &#123; if (retries &gt; RETRIES_BEFORE_LOCK) &#123; // 为所有段解锁 for (int j = 0; j &lt; segments.length; ++j) segmentAt(segments, j).unlock(); &#125; &#125; return overflow ? Integer.MAX_VALUE : size;&#125; 通常我们看到的JDK源码中的容器的size()方法，往往只有几句代码，逻辑也很清晰。然而ConcurrentHashMap的size()显然就很复杂了。要获得所有段的锁后才能实际开始求值。单就size()方法而言，ConcurrentHashMap在并发环境下的性能甚至是还不如由java.util.Collections.synchronizedMap()方法得到的线程安全的Map的。 这给了我们一个启示：对于ConcurrentHashMap这种分段加锁的容器而言，其调用需要全局锁的方法时的性能往往不如全局加锁控制线程安全的容器。因此选择并发容器时还应该看场景才行。 使用读写分离锁在JDK中，本思路的典型应用是Java 并发-读写锁ReadWriteLock 事实上，读写分离锁这种优化思路可以看作是减小锁粒度这一优化思路的特例：上文中提到的ConcurrentHashMap是从数据的角度减小锁粒度，而使用读写分离锁则是从功能的角度上减小锁粒度。 锁分离锁分离是读写分离锁的扩展，因此也可看作是减小锁粒度的特例。读写分离锁划分功能的依据是”读与写”，那么我们同样可以依据其他功能来划分。比较典型的例子就是java.util.concurrent.LinkedBlockingQueue，其类定义如下： 1public class LinkedBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements BlockingQueue&lt;E&gt;, java.io.Serializable 它是Java 并发-BlockingQueue的具体实现，在这篇文章中，我们讨论了LinkedBlockingQueue的近亲ArrayBlockingQueue，现在我们再来看看LinkedBlockingQueue。 作为BlockingQueue，最重要也是最常用的两个方法自然是take()及put()，它们分别代表阻塞式的读及写。因为LinkedBlockingQueue底层是以链表实现的，那么take()为弹出队首，put()则为向队尾追加新值。若使用独占锁，那么这两个操作是无法同时进行的。但事实上，这两个操作可以并行进行，彼此间并不会产生冲突。 具体来说，LinkedBlockingQueue将独占锁一分为二，分别用于take()及put()。LinkedBlockingQueue中有如下实例成员： 1234567private final ReentrantLock takeLock = new ReentrantLock();private final Condition notEmpty = takeLock.newCondition();private final ReentrantLock putLock = new ReentrantLock();private final Condition notFull = putLock.newCondition(); 自然，相应的Condition会绑在对应的锁上：take()时需等待notEmpty，put()时则需等待notFull。 然后我们具体来看下take()的代码： 12345678910111213141516171819202122232425262728293031public E take() throws InterruptedException &#123; E x; int c = -1; final AtomicInteger count = this.count; final ReentrantLock takeLock = this.takeLock; takeLock.lockInterruptibly(); try &#123; while (count.get() == 0) &#123; notEmpty.await(); &#125; x = dequeue(); c = count.getAndDecrement(); if (c &gt; 1) notEmpty.signal(); &#125; finally &#123; takeLock.unlock(); &#125; if (c == capacity) signalNotFull(); return x;&#125;private void signalNotFull() &#123; final ReentrantLock putLock = this.putLock; putLock.lock(); try &#123; notFull.signal(); &#125; finally &#123; putLock.unlock(); &#125;&#125; 再来看下put()： 12345678910111213141516171819202122232425262728293031public void put(E e) throws InterruptedException &#123; if (e == null) throw new NullPointerException(); int c = -1; Node&lt;E&gt; node = new Node(e); final ReentrantLock putLock = this.putLock; final AtomicInteger count = this.count; putLock.lockInterruptibly(); try &#123; while (count.get() == capacity) &#123; notFull.await(); &#125; enqueue(node); c = count.getAndIncrement(); if (c + 1 &lt; capacity) notFull.signal(); &#125; finally &#123; putLock.unlock(); &#125; if (c == 0) signalNotEmpty();&#125;private void signalNotEmpty() &#123; final ReentrantLock takeLock = this.takeLock; takeLock.lock(); try &#123; notEmpty.signal(); &#125; finally &#123; takeLock.unlock(); &#125;&#125; 基本思路与ArrayBlockingQueue一致。不过由于LinkedBlockingQueue有两把不同的锁，两个Condition条件则是分别绑在对应的锁上，导致要发另一个锁的Condition条件时不大方便：需要再加锁解锁一次(也就是上例中的signalNotFull()及signalNotEmpty())。因此，在take()方法中，若在本次拿取后依然还有元素，则会发送一个notEmpty，供其他take()使用。同理，在put()方法中，若在本次添加后仍未到达最大容量，则会发送一个notFull，供其他put()使用。 锁粗化我们提出的第一个锁优化策略为”减少锁的持有时间”，其目的旨在尽可能的压缩每个线程占有锁的时间。然而有趣的是，我们本小节意欲介绍的优化策略正好站在它的反面：即适当延长线程对锁的占有时间。其缘由就在于加锁解锁是需要消耗系统资源的，如果加锁解锁的操作较为频繁，而实际的加锁后的业务时间又不是很长，这就导致系统用于加锁解锁调度切换的时间比重较之实际运行业务代码的时间增大，若该值大到一定程度，还不如不要释放锁，一直持有到阶段性任务完结得好。 其实，JVM会依据一定的算法，隐式的帮助我们完成部分的锁粗化操作：例如，在JVM遇到一连串的对同一个锁的加锁解锁操作时，便可能会将所有的锁操作整合为对锁的一次请求，例如如下代码： 123456789public void m() &#123; synchronized (this) &#123; // do sth1 &#125; // 不需要并发控制的代码，很快能完成 synchronized (this) &#123; // do sth2 &#125;&#125; 则其可能会被整合为： 1234567public void m() &#123; synchronized (this) &#123; // do sth1 // 不需要并发控制的代码，很快能完成 // do sth2 &#125;&#125; 写代码时，我们也应有意识的判断是否应进行锁的粗化。例如如下代码： 12345for (int i = 0; i &lt; 1000; i++) &#123; synchronized (this) &#123; i++; &#125;&#125; 这段代码会在每次for循环内部进行一次加锁解锁，而每次循环实际的业务仅仅是简单的i++，显然这是很不合理的，因此改为： 123synchronized (this) &#123; for (int i = 0; i &lt; 1000; i++) i++;&#125; 这样就会合理得多。]]></content>
      <categories>
        <category>Java 并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python-Centos6.x中Python2.6升级至2.7]]></title>
    <url>%2F2018%2F03%2F08%2FPython-Centos6.x%E4%B8%ADPython2.6%E5%8D%87%E7%BA%A7%E8%87%B32.7%2F</url>
    <content type="text"><![CDATA[本文安装方法面向系统： Centos6.x 确定版本1python --version 若版本为2.6(Centos6.x中默认自带的Python就是2.6的)则可依本文升级为2.7。 下载Python Python-2.7.12官方下载 Python-2.7.12个人存档 安装Python2.7以Python-2.7.12.tgz为例： 1234567tar -zxvf Python-2.7.12.tgzcd Python-2.7.12./configure make all make install make clean make distclean 执行： 1/usr/local/bin/python2.7 -V 若输出： 1Python 2.7.12 则说明安装完成，可删除安装包。 此时虽然已完成2.7的安装，但系统默认的Python依然是2.6的。因此需建立软连接，使系统默认的Python指向Python2.7： 12mv /usr/bin/python /usr/bin/python2.6.6 ln -s /usr/local/bin/python2.7 /usr/bin/python 然后再查看系统默认的Python版本： 1python -V 输出： 1Python 2.7.12 至此系统默认的Python已指向Python2.7。 修改yum配置文件因yum需在Python2.6的环境下运行，因此需将其所用的Python环境单独改回2.6： 12345vim /usr/bin/yum 将文件头部的#!/usr/bin/python改成#!/usr/bin/python2.6.6 安装pip12wget https://bootstrap.pypa.io/get-pip.py python get-pip.py]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Pip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx-Nginx安装及简单使用]]></title>
    <url>%2F2018%2F03%2F08%2FNginx-Nginx%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[安装本文安装方法面向系统： CentOS 6.x openresty官网下载地址 CentOS 6.x源码安装包个人存档 openresty官网中有详尽的安装教程，在此总结CentOS 6.x下源码安装的步骤。安装包不妨以openresty-1.13.6.1.tar.gz为例： 12345tar -xzvf openresty-1.13.6.1.tar.gzcd openresty-1.13.6.1/./configuremakemake install 其中./configure默认为： 1./configure --prefix=/usr/local/openresty 也可自行指定安装目录，例如： 1./configure --prefix=/reimu/soft/openresty 基本组件位置不妨设根目录为/reimu/soft/openresty，则： Nginx程序位置：/reimu/soft/openresty/nginx/sbin/nginx Nginx配置文件位置：/reimu/soft/openresty/nginx/conf/nginx.conf Nginx默认日志文件夹：/reimu/soft/openresty/nginx/logs 常见操作启动Nginx： 1/reimu/soft/openresty/nginx/sbin/nginx -c /reimu/soft/openresty/nginx/conf/nginx.conf 验证Nginx配置文件正否符合规范： 1/reimu/soft/openresty/nginx/sbin/nginx -t 若符合规范，则输出如下： 12nginx: the configuration file /reimu/soft/openresty/nginx/conf/nginx.conf syntax is oknginx: configuration file /reimu/soft/openresty/nginx/conf/nginx.conf test is successful 刷新配置文件配置，重启程序： 1/reimu/soft/openresty/nginx/sbin/nginx -s reload]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 并发-ConcurrentSkipListMap]]></title>
    <url>%2F2018%2F02%2F07%2FJava%20%E5%B9%B6%E5%8F%91-ConcurrentSkipListMap%2F</url>
    <content type="text"><![CDATA[跳表跳表(SkipList)是一种可用来进行快速查找的数据结构，时间复杂度为O(logn)，有点类似于平衡树。之所以这么说，是因为它们都可以对元素进行快速的查找。但二者有一个重要的区别：对平衡树的修改(也就是所谓的插入和删除)往往很可能会导致平衡树进行一次全局的调整(也就是所谓的调平)，而对跳表而言，插入和删除只需要对整个数据结构的局部进行调整即可。这样的好处是显而易见的： 需要调整的规模较小，且数据量越大所带来的性能提升自然也越大。 在并发环境下，当需要修改跳表时，我们不需要将整张表锁起来，而可以只锁住本次修改所影响的区域，提高性能。 跳表的另一个特点就是随机算法。跳表的本质是同时维护多个链表，且这些链表是分层的。如下图所示： 最底层的链表包含跳表的所有元素，每往上一层的链表都是下面链表的子集(又是典型的用空间换时间的策略)，一个元素被插入哪些层完全是随机的(当然，最下面那层是必然会被插入的)，因此如果运气不好的话，也许会得到一个性能很糟糕的结构。不过在实际使用中，尤其是数据量较大时，概率将会极大的掩盖运气，跳表的性能通常都是非常好的。 跳表内所有链表的元素都是具有偏序关系的(所以才说跳表和平衡树像嘛)。查找时，通常是从顶层链表开始找起，一旦发现元素值大于待搜索值，或者找到末尾也未找到，则说明本层已无找到的可能，便进入下一层，直到找到或是遍历完底层也没找到(此时说明确实没有)。 下图是一个查找值7的小例子： ConcurrentSkipListMapjava API中提供的跳表为java.util.concurrent.ConcurrentSkipListMap，类定义如下： 1public class ConcurrentSkipListMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements ConcurrentNavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable 这是一个Map，它与我们在Java API中最常见的使用哈希算法实现的Map有一个显著的不同：哈希并不会保存元素的顺序，而跳表因其特性其元素自然是有序的(所以说，并非所有Map都是无序的)。因此如果需要一个有序的Map，那么跳表可能是很好的选择。 我们可以先来看一个小例子： 123456789101112import java.util.Map;import java.util.concurrent.ConcurrentSkipListMap;public class Test &#123; public static void main(String[] args) &#123; Map&lt;Integer, Integer&gt; map = new ConcurrentSkipListMap&lt;&gt;(); for (int i = 0; i &lt; 5; i++) map.put(i, i); for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) System.out.println(entry.getKey()); &#125;&#125; 输出： 1234501234 既然跳表底层是以链表实现的，那么它最重要的数据结构自然就是节点了。对于ConcurrentSkipListMap而言，节点类是他的静态成员内部类。全部代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687static final class Node&lt;K,V&gt; &#123; // key与value组合构成了链表节点本身存储的元素值 final K key; // 即map的key volatile Object value; // 即map的value volatile Node&lt;K,V&gt; next; // 下一个节点 Node(K key, Object value, Node&lt;K,V&gt; next) &#123; this.key = key; this.value = value; this.next = next; &#125; Node(Node&lt;K,V&gt; next) &#123; this.key = null; this.value = this; this.next = next; &#125; /** * 设置value字段 * 使用CAS来进行并发控制 */ boolean casValue(Object cmp, Object val) &#123; return UNSAFE.compareAndSwapObject(this, valueOffset, cmp, val); &#125; /** * 设置next字段 * 使用CAS来进行并发控制 */ boolean casNext(Node&lt;K,V&gt; cmp, Node&lt;K,V&gt; val) &#123; return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val); &#125; boolean isMarker() &#123; return value == this; &#125; boolean isBaseHeader() &#123; return value == BASE_HEADER; &#125; boolean appendMarker(Node&lt;K,V&gt; f) &#123; return casNext(f, new Node&lt;K,V&gt;(f)); &#125; void helpDelete(Node&lt;K,V&gt; b, Node&lt;K,V&gt; f) &#123; if (f == next &amp;&amp; this == b.next) &#123; if (f == null || f.value != f) appendMarker(f); else b.casNext(this, f.next); &#125; &#125; V getValidValue() &#123; Object v = value; if (v == this || v == BASE_HEADER) return null; return (V)v; &#125; AbstractMap.SimpleImmutableEntry&lt;K,V&gt; createSnapshot() &#123; V v = getValidValue(); if (v == null) return null; return new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(key, v); &#125; private static final sun.misc.Unsafe UNSAFE; private static final long valueOffset; private static final long nextOffset; static &#123; try &#123; UNSAFE = sun.misc.Unsafe.getUnsafe(); Class k = Node.class; valueOffset = UNSAFE.objectFieldOffset (k.getDeclaredField(&quot;value&quot;)); nextOffset = UNSAFE.objectFieldOffset (k.getDeclaredField(&quot;next&quot;)); &#125; catch (Exception e) &#123; throw new Error(e); &#125; &#125;&#125; 简单看下来，最大的感触自然就是全程没有出现synchronized或Lock，看来又是一个只依赖CAS实现并发控制的线程安全的容器(之所以说又，是因为我想到了Java 并发-ConcurrentLinkedQueue) 除了Node外，ConcurrentSkipListMap中另一个重要的数据结构名为Index。它也是ConcurrentSkipListMap的静态成员内部类，类定义如下： 1static class Index&lt;K,V&gt; Index负责将各层链表拼接起来，它有如下关键的实例成员变量： 12345678// Index内部封装的节点final Node&lt;K,V&gt; node;// 向下的引用final Index&lt;K,V&gt; down;// 向右的引用volatile Index&lt;K,V&gt; right; 也就是说，从外部看，ConcurrentSkipListMap中存储的基本元素是Index，它负责进行网络的构建，其内部封装着存储实际业务逻辑的Node。 此外，每一层链表的表头Index中还要存储本行链表是第几层。ConcurrentSkipListMap将这种表头Index定义为它的静态成员内部类HeadIndex。既然是特殊的Index，那么HeadIndex自然是Index的子类。该类的代码很短，全部代码如下： 1234567static final class HeadIndex&lt;K,V&gt; extends Index&lt;K,V&gt; &#123; final int level; HeadIndex(Node&lt;K,V&gt; node, Index&lt;K,V&gt; down, Index&lt;K,V&gt; right, int level) &#123; super(node, down, right); this.level = level; &#125;&#125;]]></content>
      <categories>
        <category>Java 并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 并发-BlockingQueue]]></title>
    <url>%2F2018%2F02%2F07%2FJava%20%E5%B9%B6%E5%8F%91-BlockingQueue%2F</url>
    <content type="text"><![CDATA[在工作中，我们经常会遇到生产者-消费者模型的应用，例如：如果两个系统需要进行消息的沟通，我们往往会使用某个基于AMQP(Advanced Message Queuing Protocol)协议的消息队列，例如RabbitMQ,Qpid等。 而如果是在一个程序的内部，两个模块间需要线程安全的通信又该怎么做呢？ Java API为我们提供了java.util.concurrent.BlockingQueue接口，它的接口定义如下： 1public interface BlockingQueue&lt;E&gt; extends Queue&lt;E&gt; 它是一个线程安全的，高性能的阻塞队列。通常被用于模块间消息通讯的缓冲区。Java API为我们提供了很多实现，最常用的是如下两个： java.util.concurrent.ArrayBlockingQueue，类定义如下： 1public class ArrayBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements BlockingQueue&lt;E&gt;, java.io.Serializable java.util.concurrent.LinkedBlockingQueue，类定义如下： 1public class LinkedBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements BlockingQueue&lt;E&gt;, java.io.Serializable 顾名思义，ArrayBlockingQueue底层以数组实现，而LinkedBlockingQueue底层则以链表实现。二者的优缺点比较基本也就是数组与链表的优缺点比较。因此，ArrayBlockingQueue常用做有界队列，这样就避免了因扩展数组而造成的性能损失。而LinkedBlockingQueue常做无界队列，不会因初始值过大而在一开始便吃掉系统大量的内存。 而BlockingQueue之所以能作为阻塞队列，其关键还在于Blocking。而所有的阻塞队列都需要考虑一个基本的问题：当读线程消费完当前队列中所有的消息后，它如何得知下一条消息何时到来呢？当写线程因阻塞队列已满而无法写入新消息时，它如何知道何时才会有空间写入呢？ 最为简单粗暴的方式就是让读写线程在空闲时不断的轮询阻塞队列，这样做虽然理论上可行，但显然造成了很多不必要的性能损失，而且轮训的间隔周期也不好确定。 BlockingQueue则是在队列为空时让读线程等待，待有消息进入阻塞队列后再将其唤醒。反之写线程也是同理。那么它是如何实现的呢？ 我们不妨以ArrayBlockingQueue为例来说明这个问题。 顾名思义，ArrayBlockingQueue的底层数据结构自然是一个数组，它是ArrayBlockingQueue的一个实例成员变量： 1final Object[] items; 向队列插入数据常用offer()方法或put()方法。我们先来说较为简单的offer()方法： 123456789101112131415public boolean offer(E e) &#123; checkNotNull(e); final ReentrantLock lock = this.lock; lock.lock(); try &#123; if (count == items.length) return false; else &#123; insert(e); return true; &#125; &#125; finally &#123; lock.unlock(); &#125;&#125; 该方法定义在Queue接口中，而ArrayBlockingQueue的实现也是在保证线程安全的基础上完全遵循了Queue接口的规范：若插入成功返回true，若因容量已满插入失败则立刻返回false。并未起到阻塞的作用。它的代码逻辑也很简单清晰，就不赘述了。 那么，实现阻塞的大任自然是着落在另一个插入方法put()上了。该方法插入成功当然也是立刻返回true，因容量已满而导致插入失败时则会让写线程一直等待，直到阻塞队列倒出空间。 同理，弹出队首元素常用poll()方法或take()方法。poll()方法的代码为： 123456789public E poll() &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; return (count == 0) ? null : extract(); &#125; finally &#123; lock.unlock(); &#125;&#125; 同offer()方法，poll()方法依然是声明于Queue接口中，而ArrayBlockingQueue除了将其线程安全化之外依然没做额外的操作：若队列不为空则返回队首元素，反之则立刻返回null。 而take()方法就是那个阻塞的弹出方法了：若队列不为空则返回队首元素，反之则让读线程一直等待，直到队列非空。 为了实现put()及take()方法的功能，ArrayBlockingQueue在它的锁对象上绑定了两个Condition： 12345final ReentrantLock lock;private final Condition notEmpty;private final Condition notFull; 看到这里我想大家已经能隐隐猜到Doug Lea的套路了：当读线程调用take()方法时，如果队列为空，则让读线程等待notEmpty。同理，当写线程调用put()方法时，若队列已满，则让写线程等待notFull。 那么到底是不是这样呢？我们赶紧来看看take()方法的源码吧： 1234567891011public E take() throws InterruptedException &#123; final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try &#123; while (count == 0) notEmpty.await(); return extract(); &#125; finally &#123; lock.unlock(); &#125;&#125; 其中extract()方法是在确保了非空后的取消息操作： 123456789private E extract() &#123; final Object[] items = this.items; E x = this.&lt;E&gt;cast(items[takeIndex]); items[takeIndex] = null; takeIndex = inc(takeIndex); --count; notFull.signal(); return x;&#125; 除了正常的取值操作外，最只得我们关注的就是notFull.signal();这一句了：因为取了一个元素，便空出了一个位子，自然可以发一个非空的信号了。看了一个信号对应一个元素。 进一步的，我们也不难推测出，put()方法因为放入了一个元素，队列自然就非空了，那么应该会释放一个notEmpty.signal();才对。那么是不是这样呢，我们再来看put()方法的源码： 12345678910111213141516171819public void put(E e) throws InterruptedException &#123; checkNotNull(e); final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try &#123; while (count == items.length) notFull.await(); insert(e); &#125; finally &#123; lock.unlock(); &#125;&#125;private void insert(E x) &#123; items[putIndex] = x; putIndex = inc(putIndex); ++count; notEmpty.signal();&#125; 哦耶！推测完全正确。]]></content>
      <categories>
        <category>Java 并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 并发-CopyOnWriteArrayList]]></title>
    <url>%2F2018%2F02%2F07%2FJava%20%E5%B9%B6%E5%8F%91-CopyOnWriteArrayList%2F</url>
    <content type="text"><![CDATA[很多时候，我们对某些容器的操作确实是并发的，然而读却远多于写。这其实是一个比较尴尬的局面：因为确实存在并发的写操作，因此必须设置线程安全策略，然后由于读远多于写，该策略登场的机会不高，毕竟纯粹是读的话即便是并发环境也是不需要容器是线程安全的。 因此，操作系统中提出了读写锁的概念，算是针对这种情况对普通的锁进行了特化。简单来说： 情况1：若已有读者，则新的读者不会被阻塞。 情况2：若已有读者，则新的写者会被阻塞。 情况3：若已有写者，则新的读者会被阻塞。 情况4：若已有写者，则新的写者会被阻塞。 实际上，只有情况1得到了优化。不过由于应用场景本就是读远多于写，因此对性能的提升还是巨大的。 Java API中的java.util.concurrent.CopyOnWriteArrayList也提供了类似于读写锁的功能。不过它更进一步，不仅是情况1，情况2,3也不会被阻塞了。也就是阻塞范围被缩小为只有写者-写者。 那么它是如何做到的呢？玄机其实就藏在它的类名中：CopyOnWrite。也就是在写操作前，会进行一次自我复制，这是典型的用空间换时间的做法。 具体来说，当CopyOnWriteArrayList需要被修改时，我们并不会修改原内容(这就保证了读线程的数据一致性)，而是生成一份源数据的副本，将修改都作用到这份副本上，而后再在合适的时机用修改后的副本替换源数据。 CopyOnWriteArrayList的类定义如下： 1public class CopyOnWriteArrayList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable 和预想的稍有不同，看名字还以为它是ArrayList的子类，结果二者并没有直接的联系。不过既然CopyOnWriteArrayList的名称中包含ArrayList，那么它底层用于存储数据的结构就应该是一个数组。事实上也确然如此。CopyOnWriteArrayList中有如下成员变量： 1private volatile transient Object[] array; 所谓的读写，实际上就是在折腾这个数组。读操作举例如下： 123public E get(int index) &#123; return get(getArray(), index);&#125; 这是最常见的以索引index取元素的方法，它调用了两个方法： 1234567final Object[] getArray() &#123; return array;&#125;private E get(Object[] a, int index) &#123; return (E) a[index];&#125; 这些方法的逻辑都非常简单，也没有任何的线程安全策略。 相对来说，写操作就要复杂一些了： 12345678910111213141516public boolean add(E e) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); int len = elements.length; // 生成一份副本，为容纳新元素，副本容积+1 Object[] newElements = Arrays.copyOf(elements, len + 1); newElements[len] = e; // 用副本替换源数据 setArray(newElements); return true; &#125; finally &#123; lock.unlock(); &#125;&#125; 使用了重入锁ReentrantLock做并发控制，总体来说，逻辑还是很清晰的(相对于Java 并发-ConcurrentLinkedQueue这种使用无锁CAS的容器而言)。 本以为其中的setArray()方法里面会有什么牛逼的套路，点开之后却发现非常简单： 123final void setArray(Object[] a) &#123; array = a;&#125; 稍微有点不理解大神是怎么想的，这么简单的代码为啥不直接写，还要在外面包一个方法？ 最后还需要特别声明的一点就是array是被volatile修饰的，这样才能保证写操作对a的替换修改能立刻为读操作所见。]]></content>
      <categories>
        <category>Java 并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 基础-使用dom4j解析xml]]></title>
    <url>%2F2018%2F02%2F06%2FJava%20%E5%9F%BA%E7%A1%80-%E4%BD%BF%E7%94%A8dom4j%E8%A7%A3%E6%9E%90xml%2F</url>
    <content type="text"><![CDATA[首先在pom文件中添加dom4j的Maven地址： 12345&lt;dependency&gt; &lt;groupId&gt;dom4j&lt;/groupId&gt; &lt;artifactId&gt;dom4j&lt;/artifactId&gt; &lt;version&gt;1.6.1&lt;/version&gt;&lt;/dependency&gt; 随后创建配置文件conf.xml，内容如下： 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;幻想乡 设定者=&quot;ZUN&quot; 整数值=&quot;3&quot; 浮点数值=&quot;2.2&quot;&gt; &lt;长者&gt;八云紫&lt;/长者&gt; &lt;少女&gt;博丽灵梦&lt;/少女&gt; &lt;少女&gt;雾雨魔理沙&lt;/少女&gt; &lt;少女&gt;十六夜咲夜&lt;/少女&gt;&lt;/幻想乡&gt; 标签值自然是不推荐用中文的(和代码中不推荐将类名及变量名等定义为中文是一个道理)，本文这么写只是为了强调标签值其实也可以是中文的。 然后基本的前置准备代码为： 123SAXReader sReader = new SAXReader();Document document = sReader.read(new File(&quot;conf.xml&quot;));Element root = document.getRootElement(); 其中document代表配置文件本身，而root则是根节点的元素值。根节点必须是唯一的，也就是说： 1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;test1&gt;&lt;/test1&gt;&lt;test2&gt;&lt;/test2&gt; 这样的xml文件是非法的。 从宏观上看，Element是xml文件基本的，也是唯一的数据结构。所谓xml文件就是由一个个Element以一定的架构关联在一起的集合。每个Element都由以下4部分构成： 标签名 属性列表 文本值 子元素列表 标签名是Element最基本的属性，用来表示元素是什么： 1System.out.println(root.getName()); 输出： 1幻想乡 属性列表属性(Attribute)列表出现在标签中，可有多个，用来表示元素有哪些属性，其格式为key-value对。 若示例代码为： 1234List&lt;Attribute&gt; list = root.attributes();for (Attribute attribute : list) &#123; System.out.println(attribute.getName() + &quot; : &quot; + attribute.getValue());&#125; 输出： 123设定者 : ZUN整数值 : 3浮点数值 : 2.2 这样便可以列出某元素中的所有属性。需要注意的是xml文件中所有的属性值都必须用双引号引起来，且attribute.getValue()的返回值为String。 如果我们想依元素属性的key值获得特定的属性： 1Attribute a = root.attribute(&quot;设定者&quot;); 这样便拿到了root节点中的属性”设定者”。 文本值元素的值可以为一个简单的文本，也可以是一系列的子元素。二者只能取其一。 文本值获取举例： 12Element e = root.element(&quot;长者&quot;);System.out.println(e.getText()); 这样便取到了”幻想乡.长者”中存储的文本值。纯从存储的角度来讲，除了根节点外，这种元素其实都是没有意义的，因为它们完全可以化为其父元素的一个属性。不过从业务逻辑的角度考虑：属性是元素的特征，而子元素是元素的孩子，二者的含义还是有很大的区别的。 子元素列表可依如下方式迭代某元素下所有的子元素： 12345Iterator&lt;Element&gt; iterator = root.elementIterator();while (iterator.hasNext()) &#123; Element e = iterator.next(); System.out.println(e.getName());&#125; 输出： 1234长者少女少女少女 至于按照子元素标签值取某元素下的特定子元素，上一小节中已在取”幻想乡.长者”的例子中展示过。 这里需要注意的是，若取的标签值为”少女”，得到的子元素不止一个的时候该怎么办呢？事实上，此时如果依然采用上一小节中的root.element(“长者”)的方法返回是空：这其实很好理解，程序并不知道该在复数个结果中选择哪个返回给我们。 解决办法也很简单： 12345Iterator&lt;Element&gt; iterator = root.elementIterator(&quot;少女&quot;);while (iterator.hasNext()) &#123; Element e = iterator.next(); System.out.println(e.getName());&#125; 指定标签值即可，输出： 123少女少女少女]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>dom4j</tag>
        <tag>xml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-读取properties]]></title>
    <url>%2F2018%2F02%2F06%2FSpring-%E8%AF%BB%E5%8F%96properties%2F</url>
    <content type="text"><![CDATA[本文介绍的方法为通过注解直接将properties文件中的值注入到某个已被bean管理的实例的实例成员变量中。该实例通常为单例。因为如果不是单例而其某实例变量又被注入了相同的值的话，那么该字段就不该声明为实例变量，而应是类变量。 首先创建配置文件config.properties，内容如下： 123cTest1=1cTest2=reimucTest3=2.4 properties中可填入任意类型的值(原则上不支持中文字符，如果实在要用请用UTF-8编码，不过不推荐这么做，因为没人能直接看得懂UTF-8编码后的汉字，不利于后期配置文件的维护)。 properties是按照 1key=value 的方式存储的，其中key不能包含.，例如： 1view.frame.size=50 试图存储这样的key是不可以的。 随后在Spring的配置文件applicationContext.xml的beans中添加如下bean： 1234567&lt;bean id=&quot;config&quot; class=&quot;org.springframework.beans.factory.config.PropertiesFactoryBean&quot;&gt; &lt;property name=&quot;locations&quot;&gt; &lt;array&gt; &lt;value&gt;classpath:config.properties&lt;/value&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt; 其中array标签中填入配置文件config.properties的路径。既然标签名为数组，那么自然可在其中填入多个properties，本文为了方便举例，只填入一个。 最后，在需注入的实例类中按如下方式声明字段(注意该类必须加载入beans的管理体系中)： 12345678910111213141516171819202122232425import org.springframework.beans.factory.annotation.Value;public class Test &#123; private int test1; private String test2; private double test3; @Value(&quot;#&#123;config.cTest1&#125;&quot;) public void setTest1(int test1) &#123; this.test1 = test1; &#125; @Value(&quot;#&#123;config.cTest2&#125;&quot;) public void setTest2(String test2) &#123; this.test2 = test2; &#125; @Value(&quot;#&#123;config.cTest3&#125;&quot;) public void setTest3(double test3) &#123; this.test3 = test3; &#125;&#125; 如上代码所示，当然实例变量名是可以与properties对应的key值不同的。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>properties</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 并发-ConcurrentLinkedQueue]]></title>
    <url>%2F2018%2F02%2F05%2FJava%20%E5%B9%B6%E5%8F%91-ConcurrentLinkedQueue%2F</url>
    <content type="text"><![CDATA[java.util.concurrent.ConcurrentLinkedQueue可以看作线程安全的高效并发的java.util.LinkedList，它应该是高并发环境下Java API提供的性能最高的队列了。它的类定义为： 1public class ConcurrentLinkedQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements Queue&lt;E&gt;, java.io.Serializable 节点顾名思义，ConcurrentLinkedQueue底层是以链表实现的。而作为一个链表，最核心的数据结构自然是构成链表的节点了。ConcurrentLinkedQueue的节点是其自身的静态成员内部类，该节点类的全部代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455private static class Node&lt;E&gt; &#123; // item,next支撑起了Node作为链表的节点的基础 volatile E item; // 节点中存储的数据值 volatile Node&lt;E&gt; next; // 下一个节点 Node(E item) &#123; NSAFE.putObject(this, itemOffset, item); &#125; /** * 设置节点中存储的数据值 * 利用CAS保证线程安全性： * 设置时当前值与期望值相同则设置为目标值 * @param cmp E, 期望值 * @param val E, 目标值 * @return boolean, true--设置成功，false--设置失败 */ boolean casItem(E cmp, E val) &#123; return UNSAFE.compareAndSwapObject(this, itemOffset, cmp, val); &#125; void lazySetNext(Node&lt;E&gt; val) &#123; UNSAFE.putOrderedObject(this, nextOffset, val); &#125; /** * 设置本节点的下一个节点 * 利用CAS保证线程安全性： * 设置时当前值与期望值相同则设置为目标值 * @param cmp Node&lt;E&gt;, 期望值 * @param val Node&lt;E&gt;, 目标值 * @return boolean, true--设置成功,false--设置失败 */ boolean casNext(Node&lt;E&gt; cmp, Node&lt;E&gt; val) &#123; return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val); &#125; private static final sun.misc.Unsafe UNSAFE; private static final long itemOffset; private static final long nextOffset; static &#123; try &#123; UNSAFE = sun.misc.Unsafe.getUnsafe(); Class k = Node.class; itemOffset = UNSAFE.objectFieldOffset (k.getDeclaredField(&quot;item&quot;)); nextOffset = UNSAFE.objectFieldOffset (k.getDeclaredField(&quot;next&quot;)); &#125; catch (Exception e) &#123; throw new Error(e); &#125; &#125;&#125; head与tailConcurrentLinkedQueue类中记录了两个特殊的节点： 123private transient volatile Node&lt;E&gt; head;private transient volatile Node&lt;E&gt; tail; head指向队首节点，tail指向队尾节点。它们都不为null，但其中的item可能为null。 在ConcurrentLinkedQueue内部，可通过ConcurrentLinkedQueue.succ()完成队列自特定节点起的遍历： 1234final Node&lt;E&gt; succ(Node&lt;E&gt; p) &#123; Node&lt;E&gt; next = p.next; return (p == next) ? head : next;&#125; 关于这个方法，需要注意的有两点： 该方法并没有任何的并发安全控制，但由于它的访问权限为默认，因此在调用它的地方，如果必要的话，应该都会加上相应的线程安全措施。 p == next代表next指向其本身的节点，它们被称为”哨兵节点”。这种节点是指那些原则上已不存在，却因为各种原因(例如并发安全问题)暂时还未来得及删掉的节点：例如要删除的节点，或者空节点。此时因已无法通过哨兵节点拿到next，故只能返回head从头再来。 按照定义，我们理所当然的会认为head指向队列的第一个节点，tail指向队列的最后的一个节点。但实际上，如果我们将链表中一次取next操作视为时间复杂度计算中的基本步骤的话，它们的准确定义为： head:以该节点为起点，遍历至实际有效的第一个节点的时间复杂度为O(1)。 tail:以该节点为起点，遍历至实际有效的最后一个节点的时间复杂度为O(1)。 Oh,No!这是何等操蛋又让人迷茫的定义啊。我们不妨以从零开始逐个插入节点为例来加深一下蛋疼感： 当插入元素为列表的第奇数个节点时，tail不会实际移动，此时tail指向得是倒数第二个节点；当插入元素为列表的第偶数个节点时，tail会连续移动过两个节点，指向队列的最后一个节点。 弹出节点的套路也是类似：若被弹出的节点是奇数个节点时，head不会实际移动，此时head指向得是第一个节点的前一个节点，也就是一个已实际上被移除的节点；若被弹出的节点是偶数个节点时，head会连续移动两次，指向队列的第一个节点。 ……额…… 为什么这么搞暂时不知，姑且记下，有空详查。 offer()方法作为一个队列，最重要的自然就是offer()及poll()方法了。先来看offer的源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243public boolean offer(E e) &#123; checkNotNull(e); final Node&lt;E&gt; newNode = new Node&lt;E&gt;(e); // 该方法的核心目标就是找到真正的最后一个节点，而后将e插入到它的后面 for (Node&lt;E&gt; t = tail, p = t;;) &#123; // 由于tail未必是真正的最后一个节点，因此第一次循环开始前设置的p=tail也未必是最后一个节点 // 然而tail必然可以在O(1)时间内找到真正的最后一个节点，因此for循环的定义体中并未设置出口：找到前一直循环下去，总会出去的 Node&lt;E&gt; q = p.next; if (q == null) &#123; // q==null说明p当真是最后一个节点了 if (p.casNext(null, newNode)) &#123; // 成功将p.next设置为e。此时插入动作已完成 // 下面的这个if是专门用来处理tail奇数个节点时不动偶数个节点时连动两次的逻辑的 if (p != t) // p!=t说明上一个节点是奇数个节点，那么本节点就是偶数个节点了，要连动两次 // 并未针对casTail()的返回值做处理。也就是说不管tail更新成功与否都无妨 // 不得不说这里的设计思路屌爆了，给大神点赞： // 设置成功：没什么说的，成了。 // 设置失败：失败说明在设置时又有新节点插入了，那么本节点自然也就不可能是tail了，自然失败就失败了 casTail(t, newNode); // 唯一出口，也就是说本方法是不可能返回false的=-= return true; &#125; // p.next设置为e失败了，再重来一次。 // 因该分支中并未修改p的值，因此再次重来p还是进入本if之前的那个p &#125; else if (p == q) // p是哨兵节点 // 首先不管怎么样，经过下面的语句后t都会被修正为t=tail // t是在for循环开始前设置等于tail的，串行环境下应始终有t=tail才是 // 如果执行下面语句前t都不等于tail了，说明这个for循环的根基已被动摇，只能从head开始遍历 // 如果将本方法的思路视为乐观锁，那么从head开始遍历实在是最糟糕的情况了 // 如果执行下面语句前依然有t=tail，说明本for循环等根基还在，可以从t(也就是此时最新的tail)再次来过 p = (t != (t = tail)) ? t : head; else // q并非最后一个节点，还要再向后遍历 // 简单来看，直接设置p=q即可，这样便可实现向后遍历 // 不过大神提到了一种特殊情况：p不是t了(也就是p已经移动过了)且t不是tail了(前面已经提到，串行环境下是不可能的。显然是出现了并发问题，动摇了本for循环的根基) // 此时要从t开始遍历，依然是乐观锁思想下的悲观情况 p = (p != t &amp;&amp; t != (t = tail)) ? t : q; &#125;&#125; 代码其实并不长，但却不大好理解(我写的注释比代码还多)。不过简单看一下就可以发现：该方法并没有使用synchronized或是Lock，它只调用了两个方法casNext(),casTail()，而这两个方法也只用到了CAS。 唔，=-=。。。 这说明了什么！这说明了什么！！这说明了什么！！！ 这说明ConcurrentLinkedQueue是一个无锁的队列，它只用底层的CAS就保证了线程安全性！ 难怪doc都说ConcurrentLinkedQueue是高并发环境下Java API提供的性能最高的队列，给Doug Lea爸爸跪了。 需要强调一下的是：t!=t并不是原子操作，也就说是先取一次t存起来，然后再取第二次t，而后比较这两次取得的t的结果。因此在并发环境中，t!=t返回true是完全有可能。我们不妨以一个小例子来证明一下： 1234567public class Test &#123; public static void main(String[] args) &#123; Object o1 = new Object(); System.out.println(o1 != o1); &#125;&#125; 我们用javap反编译一下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384Classfile /D:/Test.class Last modified 2018-2-6; size 487 bytes MD5 checksum 76721705c54f8bd636869e0cfab7f65e Compiled from &quot;Test.java&quot;public class Test SourceFile: &quot;Test.java&quot; minor version: 0 major version: 51 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #2.#18 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = Class #19 // java/lang/Object #3 = Fieldref #20.#21 // java/lang/System.out:Ljava/io/PrintStream; #4 = Methodref #22.#23 // java/io/PrintStream.println:(Z)V #5 = Class #24 // Test #6 = Utf8 &lt;init&gt; #7 = Utf8 ()V #8 = Utf8 Code #9 = Utf8 LineNumberTable #10 = Utf8 main #11 = Utf8 ([Ljava/lang/String;)V #12 = Utf8 StackMapTable #13 = Class #25 // &quot;[Ljava/lang/String;&quot; #14 = Class #19 // java/lang/Object #15 = Class #26 // java/io/PrintStream #16 = Utf8 SourceFile #17 = Utf8 Test.java #18 = NameAndType #6:#7 // &quot;&lt;init&gt;&quot;:()V #19 = Utf8 java/lang/Object #20 = Class #27 // java/lang/System #21 = NameAndType #28:#29 // out:Ljava/io/PrintStream; #22 = Class #26 // java/io/PrintStream #23 = NameAndType #30:#31 // println:(Z)V #24 = Utf8 Test #25 = Utf8 [Ljava/lang/String; #26 = Utf8 java/io/PrintStream #27 = Utf8 java/lang/System #28 = Utf8 out #29 = Utf8 Ljava/io/PrintStream; #30 = Utf8 println #31 = Utf8 (Z)V&#123; public Test(); flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 1: 0 public static void main(java.lang.String[]); flags: ACC_PUBLIC, ACC_STATIC Code: stack=3, locals=2, args_size=1 0: new #2 // class java/lang/Object 3: dup 4: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 7: astore_1 8: getstatic #3 // Field java/lang/System.out:Ljava/io/PrintStream; 11: aload_1 12: aload_1 13: if_acmpeq 20 16: iconst_1 17: goto 21 20: iconst_0 21: invokevirtual #4 // Method java/io/PrintStream.println:(Z)V 24: return LineNumberTable: line 4: 0 line 5: 8 line 6: 24 StackMapTable: number_of_entries = 2 frame_type = 255 /* full_frame */ offset_delta = 20 locals = [ class &quot;[Ljava/lang/String;&quot;, class java/lang/Object ] stack = [ class java/io/PrintStream ] frame_type = 255 /* full_frame */ offset_delta = 0 locals = [ class &quot;[Ljava/lang/String;&quot;, class java/lang/Object ] stack = [ class java/io/PrintStream, int ]&#125; 我们来看main方法，o1于指令7被存入局部变量表索引为1的位置。然后11,12连取了两次，随后13行才开始计较。很显然，在并发环境中，11,12两行的取值操作并非线程安全的。 poll()方法代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243public E poll() &#123; // 这里用了因为不太好驾驭以及可能导致代码混乱而不被推荐的goto // ... // 大神这么屌当然是可以驾驭的，所以没毛病 restartFromHead: for (;;) &#123; for (Node&lt;E&gt; h = head, p = h, q;;) &#123; // 由于head未必是真正的第一个节点，因此第一次循环开始前设置的p=head也未必是第一个节点 // 然而head必然可以在O(1)时间内找到真正的第一个节点，因此for循环的定义体中并未设置出口：找到前一直循环下去，总会出去的 E item = p.item; if (item != null &amp;&amp; p.casItem(item, null)) &#123; // 进入此if有两个条件： // 1.item!=null，说明找到了，p就是第一个节点 // 2.设置p.item为null完成。 // 此时第一个元素已从队列中移除。核心操作已完成 // 下面的这个if是专门用来处理head奇数个节点时不动偶数个节点时连动两次的逻辑的 if (p != h) // 该方法返回值为空，内部稍显复杂，并不像offer()方法时的casTail()那么简单，就不深入分析了 updateHead(h, ((q = p.next) != null) ? q : p); // 返回被移除元素的值 return item; &#125; else if ((q = p.next) == null) &#123; // 准备进入本if的判定说明上一个if没过，也就是说p此时是指在第一个节点前面的某个废弃节点上的 // 再说本if的判定内容，p的下一个节点为null说明就没第一个节点了(因为p此时必是指在废弃节点上的) updateHead(h, p); return null; &#125; else if (p == q) // 进入本if的判定说明上一个if没过，此时q=p.next // 若有p=q则说明p是哨兵，触发了乐观锁思路下的悲观情况，goto到最重头再来 continue restartFromHead; else // 前面的if都过了，说明 // 1.p是指在第一个节点前的某个废弃节点上的 // 2.p的下一个节点不为空(也就是说起码当前是看不出来队列是否为空的) // 3.p不是哨兵 // 那么很自然的，就继续向后遍历了 p = q; &#125; &#125; &#125; 总结虽然本文只是简单的介绍了ConcurrentLinkedQueue的offer()及poll()方法，但我们已经能体会到只用CAS实现无锁的线程安全容器的困难程度了：大神写好的代码读着都费劲，更别说自己去设计了。因此虽然无锁的性能确实很高，但在一般的程序开发中的应用却极少。]]></content>
      <categories>
        <category>Java 并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java AWT-动画]]></title>
    <url>%2F2018%2F02%2F03%2FJava%20AWT-%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[我们先创建基本的窗体： 12345678910111213141516171819202122232425262728293031import java.awt.Frame;import java.awt.Graphics;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;public class GameFrame extends Frame &#123; private static final long serialVersionUID = 1L; public void launchFrame() &#123; super.setLocation(700, 300); super.setSize(400, 300); super.addWindowListener( new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125; &#125; ); super.setVisible(true); &#125; @Override public void paint(Graphics g) &#123; &#125; public static void main(String[] args) &#123; new GameFrame().launchFrame(); &#125;&#125; 所谓动画，就是快速的绘制不同的静态画面，让人看起来”画动了”。AWT中绘制组件的流程为： 1repaint() —&gt; update() —&gt; paint() 要实现动画，最简单的方式就是写一个线程，然后高频率的repaint()即可。 则上述程序可改造为： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.awt.Font;import java.awt.Frame;import java.awt.Graphics;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;public class GameFrame extends Frame &#123; private static final long serialVersionUID = 1L; public void launchFrame() &#123; super.setLocation(700, 300); super.setSize(400, 300); new Thread(this.new RepaintRunnable()).start(); super.addWindowListener( new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125; &#125; ); super.setVisible(true); &#125; @Override public void paint(Graphics g) &#123; g.setFont(new Font(null, Font.BOLD, 30)); g.drawString(&quot;&quot; + (System.currentTimeMillis() / 100), 100, 100); &#125; private class RepaintRunnable implements Runnable &#123; @Override public void run() &#123; while (true) &#123; try &#123; GameFrame.this.repaint(); Thread.sleep(40); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; new GameFrame().launchFrame(); &#125;&#125; 每隔40ms刷新一次，为体现刷新效果，我们绘制了秒数随时间的变化。运行后，可以观测到秒数确实在按要求变动，但闪烁情况极其严重。 这是为什么呢？前文我们已经提到，AWT中绘制组件的流程为： 1repaint() —&gt; update() —&gt; paint() 我们可以看一下update()的代码： 12345678public void update(Graphics g) &#123; if (isShowing()) &#123; if (! (peer instanceof LightweightPeer)) &#123; g.clearRect(0, 0, width, height); &#125; paint(g); &#125;&#125; 很明显，所谓的更新，其实是首先进行了清屏，也就是g.clearRect()，随后再重新画一遍。不断的清了画清了画，自然会导致闪烁。 既然找到了原因，那么解决思路就很明确了，自然是要重写update()方法才行： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.awt.Font;import java.awt.Frame;import java.awt.Graphics;import java.awt.Image;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;public class GameFrame extends Frame &#123; private static final long serialVersionUID = 1L; public void launchFrame() &#123; super.setLocation(700, 300); super.setSize(400, 300); new Thread(this.new RepaintRunnable()).start(); super.addWindowListener( new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125; &#125; ); super.setVisible(true); &#125; @Override public void paint(Graphics g) &#123; g.setFont(new Font(null, Font.BOLD, 30)); g.drawString(&quot;&quot; + (System.currentTimeMillis() / 100), 100, 100); &#125; private class RepaintRunnable implements Runnable &#123; @Override public void run() &#123; while (true) &#123; try &#123; GameFrame.this.repaint(); Thread.sleep(40); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; @Override public void update(Graphics g) &#123; Image bImage = super.createImage(this.getWidth(), this.getHeight()); Graphics bg = bImage.getGraphics(); this.paint(bg); bg.dispose(); g.drawImage(bImage, 0, 0, this); &#125; public static void main(String[] args) &#123; new GameFrame().launchFrame(); &#125;&#125; 此时闪烁情况得到了极大的缓解，已无法被人眼所见。 下面我们再来看一个小例子，实现一个匀速直线运动，遇到边框会反弹的小球： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788import java.awt.Frame;import java.awt.Graphics;import java.awt.Image;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;public class GameFrame extends Frame &#123; private static final long serialVersionUID = 1L; private int x = 100; private int y = 100; private boolean ifXPositive = true; private boolean ifYPositive = true; public void launchFrame() &#123; super.setLocation(700, 300); super.setSize(400, 300); new Thread(this.new RepaintRunnable()).start(); super.addWindowListener( new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125; &#125; ); super.setVisible(true); &#125; @Override public void paint(Graphics g) &#123; final int titleWidth = 40; // 标题栏宽度 final int padding = 10; // 左右下留白宽度 final int diameter = 20; // 小球直径 final int xLength = 3; // 距上次刷新x轴移动距离的绝对值 final int yLength = 3; // 距上次刷新y轴移动距离的绝对值 g.fillOval(this.x, this.y, diameter, diameter); this.x = this.ifXPositive ? this.x + xLength : this.x - xLength; this.y = this.ifYPositive ? this.y + yLength : this.y - yLength; if (this.x &lt;= padding) &#123; this.x = padding; this.ifXPositive = !this.ifXPositive; &#125; if (this.x &gt;= this.getWidth() - padding - diameter) &#123; this.x = this.getWidth() - padding - diameter; this.ifXPositive = !this.ifXPositive; &#125; if (this.y &lt;= titleWidth) &#123; this.y = titleWidth; this.ifYPositive = !this.ifYPositive; &#125; if (this.y &gt;= this.getHeight() - padding - diameter) &#123; this.y = this.getHeight() - padding - diameter; this.ifYPositive = !this.ifYPositive; &#125; &#125; private class RepaintRunnable implements Runnable &#123; @Override public void run() &#123; while (true) &#123; try &#123; GameFrame.this.repaint(); Thread.sleep(40); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; @Override public void update(Graphics g) &#123; Image bImage = super.createImage(this.getWidth(), this.getHeight()); Graphics bg = bImage.getGraphics(); this.paint(bg); bg.dispose(); g.drawImage(bImage, 0, 0, this); &#125; public static void main(String[] args) &#123; new GameFrame().launchFrame(); &#125;&#125; 上例中小球将永久运动下去，我们也可以在小球的运动过程中让其逐渐损失速度，最终停止： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899import java.awt.Frame;import java.awt.Graphics;import java.awt.Image;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;public class GameFrame extends Frame &#123; private static final long serialVersionUID = 1L; private int x = 100; private int y = 100; private boolean ifXPositive = true; private boolean ifYPositive = true; /** * int, 距上次刷新x轴移动距离的绝对值 */ private int xLength = 300; /** * int, 距上次刷新y轴移动距离的绝对值 */ private int yLength = 300; public void launchFrame() &#123; super.setLocation(700, 300); super.setSize(400, 300); new Thread(this.new RepaintRunnable()).start(); super.addWindowListener( new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125; &#125; ); super.setVisible(true); &#125; @Override public void paint(Graphics g) &#123; final int titleWidth = 40; // 标题栏宽度 final int padding = 10; // 左右下留白宽度 final int diameter = 20; // 小球直径 final double decay = 0.99999; // 两次时间间隔间的速度衰减 g.fillOval(this.x, this.y, diameter, diameter); this.xLength = (int)(this.xLength * decay); this.yLength = (int)(this.yLength * decay); this.x = this.ifXPositive ? this.x + this.xLength : this.x - this.xLength; this.y = this.ifYPositive ? this.y + this.yLength : this.y - this.yLength; if (this.x &lt;= padding) &#123; this.x = padding; this.ifXPositive = !this.ifXPositive; &#125; if (this.x &gt;= this.getWidth() - padding - diameter) &#123; this.x = this.getWidth() - padding - diameter; this.ifXPositive = !this.ifXPositive; &#125; if (this.y &lt;= titleWidth) &#123; this.y = titleWidth; this.ifYPositive = !this.ifYPositive; &#125; if (this.y &gt;= this.getHeight() - padding - diameter) &#123; this.y = this.getHeight() - padding - diameter; this.ifYPositive = !this.ifYPositive; &#125; &#125; private class RepaintRunnable implements Runnable &#123; @Override public void run() &#123; while (true) &#123; try &#123; GameFrame.this.repaint(); Thread.sleep(40); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; @Override public void update(Graphics g) &#123; Image bImage = super.createImage(this.getWidth(), this.getHeight()); Graphics bg = bImage.getGraphics(); this.paint(bg); bg.dispose(); g.drawImage(bImage, 0, 0, this); &#125; public static void main(String[] args) &#123; new GameFrame().launchFrame(); &#125;&#125;]]></content>
      <categories>
        <category>Java AWT</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>GUI</tag>
        <tag>AWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java AWT-基本操作]]></title>
    <url>%2F2018%2F02%2F03%2FJava%20AWT-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[创建基本的窗体AWT中封装窗体逻辑的类为java.awt.Frame，通常我们通过继承它来使用它的功能，它的类定义为： 1public class Frame extends Window implements MenuContainer 下面我们给出Frame常用方法的定义。首先给出Frame继承自它的父类java.awt.Window的方法： 123456789/** * 设定窗体相对于屏幕的位置为(x,y) */public void setLocation(int x, int y)/** * 设定窗体的宽为width，高为height */public void setSize(int width, int height) 然后我们就可以开始写第一个小例子了： 123456789101112131415import java.awt.Frame;public class GameFrame extends Frame &#123; private static final long serialVersionUID = 1L; public void launchFrame() &#123; super.setLocation(700, 300); super.setSize(400, 300); &#125; public static void main(String[] args) &#123; new GameFrame().launchFrame(); &#125;&#125; 运行后无输出，程序也无法终止。之所以无输出，是因为窗体默认是不可见的。而之所以无法终止，是因为窗体虽然是不可见的，但它的确存在。 为了让窗体可见，我们还要使用Frame继承自它的父类java.awt.Window中的另一个方法： 12345/** * true--窗体可见,false--窗体不可见 * 默认为false */public void setVisible(boolean b) 相应的代码改为： 12345678910111213141516import java.awt.Frame;public class GameFrame extends Frame &#123; private static final long serialVersionUID = 1L; public void launchFrame() &#123; super.setLocation(700, 300); super.setSize(400, 300); super.setVisible(true); &#125; public static void main(String[] args) &#123; new GameFrame().launchFrame(); &#125;&#125; 此时运行程序，会按设定生成所需的窗体： 之所以不默认设定窗体可见，是为了使得窗体可见的时机可控。很多时候，窗体的加载是一个耗时的操作，我们并不希望给用户展示一个”半成品”，此时我们就可以待窗体加载到”可以见人了”的程度后再设定为可见。 至此我们已绘制出了窗体，不过当我们点击窗体右上角的叉时却无法关闭窗体，其原因为默认情况下并没有给”点击叉”这一行为关联任何动作。因此我们需要自行添加窗口监听设定被触发的行为。添加窗口监听的方法依然在java.awt.Window中： 1public synchronized void addWindowListener(WindowListener l) 不妨稍微插一句，至此为止我们介绍的所有Frame中的方法都不是存在于Frame中的，而是Frame继承自其父类Window的。事实上，我们后文介绍的方法也基本都是这个套路。核心的骨架已在Window中确定好，Frame只负责封装一些小的细节。 引入监听器后，代码改进为： 1234567891011121314151617181920212223242526import java.awt.Frame;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;public class GameFrame extends Frame &#123; private static final long serialVersionUID = 1L; public void launchFrame() &#123; super.setLocation(700, 300); super.setSize(400, 300); super.addWindowListener( new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125; &#125; ); super.setVisible(true); &#125; public static void main(String[] args) &#123; new GameFrame().launchFrame(); &#125;&#125; 这里我们让”点击叉”这个行为触发程序的结束。现在我们再运行程序，就可以通过点击右上角的叉结束程序，关闭窗体了。之所以不将结束程序设定为默认操作，是为了给程序员留出编码空间，例如，我们可以在真正关闭前设定再弹出一个框:”是否确定退出？”做二次确认。事实上，绝大多数的桌面应用软件也都是这么做的。 绘制窗体中的组件绘制方法依然在java.awt.Window中： 1public void paint(Graphics g) 其中Graphics可以理解为画笔。通常我们通过重写该方法来封装自身的业务逻辑： 12345678910111213141516171819202122232425262728293031import java.awt.Frame;import java.awt.Graphics;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;public class GameFrame extends Frame &#123; private static final long serialVersionUID = 1L; public void launchFrame() &#123; super.setLocation(700, 300); super.setSize(400, 300); super.addWindowListener( new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125; &#125; ); super.setVisible(true); &#125; @Override public void paint(Graphics g) &#123; &#125; public static void main(String[] args) &#123; new GameFrame().launchFrame(); &#125;&#125; 运行后并未绘制任何组件：这是理所当然的，因为paint()方法为空。下面我们就来举一个绘制的小例子： 1234567891011121314151617181920212223242526272829303132import java.awt.Frame;import java.awt.Graphics;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;public class GameFrame extends Frame &#123; private static final long serialVersionUID = 1L; public void launchFrame() &#123; super.setLocation(700, 300); super.setSize(400, 300); super.addWindowListener( new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125; &#125; ); super.setVisible(true); &#125; @Override public void paint(Graphics g) &#123; g.drawLine(100, 100, 200, 200); &#125; public static void main(String[] args) &#123; new GameFrame().launchFrame(); &#125;&#125; 输出： 这样就绘制了一条线段。由此可见，绘制组件最终是要着落在Graphics这个类上的。 Graphics绘制基本图形下面我们会介绍Graphics类常用的绘制基本图形的方法，基本沿用前文代码，若有需要可能会改变窗体大小。 首先是上一小节已经展示的： 12345678/** * 绘制一条线段 * @param x1 int, 端点1横坐标 * @param y1 int, 端点1纵坐标 * @param x2 int, 端点2横坐标 * @param y2 int, 端点2纵坐标 */public abstract void drawLine(int x1, int y1, int x2, int y2) 12345678/** * 绘制一个矩形 * @param x int, 左上角横坐标 * @param y int, 左上角纵坐标 * @param width int, 矩形宽 * @param height int, 矩形高 */public void drawRect(int x, int y, int width, int height) 实例： 1g.drawRect(0, 0, 100, 100); 输出： 上一个绘制线段的例子可能看得不够真切，不过本例中就暴露了一个需要注意的点：绘制图形时会以窗体的外轮廓为起点，并不会让出标题栏的宽度。 123456789/** * 绘制一个椭圆 * 给定的入参实质上是在确定椭圆所属的外切矩形 * @param x int, 左上角横坐标 * @param y int, 左上角纵坐标 * @param width int, 矩形宽 * @param height int, 矩形高 */public abstract void drawOval(int x, int y, int width, int height) 示例： 1g.drawOval(100, 100, 100, 200); 输出： 特别的，若外切矩形是一个正方形，绘制出的自然是一个圆了，示例： 1g.drawOval(100, 100, 200, 200); 输出： 1234567/** * 绘制文字 * @param x String, 文字内容 * @param x int, 第一个字符的横坐标 * @param y int, 字符串的纵坐标 */public abstract void drawString(String str, int x, int y) 示例： 1g.drawString(&quot;博丽灵梦&quot;, 0, 100); 输出： 字符串并没有打全，其原因就在于其实不仅仅是标题栏，整个窗体其实围了一圈的外边框，而这一圈外边框都是无法绘制图形的，但是计算坐标又是以窗体外边框为起点。不得不说，这可着实让人蛋疼。 如果想改变字体，可自定义字体类： 12g.setFont(new Font(&quot;楷体&quot;, Font.BOLD, 20));g.drawString(&quot;博丽灵梦&quot;, 100, 100); 输出： 12345678/** * 绘制一个填充矩形 * @param x int, 左上角横坐标 * @param y int, 左上角纵坐标 * @param width int, 矩形宽 * @param height int, 矩形高 */public abstract void fillRect(int x, int y, int width, int height) 示例： 1g.fillRect(100, 100, 100, 200); 输出： 同理： 1public abstract void fillOval(int x, int y, int width, int height) 则可绘制一个填充椭圆。 Graphics改变画笔颜色在绘制前修改画笔颜色即可： 12g.setColor(Color.BLUE);g.fillRect(100, 100, 100, 200); 输出： 为避免画笔颜色被修改乱套，建议每次修改前保存下，用完后再改回去： 1234Color base = g.getColor();g.setColor(Color.BLUE);g.fillRect(100, 100, 100, 200);g.setColor(base); Graphics绘制图片事实上，绘制基本图形的方法上文只介绍了其中很小的一本分，之所以不都介绍完，是因为实际写代码时基本用不到，而用不到的原因则在于： 实在是太TM丑了！ 实际编程中，我们基本只会绘制一种组件：那就是图片。 既然要绘制图片，第一步自然就是将图片加载至内存： 123456789101112131415/** * 加载默认图片目录下的图片 * 图片默认目录为：src/main/resources/images * @param path String, 图片相对于图片默认目录的路径。 * 例如图片为src/main/resources/images/a.jpg * 则path=a.jpg * @return Image, 存入内存中的图片信息 * @throws IOException */public static Image loadImage(String path) throws IOException &#123; URL url = Utils.class.getClassLoader() .getResource(&quot;images/&quot; + path); BufferedImage bImage = ImageIO.read(url); return bImage;&#125; 测试用图命名为test.jpg，丢到images目录下。test.jpg为： 然后我们就可以开始绘制了，此时的paint方法为： 123456789@Overridepublic void paint(Graphics g) &#123; try &#123; Image image = Utils.loadImage(&quot;test.jpg&quot;); g.drawImage(image, 100, 100, null); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 其中用于绘制的方法的定义为： 12345678/** * 绘制图片 * @param img Image, 加载至内存中的图片 * @param x int, 目标位置左上角横坐标 * @param y int, 目标位置左上角纵坐标 * @param observer ImageObserver, 通常传入null即可 */public abstract boolean drawImage(Image img, int x, int y, ImageObserver observer) 输出为： 很显然，该方法取了源图片全图，并且不加任何修改。如果只想取部分图片，或是调整图片大小比例，可使用如下方法： 1234567891011121314151617/** * 绘制图片 * @param img Image, 加载至内存中的图片 * @param dx1 int, 目标图片左上角横坐标 * @param dy1 int, 目标图片左上角纵坐标 * @param dx2 int, 目标图片右下角横坐标 * @param dy2 int, 目标图片右下角纵坐标 * @param sx1 int, 源图片左上角横坐标 * @param sy1 int, 源图片左上角纵坐标 * @param sx2 int, 源图片右下角横坐标 * @param sy2 int, 源图片右下角纵坐标 * @param observer ImageObserver, 通常传入null即可 */public abstract boolean drawImage(Image img, int dx1, int dy1, int dx2, int dy2, int sx1, int sy1, int sx2, int sy2, ImageObserver observer); 乍一看入参可真他娘的多啊，好麻烦的样子。仔细看来其实很有条理：(sx1,sy1)-(sx2,sy2)确定了源图片的取图区域，(dx1,dy1)-(dx2,dy2)确定了目标位置的放置区域。这两份区域大小，比例可不相同，进而使得绘制出的图片的大小，比例不同于源图。 示例： 1234g.drawImage(image , 17, 50, 517, 550 , 400, 150, 900, 650 , null); 输出： 绘制通用控件如果要绘制按钮，文本输入框，选择框之类的控件，可参见Java 设计模式-16.Mediator模式中的示例程序。]]></content>
      <categories>
        <category>Java AWT</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>GUI</tag>
        <tag>AWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java GUI-碎片]]></title>
    <url>%2F2018%2F02%2F03%2FJava%20GUI-%E7%A2%8E%E7%89%87%2F</url>
    <content type="text"><![CDATA[AWT与SwingJava的GUI(Graphical User Interface)主要有两大版本： AWT(Abstract Window Toolkit):已过时，例如Frame。 Swing:AWT的功能升级版，推荐使用，例如JFrame(命名上通常都是AWT对应功能的类前加J)。 不过实话来说，Java在桌面应用软件领域发展得并不好，最大的用途大概也就是给学习Java的学生布置课后作业了(汗)，因此较真AWT或Swing该用哪一个其实是然并卵的，因为工作中基本用不到这方面的知识。 物体位置标记规则GUI二维编程中，坐标系的起点位于左上角，x轴向右正向延伸，y轴向下正向延伸(即可用区域永远在第一象限)，单位为像素(px)。 我们不妨以最外层的，屏幕与游戏窗体间的关系为例： 则窗体的位置可确定为(x1,y1)。 同理，在窗体内部我们也可以确定任意组件的坐标： 则组件的位置可确定为(x2,y2)。需要注意的是，此时已进入了窗体，因此使用的都是相对于窗体的位置。 窗体必然是一个矩形，因此只要确定了左上角顶点的坐标以及窗体的长与宽，即可完全确定一个窗体。对于窗体中的组件，只要其形状为矩形，那么同理也可完全确定。 那么组件不是矩形的时候该怎么办呢？ GUI的解决策略为：不办！也就是说它会将一切组件视为矩形，实际形状不是矩形的要放到一个矩形的组件中(顺带说一句，三维编程的思路同理，组件是被放到长方体中的)。 这样的好处是简单粗暴，坏处就是精度较低。举个例子，在这样的规则下，检测两个组件是否碰撞实际上是在判断它们所属的矩形是否相交。比如两个圆，实际上本身并未碰撞，却可能因它们所属的矩形碰撞了而被判定为碰撞。]]></content>
      <categories>
        <category>Java GUI</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>GUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 并发-容器线程安全化方法]]></title>
    <url>%2F2018%2F02%2F01%2FJava%20%E5%B9%B6%E5%8F%91-%E5%AE%B9%E5%99%A8%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%8C%96%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Java API中提供了常见的线程安全的容器，可参见Java 并发-线程安全的容器。这些容器专为并发环境设计，性能极高。但是在串-并行混合，对性能要求又不高时，比起专门声明新的线程安全的容器，我们更希望能有一个简单的方式将线程不安全的容器改造为线程安全的。这部分功能被封装在java.util.Collections工具类的容器线程安全化方法中：这些方法接收一个特定的容器，然后将它改造为线程安全的容器后返回: 1234567public static &lt;T&gt; Collection&lt;T&gt; synchronizedCollection(Collection&lt;T&gt; c)public static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list)public static &lt;T&gt; Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s)public static &lt;K,V&gt; Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m) synchronizedCollection全部代码如下： 123public static &lt;T&gt; Collection&lt;T&gt; synchronizedCollection(Collection&lt;T&gt; c) &#123; return new SynchronizedCollection&lt;&gt;(c);&#125; 它的返回值是Collections的静态成员内部类，全部代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566static class SynchronizedCollection&lt;E&gt; implements Collection&lt;E&gt;, Serializable &#123; private static final long serialVersionUID = 3053995032091335093L; final Collection&lt;E&gt; c; final Object mutex; SynchronizedCollection(Collection&lt;E&gt; c) &#123; if (c==null) throw new NullPointerException(); this.c = c; mutex = this; &#125; SynchronizedCollection(Collection&lt;E&gt; c, Object mutex) &#123; this.c = c; this.mutex = mutex; &#125; public int size() &#123; synchronized (mutex) &#123;return c.size();&#125; &#125; public boolean isEmpty() &#123; synchronized (mutex) &#123;return c.isEmpty();&#125; &#125; public boolean contains(Object o) &#123; synchronized (mutex) &#123;return c.contains(o);&#125; &#125; public Object[] toArray() &#123; synchronized (mutex) &#123;return c.toArray();&#125; &#125; public &lt;T&gt; T[] toArray(T[] a) &#123; synchronized (mutex) &#123;return c.toArray(a);&#125; &#125; public Iterator&lt;E&gt; iterator() &#123; return c.iterator(); &#125; public boolean add(E e) &#123; synchronized (mutex) &#123;return c.add(e);&#125; &#125; public boolean remove(Object o) &#123; synchronized (mutex) &#123;return c.remove(o);&#125; &#125; public boolean containsAll(Collection&lt;?&gt; coll) &#123; synchronized (mutex) &#123;return c.containsAll(coll);&#125; &#125; public boolean addAll(Collection&lt;? extends E&gt; coll) &#123; synchronized (mutex) &#123;return c.addAll(coll);&#125; &#125; public boolean removeAll(Collection&lt;?&gt; coll) &#123; synchronized (mutex) &#123;return c.removeAll(coll);&#125; &#125; public boolean retainAll(Collection&lt;?&gt; coll) &#123; synchronized (mutex) &#123;return c.retainAll(coll);&#125; &#125; public void clear() &#123; synchronized (mutex) &#123;c.clear();&#125; &#125; public String toString() &#123; synchronized (mutex) &#123;return c.toString();&#125; &#125; private void writeObject(ObjectOutputStream s) throws IOException &#123; synchronized (mutex) &#123;s.defaultWriteObject();&#125; &#125;&#125; 原来如此，SynchronizedCollection以mutex为监视器，在c的方法外部都包装上了一层synchronized。具体的业务逻辑依然是调用c的方法，确实相当于将原容器线程安全化了。不过本质上来说，这和在容器的外部代码中使用synchronized是一回事，性能不高也是理所当然的了。 SynchronizedCollection共有两个构造函数，其区别就在于是否指定mutex。Collections.SynchronizedCollection()并未传入监视器对象，此时监视器对象将为SynchronizedCollection实例本身。 那么指定mutex的那个构造函数又有什么用处呢？Collections有如下方法： 123static &lt;T&gt; Collection&lt;T&gt; synchronizedCollection(Collection&lt;T&gt; c, Object mutex) &#123; return new SynchronizedCollection&lt;&gt;(c, mutex);&#125; 该方法供java.util包内部调用，并非暴露出去的公共方法，故在此就不深究了。 synchronizedList套路与Collections.SynchronizedCollection()相同，因此只贴出相关代码，就不再赘述细节了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104public static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list) &#123; return (list instanceof RandomAccess ? new SynchronizedRandomAccessList&lt;&gt;(list) : new SynchronizedList&lt;&gt;(list));&#125;static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list, Object mutex) &#123; return (list instanceof RandomAccess ? new SynchronizedRandomAccessList&lt;&gt;(list, mutex) : new SynchronizedList&lt;&gt;(list, mutex));&#125;static class SynchronizedList&lt;E&gt; extends SynchronizedCollection&lt;E&gt; implements List&lt;E&gt; &#123; private static final long serialVersionUID = -7754090372962971524L; final List&lt;E&gt; list; SynchronizedList(List&lt;E&gt; list) &#123; super(list); this.list = list; &#125; SynchronizedList(List&lt;E&gt; list, Object mutex) &#123; super(list, mutex); this.list = list; &#125; public boolean equals(Object o) &#123; if (this == o) return true; synchronized (mutex) &#123;return list.equals(o);&#125; &#125; public int hashCode() &#123; synchronized (mutex) &#123;return list.hashCode();&#125; &#125; public E get(int index) &#123; synchronized (mutex) &#123;return list.get(index);&#125; &#125; public E set(int index, E element) &#123; synchronized (mutex) &#123;return list.set(index, element);&#125; &#125; public void add(int index, E element) &#123; synchronized (mutex) &#123;list.add(index, element);&#125; &#125; public E remove(int index) &#123; synchronized (mutex) &#123;return list.remove(index);&#125; &#125; public int indexOf(Object o) &#123; synchronized (mutex) &#123;return list.indexOf(o);&#125; &#125; public int lastIndexOf(Object o) &#123; synchronized (mutex) &#123;return list.lastIndexOf(o);&#125; &#125; public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; synchronized (mutex) &#123;return list.addAll(index, c);&#125; &#125; public ListIterator&lt;E&gt; listIterator() &#123; return list.listIterator(); &#125; public ListIterator&lt;E&gt; listIterator(int index) &#123; return list.listIterator(index); &#125; public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; synchronized (mutex) &#123; return new SynchronizedList&lt;&gt;(list.subList(fromIndex, toIndex), mutex); &#125; &#125; private Object readResolve() &#123; return (list instanceof RandomAccess ? new SynchronizedRandomAccessList&lt;&gt;(list) : this); &#125;&#125;static class SynchronizedRandomAccessList&lt;E&gt; extends SynchronizedList&lt;E&gt; implements RandomAccess &#123; SynchronizedRandomAccessList(List&lt;E&gt; list) &#123; super(list); &#125; SynchronizedRandomAccessList(List&lt;E&gt; list, Object mutex) &#123; super(list, mutex); &#125; public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; synchronized (mutex) &#123; return new SynchronizedRandomAccessList&lt;&gt;( list.subList(fromIndex, toIndex), mutex); &#125; &#125; private static final long serialVersionUID = 1530674583602358482L; private Object writeReplace() &#123; return new SynchronizedList&lt;&gt;(list); &#125;&#125; synchronizedSet同synchronizedList，只贴出代码： 123456789101112131415161718192021222324252627public static &lt;T&gt; Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s) &#123; return new SynchronizedSet&lt;&gt;(s);&#125;static &lt;T&gt; Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s, Object mutex) &#123; return new SynchronizedSet&lt;&gt;(s, mutex);&#125;static class SynchronizedSet&lt;E&gt; extends SynchronizedCollection&lt;E&gt; implements Set&lt;E&gt; &#123; private static final long serialVersionUID = 487447009682186044L; SynchronizedSet(Set&lt;E&gt; s) &#123; super(s); &#125; SynchronizedSet(Set&lt;E&gt; s, Object mutex) &#123; super(s, mutex); &#125; public boolean equals(Object o) &#123; if (this == o) return true; synchronized (mutex) &#123;return c.equals(o);&#125; &#125; public int hashCode() &#123; synchronized (mutex) &#123;return c.hashCode();&#125; &#125;&#125; synchronizedMap这个就稍稍有些特殊了，不过我们还是先贴出代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394public static &lt;K,V&gt; Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m) &#123; return new SynchronizedMap&lt;&gt;(m);&#125;private static class SynchronizedMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Serializable &#123; private static final long serialVersionUID = 1978198479659022715L; private final Map&lt;K,V&gt; m; final Object mutex; SynchronizedMap(Map&lt;K,V&gt; m) &#123; if (m==null) throw new NullPointerException(); this.m = m; mutex = this; &#125; SynchronizedMap(Map&lt;K,V&gt; m, Object mutex) &#123; this.m = m; this.mutex = mutex; &#125; public int size() &#123; synchronized (mutex) &#123;return m.size();&#125; &#125; public boolean isEmpty() &#123; synchronized (mutex) &#123;return m.isEmpty();&#125; &#125; public boolean containsKey(Object key) &#123; synchronized (mutex) &#123;return m.containsKey(key);&#125; &#125; public boolean containsValue(Object value) &#123; synchronized (mutex) &#123;return m.containsValue(value);&#125; &#125; public V get(Object key) &#123; synchronized (mutex) &#123;return m.get(key);&#125; &#125; public V put(K key, V value) &#123; synchronized (mutex) &#123;return m.put(key, value);&#125; &#125; public V remove(Object key) &#123; synchronized (mutex) &#123;return m.remove(key);&#125; &#125; public void putAll(Map&lt;? extends K, ? extends V&gt; map) &#123; synchronized (mutex) &#123;m.putAll(map);&#125; &#125; public void clear() &#123; synchronized (mutex) &#123;m.clear();&#125; &#125; private transient Set&lt;K&gt; keySet = null; private transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = null; private transient Collection&lt;V&gt; values = null; public Set&lt;K&gt; keySet() &#123; synchronized (mutex) &#123; if (keySet==null) keySet = new SynchronizedSet&lt;&gt;(m.keySet(), mutex); return keySet; &#125; &#125; public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; synchronized (mutex) &#123; if (entrySet==null) entrySet = new SynchronizedSet&lt;&gt;(m.entrySet(), mutex); return entrySet; &#125; &#125; public Collection&lt;V&gt; values() &#123; synchronized (mutex) &#123; if (values==null) values = new SynchronizedCollection&lt;&gt;(m.values(), mutex); return values; &#125; &#125; public boolean equals(Object o) &#123; if (this == o) return true; synchronized (mutex) &#123;return m.equals(o);&#125; &#125; public int hashCode() &#123; synchronized (mutex) &#123;return m.hashCode();&#125; &#125; public String toString() &#123; synchronized (mutex) &#123;return m.toString();&#125; &#125; private void writeObject(ObjectOutputStream s) throws IOException &#123; synchronized (mutex) &#123;s.defaultWriteObject();&#125; &#125;&#125; 之所以说它有些特殊，是因为Map的线程安全化方法被放在Collections类中是略有不妥的，估计是Java API的设计人员想将所有的容器线程安全化方法集中到一个类中吧。正因为如此，SynchronizedMap的访问权限是私有，且没有传入监视器对象的Collections.synchronizedMap()。]]></content>
      <categories>
        <category>Java 并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 并发-线程安全的容器]]></title>
    <url>%2F2018%2F01%2F24%2FJava%20%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[为了降低开发人员进行并发编程的工作成本，Java API提供了常见的线程安全的容器(链表，Map，队列等)。这些容器大多位于java.util.concurrent包中(其他位置也零星的分布着线程安全的容器，例如java.util.Vector，这些容器的性能往往较差)，常用的列举如下： java.util.concurrent.ConcurrentHashMap: 可以看作线程安全的高效并发的java.util.HashMap。 java.util.concurrent.CopyOnWriteArrayList: 顾名思义，该容器属于java.util.ArrayList一系。在读多写少的场合，它的性能远高于java.util.Vector。详见Java 并发-CopyOnWriteArrayList。 java.util.concurrent.ConcurrentLinkedQueue: 使用链表实现，可以看作线程安全的高效并发的LinkedList。详见Java 并发-ConcurrentLinkedQueue。 java.util.concurrent.BlockingQueue: java.util.Queue接口的子接口，是线程安全的阻塞队列，常用作并发编程中的缓冲区。Java API提供了它的数组，链表等具体的实现。详见Java 并发-BlockingQueue。 java.util.concurrent.ConcurrentSkipListMap: 这是一个底层以Map实现的线程安全的跳表，可进行高效的查找。详见Java 并发-ConcurrentSkipListMap。 纵观上述例子，我们几乎都可以找到一个统一的关键词，”高效”。这份高效源于专业：上述容器是专门为并发编程设计的，自然更能适应并发环境。 在此，我们不妨顺着”专业”继续往下说：专业同样意味着不全面。举个例子，我们在串行环境中创建了一个HashMap的实例，如果我们想将它转换为ConcurrentHashMap是比较麻烦的：只能新建ConcurrentHashMap的实例，然后将已有的hashMap中的数据一点点的导入。对此，Java API中已提供了解决方法：如果我们对并发容器的性能要求不高，那么其实是可以通过一个方法简单的将它们线程安全化的，这些方法位于java.util.Collections工具类中，可参见Java 并发-容器线程安全化方法。]]></content>
      <categories>
        <category>Java 并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 并发-Fork Join框架]]></title>
    <url>%2F2018%2F01%2F23%2FJava%20%E5%B9%B6%E5%8F%91-Fork%20Join%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[“分治法”是一种非常有效的解决问题的思路，大名鼎鼎的MapReduce就是它的实际应用。 我们可以以一个小例子来简单介绍下分治法的基本思想：假如我们需要处理1000个数据，而这1000个数据的处理是彼此独立的，不需要建立特定的处理顺序。比较极端的方式有两种：其一是同时处理这1000个数据，这样做效率最高，但对系统的负担也最大。其二是每次只处理1个，处理1000次，这样做对系统的负担最小，但效率最低。 其实这两种处理方式可以看作同一个模式下的两个极端情况：每次处理x个，处理y轮，保证x*y为数据总数即可。其实这已经运用了分治法的思想，将一个大的问题，分解成了y轮。 因此分治法的本质就是分解：将无法直接解决的大的问题分解为一个个小的，可以通过现有资源解决的问题。在解决这些小的问题后再进行汇总，最终间接解决大的问题。其实不仅仅是编程，为人处事也是这个道理。 具体到Java API中，分治法的应用便是Fork Join框架。Fork的原义是叉子，引申义就是问题的分解：像叉子的前端一样被分解为多个更小的问题。事实上，Java的这种起名方式源自Linux。在Linux中，fork()函数用来创建子进程。 而Join则与Java API中的join方法相同，代表等待。 因此Fork Join确实是很形象的描述了分治法的精髓：当问题需要分解时，它便像叉子的前端一样被分解为多个分叉，而先完成的分叉会等待尚未完成的分叉，待全部分叉均完成后再汇聚起来，向下进行。 依然以开篇的那个小例子为例，fork出1000个叉确实是太多了，而只fork出一个叉相当于就没分治。因此合乎逻辑的做法应当是根据系统的承载能力及对性能的要求fork出一个(1,1000)之间的整数。很显然，这里需要用到线程池。 这个线程池名为java.util.concurrent.ForkJoinPool，它的类定义如下： 1public class ForkJoinPool extends AbstractExecutorService 果不其然，它继承了AbstractExecutorService，承接自线程池一脉。在Java 并发-线程池中，我们曾给出过线程池核心类/接口的层次关系图： 现在，我们可以进一步丰富这张图： 它的常用构造函数有两个： 12345678public ForkJoinPool(int parallelism) &#123; this(parallelism, defaultForkJoinWorkerThreadFactory, null, false);&#125;public ForkJoinPool() &#123; this(Runtime.getRuntime().availableProcessors(), defaultForkJoinWorkerThreadFactory, null, false);&#125; 前者会按照使用者的要求创建一个大小为parallelism的线程池，而后者则会直接取可用CPU数作为线程池的大小。二者内部实际上调用的是同一个方法： 123456789101112131415161718192021222324252627282930public ForkJoinPool(int parallelism, ForkJoinWorkerThreadFactory factory, Thread.UncaughtExceptionHandler handler, boolean asyncMode) &#123; checkPermission(); if (factory == null) throw new NullPointerException(); if (parallelism &lt;= 0 || parallelism &gt; MAX_ID) throw new IllegalArgumentException(); this.parallelism = parallelism; this.factory = factory; this.ueh = handler; this.locallyFifo = asyncMode; long np = (long)(-parallelism); this.ctl = ((np &lt;&lt; AC_SHIFT) &amp; AC_MASK) | ((np &lt;&lt; TC_SHIFT) &amp; TC_MASK); this.submissionQueue = new ForkJoinTask&lt;?&gt;[INITIAL_QUEUE_CAPACITY]; int n = parallelism &lt;&lt; 1; if (n &gt;= MAX_ID) n = MAX_ID; else &#123; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; &#125; workers = new ForkJoinWorkerThread[n + 1]; this.submissionLock = new ReentrantLock(); this.termination = submissionLock.newCondition(); StringBuilder sb = new StringBuilder(&quot;ForkJoinPool-&quot;); sb.append(poolNumberGenerator.incrementAndGet()); sb.append(&quot;-worker-&quot;); this.workerNamePrefix = sb.toString();&#125; 很长，而且看起来做了很多事，挺复杂的样子。不过我们很简单就可以确定的是，这确实是在构建一个和我们最常用的ThreadPoolExecutor完全不同的线程池，并且这个线程池应该是比ThreadPoolExecutor要复杂得多。 事实上也的确如此，不过这种复杂对于使用者基本是透明的，因为它们绝大多数都被用以实现ForkJoinPool更复杂的逻辑需求以及优化它的性能。例如，对于普通的线程池，也就是ThreadPoolExecutor而言，提交给它的任务可以是不同的，因此两个线程之间是无法互相帮助的。而ForkJoinPool中的任务都是相同的(叉子的每个尖端当然都是相同的)，因此两个线程间可以互相帮助：例如线程1已将线程池分配给它的任务全部执行完，而线程2的阻塞队列中尚有任务积压，那么线程1就可以帮着线程2完成一部分积压的任务。当然，这里只是简单说下思路，实际实现起来还是比较麻烦的。例如，为了避免在帮助时发生冲突，从自身队列中取数据时应取队首的，而帮助他人时则从队尾开始拿数据。 再比如，ForkJoinPool会使用一个无锁的栈来管理空闲线程。如果一个工作线程没有被分配任务，那么它除了帮助他人外，还有可能(注意仅仅只是可能)被挂起，被挂起的线程将会被压入ForkJoinPool所管理的那个栈中，待需要时再唤醒线程。 在任务的提交上，ForkJoinPool最常用的提交方法为： 123456public &lt;T&gt; ForkJoinTask&lt;T&gt; submit(ForkJoinTask&lt;T&gt; task) &#123; if (task == null) throw new NullPointerException(); forkOrSubmit(task); return task;&#125; 从入参所属类的名字上我们便可看出，这个方法是为ForkJoinPool量身打造的，而java.util.concurrent.ForkJoinTask的类定义为： 1public abstract class ForkJoinTask&lt;V&gt; implements Future&lt;V&gt;, Serializable 它是ForkJoinPool专用的任务，其设计思路与我们最熟悉的构成Thread的核心Runnable完全不同，不过二者的性质是相同的，都代表要线程池执行的任务本身，其内部封装着具体的任务逻辑。 我们在使用时通常会使用ForkJoinTask的如下两个方法： 123public final ForkJoinTask&lt;V&gt; fork()public final V join() fork及join不必多说，它们所实现的就是Fork Join的核心功能，join返回任务的执行结果，其类型就是ForkJoinTask类定义中的V。 ForkJoinTask是一个抽象类，我们常用的它的子类有两个，它们的类定义分别为： 1public abstract class RecursiveTask&lt;V&gt; extends ForkJoinTask&lt;V&gt; 1public abstract class RecursiveAction extends ForkJoinTask&lt;Void&gt; 这又是两个抽象类，也就是说摆明了是要我们继承了才能用。 理所当然的，它们都位于java.util.concurrent包中。需要注意的是，单看ForkJoinTask，仿佛它的子类都应有返回值，但事实上，Java API不仅提供了有返回值的子类(RecursiveTask，类比于Callable)，同时也提供了无返回值的子类(RecursiveAction，类比于Runnable)。 无论是RecursiveTask，亦或是RecursiveAction，执行任务的逻辑都被封装在了方法compute()中： 有意思的是，这个方法并未出现在ForkJoinTask中，也就是RecursiveTask及RecursiveAction特有的执行方法，相当于Runnable的run()，或是Callable的call()。事实上，ForkJoinTask确实不仅仅这两个子类，我并未关注其他子类是怎么实现的，不过估计应该是有子类不依靠compute()来执行吧。 这个compute()在RecursiveTask的代码为： 1protected abstract V compute(); 在RecursiveAction中的代码为： 1protected abstract void compute(); 自然，这便是需要我们自行实现，封装任务逻辑的关键代码(也是RecursiveTask及RecursiveAction中唯一的抽象方法)。 无论分治法在内部将问题分解为了多少个小问题，从外部调用者来看，只需提交一个任务，然后等待ForkJoinPool得到该问题的解，这个解包含在submit的返回值ForkJoinTask中，它对应未经分解的那个大问题，其值可以通过它的get方法得到： 1public final V get() throws InterruptedException, ExecutionException 最后再提一点，既然ForkJoinTask从概念上对应于Runnable或Callable，那么它也该有个类似于Thread一样的容器来封装才对。没错，这个容器名为java.util.concurrent.ForkJoinWorkerThread，它的类定义为： 1public class ForkJoinWorkerThread extends Thread 看来较之于任务，容器倒是没那么另类，是直接继承了最常见的Thread。 下面我们来看一个小例子：要求做1-200000的数列求和，假设当前系统一个线程单次最多只能计算10000个数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.util.concurrent.ExecutionException;import java.util.concurrent.ForkJoinPool;import java.util.concurrent.ForkJoinTask;import java.util.concurrent.RecursiveTask;public class Test &#123; public static void main(String[] args) throws InterruptedException, ExecutionException &#123; ForkJoinPool forkJoinPool = new ForkJoinPool(); MyTask myTask = new MyTask(1L, 200000L); ForkJoinTask&lt;Long&gt; forkJoinTask = forkJoinPool.submit(myTask); System.out.println(forkJoinTask.get()); &#125;&#125;class MyTask extends RecursiveTask&lt;Long&gt; &#123; private static final long serialVersionUID = 1L; private static final int LIMIT = 10000; private long begin; private long end; MyTask(long begin, long end) &#123; this.begin = begin; this.end = end; &#125; @Override protected Long compute() &#123; long sum = 0L; long count = this.end - this.begin + 1; if (count &lt;= MyTask.LIMIT) &#123; for (long i = this.begin; i &lt;= this.end; i++) sum += i; return sum; &#125; long mid = this.begin + (this.end - this.begin) / 2; // 将规模缩减至一半 MyTask myTask1 = new MyTask(this.begin, mid); myTask1.fork(); sum += myTask1.join(); MyTask myTask2 = new MyTask(mid + 1, this.end); myTask2.fork(); sum += myTask2.join(); return sum; &#125;&#125; 输出： 120000100000 看完这个小例子，想必很自然的就会联想到递归：因为这与递归实在是太像了。没错，事实上，大家不妨认真思考下，递归也是分治思想的体现啊！ 不过，递归默认是不支持并发的，如果想将原生的递归改造为并发也是非常麻烦的。所以我们其实也可以这样想：Fork Join框架可以看作是并发环境下的递归。 既然Fork Join框架本质上和递归类似，那么如果调用的层次过深，它也同样可能出现栈溢出。同时，由于Fork Join底层使用的是线程池，那么它也可能出现普通线程池容易引发的错误：例如程序占用的线程数量过多，导致系统性能下降甚至崩溃。这都是使用Fork Join框架时需要注意的地方。]]></content>
      <categories>
        <category>Java 并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 并发-Future]]></title>
    <url>%2F2018%2F01%2F09%2FJava%20%E5%B9%B6%E5%8F%91-Future%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Java 并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>Future</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 并发-循环栅栏CyclicBarrier]]></title>
    <url>%2F2018%2F01%2F08%2FJava%20%E5%B9%B6%E5%8F%91-%E5%BE%AA%E7%8E%AF%E6%A0%85%E6%A0%8FCyclicBarrier%2F</url>
    <content type="text"><![CDATA[CyclicBarrier可以看作是Java 并发-倒计数器CountDownLatch的功能增强版。其中Barrier(栅栏)是Latch(门栓)的同义词，本质上都表示一种障碍。CyclicBarrier可理解为”循环的倒计数门栓”。即CyclicBarrier在CountDownLatch的基础上加入了循环的功能：每当一次计数结束，系统都会执行一个固定的程序员设定好的操作。随后将计数值归为初始值，再开始下一次循环。 java.util.concurrent.CyclicBarrier的类定义为： 1public class CyclicBarrier 其常用构造函数为： 1public CyclicBarrier(int parties, Runnable barrierAction) 其中parties是倒计数值，barrierAction是每次计数结束后要进行的操作。 我们不妨模拟这样1个场景：有一个化学实验室，同时可供3名学生作为一个小组进行实验。要求必须凑够3人才能开始实验。上一组实验完成后下一组才可进入。组队的学生没有特殊的要求，只要凑齐了3人，不管是谁都可以组队进行实验。现有9名学生会逐渐去实验室做实验。 该场景的代码实现为： 1234567891011121314151617181920212223242526272829303132333435import java.util.Random;import java.util.concurrent.BrokenBarrierException;import java.util.concurrent.CyclicBarrier;public class Test &#123; static int TEAM_SIZE = 3; private static long BASE_BEGIN = System.currentTimeMillis(); private static CyclicBarrier CB; public static void main(String[] args) &#123; Runnable barrierAction = new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;=====一组学生在实验室中完成实验=====&quot;); &#125; &#125;; Test.CB = new CyclicBarrier(Test.TEAM_SIZE, barrierAction); Runnable student = new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(new Random().nextInt(10000)); System.out.println(Thread.currentThread().getName() + &quot;于第&quot; + (System.currentTimeMillis() - Test.BASE_BEGIN) + &quot;毫秒到达实验室&quot;); Test.CB.await(); &#125; catch (InterruptedException | BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; for (int i = 0; i &lt; 9; i++) new Thread(student, &quot;学生&quot; + i).start(); &#125;&#125; 输出： 123456789101112学生5于第1640毫秒到达实验室学生7于第1819毫秒到达实验室学生4于第6542毫秒到达实验室=====一组学生在实验室中完成实验=====学生0于第8260毫秒到达实验室学生8于第8365毫秒到达实验室学生3于第8816毫秒到达实验室=====一组学生在实验室中完成实验=====学生1于第9146毫秒到达实验室学生2于第9709毫秒到达实验室学生6于第9963毫秒到达实验室=====一组学生在实验室中完成实验===== 如果我们将学生个数改为10： 1234567891011121314151617181920212223242526272829303132333435import java.util.Random;import java.util.concurrent.BrokenBarrierException;import java.util.concurrent.CyclicBarrier;public class Test &#123; static int TEAM_SIZE = 3; private static long BASE_BEGIN = System.currentTimeMillis(); private static CyclicBarrier CB; public static void main(String[] args) &#123; Runnable barrierAction = new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;=====一组学生在实验室中完成实验=====&quot;); &#125; &#125;; Test.CB = new CyclicBarrier(Test.TEAM_SIZE, barrierAction); Runnable student = new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(new Random().nextInt(10000)); System.out.println(Thread.currentThread().getName() + &quot;于第&quot; + (System.currentTimeMillis() - Test.BASE_BEGIN) + &quot;毫秒到达实验室&quot;); Test.CB.await(); &#125; catch (InterruptedException | BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; for (int i = 0; i &lt; 10; i++) new Thread(student, &quot;学生&quot; + i).start(); &#125;&#125; 则输出： 12345678910111213学生0于第834毫秒到达实验室学生4于第1119毫秒到达实验室学生7于第2412毫秒到达实验室=====一组学生在实验室中完成实验=====学生3于第2671毫秒到达实验室学生8于第6435毫秒到达实验室学生6于第6929毫秒到达实验室=====一组学生在实验室中完成实验=====学生5于第7242毫秒到达实验室学生9于第8087毫秒到达实验室学生2于第8644毫秒到达实验室=====一组学生在实验室中完成实验=====学生1于第9065毫秒到达实验室 因未达到组队条件学生1将无法进行实验，且程序也无法终止。 通过上面的小例子，我们还可以注意到CyclicBarrier需检查两个异常：InterruptedException，BrokenBarrierException。其中InterruptedException是所有等待操作基本都会检查的，而BrokenBarrierException是CyclicBarrier特有的。因为在同一个计数周期内的线程之间是有连带关系的，若其中一个被中断了，剩下的即便没有被中断本次倒数也无效了，不能无限的等待下去，此时这些线程就会抛出BrokenBarrierException。 让我们来简化上面的小例子： 12345678910111213141516171819202122232425262728293031323334import java.util.concurrent.BrokenBarrierException;import java.util.concurrent.CyclicBarrier;public class Test &#123; static int TEAM_SIZE = 3; private static CyclicBarrier CB; public static void main(String[] args) &#123; Runnable barrierAction = new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;=====一组学生在实验室中完成实验=====&quot;); &#125; &#125;; Test.CB = new CyclicBarrier(Test.TEAM_SIZE, barrierAction); Runnable student = new Runnable() &#123; @Override public void run() &#123; try &#123; Test.CB.await(); &#125; catch (InterruptedException | BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; for (int i = 0; i &lt; 3; i++) &#123; Thread t = new Thread(student, &quot;学生&quot; + i); t.start(); if (i == 1) t.interrupt(); &#125; &#125;&#125; 我们将线程总数控制为3，并中断线程1，则输出： 123456789101112131415java.lang.InterruptedException at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:204) at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:355) at com.test.Test$2.run(Test.java:27) at java.lang.Thread.run(Thread.java:745)java.util.concurrent.BrokenBarrierException at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:243) at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:355) at com.test.Test$2.run(Test.java:27) at java.lang.Thread.run(Thread.java:745)java.util.concurrent.BrokenBarrierException at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:243) at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:355) at com.test.Test$2.run(Test.java:27) at java.lang.Thread.run(Thread.java:745) 和预期的一样，我们得到了一个InterruptedException及两个BrokenBarrierException。]]></content>
      <categories>
        <category>Java 并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>CyclicBarrier</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 并发-倒计数器CountDownLatch]]></title>
    <url>%2F2018%2F01%2F08%2FJava%20%E5%B9%B6%E5%8F%91-%E5%80%92%E8%AE%A1%E6%95%B0%E5%99%A8CountDownLatch%2F</url>
    <content type="text"><![CDATA[CountDownLatch直译为倒计数门栓。其中门栓的含义很直观，仅取其字面意思即可：在计数结束前，将线程用门栓关在门里，待计数结束，再将门栓取下，放线程出来。 有人会将CountDownLatch译为倒计时器。我并不推荐这种翻译，因为这会让使用者产生一种误解：CountDownLatch会等待一段时间。而事实上，CountDownLatch进行的是数字上的倒数，故翻译为倒计数器更为合理。 java.util.concurrent.CountDownLatch的类定义为 1public class CountDownLatch 其常用的构造函数为： 1234/** * @param count int, 倒计数的个数 */public CountDownLatch(int count) 我们不妨构造一个小场景：一个工作在开始前需要先完成准备工作，而准备工作由5位不同的工人完成。代码如下： 12345678910111213141516171819202122232425262728import java.util.Random;import java.util.concurrent.CountDownLatch;public class Test &#123; private static int WORKER_COUNT = 5; private static CountDownLatch CDL = new CountDownLatch(Test.WORKER_COUNT); public static void main(String[] args) throws InterruptedException &#123; Runnable r = new Runnable() &#123; @Override public void run() &#123; long begin = System.currentTimeMillis(); try &#123; Thread.sleep(new Random().nextInt(10) * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;准备完成，耗时&quot; + ((System.currentTimeMillis()- begin) / 1000) + &quot;秒&quot;); Test.CDL.countDown(); &#125; &#125;; for (int i = 0; i &lt; Test.WORKER_COUNT; i++) new Thread(r, &quot;工人&quot; + i).start(); Test.CDL.await(); System.out.println(&quot;准备完成，工作开始...&quot;); &#125;&#125; 输出： 123456工人2准备完成，耗时2秒工人1准备完成，耗时6秒工人0准备完成，耗时8秒工人4准备完成，耗时9秒工人3准备完成，耗时9秒准备完成，工作开始...]]></content>
      <categories>
        <category>Java 并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>CountDownLatch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 并发-读写锁ReadWriteLock]]></title>
    <url>%2F2018%2F01%2F08%2FJava%20%E5%B9%B6%E5%8F%91-%E8%AF%BB%E5%86%99%E9%94%81ReadWriteLock%2F</url>
    <content type="text"><![CDATA[java.util.concurrent.locks.ReadWriteLock是JDK1.5起提供的读写分离锁。其目的是为了解决操作系统中的读者写者问题: 123public class ReentrantReadWriteLock implements ReadWriteLock, java.io.Serializablepublic interface ReadWriteLock 需要注意的是，它并没有实现Lock接口。 在读者写者的应用场景中，对于普通的ReentrantLock而言，访问临界区的线程只有一种身份，并不会区分读者与写者：这就导致任意两个访问临界区的线程都是冲突对立的。然而实际上，读者并不会修改临界区，因此读者与读者之间不应该阻塞。ReadWriteLock就是为了优化这种场景而设计的。 这种优化在读远多于写时对性能的提升非常明显，我们不妨来看下面的例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import java.util.Random;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class Test &#123; private static Lock LOCK = new ReentrantLock(); private static int VALUE; public static int read() &#123; int result = 0; Test.LOCK.lock(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; result = Test.VALUE; Test.LOCK.unlock(); return result; &#125; public static void write(int v) &#123; Test.LOCK.lock(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Test.VALUE = v; Test.LOCK.unlock(); &#125; public static void main(String[] args) &#123; long begin = System.currentTimeMillis(); Runnable read = new Runnable() &#123; @Override public void run() &#123; Test.read(); &#125; &#125;; Runnable write = new Runnable() &#123; @Override public void run() &#123; Test.write(new Random().nextInt()); &#125; &#125;; int readCount = 18; int writeCount = 2; ExecutorService esRead = Executors.newFixedThreadPool(readCount); ExecutorService esWrite = Executors.newFixedThreadPool(writeCount); for (int i = 0; i &lt; readCount; i++) esRead.submit(read); for (int i = 0; i &lt; writeCount; i++) esWrite.submit(write); esRead.shutdown(); esWrite.shutdown(); try &#123; boolean loop = true; do &#123; loop = (!esRead.awaitTermination(10, TimeUnit.MILLISECONDS)) || (!esWrite.awaitTermination(10, TimeUnit.MILLISECONDS)) ; &#125; while(loop); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println((System.currentTimeMillis() - begin) / 1000); &#125;&#125; 输出: 120 此时使用的是普通的ReentrantLock，耗时不多不少正好20秒，符合预期。现在我们使用ReadWriteLock： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import java.util.Random;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReadWriteLock;import java.util.concurrent.locks.ReentrantReadWriteLock;public class Test &#123; private static ReadWriteLock LOCK = new ReentrantReadWriteLock(); private static Lock READ_LOCK = Test.LOCK.readLock(); private static Lock WRITE_LOCK = Test.LOCK.writeLock(); private static int VALUE; public static int read() &#123; int result = 0; Test.READ_LOCK.lock(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; result = Test.VALUE; Test.READ_LOCK.unlock(); return result; &#125; public static void write(int v) &#123; Test.WRITE_LOCK.lock(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Test.VALUE = v; Test.WRITE_LOCK.unlock(); &#125; public static void main(String[] args) &#123; long begin = System.currentTimeMillis(); Runnable read = new Runnable() &#123; @Override public void run() &#123; Test.read(); &#125; &#125;; Runnable write = new Runnable() &#123; @Override public void run() &#123; Test.write(new Random().nextInt()); &#125; &#125;; int readCount = 18; int writeCount = 2; ExecutorService esRead = Executors.newFixedThreadPool(readCount); ExecutorService esWrite = Executors.newFixedThreadPool(writeCount); for (int i = 0; i &lt; readCount; i++) esRead.submit(read); for (int i = 0; i &lt; writeCount; i++) esWrite.submit(write); esRead.shutdown(); esWrite.shutdown(); try &#123; boolean loop = true; do &#123; loop = (!esRead.awaitTermination(10, TimeUnit.MILLISECONDS)) || (!esWrite.awaitTermination(10, TimeUnit.MILLISECONDS)) ; &#125; while(loop); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println((System.currentTimeMillis() - begin) / 1000); &#125;&#125; 经过大量测试，输出为3或4。较之此前的20，性能显然得到了极大的提升。 由该小例子我们也能具体得知，ReadWriteLock作为一个接口，与Lock是一级的，其实现类为ReentrantReadWriteLock。然后再由ReentrantReadWriteLock生成具体的读锁及写锁。因为到读锁及写锁这一层时，锁已没有什么特殊性，因此其实现的是Lock接口。]]></content>
      <categories>
        <category>Java 并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>ReadWriteLock</tag>
        <tag>读写锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 并发-信号量Semaphore]]></title>
    <url>%2F2018%2F01%2F08%2FJava%20%E5%B9%B6%E5%8F%91-%E4%BF%A1%E5%8F%B7%E9%87%8FSemaphore%2F</url>
    <content type="text"><![CDATA[无论是synchronized抑或是Lock，同一时刻只允许有1个线程访问临界区，如果我们要实现操作系统中的多信号量的功能，即同一时刻允许复数个线程访问临界区，则需要使用Java API提供的java.util.concurrent.Semaphore类。该类常用的构造函数有以下两个： 12345678910/** * permits, int 信号量数 */public Semaphore(int permits)/** * permits, int 信号量数 * fair, boolean true--公平 false--不公平 */public Semaphore(int permits, boolean fair) 通常情况下，每个线程只会申请一个信号量，此时信号量数就相当于同时能访问临界区的线程数。Semaphore类的常用方法如下： 1234567891011121314151617181920212223242526/** * 申请获得一个信号量 */public void acquire() throws InterruptedException/** * 申请获得一个信号量，但不响应中断 */public void acquireUninterruptibly()/** * 申请获得一个信号量。成功返回true，失败不会等待，直接返回false */public boolean tryAcquire()/** * 申请获得一个信号量。 * 成功返回true * 失败后会等待一段时间(timeout)，若在此期间获得信号量则返回true，反之返回false */public boolean tryAcquire(long timeout, TimeUnit unit) throws InterruptedException/** * 释放已获得的信号量 */public void release() 显然这与Lock中的加锁解锁极为类似。下面我们来看一个小例子： 1234567891011121314151617181920212223242526272829import java.util.Calendar;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;public class Test &#123; private static Semaphore SEMP = new Semaphore(5); public static void main(String[] args) &#123; Runnable r = new Runnable() &#123; @Override public void run() &#123; try &#123; Test.SEMP.acquire(); Thread.sleep(1000); System.out.println(Calendar.getInstance().get(Calendar.SECOND) + &quot;-----&quot; + Thread.currentThread().getId() + &quot; done.&quot;); Test.SEMP.release(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; int threadCount = 20; ExecutorService es = Executors.newFixedThreadPool(threadCount); for (int i = 0; i &lt; threadCount; i++) es.submit(r); es.shutdown(); &#125;&#125; 输出： 123456789101112131415161718192050-----12 done.50-----10 done.50-----9 done.50-----13 done.50-----11 done.51-----14 done.51-----17 done.51-----21 done.51-----18 done.51-----16 done.52-----19 done.52-----20 done.52-----15 done.52-----22 done.52-----23 done.53-----25 done.53-----26 done.53-----24 done.53-----27 done.53-----28 done. 分析输出可得：每秒输出1组，每组5个。与预期相符。]]></content>
      <categories>
        <category>Java 并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>Semaphore</tag>
        <tag>信号量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 并发-Condition条件]]></title>
    <url>%2F2017%2F12%2F29%2FJava%20%E5%B9%B6%E5%8F%91-Condition%E6%9D%A1%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[synchronized通过wait()及notify()实现线程间的通信。java.util.concurrent.locks.Lock接口号称synchronized的功能升级版，自然也应实现相应的通信机制。该机制被封装在java.util.concurrent.locks.Condition接口的实现类中。 Lock接口中有如下方法： 1Condition newCondition(); 该方法会返回一个Condition接口某实现类的实例，该实例将与调用它的锁实例绑定，用于该锁实例的通信。 Condition接口的全部方法如下： 123456789101112131415161718192021222324252627/** * 使当前线程等待，并放弃已获得的锁 * 会因signal()或signalAll()停止等待并重新尝试获取锁 * 会因线程中断而结束等待 */void await() throws InterruptedException;/** * 不响应中断，其余与await()相同 */void awaitUninterruptibly();long awaitNanos(long nanosTimeout) throws InterruptedException;boolean await(long time, TimeUnit unit) throws InterruptedException;boolean awaitUntil(Date deadline) throws InterruptedException;/** * 随机唤醒一个处于await状态的线程 */void signal();/** * 唤醒所有处于await状态的线程 */void signalAll(); 较之synchronized机制，很显然，await对应于wait，signal对应于notify。 下面来看一个小例子： 1234567891011121314151617181920212223242526272829import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;public class Test &#123; private static ReentrantLock LOCK = new ReentrantLock(); private static Condition CONDITION = Test.LOCK.newCondition(); public static void main(String[] args) throws InterruptedException &#123; Runnable r = new Runnable() &#123; @Override public void run() &#123; Test.LOCK.lock(); try &#123; Test.CONDITION.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;after wait&quot;); Test.LOCK.unlock(); &#125; &#125;; new Thread(r).start(); Thread.sleep(100); Test.LOCK.lock(); Test.CONDITION.signal(); Test.LOCK.unlock(); &#125;&#125; 输出： 1after wait 显然，套路与synchronized极其相似，只不过synchronized用作同步标志的是任意对象，通讯机制是任意对象都有的wait和notify方法，而锁机制则做了特化：同步对象是Lock，通讯机制被封装在与该Lock对象绑定的Condition中。 在synchronized中，若要使用通讯机制，则必须先获得监视器对象的认可，在synchronized代码块的范围内也只能调用监视器对象的wait和notify方法。同理，若要使用锁的通讯机制，必须先获得锁的钥匙(lock)，而后在持有钥匙期间(unlock之前)调用与锁绑定的Condition对象的await及signal方法。 不过，需要注意的是，synchronized是用一对{}区分同步区域的，离开该区域自动退出同步。而锁机制则需要显式加锁及解锁，在提高灵活性的同时也增大了程序员犯错的可能：很有可能只顾着加锁而忘记了解锁。例如我们按如下方式修改上例： 123456789101112131415161718192021222324252627282930import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;public class Test &#123; private static ReentrantLock LOCK = new ReentrantLock(); private static Condition CONDITION = Test.LOCK.newCondition(); public static void main(String[] args) throws InterruptedException &#123; Runnable r = new Runnable() &#123; @Override public void run() &#123; Test.LOCK.lock(); try &#123; Test.CONDITION.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;after wait&quot;); Test.LOCK.unlock(); &#125; &#125;; new Thread(r).start(); Thread.sleep(100); Test.LOCK.lock(); Test.CONDITION.signal(); // 没有释放锁 // Test.LOCK.unlock(); &#125;&#125; 此时程序无输出且无法结束。 对于synchronized而言，每个监视器对象只能对应一个通讯队列。而在锁机制中，每个Lock对象可绑定多个Condition，功能自然更为强大。 Java API中大量使用锁及其通讯机制，以java.util.concurrent.ArrayBlockingQueue为例。其首先按如下方式声明了锁： 12345final ReentrantLock lock;private final Condition notEmpty; // 信号量：非空private final Condition notFull; // 信号量：非满 构造函数中完成了锁及信号量的初始化： 12345678public ArrayBlockingQueue(int capacity, boolean fair) &#123; if (capacity &lt;= 0) throw new IllegalArgumentException(); this.items = new Object[capacity]; lock = new ReentrantLock(fair); notEmpty = lock.newCondition(); notFull = lock.newCondition();&#125; 关于锁的运用我们来看两个典型的方法，向队尾追加put()及从队头取出take()。 首先来看put()： 123456789101112131415161718192021public void put(E e) throws InterruptedException &#123; checkNotNull(e); final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try &#123; while (count == items.length) // 当前队列已满，等待收到非满的信号时才能继续 notFull.await(); insert(e); &#125; finally &#123; lock.unlock(); &#125;&#125;private void insert(E x) &#123; items[putIndex] = x; putIndex = inc(putIndex); ++count; notEmpty.signal(); // 因为放入了一个元素，发出非空的信号 // 如果当前有线程正在等待该信号则可继续执行下去&#125; 相应的take()为： 1234567891011121314151617181920212223public E take() throws InterruptedException &#123; final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try &#123; while (count == 0) // 当前队列为空，等待收到非空的信号时才能继续 notEmpty.await(); return extract(); &#125; finally &#123; lock.unlock(); &#125;&#125;private E extract() &#123; final Object[] items = this.items; E x = this.&lt;E&gt;cast(items[takeIndex]); items[takeIndex] = null; takeIndex = inc(takeIndex); --count; notFull.signal(); // 因为取出了一个元素，发出非满的信号 // 如果当前有线程正在等待该信号则可继续执行下去 return x;&#125; 很显然，这就是操作系统中典型的多生产者(通过put放入缓冲区)-单缓冲区(队列对象)-多消费者(通过take从缓冲区中取出)模型。]]></content>
      <categories>
        <category>Java 并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>锁</tag>
        <tag>Lock</tag>
        <tag>ReentrantLock</tag>
        <tag>重入锁</tag>
        <tag>Condition</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 反射-逆向移植]]></title>
    <url>%2F2017%2F12%2F19%2FJava%20%E5%8F%8D%E5%B0%84-%E9%80%86%E5%90%91%E7%A7%BB%E6%A4%8D%2F</url>
    <content type="text"><![CDATA[一般来说，在公司或组织规模较小的发展期，都是以做项目为主，即会不断的做新项目。此时应用新技术几乎是零成本的，只要确定新技术可用，直接在新项目中使用即可。 随着组织的发展，工作的重心虽然依然是做新项目，但维护已有项目的压力也已初现端倪。对于已有项目而言，替换新技术或新架构不再是零成本了，不过因为项目本身不大，终归是可做的。 当组织达到一定规模后，就会从做项目转为做产品。此时工作的重心将转移到维护已有项目上。同时这些已有项目已经有了足够的技术积淀，规模也足够庞大，此时再试图替换新技术就是一件极为困难的事了。 然而互联网行业日新月异，应用新技术，保持自身产品的竞争力又是必须的。时至今日，这组矛盾依然是程序员们所必须面对的一大挑战。 具体到Java，每次大的JDK版本的升级既是一场狂欢，又是一场灾难。喜的是可以在Java中使用很多梦寐以求的新技术，悲的是新版本的学习成本倒尚在其次，如何平滑的将新版本应用于已有项目才是难点所在。例如JDK1.5中发布了自动装箱，泛型，动态注解，枚举，变长参数，增强for循环等影响深远的新功能，不用吧，看着实在是眼红。用吧，旧版本的代码又不能兼容，总之是陷入两难的境地中。 很多公司干脆采取了简单粗暴的做法：如果这次JDK的大版本更新所带来的新内容足够震撼，那么干脆就舍弃旧代码，用新版本做一次重构。这样的好处自然是简单粗暴，坏处却也很明显：如果项目规模已足够大，那么重构本身是很花成本的事情。此外，JDK最近的大版本有日渐提速的趋势，照顾着JDK版本进行重构显然不利于项目的架构规划。 为此，Java逆向移植工具(Java Backporting Tools)应运而生。本文将介绍其中的佼佼者：Retrotranslator。 Retrotranslator的作用是将JDK1.5编译出的class文件转换为可在JDK1.4或JDK1.3上部署的版本。转换后依然可以很好的支持自动装箱，泛型，动态注解，枚举，变长参数，增强for循环，静态导入等语法特性。甚至还可以支持JDK1.5中新增的集合改进，并发包以及对泛型，注解等的反射操作。 那么Retrotranslator是如何做到的呢？在讨论这个问题之前，我们需要先明确一下，一次JDK的大版本更新通常会提供哪些新内容。简单来说，可分为以下4类： javac编译器层面的改进。如JDK1.5新增的自动装箱拆箱，其本质实际上就是编译器在程序中使用到包装类对象的地方自动插入了很多诸如Integer.valueOf()之类的代码。JDK1.5提供的变长参数则是在javac编译后会被自动转化为数组。而对于JDK1.5新增的泛型，则会在编译阶段直接被javac编译器擦除(不过在元数据中依然还保留着泛型相关的信息)，同时在相应的地方由javac编译器自动插入类型转换代码。 增加Java API。例如JDK1.2时新增的java.util.Collections等一系列集合框架类。JDK1.5时新增的java.util.concurrent并发包等。 更新底层的字节码指令集。这种改动相对少见。例如JDK1.7新增的动态类型支持，就需要在字节码指令集中新增一条指令invokedynamic。 改进JVM。这类改动往往会从本质上影响程序的性能，但对程序员开发代码而言却基本是透明的。例如JDK1.5时重新定义了Java内存模型(Java Memory Model,JMM)等。 在这4种改动中，Retrotranslator等逆向移植工具只能模拟前两种。这其实很好理解：逆向移植工具所做的工作仅仅只是转换class文件，相当于二次编译。因为依然是跑在旧版本的JVM内，那么JVM内部的优化自然是无法模拟，或者更精确的说，是无法做到完全的模拟，而且能模拟的部分，也一定是用一个取巧的手段，以牺牲性能为代价，最终达到一种似是而非的效果。 我们再具体到能模拟的那前两种改动中。其中第二种改动的模拟是要相对容易些的。因为所谓的Java API层面的改进无非就是加入或者更新了一部分代码。而这一部分代码所使用的底层指令集其实还是老版本那一套，因此只要在转换时将缺少的代码补上即可。例如JDK1.5中新增的java.util.concurrent并发包，实际上是由多线程大师Doug Lea在JDK1.5之前就已经开发好的一套并发包(那时被称为dl.util.concurrent)。因其性能卓越，在JDK1.5时被作为标准API引入Java核心API类库，引入后定名为java.util.concurrent，其内容基本与原始的dl.util.concurrent一致，只是由作者及JDK的开发人员一起做了小幅的改动。Retrotranslator中替代java.util.concurrent并发包的类库为另一个基于dl.util.concurrent改进而得的并发包类库backport-util-concurrent.jar。 而对于第一种改进的模拟则要复杂得多了。Retrotranslator的实现方式为通过ASM框架直接操作字节码。最容易想到也最为简单的需改动的内容就是改动class文件中的minor_version。当然实际需要改动得要比这个复杂得多，不过这一切都是可做的。而这个可做的基础就在于这些改动都是可以收束到javac编译器这一层的，更直白的说，这种改动根本不涉及JVM，因此我们才可以采用这种类似于二次编译的方式实现它。 我们不妨以JDK1.5时新增的枚举为例。虽然从程序员的角度来看，引入了全新的关键字enum，同时Enum也仿佛是与Class及Interface并列的第三种类型，但这一切其实都是javac编译器做出来的假象。实际上，在编译为class文件之后，从JVM的角度来看，枚举类仅仅是一个继承于java.lang.Enum，自动生成values()及valueOf()方法的普通Java类而已。既然不需要JVM新功能的支持那么逆向移植工具就可以通过二次编译在旧版本JDK环境中实现枚举了，因为class文件常量池集合中描述枚举时用的依然是CONSTANT_Class_info，也就是javac也是依然将枚举当成一个类来看的，并未为了枚举添加CONSTANT_Enum_info之类的枚举符号引用常量。 Retrotranslator对于枚举的整体思路为首先将枚举类的父类从java.lang.Enum替换为它自身所包含的net.sf.retrotranslator.runtime.java.lang.Enum_，然后再在类和字段的访问标志中抹去ACC_ENUM标志位。当然这其中有很多复杂的细节，例如既然父类被替换了，那么values()及valueOf()方法自然需要重写，常量池中也要引入大量来自新父类的符号引用。]]></content>
      <categories>
        <category>Java 反射</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 反射-动态代理]]></title>
    <url>%2F2017%2F12%2F19%2FJava%20%E5%8F%8D%E5%B0%84-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[提到字节码生成技术，大家往往都会想到Javassist,CGLib,ASM等操作字节码的类库，给人一种很酷炫的感觉。实际上字节码生成技术距离我们并没那么遥远。在我们接触Java伊始遇到的javac编译器就是一个用Java写成的字节码生成器。此外Web服务器中的JSP编译器，编译时植入的AOP框架，甚至JVM在实现反射时都有可能会在运行时生成字节码以提高执行速度。 本文所讨论的反射中的动态代理技术就是字节码生成技术中一个相对简单的应用。 对于很多程序员而言，动态代理并不熟悉，也没接触过java.lang.reflect.Proxy或java.lang.reflect.InvocationHandler。不过我想大部分人都用Spring框架做过Bean的组织管理，而Spring的Bean管理本质上应用的就是动态代理技术。 如果我们将程序员手写代理类的方式称为静态代理的话，那么动态代理指得就是代理类无需程序员编写，将由JVM自动生成。动态代理的优势并不在于节省程序员编写代理类的那一点点的开发成本，而是从本质上提高程序的灵活性：动态代理可以在原始类和接口还未知的时候，就确定代理类的代理行为。这样就实现了代理类与原始类的解耦，从而能让代理类灵活的重用于不同的应用场景中。 静态代理： 12345678910111213141516171819202122232425262728public class Test &#123; public static void consumer(ProxyInterface pi) &#123; pi.say(); &#125; public static void main(String[] args) &#123; Test.consumer(new ProxyObject()); &#125;&#125;interface ProxyInterface &#123; public void say();&#125;class RealObject implements ProxyInterface &#123; @Override public void say() &#123; System.out.println(&quot;say&quot;); &#125;&#125;class ProxyObject implements ProxyInterface &#123; @Override public void say() &#123; new RealObject().say(); &#125;&#125; 输出： 1say 改造为动态代理： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class Test &#123; public static void customer(ProxyInterface pi) &#123; pi.say(); &#125; public static void main(String[] args) &#123; RealObject real = new RealObject(); ClassLoader loader = ProxyInterface.class.getClassLoader(); Class&lt;?&gt;[] interfaces = new Class[]&#123;ProxyInterface.class&#125;; InvocationHandler h = new ProxyObject(real); ProxyInterface proxy = (ProxyInterface)Proxy.newProxyInstance(loader, interfaces, h); Test.customer(proxy); &#125;&#125;interface ProxyInterface &#123; void say();&#125;class RealObject implements ProxyInterface &#123; @Override public void say()&#123; System.out.println(&quot;say&quot;); &#125;&#125;class ProxyObject implements InvocationHandler &#123; private Object real = null; public ProxyObject(Object real) &#123; this.real = real; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; return method.invoke(this.real, args); &#125;&#125; 输出： 1say 上述动态代理的代码中最核心的方法就是Proxy.newProxyInstance()了。该方法返回了一个实现ProxyInterface接口，实际业务逻辑类型是RealObject的动态代理类。该代理类程序员并未编写，是在运行期动态生成的。 如果我们跟踪方法Proxy.newProxyInstance()的源码，会发现它进行了验证，优化，缓存，同步，生成字节码，显式类加载等操作。其中最重要的是生成字节码的操作，也是本方法的核心功能点，是通过sun.misc.ProxyGenerator.generateProxyClass()方法完成的。该方法生成的就是动态代理类的字节码，其基本思路并不复杂，基本就是在模仿javac编译器，为接口中定义的每一个方法，以及从java.lang.Object中继承来的equals(),hashCode(),toString()都生成对应的实现，实现的具体的逻辑由程序员写在实现InvocationHandler接口的对象的invoke()方法中。 需要注意的是，使用上述方法实现的动态代理技术是比较原始和粗糙的，实现的动态代理类也是高度模板化的，虽说是动态的，但灵活度并没有那么高。因此实际开发中，还是推荐大家使用大神们已经封装好的各种操作字节码的类库。这二者的关系就好比Javascript与Jquery。]]></content>
      <categories>
        <category>Java 反射</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>反射</tag>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat-CATALINA_HOME与CATALINA_BASE]]></title>
    <url>%2F2017%2F12%2F12%2FTomcat-CATALINA_HOME%E4%B8%8ECATALINA_BASE%2F</url>
    <content type="text"><![CDATA[如果同一台机器上只需要起一个Tomcat实例，那么是不涉及本文要探讨的问题的。不过如果要起多个实例呢？这在日常开发中确实是很常见的需求：例如多个程序员共用一台测试机，他们都需要在上面部署自己的Tomcat(显然将他们的应用都丢到一个Tomcat下是不合理的，因为没人希望启动自身应用时会带着把其他人的应用也启动起来)。 一个简单可行的解决方案就是将Tomcat复制为几个独立的副本，然后各自修改Tomcat的启动参数，例如端口，JVM参数等。 这个方法简单粗暴，然而却不那么优雅：因为通常修改的其实仅仅就只有启动参数，而绝大多数的资源，例如jar包，Tomcat的核心配置参数等都是重复的。当然也会有不通常的情况：某个实例要用Tomcat5而另一个要用Tomcat7。不过这个只是小概率事件，绝大多数时候都只需要改配置。 CATALINA_BASE就是为了解决这个问题而诞生的。简单来说，CATALINA_HOME是Tomcat的安装目录，CATALINA_BASE是Tomcat的工作目录。安装目录中存放的是Tomcat中可共享的资源，只有一个。而工作目录则是每个Tomcat实例对应一个，其中只存放自身特殊的配置信息，核心信息还是要去安装目录读取。 举个小例子。我的环境为Windows7，用于测试的Tomcat版本为apache-tomcat-7.0.82。其目录结构如下： 它的存放路径为 1D:\test\apache-tomcat-7.0.82 我们不妨将其设为CATALINA_HOME，即安装目录。然后我们再在其所在的目录中新建两个目录用于存放Tomcat实例： 即tomcat1及tomcat2的路径就是对应Tomcat实例的CATALINA_BASE，即工作目录。 现以实例tomcat1为例，将安装目录中每个实例私有的数据： 复制到目录tomcat1下。 当然为了能够同时启动各个实例，我们还必须为每个实例设置不同的监听端口。其位置在tomcat1目录下的conf/server.xml中。这里我们均保持默认值： 12345678&lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot;&gt; &lt;Service name=&quot;Catalina&quot;&gt; &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; &lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt; &lt;/Service&gt;&lt;/Server&gt; 为了启动方便，我们还可以在tomcat1目录下添加一个小脚本startup.bat： 1234set &quot;CATALINA_BASE=%cd%&quot;set &quot;CATALINA_HOME=D:\test\apache-tomcat-7.0.82&quot;set &quot;EXECUTABLE=%CATALINA_HOME%\bin\catalina.bat&quot;call &quot;%EXECUTABLE%&quot; start 同理，我们可以继续配置实例tomcat2，当然要给它一个不同的端口，例如： 12345678&lt;Server port=&quot;8006&quot; shutdown=&quot;SHUTDOWN&quot;&gt; &lt;Service name=&quot;Catalina&quot;&gt; &lt;Connector port=&quot;8088&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; &lt;Connector port=&quot;8010&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt; &lt;/Service&gt;&lt;/Server&gt; 依次双击tomcat1及tomcat2目录下的startup.bat。这样这两个实例便同时启动起来了： 至此，CATALINA_BASE便已介绍完毕了。我本人是很少用这个功能的，即便需要在同一个机器上起多个Tomcat实例，我往往也会采取本文最开始介绍的那种不那么”优雅”的做法。原因主要在于那样简单粗暴，不需要像后者这样配置来配置去。同时损失的不过是一点点磁盘空间而已，通常完全可以接受。]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM-字节码解释执行引擎]]></title>
    <url>%2F2017%2F12%2F11%2FJVM-%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[JVM对于字节码指令的执行方法有两种： 解释执行：通过解释器执行。 编译执行：通过即时编译器(JIT)产生本地代码执行。 本文重点探讨解释执行的具体过程。 解释执行与编译执行在真正开始讲解解释执行的具体过程之前，我想先提纲挈领的描述下解释执行与编译执行的区别。 Java经常会被人(尤其是主语言是其他开发语言的程序员)定位为解释执行的语言。其原因就在于1996年JDK1.0诞生时，其所使用的默认JVM为Sun Classic VM，这是一个纯解释执行的JVM，因此此时这样定位尚属准确。而到了1998年JDK1.2时，虽然默认JVM依然是Sun Classic VM，然而此时Sun Classic VM已不是唯一的JVM了，HotSpot VM这个解释与编译混合执行的JVM已被作为可选JVM加入JDK。而到了2000年的JDK1.3，HotSpot VM成为了默认JVM，Sun Classic VM降为可选JVM(JDK1.2到JDK1.3默认JVM的变化正所谓扶上马送一程)。自此以后用解释执行来描述Java就不再准确了，因为Class文件中的内容到底会被解释执行还是编译执行，就成了只有JVM自己才能准确判断的事情了。因此准确来说，Java是一门解释与编译混合执行的语言。 不过说真的，空洞的从理论上争论一个语言到底是解释执行还是编译执行其实意义并没有那么大。关键还是要结合实现，具体问题具体分析。高级编程语言也发展了这么多年了，其实际套路已无法完全遵循最初制定的框架(也就是计划赶不上变化)，C与C++现在也已经有了通过解释器执行的版本(如CINT)。而Java也不总是编译期与运行期断为两截了，也出现了直接将.java编译为本地机器代码的编译器(如GNU Compiler for the Java，即GCJ)。因此我们平常所说的”C/C++是编译执行的语言”，”Java是解释与编译混合执行的语言”等等所指的都是主流情况，而无法涵盖全部(因为实在也没必要较那个真)。 其实无论是基于物理机，JVM，亦或是其他的高级语言虚拟机(High Level Language Virtual Machine,HLLVM)，现代高级编程语言的执行流程都大同小异。在逻辑上基本不出下图的藩篱： 显然，最下面那行对应编译执行，中间那行对应解释执行。而中间那行中的”指令流”一步指的自然是javac编译器生成.class文件的过程了。 上图中的思路即为现代经典编译原理的思路。在执行前先对程序源码进行词法分析和语法分析处理，把源码转化为抽象语法树(Abstract Syntax Tree,AST)。具体到每一门语言，这一步大体上会有3种实现思路： 词法分析，语法分析，乃至后续的优化器及目标代码生成器等一切编译相关的组件均独立于执行器实现，形成一个完成的编译器。例如C/C++。 将一部分组件(例如生成抽象语法树之前的步骤)实现为一个独立的编译器，而后续的步骤则与执行器混合在一起。例如Java。 将所有的编译组件及执行组件均封装在一个黑盒中，例如大多数的JavaScript(JavaScript真不愧是以简单暴躁著称)。 或者我们可以更具体一些，对于JDK而言，javac编译器完成了上图中程序源码到第二行中指令流之间的过程。因为这一部分动作是在JVM之外进行的，而解释器在JVM内部，所以我们也说Java的编译器是半独立实现的(JVM之外javac实现的那部分是独立的，而JVM内部的那部分则不是)。 基于栈的指令集与基于寄存器的指令集JVM基本上是一种基于栈的指令集架构(Instruction Set Architecture,ISA)，指令依赖方法区-局部变量表-操作数栈进行工作。之所以说基本上，是因为纯粹的基于栈的指令集架构中的指令应该全部都是零地址指令，或者说是不带参数的指令。而JVM的指令集中有小部分指令是需要参数的。之所以做这个变通，是为了提高代码的可校验性。 与基于栈的指令集架构相对的另一套同样很常用的指令集架构是基于寄存器的指令集架构。最典型的就是x86的二地址指令集架构，或者更通俗的说，就是现在主流的PC微型机中直接支持的指令集架构，其中的指令依赖寄存器进行工作。那么，二者之间有何不同呢？ 举个小例子，如果要计算1+1的结果，那么对于JVM中的基于栈的指令集而言是这样的： 1234iconst_1 // 将1压入操作数栈iconst_1 // 将1压入操作数栈iadd // 弹出操作数栈栈顶的两个int型元素求和后再将int型结果压回操作数栈istore_0 // 将操作数栈栈顶的int型元素弹出并存入局部变量表索引为0的Slot中 如果是针对基于寄存器的指令集架构的pc机而言，那么1+1是这样的： 12mov eax, 1 // 将eax寄存器的值设为1add eax, 1 // 将eax寄存器中的值加1并存回eax寄存器 那么这两套指令集哪一个更好一些呢？ 其实这两套指令集能齐头并进的共同发展这么多年，本身便已给出答案了：自然是各有其优劣之处：某些场景下基于寄存器的指令集更好，另一些场景下则是基于栈的指令集更优秀一些。 基于栈的指令集较之基于寄存器的指令集最大的优势就在于栈更为抽象，从而易于移植。基于寄存器的指令集中所使用的寄存器往往由物理机在硬件上直接提供(之所以说往往，是因为也有基于虚拟机寄存器的例子。例如Google Android平台的Dalvik VM。不过，即便是基于虚拟机寄存器，也希望把虚拟机寄存器尽量映射到物理寄存器上以获得更高的性能)，这就不可避免的会受到硬件的约束。例如，32位80x86体系(主流PC机)的CPU提供了8个32位的寄存器，而ARM(主流手机)的CPU则提供了16个32位的通用寄存器。若使用基于寄存器架构的指令集，用户在编写指令时必须针对不同的物理寄存器设计不同的代码。而使用基于栈的指令集则屏蔽了这些底层的细节，用户使用的是抽象过的栈，至于具体的底层实现则交由虚拟机完成。 总结来说，基于栈的指令集会让程序员更为舒服，那么此消彼长，实际工作的虚拟机就不那么舒服了。上文中”具体的底层实现则交由虚拟机完成”意味着此时虚拟机需要做更多的操作，从而降低执行速度。因此，几乎所有主流的物理机的指令集都是基于寄存器的(因为也没什么可迁移的)。 通过上文1+1的小例子也可以看出：实现同一个功能，栈架构所用的指令往往要比寄存器架构所用的指令多(正如高级语言的源码通常会比汇编长那样)，因为对于实际功能而言，出栈入栈其实是多余的操作(更本质的来说，栈本身其实就是个多余的东西，因为虚拟机总归是要跑在物理机上的，而物理机又大多是基于寄存器的，因此最终干活的依然是寄存器。换句话说，栈架构相当于在寄存器架构的基础上为了便于迁移和理解加入了新的操作，自然就更长了)。 说栈架构比寄存器架构慢，上文给出的原因其实只是次要原因，更重要的是，栈并不是物理机实际提供的一个硬件，它只是存在于内存中的一个抽象概念。寄存器是距离CPU最近的存储单元，其次是缓存，然后才是内存。使用栈意味着指令中的那些出栈入栈其实都是CPU在与内存交互，尽管部分热点数据会进入缓存甚至寄存器，然而这无法从本质上解决问题，毕竟栈的主体依然还在内存中，而且频繁的内存-缓存-寄存器间数据的流动本身就是一项开销，因此栈架构比寄存器架构要慢很多。 JVM的解释器的执行过程既然说JVM是基于栈的指令集架构的，那么下面就具体说说其解释器的执行过程。 首先我们看一个小例子： 123456789public class Test &#123; public int calc() &#123; int a = 100; int b = 200; int c = 300; return (a + b) * c; &#125;&#125; 然后我们用javap将这段代码反编译，我们只看其中的calc()方法的Code属性： 123456789101112131415public int calc(); Code: stack=2, locals=4, args_size=1 0: bipush 100 2: istore_1 3: sipush 200 6: istore_2 7: sipush 300 10: istore_3 11: iload_1 12: iload_2 13: iadd 14: iload_3 15: imul 16: ireturn 这段信息首先告诉我们： 1stack=2, locals=4, args_size=1 即操作数栈的最大深度为2，局部变量表的长度为4个Slot，传入参数个数为1(this)。 现在我们以如下7张图描述解释器的执行过程： 需要说明的是，上面的过程仅仅是理论上的概念模型，而大多数的JVM实现都会做一些优化来提高性能，因此实际运行起来通常不会与这个概念模型完全相同。其实更准确的说，主流JVM的实际情况会与这个概念模型的差别非常大。例如HotSpot的指令集中有很多以”fast_”开头的非标准字节码指令用于合并，替换输入的字节码以提升解释执行的性能。而对于即时编译器(JIT)而言，优化的手段就更加花样繁多了。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>Java虚拟机</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java IO-File类]]></title>
    <url>%2F2017%2F12%2F09%2FJava%20IO-File%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[java.io.File类以文件的全路径名为核心要素，操作文件的各项属性。换句话说，一个File类的实例就代表一个文件。这里需要注意的是在File类眼中我们通常意义上的文件和目录并没有本质上的区别，在大的类别上都会被其视为文件。 统一的分隔符以Windows系统为例，E盘下的a目录下的b.txt文件的全路径名可表示为： 1E:\a\b.txt 但是我们却无法直接在Java中定义这样的字符串： 1String filePath = &quot;E:\a\b.txt&quot;; 会无法通过编译，Eclipse中的提示为： 1Invalid escape sequence (valid ones are \b \t \n \f \r \&quot; \&apos; \\ ) 很显然，’\’这个字符是转义字符的前置标记，像上例那么写会引起编译器的迷惑，它不知道我们是真的想输出’\’还是想将’\’后的字符转义。因此，如果我们真的想输出’\’，只能这样写： 1String filePath = &quot;E:\\a\\b.txt&quot;; 从书写的角度上来讲，这是不符合人类的认知习惯的。 不仅如此，以上仅仅只是Windows系统的路径规范，到了其他操作系统中一般都会有所不同。例如Linux系统中类似文件的全路径为: 1e/a/b.txt 此时就不涉及转义问题而可直接在Java中声明： 1String filePath = &quot;e/a/b.txt&quot;; 这其实是相悖于Java的平台无关性口号的，因为我们此时已经需要根据底层操作系统的不同编写不同的代码了。同时还牵扯到让人难以理解的转义问题。 为了最大限度的解决这个问题，File类中提供了读取系统目录连接字符的类变量： 1public static final char separatorChar = fs.getSeparator(); 这个字段读出来的就是当前系统的连接符了。例如Windows下是’\’，而Linux下是’/‘。并且也不会涉及到转义的问题。 考虑到比起char，大家应该更习惯使用String，因此File类中还贴心的提供了String版本的连接符： 1public static final String separator = &quot;&quot; + separatorChar; 这样在我的Windows系统中的下述代码： 1234567891011import java.io.File;public class Test &#123; public static void main(String[] args) &#123; StringBuilder sb = new StringBuilder(&quot;E:&quot;).append(File.separator) .append(&quot;a&quot;) .append(File.separator) .append(&quot;b.txt&quot;); System.out.println(sb.toString()); &#125;&#125; 输出： 1E:\a\b.txt 最后需要说明的是，虽然Windows系统下默认的连接符是’\’，然而Java却也没那么死板。写成’/‘在Windows系统中其实也能识别： 12345678import java.io.File;public class Test &#123; public static void main(String[] args) &#123; File file = new File(&quot;E:/a/b.txt&quot;); System.out.println(file.getPath()); &#125;&#125; 输出： 1E:\a\b.txt 很显然，输出结果又变回了Windows系统默认的’\’，显然是其内部有所转换。当然这个灵活性也要有个限度，例如Windows系统下如果写成这个样子： 1File file = new File(&quot;E/a/b.txt&quot;); 再或者： 1File file = new File(&quot;/E/a/b.txt&quot;); 再或者： 1File file = new File(&quot;E\\a\\b.txt&quot;); 再或者： 1File file = new File(&quot;\\E\\a\\b.txt&quot;); 总之，要是连盘符划分都去掉，即不写”:”，那只靠Java API核心类库是肯定读不出文件的。 因此个人建议干脆放弃这个其实不那么灵活的灵活性，既然File类中已经给出了类变量，那么就尽量不要写硬编码。退一步讲，即便写了硬编码，也最好用系统默认的连接符。例如如果要使用Windows系统的文件系统，那么连接符就用’\’，而不是’/‘。 构造函数123456789101112import java.io.File;public class Test &#123; public static void main(String[] args) &#123; String path = new StringBuilder(&quot;D:&quot;).append(File.separator) .append(&quot;a&quot;) .toString(); File file = new File(path); System.out.println(file.getPath()); System.out.println(file.exists()); &#125;&#125; 输出： 12D:\afalse 直接以全路径名构建File对象。这是最直接也是最常用的构造方式。注意构建File对象并不需要被构建的文件一定真实存在，例如本例中就是这样。 12345678910111213import java.io.File;public class Test &#123; public static void main(String[] args) &#123; String path0 = new StringBuilder(&quot;D:&quot;).append(File.separator) .append(&quot;a&quot;) .toString(); File file0 = new File(path0); File file1 = new File(file0, &quot;b.txt&quot;); System.out.println(file1.getParent()); System.out.println(file1.getPath()); &#125;&#125; 输出： 12D:\aD:\a\b.txt 因为目录结构总是有所属关系的，因此在已有File对象内部(此时该File对象必定是个目录)创建新File对象也是常见的需求。这比直接使用全路径名创建File对象更符合层级关系，某些情况下更易于被开发人员所理解。例如上例中，我们就以file0为父目录，创建了新文件file1。 当然，上文所说的”该File对象必定是个目录”在构造File对象时依然没有检查(连是否存在都不检查又怎么会检查到底是文件还是目录呢？)。由此可见，File类的检查限制是相对宽松的：磁盘中实际存在的文件是一回事，内存中声明的File对象又是另一回事。为什么这么做的原因也是很好理解的：Java怎么会知道你新建一个File对象的目的是什么呢？也许你就是想在磁盘上新创建一个本不存在的文件呢？此时没有才是正常的。因此除非具体操作产生矛盾(例如明明磁盘上没有这个文件却当是有那样读里面的内容，再或者明明实际是个文件却当是目录那样在内部创建新文件等等)，否则不会在创建File对象时就进行严格的检查。 如果父目录还没来得及生成File对象，也可按如下方式来做： 123456789101112import java.io.File;public class Test &#123; public static void main(String[] args) &#123; String path0 = new StringBuilder(&quot;D:&quot;).append(File.separator) .append(&quot;a&quot;) .toString(); File file1 = new File(path0, &quot;b.txt&quot;); System.out.println(file1.getParent()); System.out.println(file1.getPath()); &#125;&#125; 输出： 12D:\aD:\a\b.txt 显然，效果是一样的。 我们还可以以URI对象为核心构造File类对象： 123456789101112import java.io.File;import java.net.URI;import java.net.URISyntaxException;public class Test &#123; public static void main(String[] args) throws URISyntaxException &#123; URI uri = new URI(&quot;file:/D:/a&quot;); File file = new File(uri); System.out.println(file.getPath()); System.out.println(file.exists()); &#125;&#125; 输出： 12D:\afalse URI(Uniform Resource Identifier)，即统一资源标识符，一如其名，即试图用一个统一的格式描述来源不同的资源文件。正如上例中提到的，存储于文件系统中的URI字符串为： 1file:/D:/a 依据URI，我们同样可以构建出对应的File类对象。显然构建URI类对象时仍然不会检查资源是否存在。 关于URI，还需注意的一点是，它已经是超脱于实际操作系统之上的抽象概念了。因此其资源路径的表示方法是固定的，和具体的操作系统无关。上例中，不管使用什么文件系统，都是(当然，Linux下D:中的盘符:要去掉)： 1URI uri = new URI(&quot;file:/D:/a&quot;); 即便在Windows系统中，使用 1URI uri = new URI(&quot;file:\\D:\\a&quot;); 也是错误的。 File对象是否真的存在假设：D盘下有目录a，a中有文件b.txt。 1234567891011121314import java.io.File;public class Test &#123; public static void main(String[] args) &#123; String path0 = new StringBuilder(&quot;D:&quot;).append(File.separator) .append(&quot;a&quot;) .toString(); File file0 = new File(path0); File file1 = new File(file0, &quot;b.txt&quot;); System.out.println(file0.exists()); System.out.println(file1.exists()); &#125;&#125; 输出： 12truetrue 实际是目录还是文件假设：D盘下有目录a，a中有文件b.txt。 123456789101112131415import java.io.File;public class Test &#123; public static void main(String[] args) &#123; String path0 = new StringBuilder(&quot;D:&quot;).append(File.separator) .append(&quot;a&quot;) .toString(); File file0 = new File(path0); File file1 = new File(file0, &quot;b.txt&quot;); System.out.println(file0.isDirectory()); System.out.println(file0.isFile()); System.out.println(file1.isDirectory()); System.out.println(file1.isFile()); &#125;&#125; 输出： 1234truefalsefalsetrue 访问权限假设：D盘下有目录a，a中有文件b.txt。 12345678910111213141516171819import java.io.File;public class Test &#123; public static void main(String[] args) &#123; String path0 = new StringBuilder(&quot;D:&quot;).append(File.separator) .append(&quot;a&quot;) .toString(); File file0 = new File(path0); File file1 = new File(file0, &quot;b.txt&quot;); System.out.println(file0.isHidden()); System.out.println(file0.canRead()); System.out.println(file0.canWrite()); System.out.println(file0.canExecute()); System.out.println(file1.isHidden()); System.out.println(file1.canRead()); System.out.println(file1.canWrite()); System.out.println(file1.canExecute()); &#125;&#125; 输出： 12345678falsetruetruetruefalsetruetruetrue 需要注意的是，a作为一个目录也被判为可执行了。显然这些权限判断方法仅仅关心是否有权限，至于被操作的对象能不能做到则不在乎。这又是和整个File类一脉相承的设计思路一致。 最后修改时间假设：D盘下有目录a 12345678910111213import java.io.File;import java.util.Date;public class Test &#123; public static void main(String[] args) &#123; String path = new StringBuilder(&quot;D:&quot;).append(File.separator) .append(&quot;a&quot;) .toString(); File file = new File(path); long time = file.lastModified(); System.out.println(new Date(time)); &#125;&#125; 输出： 1Sun Dec 10 21:30:33 CST 2017 基本信息假设：D盘下有目录a，a中有文件b.txt。 123456789101112131415161718import java.io.File;public class Test &#123; public static void main(String[] args) &#123; String path0 = new StringBuilder(&quot;D:&quot;).append(File.separator) .append(&quot;a&quot;) .toString(); File file0 = new File(path0); File file1 = new File(file0, &quot;b.txt&quot;); System.out.println(file0.getName()); // 简单文件名 System.out.println(file0.getPath()); // 全路径名 System.out.println(file0.length()); // 长度，单位为byte(目录的长度默认为0) System.out.println(&quot;=======================&quot;); System.out.println(file1.getName()); // 简单文件名 System.out.println(file1.getPath()); // 全路径名 System.out.println(file1.length()); // 长度，单位为byte &#125;&#125; 输出： 1234567aD:\a0=======================b.txtD:\a\b.txt11405 父文件所谓父文件，若某文件在某目录下，那么该目录就相当于该文件的父文件。假设：D盘下有目录a，a中有文件b.txt。此时a是b.txt的父文件。D:是a的父文件。显然只有目录才有资格做父文件： 123456789101112131415161718import java.io.File;public class Test &#123; public static void main(String[] args) &#123; String path0 = new StringBuilder(&quot;D:&quot;).append(File.separator) .append(&quot;a&quot;) .toString(); File file0 = new File(path0); File file1 = new File(file0, &quot;b.txt&quot;); System.out.println(file0.getParent()); // 获得父文件全路径名 File file0p = file0.getParentFile(); // 获得父文件实例 System.out.println(file0p.getPath()); System.out.println(&quot;=======================&quot;); System.out.println(file1.getParent()); File file1p = file1.getParentFile(); System.out.println(file1p.getPath()); &#125;&#125; 输出： 12345D:\D:\=======================D:\aD:\a 那么我们不禁好奇，作为顶层目录的D盘的父文件会是什么呢？ 1234567891011import java.io.File;public class Test &#123; public static void main(String[] args) &#123; String path = new StringBuilder(&quot;D:&quot;).append(File.separator) .toString(); File file = new File(path); System.out.println(file.getParent()); System.out.println(file.getParentFile()); &#125;&#125; 输出： 12nullnull 输出都是null，合情合理。 获得目录下所有内容123456789101112131415import java.io.File;public class Test &#123; public static void main(String[] args) &#123; String path = new StringBuilder(&quot;D:&quot;).append(File.separator) .toString(); File root = new File(path); for(File file : root.listFiles()) &#123; String type = file.isFile() ? &quot;文件&quot; : &quot;文件夹&quot;; String hiden = file.isHidden() ? &quot;(隐藏)&quot; : &quot;(可见)&quot;; System.out.println(type + hiden + &quot;\t&quot; + file.getName()); &#125; &#125;&#125; 输出： 12345678910111213141516文件夹(隐藏) $RECYCLE.BIN文件夹(隐藏) 15055文件夹(隐藏) 360Downloads文件夹(隐藏) 360Rec文件夹(隐藏) Driver文件夹(可见) game文件夹(隐藏) MSOCache文件夹(可见) program文件夹(隐藏) SoftwareDistribution文件夹(隐藏) System Volume Information文件夹(可见) temp文件(可见) test.txt文件夹(隐藏) WindowsApps文件夹(可见) work文件夹(隐藏) WpSystem文件夹(隐藏) WUDownloadCache 实际创建文件12345678910111213import java.io.File;import java.io.IOException;public class Test &#123; public static void main(String[] args) throws IOException &#123; String path = new StringBuilder(&quot;D:&quot;).append(File.separator) .append(&quot;Reimu.txt&quot;) .toString(); File file = new File(path); System.out.println(file.createNewFile()); &#125;&#125; 在没有D:\Reimu.txt的前提下，上述代码执行后，D:\Reimu.txt会被创建。程序输出true。 记录下此时的文件属性： 那么我们不禁会想：如果创建前文件已存在会怎么样呢？于是再次执行代码。程序输出false。再看D:\Reimu.txt，发现没有任何变化。 难道说，如果待创建文件已存在，便输出一个false，然后什么都不做吗？ 为了验证上述猜想，我们不妨手动修改D:\Reimu.txt的内容，比如在其中添加文本：魔理沙么么哒。然后此时我们再看文件属性： 理所当然的，文件大小及修改时间发生了相应的变化。此时我们再执行上述代码，依然输出false。随后我们再观察D:\Reimu.txt的属性，发现没有任何变化，内容也依然是魔理沙么么哒(若代码生效了内容应被替换为空文件)。说明猜想成立。 实际创建目录12345678910111213import java.io.File;import java.io.IOException;public class Test &#123; public static void main(String[] args) throws IOException &#123; String path = new StringBuilder(&quot;D:&quot;).append(File.separator) .append(&quot;Reimu.txt&quot;) .toString(); File file = new File(path); System.out.println(file.mkdir()); &#125;&#125; 在没有D:\Reimu.txt存在的情况下，上述代码输出true。并成功创建了目录D:\Reimu.txt。注意这里创建的Reimu.txt看似是txt文件，然而实则是目录。我之所以起这么诡异的名字，就是为了说明Java之所以统一使用File类描述文件和目录，在底层没有对二者做本质上的区分是有道理的：因为确实也没那么大的差别，起码无法从名字上就能确认到底是文件还是目录。 同理，我们再执行一次上述代码，输出false。说明创建失败，什么都不做。 需要注意的是，若D盘下存在文件Reimu.txt(注意，这次真的是文件了，不是目录)，此时执行上述代码依然输出false。说明即便一个是目录，一个是文件，依然不允许重名。事实上，如果在Windows系统下通过图形化界面直接这么做，依然不会通过： 看来不仅是Java，Windows系统也没有对文件和目录做本质上的区分。 然后我们再看以下代码： 123456789101112131415import java.io.File;import java.io.IOException;public class Test &#123; public static void main(String[] args) throws IOException &#123; String path = new StringBuilder(&quot;D:&quot;).append(File.separator) .append(&quot;dir1&quot;) .append(File.separator) .append(&quot;dir2&quot;) .toString(); File file = new File(path); System.out.println(file.mkdir()); &#125;&#125; 目录dir1及目录dir2均不存在，此时执行上述代码输出false。D盘下也未创建任何目录。这也很合理：dir1都不存在，自然无法创建其里层的dir2。但同时这又是一个很常见的需求，就是要直接连续创建目录，难道此时只能将创建过程断成很多截，一层目录一层目录的创建吗？ 为了解决这个问题，File类提供了如下解决方案： 123456789101112131415import java.io.File;import java.io.IOException;public class Test &#123; public static void main(String[] args) throws IOException &#123; String path = new StringBuilder(&quot;D:&quot;).append(File.separator) .append(&quot;dir1&quot;) .append(File.separator) .append(&quot;dir2&quot;) .toString(); File file = new File(path); System.out.println(file.mkdirs()); &#125;&#125; 目录dir1及目录dir2均不存在，此时执行上述代码输出true。同时按目录层级D:\dir1\dir2创建了目录dir1及目录dir2。 实际删除文件/目录12345678910111213import java.io.File;import java.io.IOException;public class Test &#123; public static void main(String[] args) throws IOException &#123; String path = new StringBuilder(&quot;D:&quot;).append(File.separator) .append(&quot;1.txt&quot;) .toString(); File file = new File(path); System.out.println(file.delete()); &#125;&#125; 已有文件D:\1.txt的前提下，上述代码执行后输出true。同时磁盘中的文件被删除。需要注意的是，这种删除方式非常霸道：被删除的文件是彻底被删除了，并非被放到回收站等缓冲地带中。 当然，若待删除文件实际不存在，则输出false，并什么都不做。 关于目录的删除方式大同小异： 12345678910111213import java.io.File;import java.io.IOException;public class Test &#123; public static void main(String[] args) throws IOException &#123; String path = new StringBuilder(&quot;D:&quot;).append(File.separator) .append(&quot;dir1&quot;) .toString(); File file = new File(path); System.out.println(file.delete()); &#125;&#125; D盘下存在目录dir1，dir1中为空。上述代码执行后返回true。同时D盘下的dir1被删除，且依然是彻底删除。 不过若dir1下不为空，比如说有目录dir2或文件1.txt，那么上述代码执行后返回false，并且什么都不会做，即只要目录下有内容就不会删除目录。这样设计是很有必要的，因为正如我们前文所述，Java的这种删除方法实在是过于霸道且毫无容错机制，那么如果我们一个手抖不小心将删除的目录写成了D:\，如果自动递归删除目录下的所有内容的话，那相当于直接把D盘给格式化了。当然说格式化其实有些过了，因为毕竟有些文件Java是没有操作权限的，不过即便如此，也依然是够糟糕的了。 小例子：递归打印目录层级12345678910111213141516171819202122232425262728293031323334353637383940414243import java.io.File;public class Test &#123; private static void printFileSystemRecursion(File file, int depth) &#123; boolean isDirectory = file.isDirectory(); StringBuilder sb = new StringBuilder(&quot;[&quot;); sb = isDirectory ? sb.append(&quot;d&quot;) : sb.append(&quot;-&quot;); sb = file.canRead() ? sb.append(&quot;r&quot;) : sb.append(&quot;-&quot;); sb = file.canWrite() ? sb.append(&quot;w&quot;) : sb.append(&quot;-&quot;); sb = file.canExecute() ? sb.append(&quot;x&quot;) : sb.append(&quot;-&quot;); sb = file.isHidden() ? sb.append(&quot;.&quot;) : sb.append(&quot;-&quot;); sb.append(&quot;]&quot;).append(file.getName()); for (int i = 0; i &lt; depth; i++) System.out.print(&quot; &quot;); System.out.println(sb.toString()); if (!isDirectory) return; for(File temp : file.listFiles()) Test.printFileSystemRecursion(temp, depth + 1); &#125; private static void printFileSystem(File file) &#123; if (!file.exists()) &#123; System.out.println(file.getPath() + &quot;不存在&quot;); return; &#125; Test.printFileSystemRecursion(file, 0); &#125; public static void main(String[] args) &#123; String path = new StringBuilder(&quot;D:&quot;).append(File.separator) .append(&quot;work&quot;) .append(File.separator) .append(&quot;java&quot;) .append(File.separator) .append(&quot;javaSoft&quot;) .append(File.separator) .append(&quot;jdk&quot;) .append(File.separator) .append(&quot;include&quot;) .toString(); File file = new File(path); Test.printFileSystem(file); &#125;&#125; 输出： 123456789101112131415[drwx-]include [-rwx-]classfile_constants.h [-rwx-]jawt.h [-rwx-]jdwpTransport.h [-rwx-]jni.h [-rwx-]jvmti.h [-rwx-]jvmticmlr.h [drwx-]win32 [drwx-]bridge [-rwx-]AccessBridgeCallbacks.h [-rwx-]AccessBridgeCalls.c [-rwx-]AccessBridgeCalls.h [-rwx-]AccessBridgePackages.h [-rwx-]jawt_md.h [-rwx-]jni_md.h]]></content>
      <categories>
        <category>Java IO</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IO</tag>
        <tag>流</tag>
        <tag>File</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM-动态类型语言支持]]></title>
    <url>%2F2017%2F12%2F08%2FJVM-%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80%E6%94%AF%E6%8C%81%2F</url>
    <content type="text"><![CDATA[一些废话对于是否要写这篇文章，我其实犹豫了很久。因为我个人对Java的这套动态类型语言当前的实现方案可以说是深恶痛绝，根本是连看都不想看到。此前我就曾在另一篇博文JVM-类加载机制中狠狠的抱怨过： 在此我想稍稍抱怨一下(当然，我不行，我也不上，我实在就是想bb两句)，自从我开始研究JVM起，invokedynamic指令连同它所希望实现的动态语言支持简直就像是个毒瘤，JVM规范在面对这个问题时总会变得扭曲不自然。逻辑变得复杂难懂倒还在其次，最重要的还是失去了缜密的美感，让人看着难受。细思其缘由，我想还是因为该功能实在是与Java设计的初衷背离太远所致：需求分析的时候完全没在这地方留灵活度，上线后发现需求迫切没办法强行加功能。Java语言自最初起就被设计为了静态类型语言，但是随着时代的发展，人们对动态类型的需求逐渐迫切，Java也总是会因此被人指为不灵活，逐渐要被时代所抛弃。Java也在竭力进行改良，其结果就是现在我们看到的动态语言支持方案。个人认为这个方案比较糟(我没有更好的方案，但就是感觉比较糟)，其与Java基本的结构完全不同，仅仅只是一个为了实现功能的异类。好了=-=，抱怨结束。 不过抱怨归抱怨，该学的还是要学。难道JVM设计团队不清楚强行添加不合乎设计初衷的功能的后果吗？因为这实在是不得已而为之。当年高司令在为Java搭建基础架构时也不可能想到未来动态类型的需求会这么大。所以犹豫再三，我还是决定写下这篇博文，毕竟人生不如意事十之八九，很多事即便不想去做，也不得不做。 静态类型语言与动态类型语言在介绍Java对动态类型语言的支持之前，自然要先介绍什么是动态类型语言。而为了能使得介绍更为全面，自然也要将相关的概念一并介绍才行。 首先是第一组概念： 动态类型语言(Dynamically Typed Language)：也叫动态语言。动态类型语言是指在运行期才去做数据类型检查的语言。声明变量时无需指明变量的数据类型，该语言会在第一次为变量赋值时，自动在内部将数据类型记录下来。Python和Ruby就是典型的动态类型语言。 静态类型语言(Statically Typed Language)：也叫静态语言。静态类型语言与动态类型语言刚好相反，编译期就会进行数据类型检查。换句话说，变量在声明时就需要指明数据类型。C/C++和Java均是典型的静态类型语言。 然后是第二组概念： 强类型语言(Strongly Typed)：一旦给一个变量赋上初值后，那么这个变量的数据类型就确定为这个初值的数据类型。除非发生强制类型转换，该变量的数据类型都不会发生变化，因此往往也会被称为类型安全的语言。Java就是典型的强类型语言。 弱类型语言(Weakly Typed)：数据类型可以被忽略的语言。它与强类型的语言相反，一个变量在其生命周期中可以被赋不同数据类型的值。，因此往往也会被称为类型不安全的语言。 动态-静态与强类型-弱类型是两组容易被混淆的概念。事实上，二者的划分依据是不同的。动态-静态看的是变量初始时是否就需要确定数据类型，而强类型-弱类型看的是一旦变量被赋了初值后是否能发生变化。因为二者依据的是不同划分标准，所以共可能有4种排列组合结果： 上图中关于C++/C需要特别说明一下，这两个语言从语法层面看起来是强类型语言，然而其底层遵循的却是弱类型。因此业界对于这个问题其实比较模糊，没有什么明确的结论(注意不要拿这种无聊的问题和他人撕逼，C/C++更关心的是数据在内存中的长度，也就是更关心更底层，更本质的东西，其实并不特别在意数据类型，上图仅用于举例)。 以上是这些概念的抽象化描述。我们不妨再举一些实际的例子来说明各语言间因此可能产生的差异。 先来看下面这段Java代码： 1int[] a = new int[-1]; 这行代码是可以通过编译的，但是会在运行时抛出NegativeArraySizeException。JVM规范中明确规定NegativeArraySizeException是一个运行时异常，也就是说，所谓运行时异常，指得就是会抛出这种异常的代码不仅能通过编译，而且只要没被真正运行到，就不会抛出异常。与之相对的异常是连接时异常(例如NoClassDefFoundError)，连接时异常依然可以逃过编译，但是却无论如何也逃不过类加载的连接-解析阶段。通俗的说，就是指即便会抛出这种异常的代码存在于一条无法被执行到的分支路径上，照样也会抛出异常。其实这也很好理解：所谓连接时异常，指的自然就是在方法进行连接，也就是从符号引用到实际引用的过程中产生了异常，发生于类加载阶段，而对于每个需被加载到内存中的类而言，它根本不在乎代码是否在当前可能的执行路径上(事实上即便在乎也拿不到，除非程序实际运行到那行代码，否则类加载阶段是无法模拟预测程序会如何运行的)。因此这种异常一定会在类加载阶段被发现并抛出。 不过C语言中，含义相同的代码却无法通过编译： 1int i[-1]; 此时GCC会拒绝编译，报”size of array is negative”。 之所以会产生这种差异，主要是因为Java的编译期编译出的那个class文件并不是通常意义上的编译文件。C中编译期输出的结果直接就是最终结果了，能被实际执行指令的本地机器读取，自然要对结果负责。而Java编译出的这个class文件却只是供JVM使用的Java体系内部生成的字节码文件，要想让本地机器认识，还得在运行期翻译为本地机器的机器码。因此自然可以将部分所谓的这个编译期的工作挪到后续的运行期。 由上面的小例子我们可以得出以下推论：不同语言对数据的检查操作会发生在什么时期是没有固定的标准的，完全看语言本身的特性。所谓的”类型检查”也是同理。我们再看下面这段Java代码： 123456public class Test &#123; public static void main(String[] args) &#123; obj.println(&quot;hello&quot;); &#125;&#125; 如果全部代码只有这一行，那么显然是不行的，因为你没头没脑的冒出一个obj，JVM都不知道这个obj到底是什么，自然无法通过编译，会报obj cannot be resolved。为此，我们稍加修改： 123456789import java.io.PrintStream;public class Test &#123; public static void main(String[] args) &#123; PrintStream obj = System.out; obj.println(&quot;hello&quot;); &#125;&#125; 该代码会顺利运行并输出字符串hello。然后我们再修改一下代码： 1234567891011121314import java.io.PrintStream;public class Test &#123; public static void main(String[] args) &#123; PrintStream obj = new T(); obj.println(&quot;hello&quot;); &#125;&#125;class T &#123; public void println() &#123;&#125;&#125; 此时将无法通过编译，并报Type mismatch: cannot convert from T to PrintStream。原因很简单：Java是静态类型语言，既然声明obj时规定了其静态类型为PrintStream，那么在赋初值时其实际类型就必须是PrintStream或PrintStream的孩子。其他类，即便其内部同样包含调用所需的println()也不行。 但是相同含义的代码在ECMAScript(即JavaScript)中却能正确运行。因为JavaScript是弱类型语言(同时也是动态类型语言)，其根本就没有变量声明时的静态类型这一说，在其生命周期中所指向的实际类型自然也可以随意的变化。当执行到调用println()这一行的代码时，只要obj此时所指向的实际类型中有符合条件的println()即可。换句话说，对于动态类型语言而言，变量本身是没有类型的，变量指向的值才有类型。 静态类型语言在编译期确定类型，最显著的好处是编译器可以提供严谨的类型检查，这样与类型相关的问题能在编译期就及时发现，利于稳定性及代码达到更大的规模。而动态类型语言在运行期确定类型，则可以为开发人员提供更大的灵活性。同时也能为代码”瘦身”。例如用Java写出的上百行代码用Python实现可能只需几十行，提升简洁性的同时可读性往往也更高，提高开发人员的开发效率。 JDK1.7引入动态类型语言支持前的技术背景自1996年JDK1.1诞生起，十余年间，其JVM的字节码指令集始终未发生任何变化。直至2011年JDK1.7发布，字节码指令集终于又迎来了一位新成员：invokedynamic指令。其目的就是为了使得JDK1.7支持本文所介绍的动态类型语言。也为JDK1.8可以顺利实现Lambda表达式打下基础。 本小节的标题是有讲究的。JDK1.7并未引入动态类型语言，而只是引入动态类型语言支持。换句话说，从本质上讲，Java依然是静态类型语言，无论动态类型的需求多么强烈，都不可能动摇Java的根本。Java只是在保证基本面不变的前提下，适当加入了支持动态类型的指令和逻辑。 本文开头说动态类型语言与Java的设计初衷相悖其实是有些绝对了。因为自打一开始Java体系就在构建两个无关性：平台无关性及语言无关性。Java体系的规范也被一分为二：Java语言规范与JVM规范始终都是独立实现的。其目的就是为了让JVM与Java解耦，JVM是运行Java的平台，却不仅仅是运行Java的平台，理论上只要符合它的class文件格式规范，它能容纳所有的变成语言，而这个”所有”当然是包括动态类型语言的。 所以说，并不能说最开始规划的时候完全没想到，而是规划的蓝图太过虚无缥缈(在JVM上支持一切语言，Java这是想千秋万载一统江湖吗)，导致执行的时候完全没遵循(其实还是然并卵)。在JDK1.7之前，无论是Java语言还是JVM走得都是坚定的静态类型道路。其对动态类型支持的缺失主要是体现在方法调用上。JDK1.7之前共有4条方法调用指令： 0xb6(invokevirtual):调用实例方法。会根据对象的实际类型进行动态单分派(虚方法分派) 0xb7(invokespecial):以操作数栈栈顶reference类型的数据所指向的对象为方法的接收者，调用此对象的实例构造器方法，私有方法或超类构造方法。该指令的操作码之后会紧跟一个u2的操作数说明具体调用的是哪个方法，该参数指向常量池集合中的一个CONSTANT_UTF8_info类型的索引项，也就是该方法的方法符号引用 0xb8(invokestatic):调用类方法(static修饰的方法) 0xb9(invokeinterface):调用接口方法。运行期解释器会搜索一个实现了该接口方法的对象，并调用对应实现的接口方法 这4条指令接收的第一个参数都是被调用方法的符号引用(也就是类文件常量池中的CONSTANT_Methodref_info或CONSTANT_InterfaceMethodref_info类型的常量)。既然这个信息是在编译期生成的，那么其中记述的自然只能调用该方法的对象的静态类型。而动态类型语言需要的却是对象第一次被赋值时的实际类型，并没有所谓的静态类型的概念。这样编译期就无能为力了，只能交由JVM在运行期来做。 虽然决定了JVM来做，但还有JVM怎么做的问题。一种思路就是让底层的改动尽量小一些。换句话说，最终调用方法的还是上文的那4条指令，JVM底层其实依然无法支持动态类型，只是在上层玩些骚操作，让使用者从结果上”看起来”是实现动态类型了。比如编译期编译时在class文件中留个占位符类型，运行期动态生成字节码得到实际类型并存入该占位符，然后在调用这些方法时，就不使用通用位置的符号引用了，而是使用这个占位符。 关于这种用伪物替换真物的行为，JDK1.5引入泛型时曾做过一次。其效果很不理想，因为假的就是假的，为了让底层架构的改动较小而使用了伪物，其结果就是为了让它能实现真物的功能而付出了巨大的代价。更糟糕的是，即便付出了代价，这个伪物所实现的功能依然是似是而非，直到现在Java的泛型还存在很多莫名其妙的规范，这些与其说是规范，更接近于bug，只是Java设计团队实在没法解了，便当作规范告诉开发人员不要这么做。 而在动态类型支持这件事上，JVM设计团队还是很明智的：使用真物。因为本来此前的设计思路就与动态类型不合，开发难度已然较大，要是再加上真物伪物的复杂性，这功能基本也就没法看了。 JDK1.7中，这个真物体现在JVM层面就是新增的invokedynamic指令，该指令为动态类型而生，直接支持动态类型。而在Java语言层面的体现则是新增的java.lang.invoke包。 java.lang.invoke包我们先来讲java.lang.invoke包，因为毕竟较之JVM，程序员还是对Java语言更有亲切感。 java.lang.invoke包(该包曾经历过几次改名，最开始很长一段时间内都叫做java.dyn，后来也曾短暂的改名为java.lang.mh，最后确定名称为java.lang.invoke)的主要目的是在之前单纯依靠符号引用来确定需调用的方法的方式之外，提供一种新的动态确定目标方法的机制，称为MethodHandle。 这与C/C++中的Function Pointer(函数指针)或C#中的Delegate类似。以C/C++中的函数指针为例，如果我们要实现一个带谓词的排序函数，常用做法是把谓词定义为函数，用函数指针把该谓词传递到排序方法，如下所示： 1void sort(int list[], const int size, int (*compare)(int, int)) 换句话说，这是把方法当成一个变量丢到另一个方法的入参里了。Java就做不到这一点。如要在Java中实现类似的功能，则需要绕一些远路：通常是设计一个带有compare()方法的Comparator接口，然后将实现了这个接口的对象传入排序函数，排序函数内部再回调该对象的compare()方法。我们平时最常用的java.util.Collections类的: 1public static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c) 其内部就是按照这个思路实现的。 不过，在JDK1.7引入MethodHandle后，Java也拥有类似于C++的函数指针的功能了。 1234567891011121314151617181920212223242526272829303132333435363738import java.lang.invoke.MethodHandle;import java.lang.invoke.MethodHandles;import java.lang.invoke.MethodType;public class Test &#123; private static final MethodHandle getPrintlnMH(Object receiver) throws NoSuchMethodException, IllegalAccessException &#123; /* * MethodType代表方法类型 * 其类方法methodType()： * 第一个参数：方法的返回值 * 后续参数：方法接收的参数列表 */ MethodType mt = MethodType.methodType(void.class, String.class); /** * MethodHandles.lookup().findxxx()方法的作用为在指定类中找到符合方法签名，返回值及访问权限要求的方法句柄 * 具体到本例中，因需要调用的是虚方法。故调用findVirtual()方法。其参数含义为： * 参数1：方法接收者所属类。遵正常渠道调用的虚方法编译器会隐式添加指向接收者的this指针，此处则需要我们自己指定。 * 参数2：需调用虚方法的简单名称 * 参数3：需调用虚方法的返回值及参数列表 * 最终，还需将该方法再由bindTo()方法显式绑定回接受者上 */ return MethodHandles.lookup().findVirtual(receiver.getClass(), &quot;println&quot;, mt).bindTo(receiver); &#125; public static void main(String[] args) throws Throwable &#123; String str = &quot;我来自幻想乡&quot;; Test.getPrintlnMH(System.out).invokeExact(str); Test.getPrintlnMH(new Marisa()).invokeExact(str); &#125;&#125;class Marisa &#123; final void println(String str) &#123; System.out.println(str + &quot;DAZE&quot;); &#125;&#125; 输出： 12我来自幻想乡我来自幻想乡DAZE 本质上来讲，本例中的getPrintlnMH()模拟了invokevirtual指令的执行过程，只不过它的分派逻辑并非固化在Class文件的字节码上，而是通过getPrintlnMH()这个具体的方法由程序员指定实现。getPrintlnMH()的返回值(MethodHandle)即可视为对最终调用方法的一个引用。 再回到上文中比较的那个例子，有了MethodHandle后，我们就可以使用类似于如下方法在Java中实现比较： 1void sort(List list, MethodHandle compare) 本质上来说，Java依然无法接收方法为参数，它所采用的方式为将方法的必要信息包装成了一个对象，然后像使用方法那样使用这个对象。 以上就是MethodHandle的基本用途：封装一个代表这个方法的对象，然后在实际调用时以该对象所代表的方法信息为依据调用具体方法。这样我们不禁会产生一个新的疑问：所实现的功能不就是反射吗？为什么不直接用反射机制完成呢？为什么要再搞出个MethodHandle呢？ 确实，仅从Java语言规范的角度上讲，MethodHandle所实现的功能与反射有很大重叠的部分，然而它们还是有以下区别： 首先，反射和MethodHandle虽然都是在模拟方法调用，然而二者所模拟的层次不同：反射是在模拟Java代码层次的方法调用，不会去关心底层字节码的实现机制。而MethodHandle是在模拟字节码层次的方法调用。MethodHandles.lookup()中共有3个方法： findStatic():对应invokestatic指令 findSpecial():对应invokespecial指令 findVirtual():对应invokevirtual及invokeinterface指令 其次，反射中负责方法调用的是java.lang.reflect.Method，MethodHandle中负责方法调用的是java.lang.invoke.MethodHandle。前者包含了这个方法所有的信息，而后者仅包含与方法调用相关的信息。可以这么认为：Method是重量级，MethodHandle是轻量级。 最后，由于MethodHandle是对字节码指令的直接模拟，因此JVM对字节码指令做的种种优化(例如方法内联)理论上都适用于MethodHandle。虽然现在尚不完善，但仍留下了可供优化的空间。而仅限于语言层面的反射则做不到这一点。 通过上文的这3点，我们可以总结出：MethodHandle与反射最本质的区别就是二者作用的层级不同。反射作用于Java语法层面，因此只能为Java语言服务。而MethodHandle则作用于JVM的字节码指令层面，可以为包含Java在内的一切运行于JVM之上的语言服务。 invokedynamic在介绍完Java语言层面对动态类型的支持之后，终于来到了JVM层面。 从本质上来讲，invokedynamic指令与MethodHandle机制的目的是一样的：都是为了解决原有的4条invokexxx指令方法分派规则固化在JVM之中的问题。从而将如何定位目标方法的决定权从JVM转移到具体的用户代码中，让开发人员(也包括运行于JVM上的语言的设计人员)有更高的灵活度。 因此，我们可以将invokedynamic指令与MethodHandle机制视为为实现同一个目标的两种具体的做法。MethodHandle机制是采用上层Java代码及API实现的，而invokedynamic指令则是直接通过字节码指令及class文件实现的。二者在设计思路上有很多共通之处。 每一处含有invokedynamic指令的位置都被称作动态调用点(Dynamic Call Site)。invokedynamic指令的第一个参数不再是代表方法符号引用的CONSTANT_Methodref_info常量，而是变为JDK1.7新加入的CONSTANT_InvokeDynamic_info常量。从这个常量中可以得到如下3项信息： 引导方法(Bootstrap Method):实际存储于同样新增的class文件-属性表集合-BootstrapMethods中。其有固定的入参，返回值为java.lang.invoke.CallSite对象，该对象代表真正要执行的目标方法(类似于MethodHandle机制的MethodHandle对象)。 方法类型(MethodType) 名称 根据CONSTANT_InvokeDynamic_info常量中提供的信息，JVM就可以找到并执行引导方法(这样看来，引导方法的作用类似于上文中我们实现MethodHandle机制时设计的类方法getPrintlnMH())，最终利用引导方法返回的CallSite对象调用目标方法。 因为Java语言依然是静态类型的语言，因此与MethodHandle机制所不同的是，invokedynamic指令所面向的使用者并非Java语言，而是那些运行于JVM之上的动态类型语言。或者更具体的说，javac编译器是无法生成带有invokedynamic指令的class文件的。在Java语法层面曾经有一个java.dyn.InvokeDynamic的语法糖可以实现，但是后来取消了。 或者我们可以把话说的更明白一些，如果仅仅是对于学习Java这一门语言而言，invokedynamic指令是没有用处的，可以当它不存在。这也是JVM关于语言无关性的设计初衷：Java语言是运行于JVM平台上的，然而JVM并非完全就是为了支持Java语言而存在的。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>Java虚拟机</tag>
        <tag>虚拟机</tag>
        <tag>动态类型语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM-运行期方法调用]]></title>
    <url>%2F2017%2F12%2F06%2FJVM-%E8%BF%90%E8%A1%8C%E6%9C%9F%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%2F</url>
    <content type="text"><![CDATA[运行期方法调用的唯一目的就是确定被调用方法的版本(即确定调用哪个类的哪个方法)，执行方法体不是方法调用需考虑的问题。 对于C++这种编译执行的语言，方法的连接操作在编译结束后即完成。换句话说，编译结束后即可明确知道实际运行时该方法在内存布局中的地址。此时方法调用根本就不是一个问题：编译结果中写什么调用什么就好。 而Java这种以解释执行为主的语言将编译过程分为了两段：首先是.java源文件编译为.class的字节码文件，随后再是.class文件被解释执行或编译执行为本地机器码。这里.java到.class的转换虽然也被称为编译，却只是Java体系内部的转换，对于最终执行程序的本地机器而言，只要没有编译为它所认识的本地机器码，.java和.class对它而言都是一样的。因此.java到.class的过程其实并非真正意义上的编译，而只是一个中间过程。 不过.java到.class也确实是一种编译操作，因此我们仍然会称.java到.class的时期为Java编译期。只是务必在心里与类似C++那种真正的编译为机器码的行为做好区分。 .class文件的常量池集合中存储的方法地址均为符号引用。例如就是如下所示的字符串： 1&quot;&lt;init&gt;&quot;:()V 这种字符串易于人类理解阅读，也可用作标记，但却无法代表方法在内存中的入口。这是很容易理解的：Java体系中的编译期及运行期是被切割的，即可以编译好class文件后等很久再换一台机器执行。那么编译期自然不可能知道实际的内存布局是什么样子的，class文件中只能存储这样的符号引用。 这就会使得方法的连接操作(所谓连接，其实就是把class中记述的方法的符号引用替换为方法在内存中的实际入口地址，也就是Java中常说的直接引用)变得复杂，因为不管你Java有什么困难导致编译期无法确定方法的版本，只要你想完成最终的调用，那么在被最终转换为本地机器码之前必须完成方法的连接。既然编译期做不了，那么就只能在随后的运行期(只有两个时期，也没法推给其他人了)做了。运行期连接为Java带来了一定的动态扩展能力，却也相对的给方法的版本确认带来了麻烦，例如有如下调用逻辑： 123G0 o = new G1();// 一些代码...o.m(P p); 其中G1为G0的孩子(儿子，孙子，重孙…)。而m又是一个可被子类继承的方法。那么在程序实际运行到o.m(P p);这一行之前，JVM是无法知道到底要调用哪个类的m方法的。虽然单看上例应该调用类G1，但是上例中被省略的”一些代码”可能是这样子的： 123G0 o = new G1();o = new G0();o.m(P p); 此时该调用的类就是G0。那么在编译期javac编译到G0 o = new G1();时是无法知道后面会发生什么的。有人可能会说，o = new G0();就在它的下面，也在同一个类里，javac为什么识别不了呢？这个说的没毛病，理论上javac确实识别得了。但问题在于我么当然也可以不放在同一个类里： 123G0 o = new G1();X.m2(o);o.m(P p); X是与G(假设上述代码存在于类G中)完全无关的一个类，我们调用了它的m2方法并将o丢了进去。此时javac就真的无能为力了。因为类文件的编译都是以类为单位单独编译的，javac在编译G这个类时是无法知道X这个类的内容的，自然也不会知道X的m2方法中是否会有类似o = new G0();这样的操作。 这个问题对于运行期而言就有点严重了。因为在这个问题被摆到桌面上谈之前方法调用其实也不复杂：编译期其实可以确认方法该调用哪个版本，它所不知道的仅仅只是这个版本的方法在运行期被放到了内存的哪个位置而已。此时运行期需要做的操作仅仅只是把符号引用翻译为直接引用而已。但是当这个问题被抛出后，编译期无法确认方法该调用哪个版本，运行期在具体执行到o.m(P p);所代表的那个字节码指令之前自然也不可能知道。 这里所说的”不可能知道”其实有些绝对了，更确切的说法应该是”成本太高了，不想知道”。因为运行期的类加载过程其实基本上也是以类为单位加载的：需要一个加载一个。如果想在类加载阶段就确认这件事，那么相当于要将从G0 o = new G1();被声明，到o.m(P p);触发方法调用这期间的所有的”一些代码…”确认一遍，如果涉及到条件分支判断还要将所有分支可能导致的结果都记录下来。这个实现成本基本上就是在逼JVM开发人员自杀。 无奈之下JVM开发人员只好采取了折中的策略，说来说去可能会导致有问题的情况不也就上文说的那一种吗？那么我们将运行期的方法调用再分为两个阶段：静态多分派及动态单分派。 在具体介绍这两个阶段之前，需要先介绍一下这两个名字中那些被组合的单词。很显然，这和Java 并发-同步异步阻塞非阻塞类似：同步异步是一组概念，阻塞非阻塞是一组概念，两组概念组合共能得到4个结果。同理，静态多分派及动态单分派中的静态动态是一组概念，多分派单分派是一组概念，两组概念组合依然能得到4个结果。不过这里，只有其中的两组是有意义的，也就是静态多分派及动态单分派。 所谓静态动态，指的就是能确定方法版本的时期，编译期能确定的就叫做静态，编译期确定不了的就叫做动态。 所谓单分派与多分派指的就是确定方法版本需要参考的参数(也叫做宗量)个数，如果只参考一个宗量就叫做单分派，需要参考多个宗量就叫做多分派。宗量这个概念并非出自JVM规范，而是源自《Java与模式》一书，不过这本书也足够经典，因此业界也就默认宗量这个概念的权威性了。单看分派，宗量这些概念仿佛很专业很复杂的样子。但其实在方法分配这件事上，宗量其实就只有两个：即”哪个类”的”哪个方法”。 对于静态多分派及动态单分派的具体含义后文将详述，不过在此我们可以先提纲挈领的总结一下。这两个概念看似让人很懵逼，但说穿了套路其实很简单，在分析之前我们需要再给出两个简单的小概念，即静态类型(Static Type)[也可称为外观类型(Apparent Type)]与实际类型(Actual Type): 12G0 o = new G1();o.m(P p); 以上代码中并没有烦人的”// 一些代码…”，因此我们可以确定当o.m(P p);执行时”哪个类”指的就是类G1。此时对于o而言，其静态类型为G0，实际类型为G1。 很显然，编译期能确定的是静态类型(Java是强类型语言，只要声明了,除非进行显式的强制类型转换，否则变量的类型就不能改变)，无法确定的是实际类型。 小概念介绍完毕，我们继续分析运行期确定方法版本的那两步： 第一步，所有方法都需要做，而且是就当编译期能确定所有方法的版本那样来做。”哪个类”统一认为是静态类型。发生于类加载的连接-解析阶段，因此也被称为解析(Resolution)。 第二步，执行了第一步后仍有问题的方法才需要做，发生于字节码执行引擎实际运行到方法调用的那行指令时。 那么什么方法才是”有问题的方法”呢？仔细分析上文中描述的问题就能发现，实际上这个问题本质上就是无法确认”哪个类”，而无法确认”哪个类”的原因则是该方法可能会被子类重写(Override)。至此我们已经找到了问题的答案：”有问题的方法”指得就是那些能被子类所继承并重写的方法。换句话说，若一个方法无法被子类继承并重写，那么就只需要进行第一步。 思路其实很明确。编译期能确定的方法还按照当是没问题的方案来做，而对于那些可能会产生问题的方法则添加补救措施。注意这里说的仅仅是可能，因为允许被继承的方法并不代表它真的就会被继承，被继承了也不代表执行到方法调用那一行字节码指令时实际类型就一定是静态类型的子类型。不过，因为我们也无法保证这不可能，因此这些方法还是需要执行第二步。 静态多分派如前文所述，只需执行第一步的方法是那些编译期可知，运行期不可变的方法，换句话说，也就是指那些不可被继承重写的方法(因为要变其实也就是通过继承的重写来变)。在Java中不可被继承的方法主要分为两大类：类方法(直接与本类静态类型所关联)及私有方法(子类不可访问)。 这里可以稍微讲一下方法的调用指令。JVM-JVM字节码指令集中共提供了5条方法调用相关的指令： 0xb6(invokevirtual):调用实例方法。会根据对象的实际类型进行动态单分派(虚方法分派) 0xb7(invokespecial):以操作数栈栈顶reference类型的数据所指向的对象为方法的接收者，调用此对象的实例构造器&lt;init&gt;方法，私有方法或超类构造方法。该指令的操作码之后会紧跟一个u2的操作数说明具体调用的是哪个方法，该参数指向常量池集合中的一个CONSTANT_UTF8_info类型的索引项，也就是该方法的方法符号引用 0xb8(invokestatic):调用类方法(static修饰的方法) 0xb9(invokeinterface):调用接口方法。运行期解释器会搜索一个实现了该接口方法的对象，并调用对应的实现方法。 此外，还有那条操蛋的现在尚未出现于JVM字节码指令集中的invokedynamic，其会先在本指令运行期间动态解析出调用点限定符所引用的方法，然后再执行该方法。上文给出的那4条方法调用指令的方法分派逻辑是固化在JVM内部的，而invokedynamic的分派逻辑是由用户所设定的引导方法决定的。 根据前文分析，显然被invokestatic及invokespecial所调用的方法：静态方法，实例构造器&lt;init&gt;方法，私有方法，超类构造方法，都只需要执行第一阶段，因为它们都不可被继承。这些方法也被称为非虚方法。 但并不是说不是被invokestatic及invokespecial所调用的方法就是虚方法。因为被final修饰的方法是被invokevirtual指令所调用的，然而它虽然可以被继承，却无法被重写，不被重写就不会触发问题，因此它也是非虚方法，只需要执行第一步。除此之外，其他被invokevirtual指令调用的方法均是虚方法，可以被子类继承。需执行第二步。 这里需要再次明确的一点就是，静态多分派的方法版本是编译期就可确定的。注意这仅仅是可以确定，而不是真正的进行连接操作。无论如何(即便描述成静态的)，连接操作都是在运行期完成的。 因静态多分派阶段确认方法版本依据的是编译期的静态结果，因此在静态动态这组概念中属于”静态”，而其判定方法版本依据的是静态类型及方法签名(方法名+方法参数)，也就是既参考了”哪个类”，也参考了”哪个方法”，因此是单分派多分派这组概念中的多分派。 严格来说，分派(Dispatch)这个词在欧美一般是不用于静态环境中的。欧美那边对于第一步操作的称呼为Method Overload Resolution，即重载解决方案。这也道出了静态多分派阶段的难点：确定方法版本所用的两个宗量中静态类型是唯一不可变的。而方法签名中方法名则可能会相同，此时就会发生重载(这里依然是可能，重载并非是必然会发生的)。 关于方法签名有一个需要注意的点，静态多分派依据的信息全部来自于编译期，”哪个类”也完全认定为静态类型，这点对于方法签名中的参数类型也是一样的，即只会以方法参数的静态类型为准(还是那个问题，编译期是无法拿到实际类型的)： 12345678910111213141516171819public class Test &#123; public static void m(Parent parent) &#123; System.out.println(&quot;parent&quot;); &#125; public static void m(Son son) &#123; System.out.println(&quot;son&quot;); &#125; public static void main(String[] args) &#123; Parent parent= new Son(); Test.m(parent); &#125;&#125;class Parent &#123;&#125;class Son extends Parent &#123;&#125; 输出： 1parent 因此我们也可以这么说，完全依据静态类型来确定方法版本的分派方式为静态分派。 之所以上文说重载是静态多分派阶段的难点。是因为重载虽然在编译期就能完全确认方法版本，其确定依据却不是准确的。例如： 1G.m(P p); 若G中的m存在重载方法，首先参数的个数及顺序是强制规范，这个是明确的。然而参数类型的判断却是模糊的。编译器会找方法形参中与实参静态类型血缘最接近的那个。例如，仍然是针对上面那条调用，若G中仅有一个类方法： 12public static void m(P0 p0) &#123;&#125; 其中P0是P的前辈(父亲，爷爷…)，那么按照血缘关系则定位到这个最亲近的方法。但若G中有如下两个类方法： 12345public static void m(P0 p0) &#123;&#125;public static void m(P p) &#123;&#125; 此时依血缘最亲密的类需调用的方法就变成m(P p)。 对此，我们可以举一个比较极端的例子： 123456789101112131415161718192021222324252627282930313233343536import java.io.Serializable;public class SayHello &#123; public static void sayHello(Object arg) &#123; System.out.println(&quot;hello Object&quot;); &#125; public static void sayHello(int arg) &#123; System.out.println(&quot;hello int&quot;); &#125; public static void sayHello(long arg) &#123; System.out.println(&quot;hello long&quot;); &#125; public static void sayHello(Character arg) &#123; System.out.println(&quot;hello Character&quot;); &#125; public static void sayHello(char arg) &#123; System.out.println(&quot;hello char&quot;); &#125; public static void sayHello(char ...arg) &#123; System.out.println(&quot;hello char ...&quot;); &#125; public static void sayHello(Serializable arg) &#123; System.out.println(&quot;hello Serializable&quot;); &#125; public static void main(String[] args) &#123; SayHello.sayHello(&apos;a&apos;); &#125;&#125; 输出： 1hello char 没什么可说的，传入的为基本数据类char的值，自然精准重载到了对应方法上。此时我们删掉这个入参为char的方法，即变成： 1234567891011121314151617181920212223242526272829303132import java.io.Serializable;public class SayHello &#123; public static void sayHello(Object arg) &#123; System.out.println(&quot;hello Object&quot;); &#125; public static void sayHello(int arg) &#123; System.out.println(&quot;hello int&quot;); &#125; public static void sayHello(long arg) &#123; System.out.println(&quot;hello long&quot;); &#125; public static void sayHello(Character arg) &#123; System.out.println(&quot;hello Character&quot;); &#125; public static void sayHello(char ...arg) &#123; System.out.println(&quot;hello char ...&quot;); &#125; public static void sayHello(Serializable arg) &#123; System.out.println(&quot;hello Serializable&quot;); &#125; public static void main(String[] args) &#123; SayHello.sayHello(&apos;a&apos;); &#125;&#125; 输出： 1hello int 哦，看来是发生了一次自动的基本类型间的向上类型转换。因为’a’除了可代表字符a外，也可代表数字97(字符’a’在Unicode字符集中的编码就是97)。现在我们再把这个入参是int的方法去掉，变为： 12345678910111213141516171819202122232425262728import java.io.Serializable;public class SayHello &#123; public static void sayHello(Object arg) &#123; System.out.println(&quot;hello Object&quot;); &#125; public static void sayHello(long arg) &#123; System.out.println(&quot;hello long&quot;); &#125; public static void sayHello(Character arg) &#123; System.out.println(&quot;hello Character&quot;); &#125; public static void sayHello(char ...arg) &#123; System.out.println(&quot;hello char ...&quot;); &#125; public static void sayHello(Serializable arg) &#123; System.out.println(&quot;hello Serializable&quot;); &#125; public static void main(String[] args) &#123; SayHello.sayHello(&apos;a&apos;); &#125;&#125; 输出： 1hello long 因为没找到int，因此再次向上转型为long。我没有写其他的基本数据类型，但显然转换可以沿着char-&gt;int-&gt;long-&gt;float-&gt;double这条转换链一直自动向上转换上去。当然，char是不会自动转型为未在它转换链上层的boolean，byte，short的。 现在我们再删掉这个入参是long的方法，变为： 123456789101112131415161718192021222324import java.io.Serializable;public class SayHello &#123; public static void sayHello(Object arg) &#123; System.out.println(&quot;hello Object&quot;); &#125; public static void sayHello(Character arg) &#123; System.out.println(&quot;hello Character&quot;); &#125; public static void sayHello(char ...arg) &#123; System.out.println(&quot;hello char ...&quot;); &#125; public static void sayHello(Serializable arg) &#123; System.out.println(&quot;hello Serializable&quot;); &#125; public static void main(String[] args) &#123; SayHello.sayHello(&apos;a&apos;); &#125;&#125; 输出： 1hello Character 此时已没有基本数据类型可供自动向上转型了，因此发生了一次自动装箱，’a’被自动装箱为其包装类Character。那么老套路，我们再删掉这个入参是Character的方法： 1234567891011121314151617181920import java.io.Serializable;public class SayHello &#123; public static void sayHello(Object arg) &#123; System.out.println(&quot;hello Object&quot;); &#125; public static void sayHello(char ...arg) &#123; System.out.println(&quot;hello char ...&quot;); &#125; public static void sayHello(Serializable arg) &#123; System.out.println(&quot;hello Serializable&quot;); &#125; public static void main(String[] args) &#123; SayHello.sayHello(&apos;a&apos;); &#125;&#125; 输出： 1hello Serializable 这个输出看起来就有些诡异了。不过我们可以看一下Character类的源码： 123public final class Character implements java.io.Serializable, Comparable&lt;Character&gt; &#123;// 省略类内部代码&#125; 果然，Character实现了Serializable接口，看来编译器是认为此时血缘最亲近的就是它所实现的接口了。并且因为我们明明也写了入参是Character父类Object的方法而编译器却最终选择了Serializable。看来在编译器眼里，接口比父类要更亲密一些。不过我们不禁会产生另一个疑问：如果静态类型实现了多个接口(例如本例中的Character)，而又同时存在以这些接口为入参的重载方法，那么编译器会如何抉择呢？会按照接口在源码中的书写顺序来确定亲疏关系吗？有问题就要立刻验证，我们把代码修改如下： 12345678910111213141516import java.io.Serializable;public class SayHello &#123; public static void sayHello(Serializable arg) &#123; System.out.println(&quot;hello Serializable&quot;); &#125; public static void sayHello(Comparable&lt;Character&gt; arg) &#123; System.out.println(&quot;hello Comparable&lt;Character&gt;&quot;); &#125; public static void main(String[] args) &#123; SayHello.sayHello(&apos;a&apos;); &#125;&#125; 此时将无法通过编译，SayHello.sayHello(‘a’);这一行会提示The method sayHello(Serializable) is ambiguous for the type SayHello。至此我不禁松了一口气，看来编译器还是有底线的。毕竟Java语言规范中可从来没有说过实现接口时接口的书写顺序会有什么优先级上的影响。 顺便再说一句，只有基本数据类型之间才可能发生自动类型转化。换句话说，是不能指望Character自动转换成Integer的。 然后我们再回到原来的代码上，现在我们再删掉入参是Serializable的方法： 1234567891011121314public class SayHello &#123; public static void sayHello(Object arg) &#123; System.out.println(&quot;hello Object&quot;); &#125; public static void sayHello(char ...arg) &#123; System.out.println(&quot;hello char ...&quot;); &#125; public static void main(String[] args) &#123; SayHello.sayHello(&apos;a&apos;); &#125;&#125; 输出： 1hello Object 终于轮到父类了。事实上，编译器会在静态类型的继承链上依序向上搜索，最终追溯到Object类。这里需要注意的是，追溯时只看静态类型而不管实际存的是什么，极端的说，即便该静态类型指向的是null也无所谓。 然后我们再删掉这个入参是Object的方法： 12345678910public class SayHello &#123; public static void sayHello(char ...arg) &#123; System.out.println(&quot;hello char ...&quot;); &#125; public static void main(String[] args) &#123; SayHello.sayHello(&apos;a&apos;); &#125;&#125; 输出： 1hello char ... 此时就只剩下1个方法了，编译器也算是饥不择食了，最后连变长参数的方法也不放过。其实这也很好理解：咱们传入的参数被以组的概念理解了(只是这个组里只有1个元素)。不仅如此，变长参数方法还支持上文所有提到的那些关于亲密关系的判断。 至此这个例子便结束了。不得不说确实极端得可以，在这个例子中编译器简直是杨花水性，毫无节操。不过这种例子属于”茴香豆的茴有几种写法”一类的问题，虽然确实也是个知识点，这么写也确实不会报错，然而实际开发中完全是然并卵的，因为基本不会有什么业务需求会抽风到逼程序员写出这样的代码，而且要是真有程序员写出这种代码他也基本会被他的同事砍死。它和Java中的i++,++i一类问题一样，往往都只会以考校程序员功底的目的出现在面试或期末考试中。 动态单分派关于动态单分派，我们先解释一下名称。因为第二步发生在字节码执行引擎执行到方法调用那条字节码指令时，依据的是程序在运行期实际的动态运行结果而非编译期得出的静态结果，因此在静态动态这组概念中是动态。又因为第二步诞生的目的就是为了解决实际类型可能与静态类型不一样的问题，也就是说到了第二步，决定方法调用版本中的”哪个方法”问题在第一步中已能完全确定了，可能有问题的仅仅是”哪个类”，因此判断方法版本所需依据的宗量仅仅只有实际类型一个。因此在单分派及多分派这组概念中为单分派。 这一步实际上就是在解决上文中提到的那个因重写造成的问题的。当字节码执行引擎执行到具体的调用指令时，自然可以知道”哪个类”的实际类型是什么。 关于动态单分派，如果完全遵循上文所描述的概念模型。那么每次在确认某父类中的可继承方法是否真的被子类重写时，都需要重新搜索一遍父类和子类。而动态单分派的执行频率又很高，这就有些浪费资源了：因为编译期虽然无法确定实际类型是什么，但是确定方法的继承关系则毫无难度。因此虽然JVM实现间千差万别，但大多都会进行如下”稳定优化”手段：为类在方法区中建立一张虚方法表(Virtual Method Table，简称vtable)。当需要进行动态单分派时，就可以查找这张虚方法表而非重复搜索父类和子类了。 例如有如下代码： 123456789101112131415161718192021222324252627class QQ &#123;&#125;class _360 &#123;&#125;class Father &#123; public void hardChoice(QQ arg) &#123; System.out.println(&quot;father choose qq&quot;); &#125; public void hardChoice(_360 arg) &#123; System.out.println(&quot;father choose 360&quot;); &#125;&#125;class Son extends Father &#123; @Override public void hardChoice(QQ arg) &#123; System.out.println(&quot;son choose qq&quot;); &#125; @Override public void hardChoice(_360 arg) &#123; System.out.println(&quot;son choose 360&quot;); &#125;&#125; 这段代码中Father与Son的虚方法表如下图所示： 虚方法表创建于运行期类加载的连接-解析阶段，它诞生于运行时数据区域之一的方法区中，而非编译期产出的class文件中。因此虚方法表中存储的已经可以是各实际类型的方法指向方法区的直接引用，是拿来直接就能用的，而非class文件中那种符号引用。如果父类的某个方法子类没有重写，那么子类虚方法表中该方法的实际引用地址与其父类虚方法表中该方法的实际引用地址相同，都指向父类的方法。若子类重写了父类的某方法，则子类虚方法表中该方法的实际引用将指向子类重写后的方法。上图中，Son重写了Father中所有的方法，因此Son的虚方法表中没有指向Father虚方法表的箭头。但是Father没有重写其父类Object中的方法，因此对这些方法而言，Father的箭头均指向Object。同理，Son依然没有重写这些方法，因此它会将这些方法的箭头指向Father，进而又被指向Object。 为了程序实现上的方便，具有相同签名的方法，在父类，子类的虚方法表中的索引号应该保持一致。这样当实际类型变化时(也就是”哪个类”变化时)，只需要变更虚方法表，而无需变更索引号(即”哪个方法”不变)，这也与动态单分派中单宗量的逻辑吻合。 与虚方法表类似的，往往也会为类在方法区中建立一张invokeinterface指令会用到的接口方法表(Inteface Method Table，简称itable)。 虚方法表是大多JVM实现都会采用的”稳定优化手段”。在条件允许的情况下，JVM实现也可能会采用另外一些激进的，同样是发生于晚期(运行期)的”非稳定优化手段”： 内联缓存(Inline Cache) 基于类型继承关系分析(Class Hierarchy Analysis,CHA)技术的守护内联(Guarded Inlining)]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>Java虚拟机</tag>
        <tag>虚拟机</tag>
        <tag>方法调用</tag>
        <tag>重载</tag>
        <tag>重写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM-运行时栈帧结构]]></title>
    <url>%2F2017%2F12%2F05%2FJVM-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A0%88%E5%B8%A7%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[JVM是一种虚拟机，而虚拟机又是一个相对于物理机的概念。这两种机器都有代码执行能力，其区别在于物理机的执行引擎是直接建立在CPU，内存等硬件，指令集和操作系统层面上的。而虚拟机则是更上层的东西，其必须位于某个物理机中，受该物理机各方面因素的掣肘，但是它的执行引擎却是自行实现的，具体来说，就是指指令集及执行引擎的结构体系等各种架构都是自行设计的。因此，它虽然位于物理机中，却仿佛是一台独立的机器：能够执行那些不被该物理机的硬件所直接支持的指令。 显然，无论是物理机还是虚拟机，执行引擎都是最核心的组件之一。JVM规范中制定了JVM字节码执行引擎的概念模型(多说一句感想，关于Java，SUN建立了几乎全部的规范和标准，正所谓一流的公司卖标准，二流的公司卖产品)，该概念模型成为了所有遵守JVM规范的JVM实现的执行引擎的统一外观(Facade)。不同的JVM实现可能会采取不同的具体执行方式： 通过解释器解释执行，即通常意义上解释执行。 通过即时编译器(JIT)直接产生本地机器码，也就是通常意义上的编译执行。 各实现采取的策略往往不同，可能只采取解释执行(例如SUN早期的JVM实现Sun Classic VM)，可能只采取编译执行(例如BEA JRockit)。或者混合使用解释执行及编译执行(例如最常用的Hotspot VM)。但是无论如何，它们都是基于同一套规范的不同实现，因此从外观上来看，所有的JVM执行引擎的行为都是一致的：输入JVM的是字节码流，处理过程是字节码解析的等效过程，输出的是执行结果。 在JVM的运行时内存中，类的模版信息位于方法区中，实例对象位于Java堆中。这些内存区域都可以看作是存储数据的仓库，映射到计算机组成原理中，可以看作是内存。而虚拟机栈和本地方法栈(可看作缓存和寄存器)则是直接与JVM字节码执行引擎(可看作CPU)交互的内存区域。 CPU将所需的数据从内存中取到自身的缓存中，在执行每条指令时，都会将该指令所需的参数加载到自身的寄存器中，计算完成后将结果放回寄存器。再通过寄存器放回缓存。随后在合适的时机写回内存。因此，从更本质的角度上说，与CPU直接交互的只有寄存器。 类似的，JVM执行引擎在执行一组字节码指令时也会先将所需数据取到线程的虚拟机栈或本地方法栈中并建立栈帧(以使用实例对象为例，实际上并不是真的把该实例从Java堆中复制到了栈帧中，拿过来的仅仅是引用)，或者更具体的说，这些数据被存到了栈帧的局部变量表中，而后在执行每条字节码指令时，都会将这条指令所需的数据加载入栈帧的操作数栈中(强调一下，JVM不是基于寄存器的，是基于操作数栈的)，计算完成后再将结果放回操作数栈，而后再在合适的时机放回局部变量表(因为拿过来的就是引用，所以除了基本数据类型这种数值以外，不需要再同步了)。因此，从更本质的角度上说，与JVM字节码执行引擎直接交互的只有栈帧中的操作数栈。 本文所要描述的就是这个供JVM字节码执行引擎使用的，运行时栈帧结构的概念模型。 虚拟机栈及本地方法栈就只是一个栈式结构，本身并没有什么可说的。其所有逻辑基本都在其元素：栈帧中。因此所谓的介绍运行时栈帧结构，实际上就是介绍栈帧。 栈帧(Stack Frame)是用于支持JVM进行方法调用和方法执行的数据结构。Java中每一个方法在运行期从调用开始到执行完成的过程，实际上就是一个栈帧从入栈到出栈的过程。 在上图中，最大的圆角矩形是当前线程私有的虚拟机栈。若一个方法在其内部又调用了另一个方法(调用自己则被称为递归)，无论如何，每调用一个新的方法都会压入一个新的代表该方法的栈帧。因此一个线程中的方法调用链可能会很长，也就是该线程的虚拟机栈中的元素可能会很多。不过对于JVM执行引擎而言，对于任意特定时刻，只有位于栈顶的栈帧才是有意义的，该栈帧被称为当前栈帧(Current Stack Frame)，相应的，该栈帧所关联的那个方法被称为当前方法(Current Method)。操作数栈的信息永远来自于当前栈帧，或者更本质的说，JVM执行引擎操作的所有数据都来自于当前栈帧。 每个栈帧主要包含如下信息： 局部变量表 操作数栈 动态连接 方法返回地址 一些额外的附加信息 栈帧中需要多大的局部变量表，多深的操作数栈在编译期已完全确定，并存入： class文件-方法表集合-方法表-属性表集合-Code属性-其中有代表操作数栈最大深度的max_stack及代表局部变量表所需存储空间(单位为Slot，并可认为一个Slot 32位)的max_locals。详见JVM-类文件结构。 局部变量表及操作数栈这两个变长的数据结构占据了栈帧绝大部分的空间(其他组成结构的长度固定)，因为它们的大小在编译期已确定，因此栈帧的大小在运行期是固定的。 下文将逐个介绍栈帧的各组成部分。 局部变量表局部变量表(Local Variable Table)是一组变量值的存储空间，用于存储方法的传入参数和在方法内部定义的局部变量。局部变量表的大小在编译期即完全确定，并存入： class文件-方法表集合-方法表-属性表集合-Code属性-代表局部变量表所需存储空间的max_locals。 max_locals是一个整型数值，其基本单位被称为变量槽(Variable Slot，常简称为Slot)。JVM规范并没有明确规定一个Slot占多少位，然而纯从字面上考虑，变量槽，也就是放变量的槽，一个槽里总要放得下一个变量才是。JVM规范虽然没有明说一个Slot多大，却正如刚才我们顾名思义所推测的，说了这么一句话：一个Slot必须能容纳一个boolean,char,byte,short,int,float,reference或returnAddress类型。这8种数据类型最大的占用32位，因此一个Slot最小也得有32位。这个与直接规定一个Slot是32位是有区别的。相当于留下了向上扩展的余地。不过我们一般说到Slot时都会把它看作32位。 关于reference类型的长度，可以多说几句。事实上，JVM规范既没有给出reference类型的数据结构，也没有明确规定reference类型的长度，32位系统下reference类型的长度为32位，64位系统若开启了对象指针压缩的优化则长度为32位，否则为64位。不那么较真的情况下，通常我们都认为reference类型是32位的。虽然JVM规范对reference类型的要求很是模糊，但一般来说，JVM实现至少应该可以使用reference类型做到如下两点：一是从次引用中直接或间接地查找到对象在Java堆中的数据存放的起始地址索引(找到实例信息)。二是从此引用中直接或间接地查找到对象所属的类在方法区中存储的类型信息(找到模版信息)。二者结合才是一个完整的对象信息。否则就无法实现Java语言规范中规定的语法约束(并非所有语言都能实现这两个要求，例如C++就仅实现了第一点，未实现第二点)。 returnAddress类型配合jsr,jsr_w,ret等跳转相关的指令使用，用于在跳转后指向需返回的字节码偏移量。历史上曾使用该机制处理异常，自JDK1.7起returnAddress连同这些字节码指令均被废弃，异常机制使用class文件-方法表集合-方法表-属性表集合-Code属性-异常表集合实现。 上文中讨论的数据类型都是小于等于32位的(姑且认为引用类型就是32位的)，而Java语言规范中明确规定大于32位的数据类型只有两种，且均为64位，即long,double。对于这两种类型，JVM会采取高位对齐的方式(也就是前32位是高位，后32位是低位)为其分配两个连续的Slot。即取用时是这样的： 1(前32位 &lt;&lt; 32) | 后32位 这种把long和double分割存储的思路和Java内存模型中关于long和double的非原子协定(将1次对64位数据的读写操作拆解为两次对32位数据的读写操作。因此这次对64位数据的读写操作就不是原子的了)很类似。不过局部变量表位于栈帧中，栈帧位于虚拟机栈或本地方法栈中，而栈又是线程私有的，因此不会涉及到线程安全问题。 JVM通过索引来定位局部变量表中的变量。因此局部变量表看起来就像是一个数组。若某局部变量表占用空间为solt_count个solt，则其索引范围为[0,solt_count-1]。对于那些能被1个Slot所容纳的数据类型而言，一个Slot中放置一个变量。对于long及double这两个64位的数据类型而言，两个Slot才能容纳一个变量，该变量的索引为其所占据的第一个Slot的索引。在字节码指令调用这件事上，每个变量都是不可再分割的整体，因此调用这些变量的第二个Slot的索引是不合法的，其应该在类加载的连接-验证-字节码验证阶段被检查出来并抛出相应的异常。 关于局部变量表中变量的顺序，默认先按照传入顺序存入方法的传入参数，而后再结合局部变量在方法体内部的声明顺序和作用域分配剩余Slot。特别的，若方法为实例方法，那么传入参数列表中将默认隐含该实例方法所属实例的引用(也就是我们在代码中常用的this)，并且该引用将固定占据局部变量表的0号索引。 因为局部变量都是有作用域的，因此若当前程序计数器中指明的指令偏移量已超出了某局部变量的作用范围，该局部变量实际上就已经没用了。因此局部变量表中的Slot是可以复用的，从而节省了栈帧的使用空间。不过，这种复用的设计在某些情况下可能会产生负面影响，例如影响JVM的GC系统。我们来看下面的代码： 123456789public class Test &#123; /** * 启动参数：-verbose:gc */ public static void main(String[] args) &#123; byte[] byteArray = new byte[100 * 1024 * 1024]; System.gc(); &#125; 一个byte占据1字节(1B)，除去数组本身所需的少量内存空间，byteArray共使用100MB的空间，我们来运行以下这段代码： 12[GC 103731K-&gt;102952K(227328K), 0.0140411 secs][Full GC 102952K-&gt;102868K(227328K), 0.0121913 secs] 很显然，byteArray所使用的这100MB空间并没有被GC回收掉，这个很好理解，毕竟System.gc()执行时并未超出byteArray的作用域，那么我们再做如下修改： 123456789101112public class Test &#123; /** * 启动参数：-verbose:gc */ public static void main(String[] args) &#123; &#123; byte[] byteArray = new byte[100 * 1024 * 1024]; &#125; System.gc(); &#125;&#125; 输出： 12[GC 103731K-&gt;102968K(227328K), 0.0020960 secs][Full GC 102968K-&gt;102868K(227328K), 0.0121942 secs] 很显然，byteArray依然没有被GC回收。这就让人有些疑惑了，因为此次System.gc()执行时已经超出byteArray的作用域了，byteArray已经没用了，GC为什么不回收它呢？在回答这个问题之前，我们不妨再修改一下这段代码： 12345678910111213public class Test &#123; /** * 启动参数：-verbose:gc */ public static void main(String[] args) &#123; &#123; byte[] byteArray = new byte[100 * 1024 * 1024]; &#125; byte b = 1; System.gc(); &#125;&#125; 这个局部变量b加的看起来有些莫名其妙，然而此时我们再次运行这段代码： 12[GC 103065K-&gt;103016K(227328K), 0.0013827 secs][Full GC 103016K-&gt;468K(227328K), 0.0145637 secs] 这次byteArray终于被GC回收了。 在以上3个小例子中，byteArray能否被回收的核心依据为：局部变量表的Slot中是否还存着byteArray数组对象的引用。只要还存着，这个引用就将作为GC Root被GC所参考，从而让byteArray在可达性分析中逃过被打上GC标记的命运。第一次修改后，虽然System.gc()执行时已经超出byteArray的作用域了，但是在其执行前没有任何对局部变量表的读写操作，byteArray原本所占用的Slot还没有被其他变量所复用，因此自然无法回收。至此第二次修改的目的就很明确了，新定义的变量b重用了byteArray所占据的空间，从而byteArray得以被GC所回收。 绝大多数时候，这个例子所体现的问题并没有什么大不了的，因为并不是内存泄漏了，只是回收的没那么及时而已。不过某些情况下，若局部变量占据的内存很大，后文又会进行耗时很长的操作，导致这部分内存迟迟得不到回收，可能会出现不可接受的后果。 因此为了保险期间，显然手动处理一下才更为合理。不过第二次修改中那种莫名其妙的加一个不使用的局部变量的做法实在是有点2，通常我们会采取更易于理解，更优雅的做法： 1234567891011121314public class Test &#123; /** * 启动参数：-verbose:gc */ public static void main(String[] args) &#123; byte[] byteArray = null; &#123; byteArray = new byte[100 * 1024 * 1024]; &#125; byteArray = null; System.gc(); &#125;&#125; 这样的话，即便System.gc()执行时byteArray尚未被覆盖，但由于我们已经明确将其置为null，GC自然敢大胆的回收byteArray了。输出： 12[GC 103065K-&gt;102968K(227328K), 0.0015879 secs][Full GC 102968K-&gt;468K(227328K), 0.0158991 secs] 因此，”不使用的对象应手动赋值为null”，是一个很有用的小技巧。不过也有人认为无需将其上升到”编程规范”的高度。原因主要有以下两点： 首先，从编写代码时的逻辑思路来看，通过合理的作用域来隐式的控制局部变量的GC才是最优雅的。赋null值其实是为了照顾JVM的缺陷而强行添加的补救措施。会破坏代码的完整性，使得开发过程不那么流畅。开发出的代码看起来也总有些别扭，不那么”美”。 其次，以上的小例子都是基于字节码执行引擎的概念模型，换句话说，如果有一个JVM的实现，老老实实的严格按照JVM规范来做，可灵活实现的地方也采取尽量简单笨拙的方式，对于这种采用纯解释执行又没有太多优化的JVM实现而言(例如JDK1.0时代的默认JVM实现Sun Classic VM)，上述3个小例子中的问题是会存在的。然而当今JVM早已采用了编译与解释混合执行的方式。以Hotspot而言，若某方法被编译为本地代码(Java编译的默认单位是方法)，在开启JIT编译优化后，赋null值这种操作就会被编译优化去掉，也就是说此时写了也白写。同时字节码被编译为本地代码后，对GC Roots的枚举方式也与解释执行(或者也可以说我们通常在分析GC时使用的那个模型)时有巨大差别，仍分析上文的小例子，若其被JIT编译为了本地代码，即便没有添加赋null值的代码，也能正确及时回收局部变量(只是理论，我通过增加回边数成功触发编译了，然而并未成功回收byteArray，可能是哪里编写得尚有问题)。 对于类变量而言，存在两次赋值(详见JVM-类加载机制)。第一次是类加载的连接-准备阶段，JVM会为其赋上对应数据类型的零值。第二次是类加载的初始化阶段，会赋上开发人员在代码里定义的具体值。因此，即便初始化阶段没有赋值也不会产生异常，因为类变量已被填入零值。换句话说，我们可以在代码中定义类似这样的类变量： 1private static int V_1; 此时虽然看似V_1并没有被赋值，但实际上其会在类加载的连接-准备阶段赋上int型的零值0。 类似的，对于实例变量而言，虽然赋值时机不同，然而依然会经历类似的两次赋值。因此我们可以下述代码： 1private int v2; v2也会被默认填入int型的零值0。 然而对于局部变量而言，其并没有JVM为其默认赋零值的阶段。因此单单只是声明一个局部变量是无法使用的。例如以下代码是无法通过编译的，会提示The local variable v may not have been initialized。 1234567public class Test &#123; public static void main(String[] args) &#123; int v; System.out.println(v); &#125;&#125; 操作数栈JVM的解释执行引擎被称为基于栈的执行引擎。这里的栈指的就是操作数栈。 操作数栈(Operand Stack)也称作操作栈，它既然被称为栈，自然具备栈结构的基本特性：后人先出(LIFO,Last In First Out)。同局部变量表一样，操作数栈的最大深度也会在编译期确定，并写入： class文件-方法表集合-方法表-属性表集合-Code属性-代表操作数栈最大深度的max_stack。 max_stack的基本单位为32位。即max_stack=3表示该操作数栈能容纳3个基本元素，每个基本元素的大小为32位。对于long和double这两个64位的数据类型而言，它们将占据两个基本栈元素的空间。这与局部变量表的Slot体系是对应的。 max_stack的计算法则为，在保证任何时刻操作数栈压入基本栈元素的个数小于等于max_stack的前提下，让max_stack尽量的小。换句话说，max_stack就是方法整个运行周期中可能装入的最大的栈元素的个数。 方法刚开始执行时操作数栈是空的，随着方法体中代码的执行(其实就是依逻辑调用class文件-方法表集合-方法表-属性表集合-Code属性-字节码指令集合中的字节码指令组合)，字节码指令会将执行所需的数据压入操作数栈，计算完成后再将结果压入操作数栈。例如在执行int型加法指令iadd时，会将栈顶的两个int型整数弹出，相加后再将得到的int型结果压回操作数栈。由这个小例子我们也可以看出，字节码指令在执行时操作数栈栈顶的元素必须与该字节码指令严格配合。例如在iadd时，若栈顶的两个元素是一个float一个int，iadd会执行失败。Java设计者在编译期保证了这一点，同时也会在运行期的类加载的连接-验证-字节码验证阶段确认这一点。 在JVM规范所给出的概念模型中，虚拟机栈或本地方法栈中的栈帧间是完全独立的。然而大多数JVM实现都会做一些优化处理，令相邻的两个栈帧间出现一部分重叠。如下图所示。 方法链的调用往往遵循以下规则：执行到某条方法调用命令，该命令读取操作数栈中的参数(例如新方法的全路径名，描述符，所需参数等)调用新方法并压入代表这个新方法的栈帧。如果栈帧间是完全独立的，那么这个新的栈帧所需的传入参数必须要由调用它的方法复制一份，而这种复制行为其实是可以很容易避免的。解决策略就是上图的做法。每个栈帧的最下部是局部变量表，最上部是操作数栈，这样对于紧邻的两个栈帧而言，就可以让下面的栈帧中的操作数栈与上面的栈帧的局部变量表共享一部分信息，避免了入参的复制。节省空间，提高效率。 动态连接Class文件的常量池集合在记录方法时使用的是符号引用。而想要使用是必须进行连接的(也就是将符号引用替换为直接引用)。其连接原则就是只要能确定具体调用的方法了，就尽早进行连接。因此，编译期就能确定调用版本(注意，编译期仅仅是能确定，而并未真的替换。所有连接的替换操作都是发生在运行期的)的方法会在类加载的连接-解析阶段或者第一次使用时转化为直接引用。 能被子类继承的方法是无法在编译期确定版本的。因为编译期只能得到该引用的静态类型，若方法能被继承，说明当具体运行到这一句字节码指令时，其实际类型可能与静态类型不同(实际类型可能是该静态类型，也可能是该静态类型的子类)。而编译期显然不能预测到该实际类型到底是什么。 不过反过来说，如果一个方法不允许被子类继承，那么它必然可以在编译期就确定调用版本。这些方法包括：静态方法，私有方法，构造方法，被final修饰的方法等。这些方法的连接过程被称为解析。其连接手段是静态多分派。 而对于剩下那些能被子类继承的方法而言，除了依然要进行静态多分派之外，当程序执行到该字节码指令时，还要进行动态单分派。这些方法至此才能真正的完成连接操作。它们在执行阶段进行的连接操作被称为动态连接(Dynamic Linking)。 每个栈帧都会包含一个指向运行时常量池中该栈帧所属方法实际版本的引用，其值是动态连接之后的结果(当然，无法被继承的方法在方法调用版本判断时是没有动态连接这一步的，不过统一都这样称呼)，因此也称为栈帧中的动态连接信息(Dynamic Linking)。 方法返回地址首先需要明确的是，这里所说的栈帧中的方法返回地址(Return Address)与上文局部变量表中说到的那个被废弃的数据类型returnAddress从名字上来看很相似，但实际上二者完全没有关系。 当一个方法开始执行后(即产生了栈帧并压入操作数栈)，只有两种方式可以退出这个方法(即该方法对应的栈帧从操作数栈中弹出)。 第一种退出方式被称为正常完成出口(Normal Method Invocation Completion)。一如其名，也就是方法顺顺利利的执行完成。此种方式的触发条件为字节码执行引擎遇到任意一个表示方法返回的字节码指令。这时可能会有返回值传递给上层的方法调用者(即调用该方法的方法)。是否有返回值及返回值的类型将由遇到的那条方法返回指令决定。 另一种退出方式被称为异常完成出口(Abrupt Method Invocation Completion)。自然指得就是方法在执行过程中遇到异常(包括JVM内部产生的异常及代码使用athrow字节码指令手动抛出的异常)，并且该异常本方法无法处理(即本方法的异常表中没有搜索到匹配的异常处理器，该异常表存储于class文件-方法表集合-方法表-属性表集合-Code属性-异常表集合)。就会导致方法退出。使用这种方式退出的方法是不会给它上层的方法调用者传递任何返回值的。 无论采用哪种退出方式，在方法结束后，都需要返回到它的上层方法调用者调用它的位置，这样程序才能继续执行。方法结束实际上就意味着当前栈帧的出栈。此时需执行的操作可能有： 恢复上层方法调用者的局部变量表和操作数栈。 把返回值(如果有的话)压入上层方法调用者的操作数栈中。 调整所属线程的PC计数器的值以指向上层方法调用者调用本方法那条指令的下一条指令。 等等。 因此方法返回时可能需要在栈帧中保存一些信息，用于支持上述操作。这部分信息就被称为操作数栈的方法返回地址。一般来说，方法正常退出时，调整后的所属线程的PC计数器的值会存在栈帧的方法返回地址中。而当方法异常退出时，该值将由异常表来决定，因此通常不会存在栈帧中。 附加信息JVM规范允许具体的JVM实现增加一些自定义的信息到栈帧中。例如与调试相关的信息。附加信息完全取决于具体的JVM实现，算是JVM规范在实现灵活性上留的尺度比较大的一个口子。 在实际开发中，一般会将动态连接，方法返回地址与附加信息这3个比较零碎的信息归为一类，统称为栈帧信息。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>Java虚拟机</tag>
        <tag>虚拟机</tag>
        <tag>执行引擎</tag>
        <tag>运行时栈帧结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM-类加载器]]></title>
    <url>%2F2017%2F12%2F04%2FJVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%2F</url>
    <content type="text"><![CDATA[JVM-类加载机制中已讨论过了，JVM规范对于类加载-加载阶段中的限制很少，或者更具体的来说，是对这一阶段中”通过类的全限定名获取该类的二进制字节流”这一动作的限制很少，这为JVM的实现者提供了很高的灵活性。其原理为该动作的绝大多数的实现逻辑被放到了JVM之外(最核心的那一组类的加载逻辑依然控制在JVM内部)，从而其才有可能会被用户代码所影响。实现这一动作的代码模块被称为”类加载器”。 该机制诞生的初衷是为了实现Java Applet。Java最初的崛起依托的也是这种小程序。只是，随着SUN与微软那场著名的世纪撕逼大战的升级，Java Applet技术逐渐式微，至今基本上已完全死掉了(最初的主力业务，浏览器上的Java Applet算是彻底完蛋了。在其他领域，例如智能卡，Java Applet还有一定的生存空间)。然而失之东隅，收之桑榆，类加载器技术本身却探索出了新的发展道路，现在其已是Java技术体系中重要的基石，在类层次划分，OSGi，热部署，代码加密等领域大放异彩。 除了完成”通过类的全限定名获取该类的二进制字节流”这一具体的动作之外，类加载器还起到了重要的类身份识别作用。如果我们将类比作Mybatis配置文件中的statement，那么类加载器就是statement所属的namespace(每一个类加载器都有一个独立的类名称空间)。正如namespace+statement id唯一标识一个statement那样，类加载器+类则唯一标识一个类。更通俗的来说，比较内存中的两个类是否是同一个，必要的前提条件是二者的类加载器相同。否则，即便这两个类来源于同一个class文件，被加载入同一个JVM实现，只要加载它们的类加载器不同，它们就必定不相等。 具体到Java代码层面，这里的”不相等”会体现在类的Class对象的equals()方法，isAssignableFrom()方法，isInstance()方法等方法的返回结果上。同时既然影响了类对象的isInstance()方法，那么自然也会影响实例的instanceof比较。 为了证明这一点，我们自行设计一个类构造器： 123456789101112131415161718192021222324252627package com.test;import java.io.IOException;import java.io.InputStream;public class Test &#123; public static void main(String[] args) throws Exception &#123; ClassLoader myClassLoader = new ClassLoader() &#123; @Override public Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; try&#123; String fileName = name.substring(name.lastIndexOf(&quot;.&quot;) + 1) + &quot;.class&quot;; InputStream is = this.getClass().getResourceAsStream(fileName); byte[] b = new byte[is.available()]; is.read(b); return defineClass(name, b, 0, b.length ); &#125; catch(IOException e)&#123; throw new ClassNotFoundException(name); &#125; &#125; &#125;; Object obj = myClassLoader.loadClass(&quot;com.test.Test&quot;).newInstance(); System.out.println(obj.getClass()); System.out.println(obj instanceof com.test.Test); &#125;&#125; 输出： 12class com.test.Testtrue 这是Java API中推荐的类加载器的自定义方式，即继承ClassLoader类并重写其内部的findClass方法。不过结果却很遗憾的并不符合我们的预期：比较结果是true。难道是前文介绍的类加载器机制有误？还是obj并非是由我们自定义的myClassLoader加载的？ 答案是后者。Java默认并且推荐开发人员遵守其所构造的双亲委派模型(将在后文详述)，简单来说，就是当我们试图用一个类加载器加载某一个类前，会先尝试用该类加载器的父类加载器(这里说的父类是逻辑上的继承关系，并非一定就是写在代码里的那种继承)加载，若父类加载器加载不了，再交给本来打算使用的类加载器。显然，这是一个递归动作，任何一个类加载器的加载操作都会追溯到最顶层的那个类加载器，而后逐级向下查找。直到找到能够加载目标类的类加载器。在上例中，我们所定义的myClassLoader的父类加载器：应用程序类加载器已有能力加载目标类，自然轮不到myClassLoader出手了。 不过有时因为某些特定需求，即便Java不推荐，我们依然不得不破坏双亲委派模型。比如我们现在面临的就是这样的一个”特定的需求”：我们想看看不同类加载器加载到内存里的类到底会不会被判为不相等。为此，我们只能采用Java不推荐的方法，即一步到位，直接重写ClassLoader类中最终用于加载的loadClass方法，并在其内部指定我们自己破坏双亲委派模型的逻辑：无视父类加载器，只用当前我们自定义的类加载器加载： 123456789101112131415161718192021222324252627package com.test;import java.io.IOException;import java.io.InputStream;public class Test &#123; public static void main(String[] args) throws Exception &#123; ClassLoader myClassLoader = new ClassLoader() &#123; @Override public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123; try &#123; String fileName = name.substring(name.lastIndexOf(&quot;.&quot;) + 1) + &quot;.class&quot;; InputStream is = this.getClass().getResourceAsStream(fileName); byte[] b = new byte[is.available()]; is.read(b); return defineClass(name, b, 0, b.length); // 17行 &#125; catch (IOException e) &#123; throw new ClassNotFoundException(name); &#125; &#125; &#125;; Object obj = myClassLoader.loadClass(&quot;com.test.Test&quot;).newInstance(); System.out.println(obj.getClass()); System.out.println(obj instanceof com.test.Test); &#125;&#125; 输出： 1234567Exception in thread &quot;main&quot; java.lang.NullPointerException at com.test.Test$1.loadClass(Test.java:15) at java.lang.ClassLoader.defineClass1(Native Method) at java.lang.ClassLoader.defineClass(ClassLoader.java:800) at java.lang.ClassLoader.defineClass(ClassLoader.java:643) at com.test.Test$1.loadClass(Test.java:17) at com.test.Test.main(Test.java:23) 结果依然很糟心(人生不如意事十之八九=-=)，报错的地方是17行。我进到了这个defineClass方法内部，一路跟踪。发现它会以目标类的父类为参数再次调用我们自定义的类加载器。由于这是个递归的过程，看来是会一直追溯到Object类了。于是我尝试输出了一下fileName： 12345678910111213141516171819202122232425262728package com.test;import java.io.IOException;import java.io.InputStream;public class Test &#123; public static void main(String[] args) throws Exception &#123; ClassLoader myClassLoader = new ClassLoader() &#123; @Override public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123; try &#123; String fileName = name.substring(name.lastIndexOf(&quot;.&quot;) + 1) + &quot;.class&quot;; System.out.println(fileName); InputStream is = this.getClass().getResourceAsStream(fileName); byte[] b = new byte[is.available()]; is.read(b); return defineClass(name, b, 0, b.length); &#125; catch (IOException e) &#123; throw new ClassNotFoundException(name); &#125; &#125; &#125;; Object obj = myClassLoader.loadClass(&quot;com.test.Test&quot;).newInstance(); System.out.println(obj.getClass()); System.out.println(obj instanceof com.test.Test); &#125;&#125; 输出： 123456789Test.classObject.classException in thread &quot;main&quot; java.lang.NullPointerException at com.test.Test$1.loadClass(Test.java:16) at java.lang.ClassLoader.defineClass1(Native Method) at java.lang.ClassLoader.defineClass(ClassLoader.java:800) at java.lang.ClassLoader.defineClass(ClassLoader.java:643) at com.test.Test$1.loadClass(Test.java:18) at com.test.Test.main(Test.java:24) 果然，我们的loadClass被调用了两次，而第二次传入的java.lang.Object类我们自定义的类加载器当然没有加载的权限，is自然是null。知道了症结所在，解决起来就简单了。加载不了继续委派给父类加载器就可以了。看来父类加载器并非完全没用，我们的破坏实际上相当于将双亲委派模型的查询顺序倒了过来： 12345678910111213141516171819202122232425262728package com.test;import java.io.IOException;import java.io.InputStream;public class Test &#123; public static void main(String[] args) throws Exception &#123; ClassLoader myClassLoader = new ClassLoader() &#123; @Override public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123; try &#123; String fileName = name.substring(name.lastIndexOf(&quot;.&quot;) + 1) + &quot;.class&quot;; InputStream is = this.getClass().getResourceAsStream(fileName); if (null == is) return super.loadClass(name); byte[] b = new byte[is.available()]; is.read(b); return defineClass(name, b, 0, b.length); &#125; catch (IOException e) &#123; throw new ClassNotFoundException(name); &#125; &#125; &#125;; Object obj = myClassLoader.loadClass(&quot;com.test.Test&quot;).newInstance(); System.out.println(obj.getClass()); System.out.println(obj instanceof com.test.Test); &#125;&#125; 输出： 12class com.test.Testfalse 终于我们成功了，也顺利验证了前文理论知识的正确性。 双亲委派模型从JVM的角度来看只有两种类加载器，也就是被留在自身内部的”核心”及被丢到自身之外的”弃儿”： 启动类加载器(Bootstrap ClassLoader)：即被留在JVM内部的”核心”。其使用C++实现(强调一下，特指HotSpot VM)。 其他类加载器。即独立于JVM外部的”弃儿”。均采用Java语言实现，并均继承自抽象类java.lang.ClassLoader。 启动类加载器负责加载如下核心类： &lt;JAVA_HOME&gt;/lib目录(这里的&lt;JAVA_HOME&gt;指的是jre)下的类。 被-Xbootclasspath参数所指定的路径中的类。 除此之外，还需要类所属的文件名能被JVM所识别。换句话说，启动类加载器的类加载检查其实很严格，只能加载有数的那么几个系统核心类(例如rt.jar)，并不是随便将个jar包丢到&lt;JAVA_HOME&gt;/lib目录下启动类加载器就会去加载。 既然启动类加载器被保留在了JVM内部，那么很显然，开发人员无法直接引用它。对于HotSpot而言，被启动类加载器加载的类的类加载器是null，仿佛它不存在一样： 123456789package com.test;public class Test &#123; public static void main(String[] args) &#123; System.out.println(Object.class.getClassLoader()); System.out.println(Test.class.getClassLoader()); &#125;&#125; 输出： 12nullsun.misc.Launcher$AppClassLoader@e1641c0 显然，除了启动类加载器之外，JVM对于它的弃儿们过于的冷漠了，一句”其他”就全打发了。这些”其他”其实又可分为两类： 扩展类加载器(Extension ClassLoader) 应用程序类加载器(Application ClassLoader) 扩展类加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载如下类： &lt;JAVA_HOME&gt;/lib/ext目录(这里的&lt;JAVA_HOME&gt;指的是jre)下的类。 被系统变量java.ext.dirs所指定的路径中的类。 从名称上就可以看出来，扩展类加载器加载的是核心类库的扩展，自然也就没那么重要了。因此才会被移出JVM，用户代码也可以直接使用该类加载器。 应用程序类加载器由sun.misc.Launcher$AppClassLoader实现。很显然，较之扩展类加载器，应用程序类加载器更加的远离核心，它负责加载用户路径(也就是我们在安装Java时通常都会配置的那个环境变量ClassPath)中指定的类库，用户代码自然也可以直接使用该类加载器。因此，我们日常写的代码如果没有做特别的关于类加载器方面的操作(例如上文我们强行破坏双亲委派模型的例子)，默认的类加载器就是这个应用程序类加载器。 123456public class Test &#123; public static void main(String[] args) &#123; System.out.println(ClassLoader.getSystemClassLoader()); &#125;&#125; 输出： 1sun.misc.Launcher$AppClassLoader@7d05e560 如上代码所示，ClassLoader的类方法getSystemClassLoader默认返回的类加载器就是这个应用程序类加载器。因此它也被称作系统类加载器。从这里我们也能看出，对于Java设计者而言，他们是希望用户能尽量不去干扰更上一层的扩展类加载器(然后完全忘掉启动类加载器)，而以应用程序类加载器为代码中类加载器的根。 至此，Java预定义的类加载器已全部介绍完毕。如果有必要，用户可以再写自定义的用户类加载器(User ClassLoader)。其结构关系通常如下图所示： 这种层次继承关系被称为类加载器的双亲委派模型(Parents Delegation Model)。需要注意的是，这里的继承并不是指Java语法上的继承，而是一种更抽象的，表达执行次序的关系。例如，前文我们所做的破坏双亲委派模型，我们的匿名内部类直接继承的是抽象类ClassLoader，然而在双亲委派模型的层次继承关系中，我们自定义的这个用户类加载器依然是应用程序类加载器的孩子。或者我们可以用更准确的词语来表达：双亲委派模型中类加载器间的父子关系并非继承(Inheritance)，而是以组合(Compositon)的方式复用。父亲更像是儿子执行的前置条件。 所谓双亲委派模型，就是当我们试图用一个类加载器加载某一个类前，会先尝试用该类加载器的父类加载器加载，若父类加载器加载不了(它的搜索范围中并没有目标类)，再交给本来打算使用的类加载器。显然，这是一个递归动作，任何一个类加载器的加载操作都会追溯到最顶层的启动类加载器，而后逐级向下查找。直到找到能够加载目标类的类加载器。 双亲委派模型诞生自JDK1.2，所有类默认遵守该模型。然而，双亲委派模型并非是强制规范(例如，上文我们就写出了破坏双亲委派模型的代码)，而只是Java设计者的一种推荐。之所以如此推荐，就是为了保证类的唯一性，否则在内存中可能就会产生大量仅仅是因为类加载器不同而导致的不同的类。例如&lt;JAVA_HOME&gt;/lib目录下rt.jar中的java.lang.Object类，由于双亲委派模型的存在，内存中只会存在一个java.lang.Object类，且该类必然由启动类加载器加载。 即便某些开发人员写出了自己的java.lang.Object类，并放在ClassPath下，这个自定义的类依然无法被加载。因为按照双亲委派模型，该类的加载请求会先被送到顶层的启动类加载器中。启动类加载器一检查，java.lang.Object类已经在此前被自己加载过了(就是rt.jar中那个真正的Object)，因此直接就把这个加载结果返回了。自定义的java.lang.Object类则永无加载机会。 上文中我们既写出了破坏双亲委派模型的用户类加载器。也写出了顺应双亲委派模型，官方推荐的通过重写findClass方法实现的用户类加载器。 那么为什么重写了findClass方法双亲委派模型就能生效呢？我们不妨看下所继承的抽象类ClassLoader的源码。如果我们只是重写findClass方法，那么其loadClass(Sring str)依然保持原样，为： 123public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123; return loadClass(name, false);&#125; 我们再来看这个loadClass(name, false)： 12345678910111213141516171819202122232425262728293031323334protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException&#123; synchronized (getClassLoadingLock(name)) &#123; // 先检查目标类是否已被加载过了，避免重复加载 Class c = findLoadedClass(name); if (c == null) &#123; long t0 = System.nanoTime(); try &#123; // 触发双亲委派模型，从父类加载器查起 if (parent != null) &#123; c = parent.loadClass(name, false); &#125; else &#123; c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; &#125; // 父类加载器没找到 if (c == null) &#123; long t1 = System.nanoTime(); c = findClass(name); // 调用我们重写的findClass方法 sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125;&#125; 破坏双亲委派模型除了前文提到的为了验证理论正确性这种可有可无的原因之外，碍于需求特殊，在官方历史中双亲委派模型主要出现过3次较大规模的被破坏的情况。 第一次破坏：向前兼容 双亲委派模型诞生于JDK1.2，而所有JVM之外的类加载器共同继承的抽象类ClassLoader则诞生于JDK1.1。在JDK1.2之前，开发人员都是直接重写loadClass方法以实现用户类加载器，因此时双亲委派模型尚未诞生，自然也不存在什么破坏不破坏之说。然而，在双亲委派模型诞生后，那些诞生于JDK1.1时代的，不遵循双亲委派模型的代码又必须兼容。本来，按照最简明干净的设计，因为双亲委派模型委派双亲的逻辑都在loadClass方法中，为防被破坏不应允许开发人员再轻易重写这个方法了，大家都重写官方推荐的findClass方法就好。然而为了兼容此前已经重写了这个方法的版本，又不得不允许重写：这就为破坏双亲委派模型留下了一个口子，其无法成为一个强制规范，而只能是希望开发人员自觉遵守的推荐。正如上文中我们所做的，很轻易的就将其破坏了。 第二次破坏：上层类调用下层类 首先我们先建立上层类与下层类的概念。因类加载器是有层级关系的，而类加载器+类信息又完全确定内存的一个类，因此这些内存中的类会因加载它们的类加载器而同样具有层级关系。被越是顶层的类加载器所加载的类的层级越高。Java的设计者将越是基础，越是核心的类用越是等层的类加载器加载，这很好理解：这些基础类是大哥，是要被用户类仰望，调用的存在。加载时按照双亲委派模型，优先用上层类加载器加载它们合情合理。 但是问题在于，有时大哥也需要调用小弟。或者更具体的说，上层类在加载时需要调用下层类，此时双亲委派模型就无法实现了。 一个比较典型的例子就是JNDI服务(类似的还有JDBC,JCE,JAXB,JBI等)。JNDI(Java Naming and Directory Interface,Java命名和目录接口)是SUN公司提供的一种标准的Java命名系统接口，JNDI提供统一的客户端API，并在运行时映射为不同的命名服务和目录系统。因这些实现都遵循相同的接口规范，Java应用程序便可以在这些命名服务和目录服务之间进行交互。JNDI服务是Java所提供的标准服务，其代码位于&lt;JAVA_HOME&gt;/lib目录下的rt.jar，由启动类加载器负责加载。但是由于JNDI服务的目的就是统合管理不同的命名和目录系统，因此其必然需要调用不同厂商提供的接口实现，即JNDI接口提供者(SPI,Service Provider Interface)。显然这些外部服务的代码所能使用的类加载器的最高层级也就到应用程序类加载器，其位置往往也都是位于ClassPath下。而启动类加载器则无法加载这些下层类。 为解决这个问题，Java设计者只好引入了一个不那么优雅的设计：线程上下文类加载器(Thread Context ClassLoader)。当创建线程A时，A会从父线程中继承到这个类加载器。若没有父类线程，则会默认填入应用程序类加载器。在线程创建后，开发人员也可以通过Thread类提供的setContextClassLoader方法设置自定义的用户类加载器。直白点说，启动类加载器不是读不到ClassPath下的第三方类嘛，那么就开个后门，再提供一个能读到这些类的类加载器，即该上下文类加载器。这样虽然能完成需求，但却相当于父类加载器请求子类加载器去完成类加载动作，打通了双亲委派模型的逆向调用顺序，是对双亲委派模型的一种破坏。 第三次破坏：追求程序动态性 所谓的动态性，就是指代码热替换(HotSwap)，模块热部署(Hot Deployment)等一系列花活。说白了，就是希望Java程序的代码能像电脑的键盘，鼠标，U盘这类支持热插拔的外设一样。插上就能用，想换直接换，而不用对电脑进行重启。这是有很重要的实际意义的。大型软件重启是一件代价很高的事：这意味着在此期间服务停止，或者为了维持服务可用不得不建立分布式备份。如果上下线能实现代码的热替换，将是一个重大的进步。 当前主流的Java动态性的支持来自于OSGi标准。在此我想多八卦几句，Sun在很早之前就认识到了模块化和动态性的重要性，相继提出了JSR-294，JSR-277规范(即Java模块系统，Java Module System)，然而遗憾的是市场却并不承认：在Java模块化规范这个问题上，Sun在与JCP组织的战争中败下阵来，市场公认的标准也是JCP组织的JSR-291(也就是大名鼎鼎的OSGi R4.2)。然而头铁是Sun一惯的作风，在Java这个语言上，SUN要的是绝对的统治力，所有关于Java的规范都得是自己制定的才行。无奈自己的标准实在是得不到认可，SUN便另起炉灶，你们不是不认可我的标准嘛？没事，我也不认可你们。这么想着SUN便独立搞起了Jigsaw项目继续做自己的标准。由此来看SUN这个公司的性格确实是有些问题，最终落得惨淡收场应该也是有很大的自身性格原因(和微软的那场世纪撕逼大战其实也类似)。 虽然名义上有两套标准了，但是我们要重点说的当然还是OSGi标准。OSGi(Open Service Gateway Initiative)是OSGi联盟(OSGi Alliance)制定的一个基于Java语言的动态模块化规范。这个规范最初由Sun(注意，最初是有Sun的。所以说Sun可真是…)，IBM，爱立信等公司联合发起，目的是使服务提供商通过住宅网关为各种家用智能设备提供各种服务(也就是OSGi这个名字的具体含义)，后来OSGi得到了不错的发展，其含义也得到扩展，现在已经成为了Java世界中”事实上”的动态模块化规范(之所以要打双引号，是因为虽然市场承认这个规范，然而大哥Sun不承认)。 OSGi已有诸如Equinox,Felix等成熟的实现，另外许多大型软件平台和中间件服务器都基于或已声明将会基于OSGi规范来实现，例如IBM Jazz平台，GlassFish服务器，jBoss OSGi等。同时后文欲讨论的热插拔技术基于的也是OSGi规范。不过对于普通的程序员而言，OSGi最著名的应用当属Eclipse IDE。 OSGi的每个模块(Bundle)与普通的Java类库的区别并不大，二者一般都以JAR格式封装，内部存储的也都是Java Package和Class。然而OSGi的模块有着更高的灵活性：它可以通过Import-Package声明自身所依赖的Java Package，也可以通过Export-Package声明它允许导出发布的Java Package。这样可以使得类的访问权限更为精确，未被Export的Package及Class均会被隐藏起来。 对于标准的Java应用而言，类库间的依赖是有明显的层级关系的：程序员所编写的代码都依赖于Java的核心类库。而OSGi则打破了这种层级关系，至少从外观上来看，因为OSGi的模块本身基本是平级的，其模块间的依赖自然也是平级关系的依赖。 OSGi之所以能有上述区别于Java标准应用的特点，主要源于它那灵活的类加载器架构。 OSGi完全颠覆了Sun推荐的双亲委派模型。在OSGi中，每个模块都有一个属于自身的类加载器，而各类加载器之间只有规则，没有固定的委派关系。正因为模块与类加载器是这种一对一的关系，那么上面那句话我们也可以反过来说：每个类加载器都负责管理加载一个模块，所有对这个模块中的Package或Class的加载都由该类加载器完成。这样根据每次具体代码的不同，都会形成不同的临时的类加载器层次结构。或者更明确的说，在OSGi环境下，类加载器的层级结构不再是双亲委派模型中的树状结构，而是发展为了更复杂的网状结构。简单来说，除了最核心的那些类有点层级关系之外，绝大多数的类都是在平级的类加载器中完成的。 OSGi标准实现模块化热部署的基石也正是它的类加载机制：每个程序模块都有一个属于自己的类加载器，当需要做热替换更换一个Bundle时，会把该Bundle连同其类加载器一起换掉。 Tomcat中的类加载器主流的Java Web服务器，如Tomcat，Jetty，WebLogic，WebSphere等都会实现自定义类加载器，而且通常都不止一个。这主要是由Web服务器的功能需求决定的： 在JVM眼中，所谓的Web服务器也不过是一个普通的Java程序(这里指那些由Java写成的Web服务器)，并没有什么特殊的。然而在程序员眼中Web服务器却是部署应用的平台：它不该是程序，它应该是程序的容器。这几乎是后面我们要论述的一切矛盾的根源。 既然我们认为Web服务器是部署应用的平台，那么一个最基本的需求就是部署在同一个Web服务器上的两个应用程序应该实现代码隔离，或者起码来说，要让程序员看起来是这么回事。例如两个不同的应用可能会同时依赖于同一个第三方类库(也就是我们一般意义上的jar包)的不同版本，而因为是同一个类库，因此该类库绝大多数的代码，包括包路径，类路径等等都是相同。此时服务器不仅仅要同时加载这两个版本，并且还能明确知道哪个版本是给哪个应用用的。 我们再来说说上一条需求的反面。实际开发中，若服务器上的两个应用用到了同一个类库，那么使用不同版本的可能性其实不大。绝大多数情况下都会使用相同的版本。此时就涉及到共享的问题了。当然，我们也可以继续沿用上个需求的做法，即便版本相同，也为各个应用独立加载类库。从磁盘存储的角度上讲，这样做的影响一般不大(毕竟硬盘通常都是很大的，多放几个jar包基本没什么问题)。但是内存的消耗就有些大了，独立加载意味着多加载了好多重复的类到内存，而内存就没硬盘那么廉价了。因此代码的共享问题也是Web服务器必须考虑的。 很多运行Java应用的Web服务器本身也是用Java编写的，服务器程序本身也存在类库依赖问题。那么对于这类Web服务器而言，还需要考虑安全问题。因为显然不能让应用的代码影响到服务器程序本身，要挂也是只挂你这个应用本身，而不是将整个平台拖垮。因此服务器所使用的类库应该与应用的类库隔离。 既然要运行Java应用，那么就要支持JSP。不过JSP文件最终还是要编译为Class文件才能在JVM中执行，而与其它正经的由.java生成的Class文件相比，JSP在运行时修改的概率要大得多。而在网页应用的圈子里(比如ASP,PHP,JSP等)，这些页面基本是被人当做Html去看待的(这也是它们诞生的目的和原因)，那么修改这些页面而无需重启应用就是一件理所当然的事，如果某个页面做不到这一点，那么它基本也就别想在这个圈子里混了。因此既然要支持JSP，那么通常就要支持JSP生成类的热替换(HotSwap)功能。这里既然说到了通常，那么当然有不通常的情况：例如运行在生产模式(Production Mode)下的WebLogic服务器默认就不会处理JSP文件的变化。 正是因为这些原因，单靠JVM所提供的那个应用程序类加载器显然就不够了。因此各种Java Web服务器都会不约而同的设计多个自定义类加载器。反映到表象上，就是Java Web服务器通常都会提供好几个ClassPath路径供用户应用存放自身用到的第三方类库，这些路径通常都会以lib或classes命名。被放置到不同路径下的类库，自然会有不同的访问范围和服务范围。通常，每个路径都会有一个相应的自定义类加载器负责加载放置于其中的类库。 至此，程序员对Java Web服务器在类加载器方面的需求算是大概介绍完了。而为了实现这个相同的需求，各服务器会采取不同的做法，这里我们要聊的是Tomcat。 作为Apache基金会中的一款开源的Java Web服务器，Tomcat基本上遵循了双亲委派模型。本文中用于举例的Tomcat的版本为apache-tomcat-7.0.82。其目录结构如下： 其类加载架构为： 其中蓝底部分为JVM预设的类加载器，而白底部分则是Tomcat的自定义类加载器。 首先先来看Common这个自定义类加载器，其所加载的类路径存在conf/catalina.properties中，其默认值为： 1common.loader=$&#123;catalina.base&#125;/lib,$&#123;catalina.base&#125;/lib/*.jar,$&#123;catalina.home&#125;/lib,$&#123;catalina.home&#125;/lib/*.jar 关于Tomcat中catalina.base及catalina.home的区别，详见Tomcat-CATALINA_HOME与CATALINA_BASE 然后我们再来看看这个lib目录下到底有什么： 很显然，这是Tomcat容器级别所依赖的类库。这里我想多说一句的是，很多程序员在用Eclipse之类的IDE编写Servlet程序时会提示缺少servlet-api.jar的依赖，然而即便不管它，将程序打包放到Tomcat后依然可以正确运行。其原因就在于Tomcat已将整个类库加到了其Common类加载器的ClassPath中。 显然，Common类加载器的ClassPath中应该放置Tomcat平台级别的类库，因为它是所有Webapp类加载器的父类加载器。 接着我们继续来看再下一层的Webapp类加载器。显然，它们是应用私有的。每个应用都有一个独立的，与之对应的自定义类加载器。其加载的类库范围为： webapps/用户目录/WEB-INF/classes目录下的用户代码 webapps/用户目录/WEB-INF/lib目录下应用程序所依赖的类库 因为要保证前文提到的需求，这些类加载器就需要破坏双亲委派模型。因此我们才说Tomcat”基本上”遵循了双亲委派模型。对于具体一个类，其类加载器的优先顺序为： 12345启动类加载器扩展类加载器应用程序类加载器WebappCommon 显然，对于JVM预设的那一层次的类加载器而言，Tomcat依然是严格遵循双亲委派模型的。然而到了Tomcat自定义的类加载器这一层，双亲委派模型遭到了破坏：会优先使用应用本身的Webapp类加载器，随后才是Tomcat平台的Common类加载器。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>Java虚拟机</tag>
        <tag>虚拟机</tag>
        <tag>类加载器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 基础-回调]]></title>
    <url>%2F2017%2F12%2F02%2FJava%20%E5%9F%BA%E7%A1%80-%E5%9B%9E%E8%B0%83%2F</url>
    <content type="text"><![CDATA[本文将以两个小例子来说明钩子(Hook)及回调(CallBack)。示例中的人物均出自东方Project。 例子1：钩子魔理沙(Marisa)是一个乐于钻研魔法，研发魔法道具的好孩子，最初，她研发魔法道具的套路为： 12345678910public class Marisa &#123; public void research() &#123; System.out.println(&quot;收集蘑菇等制作道具的素材&quot;); System.out.println(&quot;调戏灵梦&quot;); System.out.println(&quot;查找素材相关的魔法理论知识&quot;); System.out.println(&quot;动手开始研发&quot;); System.out.println(&quot;造出道具&quot;); &#125;&#125; 让魔理沙比较苦手的是第三步”查找素材相关的魔法理论知识”，为此她不得不时常去找自己的后宫帕秋莉(Patchouli)咨询魔法基础姿势，于是逐渐的，研发流程变成了如下的样子： 1234567891011121314151617public class Marisa &#123; public void research(Patchouli patchouli) &#123; System.out.println(&quot;收集蘑菇等制作道具的素材&quot;); System.out.println(&quot;调戏灵梦&quot;); patchouli.teach(); System.out.println(&quot;动手开始研发&quot;); System.out.println(&quot;造出道具&quot;); &#125;&#125;class Patchouli &#123; void teach() &#123; System.out.println(&quot;边咳嗽边传授素材相关的魔法理论知识&quot;); &#125;&#125; 这样魔理沙不仅仅能学习到更多的膜法姿势，还加深了与姬友的感情。然而我们的姆Q实在是太病弱了，久而久之身体逐渐就吃不消了。于是心疼的魔理沙有问题时便不仅仅去找帕秋莉，也会去找她的另一个姬友爱丽丝·玛格特罗依德(Alice)，当她去找小爱时，流程是这样的： 1234567891011121314151617181920212223242526package com.test;public class Marisa &#123; public void research(Alice alice) &#123; System.out.println(&quot;收集蘑菇等制作道具的素材&quot;); System.out.println(&quot;调戏灵梦&quot;); alice.teach(); System.out.println(&quot;动手开始研发&quot;); System.out.println(&quot;造出道具&quot;); &#125;&#125;class Patchouli &#123; void teach() &#123; System.out.println(&quot;边咳嗽边传授素材相关的魔法理论知识&quot;); &#125;&#125;class Alice &#123; void teach() &#123; System.out.println(&quot;边傲娇边传授素材相关的魔法理论知识&quot;); &#125;&#125; 至此钩子(Hook)的基本样式已形成，多数代码如同模版一样不变，而只有少数代码需调用外部，从而实现了功能的特化和分离。这种思想源自23种Java设计模式中的模版方法模式。不过此时依然不够灵活，尚有改进空间。 这样又度过了一段神仙般的日子，不过，魔理沙也愈发觉得自己在后宫关系的处理上无法做到一碗水端平了。她总是不经意的思考：”最近是不是找帕秋莉的次数有点多，小爱会不会吃醋砍我啊”，”上次和小爱玩蘑菇的时候被射命丸文那个狗仔拍到了，她万一告诉帕秋莉怎么办啊”凡此等等。并为此烦恼不止。突然有一天魔理沙灵光乍现，醒悟了一件事：我这是在找我的好姬友探讨魔法姿势啊，又不是什么见不得光的事，在这件事上她们二人都是我的良师益友，为什么要分得这么清楚呢？解开心结后的魔理沙舒畅无比，她心目中的流程变成了这样： 1234567891011121314151617181920212223242526272829303132public class Marisa &#123; public void research(Teacher teacher) &#123; System.out.println(&quot;收集蘑菇等制作道具的素材&quot;); System.out.println(&quot;调戏灵梦&quot;); teacher.teach(); System.out.println(&quot;动手开始研发&quot;); System.out.println(&quot;造出道具&quot;); &#125;&#125;interface Teacher &#123; void teach();&#125;class Patchouli implements Teacher &#123; @Override public void teach() &#123; System.out.println(&quot;边咳嗽边传授素材相关的魔法理论知识&quot;); &#125;&#125;class Alice implements Teacher &#123; @Override public void teach() &#123; System.out.println(&quot;边傲娇边传授素材相关的魔法理论知识&quot;); &#125;&#125; 至此，便完成了一个可灵活扩展配置的钩子。 例子2：回调某一天，上白泽慧音(Keine)老师给橙(Chen)留了一个家庭作业，要她计算1+1等于几。于是橙当晚回家便自己算了起来： 12345678910public class Chen &#123; private int add(int i, int j) &#123; return i + j; &#125; public void homeWork(int i, int j) &#123; System.out.println(&quot;完成作业，结果为:&quot; + this.add(i, j)); &#125;&#125; 首先调用homeWork方法，其内部又触发add方法，整个操作都在Chen这个类的内部完成，不涉及回调 慧音老师看后很是满意，于是第二天留的家庭作业便稍难了一些，变为计算12+23等于几。 这就超出橙的知识范围了，因为她只会计算十以内的加法。没办法，她只好找到了家长八云蓝(Ran)。作为全幻想乡最强大的式神，蓝拥有着超凡的数学天赋和计算能力，比如她可以快速的口算出两个庞大整数的加法结果： 123456public class Ran &#123; public int add(int i, int j) &#123; return i + j; &#125;&#125; 溺爱孩子的蓝挨不住橙的软磨硬泡，只好算出结果后告诉橙，然后橙再将结果写到作业本上完成了作业： 12345678910111213public class Ran &#123; public int add(int i, int j) &#123; return i + j; &#125;&#125;class Chen &#123; public void homeWork(Ran ran, int i, int j) &#123; System.out.println(&quot;完成作业，结果为:&quot; + ran.add(i, j)); &#125;&#125; 此时任务已不完全由Chen完成了，但依然不是回调 没想到第三天，慧音老师出了一道更难的题，竟然已经达到了恐怖的3位数加法：123+456。 至此橙连作业本都不想碰了，她求蓝直接帮她写作业得了。在橙强大的卖萌攻势下，最终蓝还是屈服了，于是当晚的情况是这样的： 123456789101112131415161718192021public class Ran &#123; private int add(int i, int j) &#123; return i + j; &#125; public void addAgent(int i, int j, Chen chen) &#123; chen.homeWork(this.add(i, j)); &#125;&#125;class Chen &#123; public void homeWorkAgent(Ran ran, int i, int j) &#123; ran.addAgent(i, j, this); &#125; public void homeWork(int result) &#123; System.out.println(&quot;完成作业，结果为:&quot; + result); &#125;&#125; 至此回调基本成型：首先调用Chen.homeWorkAgent方法，其内部向Ran.addAgent求助。此时对于Chen而言，整个作业的事算是交代完了，她无需再操心到底是加是减，到底要写什么答案。而对于Ran而言，其在算出答案后，还需要回过头来再调回Chen中的方法homeWork(这也是回调名称的由来)，最终由Ran完成作业。 这样又过了很多天之后，橙的同班同学琪露诺(Cirno)听说了这件事并羡慕不以。毕竟她只能计算5以内的加法。于是她也委托橙让蓝帮帮自己。当晚橙回家又是一通疯狂卖萌，蓝没有办法，只能边擦着鼻血边答应了下来。只是在帮琪露诺时，要做一个小小的角色转换： 123456789101112131415161718192021public class Ran &#123; private int add(int i, int j) &#123; return i + j; &#125; public void addAgent(int i, int j, Cirno cirno) &#123; cirno.homeWork(this.add(i, j)); &#125;&#125;class Cirno &#123; public void homeWorkAgent(Ran ran, int i, int j) &#123; ran.addAgent(i, j, this); &#125; public void homeWork(int result) &#123; System.out.println(&quot;完成作业，结果为:&quot; + result); &#125;&#125; 如是反复数日后，蓝也不禁觉得有些麻烦。然后她突然想到：虽然琪露诺这个傻9完全没法和自家的小宝贝相比，然而在做题这件事上二人的身份其实是一样的，为什么要分得这么清楚呢？想通之后顿觉豁然开朗，于是此后的流程就变成了这样： 1234567891011121314151617181920212223242526272829303132333435363738394041public class Ran &#123; private int add(int i, int j) &#123; return i + j; &#125; public void addAgent(int i, int j, HomeWorkForHelp homeWorkForHelp) &#123; homeWorkForHelp.homeWork(this.add(i, j)); &#125;&#125;interface HomeWorkForHelp &#123; public void homeWork(int result);&#125;class Chen implements HomeWorkForHelp &#123; public void homeWorkAgent(Ran ran, int i, int j) &#123; ran.addAgent(i, j, this); &#125; @Override public void homeWork(int result) &#123; System.out.println(&quot;完成作业，结果为:&quot; + result); &#125;&#125;class Cirno implements HomeWorkForHelp &#123; public void homeWorkAgent(Ran ran, int i, int j) &#123; ran.addAgent(i, j, this); &#125; @Override public void homeWork(int result) &#123; System.out.println(&quot;完成作业，结果为:&quot; + result); &#125;&#125; 至此便完成了一个灵活的回调 总结结合以上两个小例子，让我们来总结下钩子与回调的异同。 首先，两个例子的基本套路是一样的。都有两大阵营：寻求帮助的人和提供帮助的人。我们不妨分别命名为A与B。 不过，在钩子的例子中，故事的主人公(或者说主视角)为A，即雾雨魔理沙，只有一个。而B的角色却有复数个：帕秋莉及爱丽丝。而在回调的例子中，故事的主人公(或者说主视角)则是B，即为八云蓝，只有一个。而A的角色却有复数个：橙和琪露诺。 另一个不同之处在于，在回调中，B必须再次调回A。换句话说，这其实是方法调用过程中同步及异步的差异(可参见Java 并发-同步异步阻塞非阻塞): 钩子：A调用B后等待，待B那边的结果返回后继续执行。即采取的是同步策略。 回调：A调用B后就不管了，待B计算出结果后需要再通知A，此时A根据结果再采取行动。即采取的是异步策略。 需要注意的是，本文中关于回调的代码其实并不是真正异步的，因为A的homeWorkAgent方法实际上只有当B的addAgent方法完成时才能完成，从代码执行逻辑上依然是同步的。要想实现真的异步，还是要采用真正并发编程的策略，让B的addAgent方法完全是在另一个新的线程中执行才可以。同时，如果单看示例中的代码逻辑，橙其实也并非是将作业完全委派给了蓝，因为毕竟homeWork方法还是橙自己的，只是触发人变为了蓝，细追究的话最终干活的人还是橙自己。不过作为一个例子，我想这样已经足以说明回调的原理了。 最后我想说的是，在两个小例子中，我故意用了类似的话： 突然有一天魔理沙灵光乍现，醒悟了一件事：我这是在找我的好姬友探讨魔法姿势啊，又不是什么见不得光的事，在这件事上她们二人都是我的良师益友，为什么要分得这么清楚呢？解开心结后的魔理沙舒畅无比 虽然琪露诺这个傻9完全没法和自家的小宝贝相比，然而在做题这件事上二人的身份其实是一样的，为什么要分得这么清楚呢？想通之后顿觉豁然开朗 这也是我们在解决多角色问题时通用的思路：为什么要分得那么清楚呢？不要过多的被对象复杂的身份所干扰，我们所须关注的仅仅是针对当前功能它们所扮演的是什么角色，只要一样，我们就可以将其抽象为一类，进而提高代码的灵活性。实际上，这就是面向接口编程的精髓所在。]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>回调</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM-类加载机制]]></title>
    <url>%2F2017%2F11%2F23%2FJVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[JVM将描述类的数据从class文件加载到内存，并对数据进行校验，转换，解析及初始化，最终形成可被JVM直接使用的Java类型，这就是JVM的类加载机制。 与那些在编译期就进行连接操作的语言不同，Java中的类型的加载，连接和初始化都是在运行期完成的(实际上这些语言的编译和Java的编译指的也不是同一回事，这些语言编译后直接就生成硬件机器所需的机器码了，自然要完成连接。而Java编译后得到的仅仅是JVM才看得懂的字节码，只是一个半成品)。这样做会增大运行期的性能开销，相应的也为Java提供了高度的灵活性：Java天生就具有的可以动态扩展的语言特性依靠的就是运行期动态加载及动态连接。例如，假设我们编写了一个面向接口的Java应用，那么我们可等到运行期再指定其具体的实现类。再比如，我们可以通过Java预定义的或自定义的类加载器，让一个本地Java应用可以在运行期从网络或其他地方动态加载一段二进制字节码流作为其程序的一部分。 为行文方便，在此为后文的叙述做如下规定： 每个具体的class文件既可能代表一个类，也可能代表一个接口。后文将统一以类来代指类和接口这两种情况。而对于类和接口需区分对待的场合会特别声明。 所谓的class文件只是一种约定俗成的称呼，实际上，class文件并不一定非要是存储于磁盘中的文件，只要是一段符合class规范的二进制字节流即可，无论以何种形式存在均可。 类加载时机在介绍类加载过程之前，首先需要明确类加载的时机，即什么情况才会触发JVM去加载一个类？JVM规范对此并没有做出强制约束，即实际的加载时机全凭具体的JVM实现自行发挥。 类加载过程概览类从被加载到JVM内存开始，到卸载出内存为止，整个生命周期会经历如下5个大的阶段： 加载(Loading) 连接(Linking) 初始化(Initialization) 使用(Using) 卸载(Unloading) 而步骤2连接又可细分为如下3步： 验证(Verification) 准备(Preparation) 解析(Resolution) 拆分后具体可如下图所示： 在分解而得的这7个小步骤中，加载，验证，准备，初始化，使用，卸载这6个步骤的开始顺序是严格有序的，而解析则不一定：某些情况下其可能会在初始化开始之后再开始，这是为了支持Java语言的运行时绑定(也称为动态绑定或晚期绑定)。注意，本段文字在描述顺序时使用的均是”开始”，而非”进行”或”完成”。即这些步骤即便严格有序也是开始的严格有序，往往是各步骤交叉混合运行的，即不会等待一个步骤彻底执行完成再执行下一个步骤，而是通常会在一个步骤的执行过程中调用，激活下一个步骤。 上文提到过，JVM规范并未对类加载时机做强制约束，但是对类加载步骤中的初始化却做了约束，这其实也算是变相约束了类加载时机，因为想要开始初始化，则必须先开始其前置的加载，验证，准备(如前文所述，解析不一定)。这实际上就是在要求类必须要被加载了。具体的，必须开始初始化的时机有以下5种： 时机1 执行以下4条字节码指令时，若对应的类没有初始化，则需要触发其初始化： new：例如使用new关键字实例化对象 getstatic,putstatic：例如读取或设置一个类的类变量(被final修饰且数据类型为基本类型或java.lang.String的类变量除外。因为其值已在编译期存入class文件–&gt;字段表集合–&gt;字段表–&gt;属性集合–&gt;ConstantValue属性中) invokestatic：例如调用一个类的类方法 这里需要说明一下的是第2点。我们不妨来看一段代码。 首先给出O： 12345678public class O &#123; public static String V = &quot;Reimu&quot;; static &#123; System.out.println(&quot;O init&quot;); &#125;&#125; 随后是测试类： 123456public class Test &#123; public static void main(String[] args) &#123; System.out.println(O.V); &#125;&#125; 输出为： 12O initReimu O被初始化了。我们不妨将Test用javap反编译： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465Classfile /E:/Test.class Last modified 2017-11-23; size 439 bytes MD5 checksum 2fcd45f3efed2349f7934e5b3857ce92 Compiled from &quot;Test.java&quot;public class Test SourceFile: &quot;Test.java&quot; minor version: 0 major version: 51 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #6.#15 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = Fieldref #16.#17 // java/lang/System.out:Ljava/io/PrintStream; #3 = Fieldref #18.#19 // O.V:Ljava/lang/String; #4 = Methodref #20.#21 // java/io/PrintStream.println:(Ljava/lang/String;)V #5 = Class #22 // Test #6 = Class #23 // java/lang/Object #7 = Utf8 &lt;init&gt; #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 main #12 = Utf8 ([Ljava/lang/String;)V #13 = Utf8 SourceFile #14 = Utf8 Test.java #15 = NameAndType #7:#8 // &quot;&lt;init&gt;&quot;:()V #16 = Class #24 // java/lang/System #17 = NameAndType #25:#26 // out:Ljava/io/PrintStream; #18 = Class #27 // O #19 = NameAndType #28:#29 // V:Ljava/lang/String; #20 = Class #30 // java/io/PrintStream #21 = NameAndType #31:#32 // println:(Ljava/lang/String;)V #22 = Utf8 Test #23 = Utf8 java/lang/Object #24 = Utf8 java/lang/System #25 = Utf8 out #26 = Utf8 Ljava/io/PrintStream; #27 = Utf8 O #28 = Utf8 V #29 = Utf8 Ljava/lang/String; #30 = Utf8 java/io/PrintStream #31 = Utf8 println #32 = Utf8 (Ljava/lang/String;)V&#123; public Test(); flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 1: 0 public static void main(java.lang.String[]); flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=1, args_size=1 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 3: getstatic #3 // Field O.V:Ljava/lang/String; 6: invokevirtual #4 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 9: return LineNumberTable: line 4: 0 line 5: 9&#125; 很显然，main()方法调用的仍是类O的类变量V，因此此时类必须初始化。 然后我们对O做如下修改，即给V加上final修饰符： 12345678public class O &#123; public static final String V = &quot;Reimu&quot;; static &#123; System.out.println(&quot;O init&quot;); &#125;&#125; 测试类不变，输出变为： 1Reimu 此时O就没有初始化。这其实是Javac编译阶段的常量传播优化：O中被final修饰的类变量V已在编译期被存储到Test类的常量池中。此后Test中对O.V的访问实际都是在对自身常量池的访问，自然也就不需要再初始化O了。我们不妨再用javap对此时的Test.class进行反编译： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061Classfile /E:/Test.class Last modified 2017-11-23; size 407 bytes MD5 checksum fa5eb1af23ee221917b59def8993a5b5 Compiled from &quot;Test.java&quot;public class Test SourceFile: &quot;Test.java&quot; minor version: 0 major version: 51 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #6.#15 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = Fieldref #16.#17 // java/lang/System.out:Ljava/io/PrintStream; #3 = String #18 // Reimu #4 = Methodref #19.#20 // java/io/PrintStream.println:(Ljava/lang/String;)V #5 = Class #21 // Test #6 = Class #22 // java/lang/Object #7 = Utf8 &lt;init&gt; #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 main #12 = Utf8 ([Ljava/lang/String;)V #13 = Utf8 SourceFile #14 = Utf8 Test.java #15 = NameAndType #7:#8 // &quot;&lt;init&gt;&quot;:()V #16 = Class #23 // java/lang/System #17 = NameAndType #24:#25 // out:Ljava/io/PrintStream; #18 = Utf8 Reimu #19 = Class #26 // java/io/PrintStream #20 = NameAndType #27:#28 // println:(Ljava/lang/String;)V #21 = Utf8 Test #22 = Utf8 java/lang/Object #23 = Utf8 java/lang/System #24 = Utf8 out #25 = Utf8 Ljava/io/PrintStream; #26 = Utf8 java/io/PrintStream #27 = Utf8 println #28 = Utf8 (Ljava/lang/String;)V&#123; public Test(); flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 1: 0 public static void main(java.lang.String[]); flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=1, args_size=1 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #3 // String Reimu 5: invokevirtual #4 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return LineNumberTable: line 4: 0 line 5: 8&#125; 注意常量池中的18，此时Reimu已被加入了Test的常量池中，main()方法中对O.V的调用实际上也是指向Test自身常量池中的常量，已与类O没有关系了。 时机2 使用java.lang.reflect包的方法对类进行反射调用时，若类没有进行过初始化，则需要先触发其初始化。 时机3 初始化一个类时，若发现其父类尚未进行过初始化，则需要先触发其父类的初始化。 时机4 当程序启动时，用户需要指定一个作为入口的主类(即包含main方法的那个类)，JVM会先初始化这个主类。 时机5 当使用JDK1.7的动态语言支持时(即invokedynamic指令和BootstrapMethods，截至JDK1.7为止，javac编译器尚无法生成invokedynamic指令及BootstrapMethods属性，必须通过一些非常规的手段才能使用到它们)，如果一个java.lang.invoke.MethodHandle实例最后的解析结果是REF_getStatic,REF_putStatic,REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。 主动引用及被动引用 对于以上5种初始化时机，JVM规范给出了一个很强烈的限定语：有且只有。这5种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发类的初始化，称为被动引用。 关于主动引用及被动引用很容易被误判，以如下代码为例： 12345678910111213141516171819202122public class Test &#123; public static void main(String[] args) &#123; System.out.println(Son.V); &#125;&#125;class Super &#123; public static int V = 123; static &#123; System.out.println(&quot;Super init&quot;); &#125;&#125;class Son extends Super &#123; static &#123; System.out.println(&quot;Son init&quot;); &#125;&#125; 运行后输出如下： 12Super init123 结果只输出了Super init而没有Son init。说明只有父类得到了初始化，子类却没有。这印证了前文的规范：子类调用父类中的静态变量并不在上文”有且只有”的那5种情况中。至于子类有没有经历加载和验证，准备等初始化的前置阶段，JVM规范则未明确规定，可供具体实现自行发挥。 再看如下代码，我们先定义类O： 12345678package com.test;public class O &#123; static &#123; System.out.println(&quot;O init&quot;); &#125;&#125; 随后再来一个测试类： 12345678package com.test;public class Test &#123; public static void main(String[] args) &#123; O[] a = new O[5]; &#125;&#125; 执行后，程序没有任何输出。说明com.test.O并没有初始化。然而，在我们看不到的地方，实际上触发了另一个名为[Lcom.test.O的类的初始化。很显然，这并不是一个合法的类的全限定名，而是类似于数组变量的描述符。它是一个由JVM自动生成，直接继承于java.lang.Object的子类，创建动作由字节码指令newarray触发。[Lcom.test.O代表了一个元素类型为com.test.O的一维数组。数组对象应有的属性及方法均实现在该类中，对于用户而言，这个类可直接使用的只有被修饰为public的length字段及clone()方法。Java对数组的这种严密的封装方式也是Java在访问数组时较之C或C++相对安全的原因：使用C或C++时，程序员对数组的操作直接被翻译为了对数组指针的移动，万一越界了那就真的是在底层越界了。而Java对数组的操作却隔着一个JVM自造出来的数组对象，接触不到底层实际用于存储数据的数组。即便越界也是Java语言层面的越界，顶多也就是抛出越界异常java.lang.ArrayIndexOutOfBoundsException，一切问题都会限制在JVM内部，而不会真的影响到更底层的内存(更准确的说，数组越界检查并非封装在数组类中，而是封装在该数组类进行数组操作时访问的xaload,xastore指令中)。 接口的加载过程则与类稍有不同。同类一样，接口的加载也分为上文介绍的那些步骤。不过前文我们在判断一个类是否初始化时，使用了static{}代码块，若该代码块被调用则类被初始化，反之则没有。接口中是不能声明static{}代码块的，但是在底层，JVM其实依然会为接口生成类构造器方法&lt;clinit&gt;用于初始化接口所定义的静态变量。初始化的时机依然是前文介绍的那”有且只有”的5种。与类有细微差别的是第3点： 13. 初始化一个类时，若发现其父类尚未进行过初始化，则需要先触发其父类的初始化。 对于接口而言，这条约束就没有那么严格了。即一个接口在初始化时，除非真的用到了父接口(例如引用父接口中定义的静态变量)，否则不需要初始化父接口。 接下来将逐个依序详解类加载的前5个步骤，也就是加载，验证，准备，解析和初始化。至于最后两项使用和卸载则没什么可说的。 加载首先必须明确的是，加载(Loading)是类加载(Class Loading)的第一个阶段，二者之间是从属关系。不要有所混淆。 根据JVM规范，加载阶段JVM需要依序完成如下3件事： 通过类的全限定名获取该类的二进制字节流。 将这个字节流所代表的静态存储结构加载入JVM所管理的内存，转化为方法区中的运行时数据结构(这里与验证阶段有重叠，实际上完成转化是在验证的第一阶段文件格式验证完成后)。 在Java堆上创建一个代表该类的java.lang.Class类的实例，作为方法区这个类的各种数据的访问入口。换句话说，类信息本身存储在方法区中，然后在Java堆上为该类专门建立了一个类对象，像句柄那样作为中间人管理及操作该类。 很显然，JVM规范对于加载的实现的要求并不具体，简直连产品经理都算不上，仅仅只是用户在描述需求。通篇都是”你要做到xxx”，至于怎么实现则几乎完全没有提及。因此对于JVM实现者而言，这种规范的灵活性就很高，例如，第一点”通过类的全限定名获取该类的二进制字节流”，一没有指明要从哪里获取，二没有指明具体该怎么获取。 JVM规范对于加载阶段的低限制给JVM实现者提供了广阔的自行发挥的余地。许多重要的Java技术都建立在这一基础之上，例如依然针对第一点”通过类的全限定名获取该类的二进制字节流”： 从zip包中直接读取二进制字节流。这也是日后Java特有的JAR,EAR,WAR压缩包的基础。 从网络中读取二进制字节流，最典型的应用场景就是Applet。 运行期通过计算动态生成，最典型的应用场景就是反射中的动态代理技术，即java.lang.reflect.Proxy.newProxyInstance()方法所动态生成的那个代理类的二进制字节流。 由其他类型的文件生成。最典型的应用场景是.jsp文件。运行期.jsp文件会生成对应Java类的二进制字节流。 从数据库中读取，这种读取方式的应用场景相对较少，主要用于某些大型分布式中间件服务器(例如SAP Netweaver)，其基本思路为将程序二进制字节码存储到数据库中并在集群中的各机器间进行分发。 相对于类加载机制中的其他阶段，非数组类的加载阶段(或者更具体的说，是加载阶段的第一步，通过类的全限定名获取该类的二进制字节流)是JVM规范限制最少的，也是开发人员可以玩出最多花样的。Java中大部分在运行期动态完成的骚操作依托的都是这一阶段。因为加载阶段既可以使用系统预设的引导类加载器完成，也可以使用用户自定义的类加载器(即重写类加载器的loadClass()方法)来控制字节流的获取方式。 而数组类则有所不同，如前文所述，数组类本身并不是由类加载器创建的，而是由JVM直接自动生成的。但数组类依然与类加载器有着千丝万缕的联系。因为即使数组类本身不是由类加载器创建，然而其中的元素却依然还是类加载器创建的(不考虑元素依然是数组的情况。其实即便元素是数组，即便元素的元素依然是数组，最终的那一层元素总得是非数组类，数组去掉所有维度信息后剩下的最终那一层元素被称为该数组的元素类型(Element Type))。 数组去掉一个维度后的元素类型被称为组件类型(Component Type)，数组的可见性与其组件类型相同。若组件类型为基本数据类型，则数组的可见性默认为public。 若数组的组件类型是基本数据类型，则该组件类型将使用Java预设的引导类加载器加载。该数组也会被标记为与引导类加载器关联。 若数组的组件类型是引用数据类型，则该组件类型将使用该引用类型的类加载器加载。该数组也会被标记为与该类加载器关联。 加载与验证的部分内容(如一部分字节码文件格式的验证动作)是交叉进行的，这些验证动作本质上依然属于验证阶段。可以理解为验证阶段认为时机已然成熟了，无需等待加载完成就可以开始了。 验证如果说加载是把所需的类信息读入内存，那么紧随其后的连接就是实际开始干活了。而连接的第一步验证则类似于程序入口处的边界判断。这一阶段的目的是为了确保class文件的字节流中包含的信息符合当前JVM实现的读取规范，并且不会危害到JVM自身的安全。 Java语言其实是一门语法上相对安全的语言(依然是较之C与C++)，语法上对编写者的限制较多，使用纯粹的Java代码是无法做到诸如访问数组边界以外的数据，将一个对象强制转型为它无法实现的类型，跳转到不存在的代码行等。如果强行这么做了，javac编译器也会拒绝编译。因此如果所有class字节码都是由javac编译器编译源码而得的，那么其实验证阶段就不那么必要了。 然而JVM的无关性却被设计为既有平台无关性，也有语言无关性。因此和JVM相关的只有class文件字节流，至于该字节流是怎么来的，是由javac编译器生成的，还是由其他编译器生成的，甚至是直接编写二进制文件硬写出来的，它并不关心。因此在字节流层面，上述通过Java语法无法实现，过不了javac编译器这一关的错误操作在字节码层面都是可以实现的，至少在语义上可以表达出来。因此，JVM在实际干活前必须检查读入的字节流是否安全。 验证阶段是非常重要的，该阶段几乎直接决定了具体的JVM实现承受恶意代码攻击的健壮性。从执行性能的角度来看，验证阶段的工作量占了整个类加载全过程中很大的一部分。 规范通常是不干预安全性这种和实际功能无关的模块的，因此JVM规范对于验证阶段的指导及限制很是笼统。最为基本的就是对class文件格式的约束。这也是最基本的约束。如果验证到字节流不符合格式上的规范，JVM就会抛出一个java.lang.VerifyError异常或其子类异常。在此之上的，应检查哪些方面，如何检查，何时检查，检查出的问题什么程度的能忍，什么程度不能忍都没有具体指示。其只是从验证思路上，将本阶段大致分为以下4种检验动作： 文件格式验证 元数据验证 字节码验证 符号引用验证 文件格式验证 这也是最基本的验证内容，且不论内容是否正确安全，如果连格式都不符合规范，该JVM从结构上都无法处理该字节流，那么后续的也都不用验了。摘录部分这一阶段的验证点如下： 开头的魔数是否是0xCAFEBABE 主次版本号是否在当前JVM可处理的范围之内 检查常量tag标志，判断常量池集合中是否有不被支持的常量类型 指向常量池集合中的常量的索引是否指向了不存在的常量或错误类型的常量 被定义为CONSTANT_Utf8_info类型的常量中的值是否符合Utf8压缩编码的规范 class是否缺少了必要的信息或被添加了莫名其妙不认识的信息 之后还有很长的验证点。不过至此我们已可以看出，该步确实就是在顺着class文件规范逐项严格检验是否符合要求。 本步完成前，字节流依然是以原始流的信息被临时读入内存，本步完成后，该字节流才真正的被映射为方法区中的结构。自本步后的后续步骤操作的都是方法区中对应的该类的信息了，和原始的字节流就没有关系了。这点并不难理解：只有格式符合规范，才能正确的映射。因此欲完成字节流向方法区中数据的转换，必须先完成文件格式验证。 元数据验证 第一阶段文件格式验证验证的是格式是否符合规范。而第二阶段元数据验证则更进一步，验证的是语义是否符合规范。即验证此时方法区中该类的信息是否符合Java的语言规范。截取部分验证点举例如下： 这个类是否有父类(除了java.lang.Object外，所有类都应有父类)。 这个类所在的继承链中是否有不允许被继承的类(即被final修饰的类)？ 如果这个类不是抽象类，那么它是否实现了其父类或其所实现的接口中要求它实现的所有方法？ 类中的字段，方法是否与其父类有冲突(例如覆盖了父类的被final修饰的实例变量或实例方法)。 字节码验证 元数据验证所做的语义验证针对的是一个个独立的个体，而本步字节码验证针对的则是方法体中的执行逻辑。这也是整个验证阶段最难于验证，最复杂的一个环节。其主要通过模拟代码执行过程中的数据流及控制流，确定整个过程是符合逻辑且安全的。截取部分验证点举例如下： 确保任何时刻操作数栈栈顶1个或多个元素的类型与当前正欲执行的字节码指令所需的操作数匹配。 确保跳转指令不会跳转出方法体或者跳转到一个奇怪的不能跳转的位置。 确保方法体中的类型转换是有效的。例如我们可以将一个子类对象赋值给其父类数据类型。但是将一个父类对象赋值给其子类类型甚至是完全不相关的类型则不行。 很显然，通过程序去验证程序的逻辑是否正确且安全是永远无法做到绝对准确的。同时繁杂的检查也将极大的占用运行时间。我们无法保证绝对准确，但是却可以尽可能的通过将验证操作前移至编译阶段来缩短运行期的验证时间(毕竟编译只需要一次，再慢也等得起)。JVM团队将方法按控制流段落划分为一个个基本块(Basic Block)，同时在class文件–&gt;方法表集合–&gt;方法表–&gt;属性集合–&gt;Code属性–&gt;属性集合–&gt;StackMapTable属性中存储每个基本块开始时局部变量表及操作数栈应有的状态。这样，在运行期类加载–&gt;验证–&gt;字节码验证阶段，就不需要根据数据流和控制流再次推算这些应有的状态了。转而直接比对实际模拟结果是否与StackMapTable属性中存储的状态一致即可。当然，使用StackMapTable属性在减少验证时间的同时，也增大了出错的几率：要是StackMapTable属性的计算出错了呢？纯粹因为计算失误导致出错的可能性不大(因为我们可以认为即便将这个验证前移到了编译阶段，验证的算法都是一样的。编译期要是算错了，放到运行期一样会算错)，问题在于恶意伪造StackMapTable属性从而骗过JVM。这个风险现在无解，是为了降低验证时间必须要承担的。 符号引用验证 符号引用验证发生在连接的第三个阶段：解析(很显然，又交叉执行了)。具体来说，是发生在JVM将符号引用转化为直接引用时。简单来说，进行到这一步，类的模版准备工作也快完事了。和C及C++相比，Java仅仅只是把连接操作后移到了运行期的解析阶段，并非就不进行连接了：因为不连接就无法指向实际的对象位置，光靠一个符号标记是无法运行下去的。而符号引用验证就是在验证该类常量池集合中自身以外的那些符号引用到底是不是真的存在，存在了到底允不允许本类用…截取部分验证点举例如下： 通过符号引用所描述的全限定名是否能找到对应的类，找到后是否有权限访问。 类中是否有所需的字段或方法，这些字段或方法是否有访问权限。 显然，本步验证是在为类加载-连接-解析做准备，若无法通过符号引用验证，则会抛出一个java.lang.IncompatibleClassChangeError的子类异常，如java.lang.IllegalAccessError,java.lang.NoSuchFieldError,java.lang.NoSuchMethodError等。 总结 从安全的角度来看，验证阶段至关重要；但是仅从程序实现角度来看，验证阶段则完全没必要：因为其中没有任何用户逻辑，无法为用户创造具体价值。因此，若对class文件充分信任，则可以在运行时通过-Xverify:none配置关闭大部分的验证操作，加速程序运行。 准备连接的第二个阶段名为准备。该阶段正式在方法区中为类变量分配内存并设置其初始值。有两点需要注意： 首先，分配内存的是类变量，实例变量会在对象实例诞生时随对象在Java堆上初始化。这个很好理解：类变量是类模板的一部分，自然应随模版初始化于方法区，而实例变量属于每个实例，自然会随实例初始化于Java堆上。 其次，这里设置的初始值通常指的是对应类型的零值，而非用户指定的具体值。如有以下类变量： 1public static int VALUE = 123; 则在准备阶段该类变量会在方法区中初始化，其值为0而非123。可以理解为该阶段仅仅只是JVM为类开辟空间的准备阶段(一如其名)，既然开辟了空间那么当然要给个默认的初值才好。至于用户指定的值123则存放于类构造器方法&lt;clinit&gt;中，会在类加载-初始化阶段由putstatic指令赋值。Java中各类型的零值如下图所示： 上文在描述初始值时使用了”通常”，那么自然就会有”不通常”，即类变量(基本数据类型或字符串)被final修饰： 1public static final int VALUE = 123; 其值已在编译期存入class文件–&gt;字段表集合–&gt;字段表–&gt;属性集合–&gt;ConstantValue属性中，则准备阶段直接就会把该类变量初始化为ConstantValue中的值。这也很好理解：毕竟，被final修饰的变量无法再被修改了，那么即使是到了初始化阶段，或是之后的任何阶段也都玩不出什么别的花样了，始终就会保持一个值。因此也就没必要费两遍事，直接在准备阶段赋了最终值即可(这也是final关键字的精髓所在，一如其名，最初即为最终)。 解析解析是连接的最后一个阶段，也是类加载过程中至关重要的一个阶段。解析会将常量池内的符号引用替换为直接引用。在JVM-类文件结构中，符号引用可以是CONSTANT_Class_info,CONSTANT_Fieldref_info,CONSTANT_Methodref_info等类型的常量。现在再从符号引用和直接引用对比的角度回顾下符号引用，并引入直接引用： 符号引用(Symbolic References):符号引用就是用一组符号描述所引用的目标，理论上并没有什么特别硬性的规定。它可以是任何形式的字面量，只要指定好描述规范(该规范已在JVM规范中指定，因此对于具体JVM实现而言，其实还是有规范的)，能在解析时无歧义的定位到目标即可。符号引用是一个逻辑上的，抽象的概念，被引用的目标不一定已加载到内存中(实际上是否加载它根本不在乎)。其与JVM实现具体的内存布局无关，由于JVM规范已规定了符号引用的描述规范(不规定不行，因为不规定的话就无法让一个统一的class文件中的符号引用在各JVM实现上无障碍的运行)，因此各JVM解析符号引用的规范必须是一致的，遵守JVM规范的。 直接引用(Direct References):直接引用可以是直接指向目标的指针，相对偏移量，也可以是一个能间接定位到目标的句柄。直接引用所指向的必然是一个实际已然存在的目标，其和具体JVM实现的的内存布局有关，即同一个符号引用在不同的JVM实例上翻译出的直接引用一般不会相同(其实即便同一个实例两次运行一般也不会相同)。 JVM规范并未指明解析具体的触发时机，只是粗略的规定在执行以下这16个用于操作符号引用的字节码指令之前，必须要对它们使用的符号引用进行解析(即保证符号引用确实是可用的，并指到实际工作的目标上)： 0xbd(anewarray):创建一个指定引用类型(如类，接口，数组)的数组，并将其引用值压入操作数栈 0xc0(checkcast):检验类实例的类型转换，检验未通过将抛出ClassCastException 0xb4(getfield):获取指定类的指定实例的实例变量，并将其值压入操作数栈 0xb2(getstatic):获取指定类的指定类变量，并将其值压入操作数栈。该指令的操作码之后会紧跟一个u2的操作数说明具体需要的是哪个类变量，该参数指向常量池集合中的一个CONSTANT_UTF8_info类型的索引项，也就是该字段的字段符号引用 0xc1(instanceof):检验类实例是否是指定类的实例，如果是将1压入操作数栈，反之压入0 invokedynamic:尚未出现在字节码指令集中 0xb9(invokeinterface):调用接口方法。运行期解释器会搜索一个实现了该接口方法的对象，并调用对应实现的接口方法 0xb7(invokespecial):以操作数栈栈顶reference类型的数据所指向的对象为方法的接收者，调用此对象的实例构造器&lt;init&gt;方法，私有方法或超类构造方法。该指令的操作码之后会紧跟一个u2的操作数说明具体调用的是哪个方法，该参数指向常量池集合中的一个CONSTANT_UTF8_info类型的索引项，也就是该方法的方法符号引用 0xb8(invokestatic):调用类方法(static修饰的方法) 0xb6(invokevirtual):调用实例方法。会根据对象的实际类型进行动态单分派(虚方法分派) 0x12(ldc):将int,float或String型常量值从常量池中推送至操作数栈栈顶。该指令的操作码之后会紧跟一个u2的操作数作为具体的值，该参数指向常量池集合中的一个对应类型的索引项 0x13(ldc_w):将int,float或String型常量值从常量池中推送至操作数栈栈顶(宽索引) 0xc5(multianewarray):创建指定类型和指定维度的多维数组(执行该指令时，操作栈中必须包含各维度的长度值)，并将其引用值压入操作数栈 0xbb(new):创建一个对象，并将其引用值压入操作数栈 0xb5(putfield):为指定类的指定实例变量赋值 0xb3(putstatic):为指定类的指定类变量赋值 JVM规范的这一限制只是限制了解析符号引用的最晚时机：即当这些指令执行时符号引用必须已经转为直接引用。换句话说，具体的JVM实现自然也可以根据需求在更早的时候完成这一操作。 对一个符号引用进行多次解析请求是很常见的事。除invokedynamic指令之外，JVM实现可选择将第一次解析的结果进行缓存(比如，在方法区的运行时常量池中记录直接引用，并把该常量标志为已解析状态)，这样除非发生特定的直接引用位置变动的情况，大部分情况都可以避免重复进行解析操作。无论如何，JVM规范都要求保证的是在同一个实体中，如果一个符号引用之前已被成功解析过，那么后续的引用解析请求就应当一直成功。同样的，若第一次解析失败了，那么其他指令对这个符号引用后续的解析请求也应收到相同的异常。 invokedynamic指令则不遵循上述规范。 在此我想稍稍抱怨一下(当然，我不行，我也不上，我实在就是想bb两句)，自从我开始研究JVM起，invokedynamic指令连同它所希望实现的动态语言支持简直就像是个毒瘤，JVM规范在面对这个问题时总会变得扭曲不自然。逻辑变得复杂难懂倒还在其次，最重要的还是失去了缜密的美感，让人看着难受。细思其缘由，我想还是因为该功能实在是与Java设计的初衷背离太远所致：需求分析的时候完全没在这地方留灵活度，上线后发现需求迫切没办法强行加功能。Java语言自最初起就被设计为了静态类型语言，但是随着时代的发展，人们对动态类型的需求逐渐迫切，Java也总是会因此被人指为不灵活，逐渐要被时代所抛弃。Java也在竭力进行改良，其结果就是现在我们看到的动态语言支持方案。个人认为这个方案比较糟(我没有更好的方案，但就是感觉比较糟)，其与Java基本的结构完全不同，仅仅只是一个为了实现功能的异类。好了=-=，抱怨结束。 invokedynamic指令所对应的引用被称为动态调用点限定符(Dynamic Call Site Specifier)，对于这条指令而言，其解析出的直接引用仅仅是本指令的本次调用生效，也就是说，必须要程序运行到这条指令，在当前的系统环境下，调用了才会知道真正的解析结果。 解析动作主要针对的是如下8种常量符号引用： 字符串类型字面量(CONSTANT_String_info) 类或接口的符号引用(CONSTANT_Class_info) 字段的符号引用(CONSTANT_Fieldref_info) 类中方法的符号引用(CONSTANT_Methodref_info) 接口中方法的符号引用(CONSTANT_InterfaceMethodref_info) 方法句柄(CONSTANT_MethodHandle_info) 方法类型(CONSTANT_MethodType_info) 动态方法调用点(CONSTANT_InvokeDynamic_info) 其中，1的解析过程非常简单，没什么可说的。6,7,8又是那个操蛋的动态语言支持系统，暂不研究。下面详细讲一下2~5。 解析类或接口的符号引用 假设字节码所处的类为D，若要把其常量池中的一个未解析过的符号引用N解析为一个类或接口C的直接引用，整个解析过程需以下3步： 若C不是一个数组类型，那么JVM会将N所代表的全限定名传递给D的类加载器去加载C。该加载过程可能会触发新的类加载(例如需加载C的父类或C所实现的接口)，会进行必要的验证(元数据验证，字节码验证等)，一旦这整个流程的某一环节出现任何异常，解析即宣告失败。 若C是一个数组类型，那么首先需找到该数组去掉所有维度信息后剩下的元素类型，然后按照第一点的规则去加载该元素类型。例如N为[Ljava/lang/Integer，则其元素类型即为java.lang.Integer。接着由JVM生成一个代表该数组的数组对象。 若上述两步未产生异常，那么C在JVM中实际上已经是一个有效的，可被直接引用的类或接口了。即至此已确保了类或接口的存在性。随后只需要再进行符号引用验证，确认D是否具备对C的访问权限，若不具备权限，则抛出java.lang.IllegalAccessError。 解析字段的符号引用 字段的符号引用的结构如下图所示： 从中先取出字段所属的类或接口的描述符，而后按照上文解析类或接口的符号引用的方法解析，若在该过程中发生任何异常，则本次字段的符号引用解析失败。若类或接口的解析成功，我们不妨仍将其命名为C，JVM会继续做如下操作： 若C内部本身就包含本字段描述符对应的字段，则返回这个字段的直接引用，查找结束。 否则，若C实现了接口，则按照实现顺序由前向后，在每个接口内部按照继承关系由下而上搜索是否包含本字段描述符，若找到则返回该直接引用，查找结束。 否则，只要C不是java.lang.Object，均按继承关系从下而上递归搜索其父类是否包含本字段描述符，若找到则返回该直接引用，查找结束。 否则，查找失败，抛出java.lang.NoSuchFieldError。 成功找到字段后，还需进行符号引用验证，确认是否具备对该字段的访问权限，若不具备权限，则抛出java.lang.IllegalAccessError。 按照上述搜索顺序，若某字段多次出现在C所实现的多个接口中，或是同时出现于C的父类或C所实现的接口中，是不会产生歧义的：按照规范总可有一个明确的搜索结果。然而javac编译器却要更为严格一些，上述情况其均会拒绝编译。这也很好理解，搞得这么乱，即便机器理得清，程序员也难免混乱。而且通常这种混乱都是编码问题造成的(名字而已，为啥非得重名不可)，算是Java语法在强行矫正程序员的不良编码习惯。举例如下： 1234567891011121314151617181920public class Test &#123; public static void main(String[] args) &#123; System.out.println(C.A); &#125;&#125;interface I0 &#123; int A = 0;&#125;interface I1 &#123; int A = 1;&#125;class C implements I0, I1 &#123; &#125; 该代码无法通过编译，在调用处(即C.A)会提示The field C.A is ambiguous。 解析类中方法的符号引用 类中方法的符号引用的结构如下图所示： 其整体的解析思路与上文提到的字段的符号引用的解析基本一致。首先，从中先取出方法所属的类的描述符，而后按照上文解析类或接口的符号引用的方法解析，若在该过程中发生任何异常，则本次方法的符号引用解析失败。若类或接口的解析成功，我们不妨仍将其命名为C，JVM会继续做如下操作： 若C是个接口，则解析失败并抛出java.lang.IncompatibleClassChangeError。 在C内部查找符合方法描述符的方法，若找到则返回该方法的直接引用，查找结束。 只要C不是java.lang.Object，均按继承关系从下而上递归搜索其父类是否包含待查找方法，若找到则返回该直接引用，查找结束。 若C实现了接口，则按照实现顺序由前向后，在每个接口内部按照继承关系由下而上搜索是否包含待查找方法，若找到则说明C是抽象类，查找结束，抛出java.lang.AbstractMethodError。 否则，查找失败。抛出java.lang.NoSuchMethodError。 成功找到方法后，还需进行符号引用验证，确认是否具备对该方法的访问权限，若不具备权限，则抛出java.lang.IllegalAccessError。 上述搜索过程会产生一些可能看起来不那么合理的结果，如下例： 12345678910111213141516171819202122public class Test &#123; public static void main(String[] args) &#123; new Son().m(); &#125;&#125;interface I &#123; void m();&#125;class Parent &#123; public void m() &#123; System.out.println(&quot;m&quot;); &#125;&#125;class Son extends Parent implements I &#123; &#125; 程序不仅可以编译通过，运行时也可正常输出： 1m Parent并未实现接口I，实现I的是Son。方法m实现于Parent，并未实现于Son。程序依然可以正常运行。 解析接口中方法的符号引用 接口中方法的符号引用的结构如下图所示： 其整体的解析思路与上文提到的类中方法的符号引用的解析基本一致。首先，从中先取出方法所属的接口的描述符，而后按照上文解析类或接口的符号引用的方法解析，若在该过程中发生任何异常，则本次方法的符号引用解析失败。若类或接口的解析成功，我们不妨仍将其命名为C，JVM会继续做如下操作： 若C是个类，则解析失败并抛出java.lang.IncompatibleClassChangeError。 在C内部查找符合方法描述符的方法，若找到则返回该方法的直接引用，查找结束。 按继承关系从下而上递归搜索C的父接口是否包含待查找方法，若找到则返回该直接引用，查找结束。 否则，查找失败。抛出java.lang.NoSuchMethodError。 因为接口中的方法默认的访问权限均为public，因此无需进行符号引用验证。自然也不会抛出java.lang.IllegalAccessError。 初始化初始化是类加载的最后一步。前面的几步是由JVM主导的，进行的也都是通用的分配空间，检查解析操作，几乎没有用户的参与(只有在加载阶段可能会调用用户自定义的类加载器)。而初始化阶段，一如其名，才是真正的按照用户定义的代码去初始化这个类。 在准备阶段，类变量已被赋过一次系统默认的零值(被final修饰的String或基本类型已赋上了最终值)，初始化阶段则是通过执行类构造器方法&lt;clinit&gt;来为其赋上用户自定义的值。 我们在编写Java源码时并未编写这个&lt;clinit&gt;方法，其实该方法是javac编译器在编译时收集所有类变量的赋值动作及static{}后按书写顺序自动生成的。但是其实也并非就是简单的将这些代码按顺序塞进&lt;clinit&gt;方法中。我们来看下面这个小例子： 12345678910public class Test &#123; static &#123; V = 1; // 可以通过编译。即可以为在后面定义的类变量赋值 System.out.println(V); // 无法通过编译 // 提示Cannot reference a field before it is defined &#125; static int V;&#125; 另一个类似于类构造器方法&lt;clinit&gt;的是实例构造器方法&lt;init&gt;。二者都是由javac编译器自动生成的。二者有主要如下不同： 与前文已介绍过的&lt;clinit&gt;方法的收集内容及顺序不同的是，&lt;init&gt;方法先按源码编写顺序收集实例变量的赋值动作，而后收集构造函数中的信息。 构造函数的第一句话默认是调用父类构造函数(没显式指明的话则会默认调用父类的无参构造函数)，因此&lt;init&gt;方法总是会显式调用父类的构造函数，又因为构造函数可以重载，因此具体调用哪一个也未知。而&lt;clinit&gt;方法则不会显式调用其父类的类构造方法(只有一个，不会出现误解，没必要显式指明)，JVM总会确保某类的&lt;clinit&gt;方法在执行之前，其父类的&lt;clinit&gt;方法已执行完成。因此无论如何，JVM中第一个被执行的&lt;clinit&gt;方法必然属于java.lang.Object。 &lt;clinit&gt;方法对于类或接口而言并不是必须的，若该类或接口中既没有类变量的赋值动作，也没有static{}，那么javac则无需为其生成&lt;clinit&gt;方法。 与类不同的是，接口中不允许有static{}，但依然允许有类变量。因此接口依然可能会有&lt;clinit&gt;方法。只是除非用到了父接口的内容，接口在初始化时无需先运行其父接口的&lt;clinit&gt;方法。同样的，接口的实现类在初始化时除非用到了该接口中的内容，也无需初始化该接口。 JVM会自行解决并发环境下&lt;clinit&gt;方法的线程安全问题。即若有多个线程同时去初始化一个类，那么只有一个线程会真正的去执行&lt;clinit&gt;方法，其他线程都会被阻塞。执行&lt;clinit&gt;方法的线程执行完成退出后，因此时该类已加载完成(有一个细节需明确一下，JVM在判断内存中的类是否相同时既看类本身，也看加载该类的类加载器。即同样是对于类A，用类加载器1加载出的A同用类加载器2加载出的类A是两个不同的类。因此此处会保证所有线程都在用同一个类加载器加载这个类)，其他线程自然无需再次初始化，直接用即可。 因此在并发环境下，&lt;clinit&gt;方法可能会导致比较隐蔽的线程阻塞问题，有如下代码： 1234567public class Test &#123; static &#123; System.out.println(Thread.currentThread().getName() + &quot; init Test&quot;); while (true) &#123;&#125; &#125;&#125; 很显然，这是想构造一个永不会完成的&lt;clinit&gt;方法。但显然javac编译器没那么笨，这样是无法通过编译的，会报Initializer does not complete normally。 不过javac也没那么聪明，略施小计即可令其懵逼： 123456789public class Test &#123; static &#123; if (true) &#123; System.out.println(Thread.currentThread().getName() + &quot; init Test&quot;); while (true) &#123;&#125; &#125; &#125;&#125; 然后我们再稍加调整，并写出用于测试的main方法： 123456789101112131415161718192021222324public class Test &#123; public static void main(String[] args) &#123; Runnable r = new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + &quot; start&quot;); Loop loop = new Loop(); &#125; &#125;; new Thread(r, &quot;Thread 1&quot;).start(); new Thread(r, &quot;Thread 2&quot;).start(); &#125;&#125;class Loop &#123; static &#123; if (true) &#123; System.out.println(Thread.currentThread().getName() + &quot; init Test&quot;); while (true) &#123;&#125; &#125; &#125;&#125; 程序输出为： 123Thread 1 startThread 2 startThread 1 init Test 该程序永不完结。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM-JVM字节码指令]]></title>
    <url>%2F2017%2F11%2F21%2FJVM-JVM%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[JVM的字节码指令由一个字节长度的，代表某种特定含义的数字(Opcode,即操作码)以及跟随其后的零至多个此操作所需的参数(Operands,即操作数)构成。由于JVM采用的是面向操作数栈而非寄存器的架构，因此大多数指令都仅有操作码，不包含操作数。 若不考虑异常处理，JVM的解释器执行字节码指令流的模型可用如下伪代码表示： 123456do &#123; PC寄存器的字节码偏移量+1; 根据PC寄存器指示的位置，从字节码指令流中取出操作码; if (该操作码需要操作数) 继续向后取出对应长度的操作数。PC寄存器随之后移; 执行该字节码指令;&#125; while (剩余字节码指令流长度 &gt; 0); 这里的+1是指加1个字节，即解释器读取字节码指令流的基本单位为1字节。若要读取一个16位的数据则需要连读两字节然后重新构建出原数据结构。例如可用byte1,byte2拼接存储short类型变量s。则解释器先读取byte1，后读取byte2。随后还原出s： 1(byte1 &lt;&lt; 8) | byte2 全部字节码指令集详见JVM-JVM字节码指令集。 字节码与数据类型JVM中绝大多数的字节码指令都限制了其操作的数据的数据类型(少数与数据类型无关的指令形如无条件跳转指令goto)。例如iload_0就是将局部变量表0号索引位置的int型数值压入操作数栈，而fload_0则是将局部变量表0号索引位置的float型数值压入操作数栈。这是严格的强类型检验，与解释器具体如何执行无关：即便最终解释器实际上是以同样的代码实现这两个指令，也不允许传入参数违法。 大部分与数据类型相关的字节码指令都会在其助记符中加入其所操作的类型的标记。例如i代表int，l代表long，s代表short，b代表byte，c代表char，f代表float，d代表double，a代表reference。也有少数字节码指令不会在其助记符中明示其所操作的数据类型，例如得到数组长度的arraylength指令，其后续必须跟随一个数组类型的对象。 与数据类型相关的字节码指令归纳如下： 很显然，并非所有数据类型都有对应的字节码指令。例如有iload却没有bload。事实上大多数字节码指令都不支持byte，char，short。而对于boolean则没有任何一种字节码指令支持。原因很简单，字节码指令的操作码只有1字节，最多也只能表示256种指令，为了使数据存储更为简洁就不得不在使用时下些功夫。事实上，编译器会在编译期或由JVM在运行期将byte及short类型的数据带符号扩展(Sign-Extend)为对应的int类型数据，而将boolean及char类型的数据零位扩展(Zero-Extend)为对应的int类型的数据。从而在处理byte,short,boolean,char类型的数据时可使用处理int类型数据的字节码指令。 事实上，如果我们看一下JVM-类文件结构就可以发现，byte,short,boolean,char类型并未出现在类文件常量池的14种cp_info中，它们都被int类型所代替了。 不过，这样会导致Java在语法上不那么友好，以如下代码为例： 12short s = 0;s = s + 1; // 无法通过编译 究其根本，还是进行加法时，s被自动扩展为了int型，其运算类型(Computational Type)变为了int，得到的结果自然也是int类型，当然就不能再赋值回short的变量了。 所有的字节码指令可大致分为后文中的9类。 加载和存储指令加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间传输。包括： 将局部变量表中的一个局部变量压入操作数栈： 12345iload,iload_&lt;n&gt;lload,lload_&lt;n&gt;fload,fload_&lt;n&gt;dload,dload_&lt;n&gt;aload,aload_&lt;n&gt; 将操作数栈中的一个值弹出并存入局部变量表： 12345istore,istore_&lt;n&gt;lstore,lstore_&lt;n&gt;fstore,fstore_&lt;n&gt;dstore,dstore_&lt;n&gt;astore,astore_&lt;n&gt; 将一个常量压入操作数栈： 12345bipush,sipushldc,ldc_w,ldc2_waconst_nulliconst_m1iconst_&lt;i&gt;,lconst_&lt;l&gt;,fconst_&lt;f&gt;,dconst_&lt;d&gt; 扩充局部变量表的访问索引：wide 处理操作数栈及局部变量表中的数据的指令主要就是通过上述指令。此外，访问对象的字段或数组元素的指令也会向操作数栈传输数据。 上述指令中有些带有&lt;n&gt;。例如iload_&lt;0&gt;等同于iload操作码后跟随int型的操作数0。之所以这么设计，是为了能让常用的数值的操作可以无需操作数而只以操作码完成，节省存储空间。当然指令是有限的(一共也就256个)，也不能无限的放宽常用值的范围。必须要取一个平衡。例如iload_&lt;n&gt;中n的取值范围为[0,3]。 运算指令运算或算术指令用于对操作数栈栈顶的一个或两个操作数进行某种特定的算术运算。其会将这一个或两个操作数弹出，运算后再将结果压入操作数栈。 大体上算术指令可分为如下两类： 对整型数据进行运算的指令 对浮点型数据进行运算的指令。 处理整数和浮点数的指令在面对溢出和除零时会有不同的解决策略。但无论是哪种算术运算，都必须使用JVM指令集支持的数据类型。正如前文提到的，由于没有直接支持byte,short,boolean,char类型的算术运算指令，因此对于这些类型的算术运算，应该使用操作int类型的指令代替。 所有算术指令如下： 加法指令：iadd,ladd,fadd,dadd 减法指令：isub,lsub,fsub,dsub 乘法指令：imul,lmul,fmul,dmul 除法指令：idiv,ldiv,fdiv,ddiv 取余(模)指令：irem,lrem,frem,drem 取反指令：ineg,lneg,fneg,dneg 位移指令：ishl,lshl,ishr,lshr,iushr,lushr 按位或指令：ior,lor 按位与指令：iand,land 按位异或指令：ixor,lxor 局部变量自增指令：iinc 比较指令：lcmp,fcmpl,fcmpg,dcmpl,dcmpg JVM字节码指令集直接支持了《Java语言规范》中描述的各种对整数及浮点数操作的语义。 关于整型数据，Java语法中在进行数据运算时可能会导致溢出，例如两个很大的正整数相加，结果可能是一个负数。但其实JVM规范中并没有明确规定整型数据溢出的运算规则，仅规定了在处理整型数据时，除了除法指令(idiv,ldiv)及取余(模)指令(irem,lrem)会因除数为零抛出ArithmeticException异常外，其余任何整型运算场景都不会抛出运行时异常。JVM规范的限制就这么多，只要满足了这个限制，具体的溢出规则就由具体实现自行把控。 关于浮点型数据的运算，JVM规范的限制明显大了很多：运算必须严格遵循IEEE754规范所规定的行为及限制。具体来说，必须严格遵守IEEE754规范所规定的非正规浮点数值(Denormalized Floating-Point Numbers)及逐级下溢(Gradual Underflow)的运算规则。 在进行浮点数运算时，所有运算结果必须舍入到适当的精度。舍入模式为IEEE754规范中默认的舍入模式。即向最接近数舍入模式：非精确的结果必须舍入为可被表示的最接近的精确值，若上下两方精确值同样接近，则优先选择最低有效位为零的。 在将浮点数转换为整数时，采用IEEE754规范中的向零舍入模式：数字会被截断，所有小数部分均会被舍弃。例如55.2舍入结果为55。-55.2舍入结果为-55(注意，不是-56。舍入为粗暴的舍弃小数部分，而非找到不大于原值的最大整数)。 和整型运算不同的是，JVM规范要求浮点数运算时不会抛出任何运行时异常(这里的异常是指Java层面的异常，不是IEEE754规范中的作为运算信号的浮点异常)。当浮点运算溢出时，将使用有符号的无穷大表示。若某运算结果没有明确的数学定义，将使用NaN表示。而所有NaN参与的运算结果均返回NaN。 比较long型数据时(lcmp)，采用的是带符号的比较方式。而比较浮点型数据时(fcmpl,fcmpg,dcmpl,dcmpg)，采用的是IEEE754规范所定义的无信号比较(Nonsignaling Comparisons)方式。 类型转换指令类型转换指令可以将两种不同的数值类型进行相互转换，其用途主要有2： 源码中显式指定的强制类型转换 前文提到的针对char,boolean,byte,short这4种类型的自动扩展 类型转换主要分为两类，一类是JVM直接支持的，转换时无需显式转换指令的，被称为宽化类型转换(Widening Numeric Conversions)，一如其名，即小范围类型向大范围类型的安全转换： int –&gt; long或float或double long –&gt; float或double float –&gt; double 相对的，另一类类型转换被称为窄化类型转换(Narrowing Numeric Conversions)，一如其名，即大范围类型向小范围类型的不安全转换。必须显式的使用转换指令完成。这些转换指令包括： i2c,i2b,i2s l2i f2l,f2i d2f,d2l,d2i 窄化类型转换可能会导致转换结果正负号较之原值发生变化。不同数量级的情况还可能导致精度丢失。 在对long或int做窄化类型转换时，转换的过程仅仅是保留接收类型长度的最低几位。因符号位位于最高位，必然导致符号位被截取掉，从而可能使符号发生变化(之所以说是可能，是因为截断后的最高位可能仍与原值相同)。 在将一个浮点数窄化为一个整数(特指long,int)时，将遵循以下规则： 若浮点值是NaN，那转换结果就是int或long类型的0 若浮点值不是无穷大的话，将采用IEEE754规范中的向零舍入模式：数字会被截断，所有小数部分均会被舍弃，获得整数值v。若v在接收类型能表示的范围之内，那转换结果就是v 反之，将根据v的符号，表示为接收类型能表示的最大正数或最小负数。 而浮点数内部的窄化，即double向float的转换，遵循IEEE754规范中的向最接近数舍入模式，得到一个float精度能表示的值。若舍入结果的绝对值过小超出了float的精度表示范围，将返回float类型的正负零。如果返回的绝对值过大超出了float的表示范围，将返回float类型的正负无穷大。double类型的NaN将转换为float类型的NaN。 尽管如上文所述，数据类型窄化可能会导致下限溢出，上限溢出或精度丢失。但是JVM规范明确规定不能因数据类型窄化而抛出运行时异常。 对象创建与访问指令虽然从理论层面来讲，Java中的类实例与数组实例都是对象。但是在实现上，JVM对类实例及数组实例的创建与访问使用了不同的字节码指令。 具体指令如下： 创建类实例的指令：new 创建数组实例的指令：newarray,anewarray,multianewarray 访问类字段(即类变量，被static修饰的字段)和实例字段(即实例变量，未被static修饰的字段)的指令：getstatic,putstatic,getfield,putfield 把一个数组元素压入操作数栈的指令：caload,baload,saload,iaload,laload,faload,daload,aaload 把操作数栈栈顶的值弹出作为数组元素存储入数组的指令：castore,bastore,sastore,iastore,lastore,fastore,dastore,aastore 取数组长度的指令：arraylength 检查类实例类型的指令：instanceof,checkcast 操作数栈管理指令如同操作一个普通的栈型数据结构那样，JVM提供了一些指令直接操作操作数栈： 将操作数栈栈顶的一个或两个元素出栈的指令：pop,pop2 复制操作数栈栈顶一个或两个元素并将这一个或两个元素的复制值重新压入操作数栈的指令：dup,dup2,dup_x1,dup2_x1,dup_x2,dup2_x2 将操作数栈最顶端的两个数值交换的指令：swap 控制转移指令控制转移指令可以让解释器有条件或无条件的从指定位置的指令而非该控制转移指令的下一条指令继续执行。从概念模型上理解，可以认为控制转移指令就是在有条件或无条件的修改PC寄存器中的值。控制转移指令包括： 条件分支指令：ifeq,iflt,ifle,ifne,ifgt,ifge,ifnull,ifnonnull,if_icmpeq,if_icmpne,if_icmplt,if_icmpgt,if_icmple,if_icmpge,if_acmpeq,if_acmpne 复合条件分支指令：tableswitch,lookupswitch 无条件跳转指令：goto,goto_w,jsr,jsr_w,ret 如上文所示，JVM中有专门的处理int及引用类型的条件分支比较指令。为了便于处理null这一特殊值，也会为其设置专门的检测指令。 同前文规则一致，对于boolean,char,byte,short型数据的条件分支比较，均采用int型的比较指令完成。 对于long,float,double而言，会先用运算指令中的比较指令：lcmp,fcmpl,fcmpg,dcmpl,dcmpg得到[1,0,-1]这样int型的比较结果并存入操作数栈，随后再用int型条件分支指令处理这些结果值，从而完成整个条件分支跳转。 由上文描述可知，所有基本数据类型的条件分支跳转实际上最终都依托于int型的条件分支跳转，更进一步的说，是依托于int型的比较操作。因此int型的比较操作是否简便完善高效就显得尤为重要。这也是JVM字节码指令集中int型的比较指令最为丰富强大的原因。 方法调用和返回指令与方法调用(即分派+执行)相关的指令列举如下： invokevirtual：调用实例方法。会根据对象的实际类型进行动态单分派(虚方法分派)。 invokeinterface：调用接口方法。运行期解释器会搜索一个实现了该接口方法的对象，并调用对应实现的接口方法。 invokespecial:以操作数栈栈顶reference类型的数据所指向的对象为方法的接收者，调用此对象的实例构造器&lt;init&gt;方法，私有方法或超类构造方法。该指令的操作码之后会紧跟一个u2的操作数说明具体调用的是哪个方法，该参数指向常量池集合中的一个CONSTANT_UTF8_info类型的索引项，也就是该方法的方法符号引用。 invokestatic：调用类方法(static修饰的方法)。 invokedynamic：至JDK1.7为止仍未存在于JVM字节码指令集中。用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法。前面介绍的4条方法调用指令的分派逻辑都固化在JVM内部，而本指令的分派逻辑则由用户设定的引导方法决定。 方法返回指令是根据返回值的类型区分的，包括: ireturn(自然，延续前文的规定，除了int之外，boolean,char,byte,short也使用该指令) lreturn freturn dreturn areturn return：供返回值为void的方法或实例初始化方法或类及接口的类初始化方法使用。 异常处理指令显式异常指令(源代码中明确用throw语句标记的异常)均由athrow指令实现。此外，其他字节码指令在检测到异常状况时也会自动抛出异常，例如前文介绍过的除法指令(idiv,ldiv)及取余(模)指令(irem,lrem)会因除数为零抛出ArithmeticException异常。 而源码中显式被catch语句捕获的异常则不是由字节码指令实现的(此前是用jsr及ret指令实现的，但在JDK1.7中这两条指令已废弃了)，而是采用了class文件-&gt;方法表集合-&gt;方法表-&gt;属性集合-&gt;Code属性-&gt;异常表集合实现的。 同步指令主要为synchronized关键字服务，详见Java 并发-synchronized。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM-JVM字节码指令集]]></title>
    <url>%2F2017%2F11%2F16%2FJVM-JVM%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%2F</url>
    <content type="text"><![CDATA[下文局部变量表的索引的基本单位是Slot。例如局部变量表依序存储着long及int两个变量。则索引0及索引1处存放long，索引2处存放int。 0x00(nop):什么都不做 0x01(aconst_null):将null压入操作数栈 0x02(iconst_m1):将int型-1压入操作数栈 0x03(iconst_0):将int型0压入操作数栈 0x04(iconst_1):将int型1压入操作数栈 0x05(iconst_2):将int型2压入操作数栈 0x06(iconst_3):将int型3压入操作数栈 0x07(iconst_4):将int型4压入操作数栈 0x08(iconst_5):将int型5压入操作数栈 0x09(lconst_0):将long型0压入操作数栈 0x0a(lconst_1):将long型1压入操作数栈 0x0b(fconst_0):将float型0压入操作数栈 0x0c(fconst_1):将float型1压入操作数栈 0x0d(fconst_2):将float型2压入操作数栈 0x0e(dconst_0):将double型0压入操作数栈 0x0f(dconst_1):将double型1压入操作数栈 0x10(bipush):将一个byte型的常量值[-128,127]压入操作数栈 0x11(sipush):将一个short型的常量值[-32768,32767]压入操作数栈 0x12(ldc):将int,float或String型常量值从常量池中推送至操作数栈栈顶。该指令的操作码之后会紧跟一个u2的操作数作为具体的值，该参数指向常量池集合中的一个对应类型的索引项 0x13(ldc_w):将int,float或String型常量值从常量池中推送至操作数栈栈顶(宽索引) 0x14(ldc2_w):将long或doble型常量值从常量池中推送至操作数栈栈顶(宽索引) 0x15(iload):将局部变量表x号索引位置的int型数值压入操作数栈。需1个操作数指明x 0x16(lload):将局部变量表x号索引位置的long型数值压入操作数栈。需1个操作数指明x 0x17(fload):将局部变量表x号索引位置的float型数值压入操作数栈。需1个操作数指明x 0x18(dload):将局部变量表x号索引位置的double型数值压入操作数栈。需1个操作数指明x 0x19(aload):将局部变量表x号索引位置的引用类型压入操作数栈。需1个操作数指明x 0x1a(iload_0):将局部变量表0号索引位置的int型数值压入操作数栈 0x1b(iload_1):将局部变量表1号索引位置的int型数值压入操作数栈 0x1c(iload_2):将局部变量表2号索引位置的int型数值压入操作数栈 0x1d(iload_3):将局部变量表3号索引位置的int型数值压入操作数栈 0x1e(lload_0):将局部变量表0号索引位置的long型数值压入操作数栈 0x1f(lload_1):将局部变量表1号索引位置的long型数值压入操作数栈 0x20(lload_2):将局部变量表2号索引位置的long型数值压入操作数栈 0x21(lload_3):将局部变量表3号索引位置的long型数值压入操作数栈 0x22(fload_0):将局部变量表0号索引位置的float型数值压入操作数栈 0x23(fload_1):将局部变量表1号索引位置的float型数值压入操作数栈 0x24(fload_2):将局部变量表2号索引位置的float型数值压入操作数栈 0x25(fload_3):将局部变量表3号索引位置的float型数值压入操作数栈 0x26(dload_0):将局部变量表0号索引位置的double型数值压入操作数栈 0x27(dload_1):将局部变量表1号索引位置的double型数值压入操作数栈 0x28(dload_2):将局部变量表2号索引位置的double型数值压入操作数栈 0x29(dload_3):将局部变量表3号索引位置的double型数值压入操作数栈 0x2a(aload_0):将局部变量表0号Slot中的引用类型压入操作数栈 0x2b(aload_1):将局部变量表1号Slot中的引用类型压入操作数栈 0x2c(aload_2):将局部变量表2号Slot中的引用类型压入操作数栈 0x2d(aload_3):将局部变量表3号Slot中的引用类型压入操作数栈 0x2e(iaload):将int型数组指定索引的值压入操作数栈 0x2f(laload):将long型数组指定索引的值压入操作数栈 0x30(faload):将float型数组指定索引的值压入操作数栈 0x31(daload):将double型数组指定索引的值压入操作数栈 0x32(aaload):将引用类型数组指定索引的值压入操作数栈 0x33(baload):将boolean或byte型数组指定索引的值压入操作数栈 0x34(caload):将char型数组指定索引的值压入操作数栈 0x35(saload):将short型数组指定索引的值压入操作数栈 0x36(istore):将栈顶int型数值弹出并存入局部变量表x号索引处。需1个操作数指明x 0x37(lstore):将栈顶long型数值弹出并存入局部变量表x号索引处。需1个操作数指明x 0x38(fstore):将栈顶float型数值弹出并存入局部变量表x号索引处。需1个操作数指明x 0x39(dstore):将栈顶double型数值弹出并存入局部变量表x号索引处。需1个操作数指明x 0x3a(astore):将栈顶引用类型弹出并存入局部变量表x号索引处。需1个操作数指明x 0x3b(istore_0):将栈顶int型数值弹出并存入局部变量表0号索引处 0x3c(istore_1):将栈顶int型数值弹出并存入局部变量表1号索引处 0x3d(istore_2):将栈顶int型数值弹出并存入局部变量表2号索引处 0x3e(istore_3):将栈顶int型数值弹出并存入局部变量表3号索引处 0x3f(lstore_0):将栈顶long型数值弹出并存入局部变量表0号索引处 0x40(lstore_1):将栈顶long型数值弹出并存入局部变量表1号索引处 0x41(lstore_2):将栈顶long型数值弹出并存入局部变量表2号索引处 0x42(lstore_3):将栈顶long型数值弹出并存入局部变量表3号索引处 0x43(fstore_0):将栈顶float型数值弹出并存入局部变量表0号索引处 0x44(fstore_1):将栈顶float型数值弹出并存入局部变量表1号索引处 0x45(fstore_2):将栈顶float型数值弹出并存入局部变量表2号索引处 0x46(fstore_3):将栈顶float型数值弹出并存入局部变量表3号索引处 0x47(dstore_0):将栈顶double型数值弹出并存入局部变量表0号索引处 0x48(dstore_1):将栈顶double型数值弹出并存入局部变量表1号索引处 0x49(dstore_2):将栈顶double型数值弹出并存入局部变量表2号索引处 0x4a(dstore_3):将栈顶double型数值弹出并存入局部变量表3号索引处 0x4b(astore_0):将栈顶引用类型弹出并存入局部变量表0号索引处 0x4c(astore_1):将栈顶引用类型弹出并存入局部变量表1号索引处 0x4d(astore_2):将栈顶引用类型弹出并存入局部变量表2号索引处 0x4e(astore_3):将栈顶引用类型弹出并存入局部变量表3号索引处 0x4f(iastore):将操作数栈栈顶int型数值弹出并存入指定int型数组的指定索引位置 0x50(lastore):将操作数栈栈顶long型数值弹出并存入指定long型数组的指定索引位置 0x51(fastore):将操作数栈栈顶float型数值弹出并存入指定float型数组的指定索引位置 0x52(dastore):将操作数栈栈顶double型数值弹出并存入指定double型数组的指定索引位置 0x53(aastore):将操作数栈栈顶引用类型数值弹出并存入指定引用类型数组的指定索引位置 0x54(bastore):将栈顶boolean或byte型数值存入指定数组的指定索引位置 0x55(castore):将栈顶char型数值存入指定数组的指定索引位置 0x56(sastore):将栈顶short型数值存入指定数组的指定索引位置 0x57(pop):将操作数栈栈顶数值弹出(数值不能是long或double) 0x58(pop2):将操作数栈栈顶数值弹出(long或double)或顶部两个数值弹出(非long或double) 0x59(dup):弹出操作数栈栈顶数值，复制该值并将原值及复制值压入操作数栈 0x5a(dup_x1):复制操作数栈栈顶数值并将两个复制值压入操作数栈 0x5b(dup_x2):复制操作数栈栈顶数值并将三个(或两个)复制值压入操作数栈 0x5c(dup2):复制栈顶一个(long或double)或两个(非long或double)数值并将复制值压入操作数栈 0x5d(dup2_x1):dup_x1指令的双倍版本 0x5e(dup2_x2):dup_x2指令的双倍版本 0x5f(swap):将操作数栈最顶端的两个数值交换(不能是long或double) 0x60(iadd):弹出操作数栈栈顶两int型数值相加并将结果压入操作数栈 0x61(ladd):弹出操作数栈栈顶两long型数值相加并将结果压入操作数栈 0x62(fadd):弹出操作数栈栈顶两float型数值相加并将结果压入操作数栈 0x63(dadd):弹出操作数栈栈顶两double型数值相加并将结果压入操作数栈 0x64(isub):弹出操作数栈栈顶两int型数值相减并将结果压入操作数栈 0x65(lsub):弹出操作数栈栈顶两long型数值相减并将结果压入操作数栈 0x66(fsub):弹出操作数栈栈顶两float型数值相减并将结果压入操作数栈 0x67(dsub):弹出操作数栈栈顶两double型数值相减并将结果压入操作数栈 0x68(imul):弹出操作数栈栈顶两int型数值相乘并将结果压入操作数栈 0x69(lmul):弹出操作数栈栈顶两long型数值相乘并将结果压入操作数栈 0x6a(fmul):弹出操作数栈栈顶两float型数值相乘并将结果压入操作数栈 0x6b(dmul):弹出操作数栈栈顶两double型数值相乘并将结果压入操作数栈 0x6c(idiv):弹出操作数栈栈顶两int型数值相除并将结果压入操作数栈 0x6d(ldiv):弹出操作数栈栈顶两long型数值相除并将结果压入操作数栈 0x6e(fdiv):弹出操作数栈栈顶两float型数值相除并将结果压入操作数栈 0x6f(ddiv):弹出操作数栈栈顶两double型数值相除并将结果压入操作数栈 0x70(irem):弹出操作数栈栈顶两int型数值取余并将结果压入操作数栈 0x71(lrem):弹出操作数栈栈顶两long型数值取余并将结果压入操作数栈 0x72(frem):弹出操作数栈栈顶两float型数值取余并将结果压入操作数栈 0x73(drem):弹出操作数栈栈顶两double型数值取余并将结果压入操作数栈 0x74(ineg):弹出操作数栈栈顶int型数值取反并将结果压入操作数栈 0x75(lneg):弹出操作数栈栈顶long型数值取反并将结果压入操作数栈 0x76(fneg):弹出操作数栈栈顶float型数值取反并将结果压入操作数栈 0x77(dneg):弹出操作数栈栈顶double型数值取反并将结果压入操作数栈 0x78(ishl):弹出操作数栈栈顶int型数值左移x位并将结果压入操作数栈。需1个操作数指明x 0x79(lshl):弹出操作数栈栈顶long型数值左移x位并将结果压入操作数栈。需1个操作数指明x 0x7a(ishr):弹出操作数栈栈顶int型数值右移x位(有符号位移，符号位不变)并将结果压入操作数栈。需1个操作数指明x 0x7b(lshr):弹出操作数栈栈顶long型数值右移x位(有符号位移，符号位不变)并将结果压入操作数栈。需1个操作数指明x 0x7c(iushr):弹出操作数栈栈顶int型数值右移x位(无符号位移，符号位也移动)并将结果压入操作数栈。需1个操作数指明x 0x7d(lushr):弹出操作数栈栈顶long型数值右移x位(无符号位移，符号位也移动)并将结果压入操作数栈。需1个操作数指明x 0x7e(iand):弹出操作数栈栈顶两int型数值按位与并将结果压入操作数栈 0x7f(land):弹出操作数栈栈顶两long型数值按位与并将结果压入操作数栈 0x80(ior):弹出操作数栈栈顶两int型数值按位或并将结果压入操作数栈 0x81(lor):弹出操作数栈栈顶两long型数值按位或并将结果压入操作数栈 0x82(ixor):弹出操作数栈栈顶两int型数值按位异或并将结果压入操作数栈 0x83(lxor):弹出操作数栈栈顶两long型数值按位异或并将结果压入操作数栈 0x84(iinc):将指定int型变量增加指定值(如i++,i–-,i+=2等) 0x85(i2l):弹出操作数栈栈顶int型数值强制转换成long型数值并将结果压入操作数栈 0x86(i2f):弹出操作数栈栈顶int型数值强制转换成float型数值并将结果压入操作数栈 0x87(i2d):弹出操作数栈栈顶int型数值强制转换成double型数值并将结果压入操作数栈 0x88(l2i):弹出操作数栈栈顶long型数值强制转换成int型数值并将结果压入操作数栈 0x89(l2f):弹出操作数栈栈顶long型数值强制转换成float型数值并将结果压入操作数栈 0x8a(l2d):弹出操作数栈栈顶long型数值强制转换成double型数值并将结果压入操作数栈 0x8b(f2i):弹出操作数栈栈顶float型数值强制转换成int型数值并将结果压入操作数栈 0x8c(f2l):弹出操作数栈栈顶float型数值强制转换成long型数值并将结果压入操作数栈 0x8d(f2d):弹出操作数栈栈顶float型数值强制转换成double型数值并将结果压入操作数栈 0x8e(d2i):弹出操作数栈栈顶double型数值强制转换成int型数值并将结果压入操作数栈 0x8f(d2l):弹出操作数栈栈顶double型数值强制转换成long型数值并将结果压入操作数栈 0x90(d2f):弹出操作数栈栈顶double型数值强制转换成float型数值并将结果压入操作数栈 0x91(i2b):弹出操作数栈栈顶int型数值强制转换成byte型数值并将结果压入操作数栈 0x92(i2c):弹出操作数栈栈顶int型数值强制转换成char型数值并将结果压入操作数栈 0x93(i2s):弹出操作数栈栈顶int型数值强制转换成short型数值并将结果压入操作数栈 0x94(lcmp):弹出并比较操作数栈栈顶两long型数值的大小，并将结果[1,0,-1]压入操作数栈 0x95(fcmpl):弹出并比较操作数栈栈顶两float型数值的大小，并将结果[1,0,-1]压入操作数栈。当其中一个数值为NaN时，压入-1 0x96(fcmpg):弹出并比较操作数栈栈顶两float型数值的大小，并将结果[1,0,-1]压入操作数栈。当其中一个数值为NaN时，压入1 0x97(dcmpl):弹出并比较操作数栈栈顶两double型数值的大小，并将结果[1,0,-1]压入操作数栈。当其中一个数值为NaN时，压入-1 0x98(dcmpg):弹出并比较操作数栈栈顶两double型数值的大小，并将结果[1,0,-1]压入操作数栈。当其中一个数值为NaN时，压入1 0x99(ifeq):当操作数栈栈顶int型数值等于0时跳转 0x9a(ifne):当操作数栈栈顶int型数值不等于0时跳转 0x9b(iflt):当操作数栈栈顶int型数值小于0时跳转 0x9c(ifge):当操作数栈栈顶int型数值大于等于0时跳转 0x9d(ifgt):当操作数栈栈顶int型数值大于0时跳转 0x9e(ifle):当操作数栈栈顶int型数值小于等于0时跳转 0x9f(if_icmpeq):比较操作数栈栈顶两int型数值大小，当结果等于0时跳转 0xa0(if_icmpne):比较操作数栈栈顶两int型数值大小，当结果不等于0时跳转 0xa1(if_icmplt):比较操作数栈栈顶两int型数值大小，当结果小于0时跳转 0xa2(if_icmpge):比较操作数栈栈顶两int型数值大小，当结果大于等于0时跳转 0xa3(if_icmpgt):比较操作数栈栈顶两int型数值大小，当结果大于0时跳转 0xa4(if_icmple):比较操作数栈栈顶两int型数值大小，当结果小于等于0时跳转 0xa5(if_acmpeq):比较操作数栈栈顶两引用类型数值，当结果相等时跳转 0xa6(if_acmpne):比较操作数栈栈顶两引用类型数值，当结果不相等时跳转 0xa7(goto):无条件跳转，后续需跟随行号作为跳转位置 0xa8(jsr):跳转至指定16位offset位置，并将jsr下一条指令地址压入操作数栈(JDK1.7已废弃该指令) 0xa9(ret):返回至本地变量(JDK1.7已废弃该指令) 0xaa(tableswitch):用于switch条件跳转，case值连续(可变长度指令) 0xab(lookupswitch):用于switch条件跳转，case值不连续(可变长度指令) 0xac(ireturn):弹出并返回操作数栈栈顶的int类型数值 0xad(lreturn):弹出并返回操作数栈栈顶的long类型数值 0xae(freturn):弹出并返回操作数栈栈顶的float类型数值 0xaf(dreturn):弹出并返回操作数栈栈顶的double类型数值 0xb0(areturn):弹出并返回操作数栈栈顶的引用类型数值 0xb1(return):从当前方法返回void，本方法结束 0xb2(getstatic):获取指定类的指定类变量，并将其值压入操作数栈。该指令的操作码之后会紧跟一个u2的操作数说明具体需要的是哪个类变量，该参数指向常量池集合中的一个CONSTANT_UTF8_info类型的索引项，也就是该字段的字段符号引用 0xb3(putstatic):为指定类的指定类变量赋值 0xb4(getfield):获取指定类的指定实例的实例变量，并将其值压入操作数栈 0xb5(putfield):为指定类的指定实例变量赋值 0xb6(invokevirtual):调用实例方法。会根据对象的实际类型进行动态单分派(虚方法分派) 0xb7(invokespecial):以操作数栈栈顶reference类型的数据所指向的对象为方法的接收者，调用此对象的实例构造器&lt;init&gt;方法，私有方法或超类构造方法。该指令的操作码之后会紧跟一个u2的操作数说明具体调用的是哪个方法，该参数指向常量池集合中的一个CONSTANT_UTF8_info类型的索引项，也就是该方法的方法符号引用 0xb8(invokestatic):调用类方法(static修饰的方法) 0xb9(invokeinterface):调用接口方法。运行期解释器会搜索一个实现了该接口方法的对象，并调用对应实现的接口方法 0xba(–):无此指令 0xbb(new):创建一个对象，并将其引用值压入操作数栈 0xbc(newarray):创建一个指定原始类型(如int,float,char等)的数组，并将其引用值压入操作数栈 0xbd(anewarray):创建一个指定引用类型(如类，接口，数组)的数组，并将其引用值压入操作数栈 0xbe(arraylength):获得数组的长度并压入操作数栈栈顶。后面需跟随一个数组类型的对象 0xbf(athrow):弹出操作数栈栈顶的异常并将其抛出 0xc0(checkcast):检验类实例的类型转换，检验未通过将抛出ClassCastException 0xc1(instanceof):检验类实例是否是指定类的实例，如果是将1压入操作数栈，反之压入0 0xc2(monitorenter):弹出并获得操作数栈栈顶对象的管程，用于被synchronized关键字修饰的同步块 0xc3(monitorexit):弹出并释放操作数栈栈顶对象的管程，用于被synchronized关键字修饰的同步块 0xc4(wide):扩展本地变量的宽度 0xc5(multianewarray):创建指定类型和指定维度的多维数组(执行该指令时，操作栈中必须包含各维度的长度值)，并将其引用值压入操作数栈 0xc6(ifnull):操作数栈栈顶为null时跳转 0xc7(ifnonnull):操作数栈栈顶不为null时跳转 0xc8(goto_w):无条件跳转(宽索引) 0xc9(jsr_w):跳转至指定32位offset位置，并将jsr_w下一条指令地址压入操作数栈(JDK1.7已废弃该指令)]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM-类文件结构]]></title>
    <url>%2F2017%2F11%2F07%2FJVM-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[任意一个class文件都对应一个唯一的类或接口。但类或接口并非必须定义在class文件中(也可通过类加载器在运行期直接生成)。本文所指的类文件结构是指满足规范的任意类或接口的class结构。 class文件是一个以1字节(即8位)为基础的二进制流。各数据项依规范紧密有序的排列着，没有分隔符的存在。当数据项需占用1字节以上的空间时，将采用高位在前的方式切割为若干个1字节的基本单位。 以十进制为例： 高位在前(Big-Endian)：123代表一百二十三。这也是人类的习惯。 低位在前(Little-Endian)：123代表三百二十一。 class文件的数据结构是一种类似于C语言结构体的伪结构，这种伪结构中只有两种数据类型：无符号数及表。 无符号数是基本的数据类型。以u1,u2,u4,u8分别代表1个字节，2个字节，4个字节，8个字节。无符号数可用来描述数字，索引引用，数量值或按照UTF-8缩略编码的字符串。 表是由无符号数或其它表作为数据项构成的复合数据类型。通常表习惯性的以_info结尾。 整个class文件本质上就是一张表。其数据项为： 若某数据类型的个数不定，通常会在最前面加上计数。后文将计数及对应个数个相同的数据类型作为一个整体(集合)描述。 magicclass文件的头4个字节被称为魔数(Magic Number)。其唯一的作用为确认该文件是否是一个身份合法的，能被JVM读取的class文件。 其实不仅仅是class，很多文件格式(例如gif,jpeg等)都采用魔数进行身份验证，其较之文件扩展名安全性更高(相对来说，扩展名更易于被改变)。魔数值只要保证在文件使用的范围内唯一即可。 示例代码： 12public class Test &#123;&#125; 以16进制编辑器打开其class文件： class文件的魔数用16进制表示为：CAFEBABE(即咖啡宝贝。能只用A~F6个字母拼出一个萌萌哒且和Java语义相关的魔数也是碉堡了) minor_version+major_version紧接着魔数之后的4个字节为class文件的版本号。其中前2个字节为次版本号(minor_version)，后两个字节为主版本号(major_version)。 主版本号始于45。即JDK1.1=45，JDK1.2=46，JDK1.3=47，JDK1.4=48，JDK1.5=49，JDK1.6=50，JDK1.7=51，JDK1.8=52…高版本的JDK可兼容运行低版本的class文件，反之则不行：即使两个JDK版本间的class文件格式并未发生变化也不行。 示例代码： 12public class Test &#123;&#125; 以JDK1.7编译： 其中0x33=51，即为JDK1.7。 常量池集合主版本号之后为常量池集合。常量池可以看作class文件的资源仓库，是class文件结构中与class的其他项目关联最多的数据类型，也是占用class空间最大的数据项之一。 示例代码： 12345678public class Test &#123; private int m; public int inc() &#123; return m + 1; &#125;&#125; 以JDK1.7编译： 常量池集合分为两部分：第一部分为两个字节，表示常量池大小(constant_pool_count)。第二部分为constant_pool_count-1个常量类型(cp_info)。 常量池集合的第0项被空了出来：表示”不引用任何一个常量池项目”。只有常量池集合有这个特殊的设定，其它的集合(接口索引集合，字段表集合，方法表集合等)均按常规从0开始存放数据项。因此，实际有效的常量数据项是索引1开始的，constant_pool_count也比cp_info类型的个数多一个。 如上图所示，示例程序constant_pool_count=0x13，即为十进制的19。即共有18个常量类型。 常量类型主要分为两大类：字面量(Literal)和符号引用(Symbolic References)。 字面量类似于Java语法层面的常量值概念。如文本字符串等。 符号引用则是编译原理方面的概念，包含以下3类： 类和接口的全限定名(Fully Qualified Name) 字段的名称和描述符(Descriptor) 方法的名称和描述符 C与C++的编译是一步到位的，编译的结果直接就是物理机器运行的二进制机器码。因此编译时会有“连接”这一步骤：即将代码中的方法，字段等与实际的物理地址相关联。而Java的编译仅仅只是编译为供JVM使用的中间字节码，并没有连接这一操作，真正的关联方法字段与其实际物理地址的操作是在运行期完成的，称为动态连接。因此，编译出的class文件中方法及字段是以符号引用的方式存储的：相当于一个指引，在运行期告诉JVM这是个什么东西，该翻译到什么内存地址中。 cp_info只是一个总称，实际上又可分为很多种。每种cp_info都是一张表。在JDK1.7之前，共有11种cp_info。JDK1.7时为了更好的支持动态语言调用，又添加了以下3种： CONSTANT_MethodHandle_info CONSTANT_MethodType_info CONSTANT_InvokeDynamic_info 14种cp_info如下图所示： 这14种cp_info的共同特点为开头均为1个字节的类型标志位(tag，即上图中的标志)，而后才是该种cp_info的具体值。这样根据每种cp_info的规范就可严格限定出该种cp_info所占用的空间。进而严格限定出常量池占用的空间。 14种常量类型的具体结构依如下3图所示： 下面具体分析下示例代码中的常量池集合： 1首先，跟在constant_pool_count=0x13=19之后的第一个常量为： 0x0A=10，查表为CONSTANT_Methodref_info，即为类中方法的符号引用。其数据结构共占据4个字节： 前2个字节，0x0004=4，指向声明方法的类描述符CONSTANT_Class_info的索引项 后2个字节，0x000F=15，指向名称及类型描述符CONSTANT_NameAndType_info的索引项 2第2个常量为： 0x09=9，查表为CONSTANT_Fieldref_info，即字段的符号引用。其数据结构共占据4个字节： 前2个字节，0x0003=3，指向声明字段的类或接口描述符CONSTANT_Class_info的索引项 后2个字节，0x0010=16，指向字段描述符CONSTANT_NameAndType_info的索引项 3第3个常量为： 0x07=7，查表为CONSTANT_Class_info，即类或接口的符号引用。其数据结构共占据2个字节： 0x0011=17。指向一个CONSTANT_UTF8_info类型的常量，代表类或接口的全限定名。 4第4个常量： 0x07=7，查表为CONSTANT_Class_info，即类或接口的符号引用。其数据结构共占据2个字节： 0x0012=18。指向一个CONSTANT_UTF8_info类型的常量，代表类或接口的全限定名。 5第5个常量： 0x01=1，查表为CONSTANT_UTF8_info，即用UTF-8压缩编码的字符串。 与普通UTF-8编码所不同，UTF-8压缩编码的编码方式为： [‘\u0001’,’\u007f’]之间的字符(即[1,127]之间的ASCII码)用1个字节表示 [‘\u0080’,’\u07ff’]之间的字符用2个字节表示 [‘\u0800’,’\uffff’]之间的字符和普通的UTF-8编码规则相同，用3个字节表示 class文件中类及接口的全路径名，方法名，变量名均由CONSTANT_UTF8_info描述。而描述该长度的值占两个字节。因此可表示的范围为[0,65535]。即能表示的字节长度最多为65535个(若字符均在ASCII码的范围之内，也可说最多表示65535个字符)。 CONSTANT_UTF8_info的数据结构占据的长度不定，tag后是表示长度的2个字节，代表字符串占用的字节数： 0x0001=1，即字符串占用1个字节，则向后取一个字节： 0x6D=109。即为ASCII编码的”m”。 6第6个常量： 0x01=1，查表为CONSTANT_UTF8_info，即用UTF-8压缩编码的字符串。其长度为： 0x0001=1，即字符串占用1个字节，则向后取一个字节： 0x49=73。即为ASCII编码的”I”。 7第7个常量： 0x01=1，查表为CONSTANT_UTF8_info，即用UTF-8压缩编码的字符串。其长度为： 0x0006=6，即字符串占用6个字节，则向后取6个字节： 8第8个常量： 0x01=1，查表为CONSTANT_UTF8_info，即用UTF-8压缩编码的字符串。其长度为： 0x0003=3，即字符串占用3个字节，则向后取3个字节： 9第9个常量： 0x01=1，查表为CONSTANT_UTF8_info，即用UTF-8压缩编码的字符串。其长度为： 0x0004=4，即字符串占用4个字节，则向后取4个字节： 10第10个常量： 0x01=1，查表为CONSTANT_UTF8_info，即用UTF-8压缩编码的字符串。其长度为： 0x000F=15，即字符串占用15个字节，则向后取15个字节： 11第11个常量： 0x01=1，查表为CONSTANT_UTF8_info，即用UTF-8压缩编码的字符串。其长度为： 0x0003=3，即字符串占用3个字节，则向后取3个字节： 12第12个常量： 0x01=1，查表为CONSTANT_UTF8_info，即用UTF-8压缩编码的字符串。其长度为： 0x0003=3，即字符串占用3个字节，则向后取3个字节： 13第13个常量： 0x01=1，查表为CONSTANT_UTF8_info，即用UTF-8压缩编码的字符串。其长度为： 0x000A=10，即字符串占用10个字节，则向后取10个字节： 14第14个常量： 0x01=1，查表为CONSTANT_UTF8_info，即用UTF-8压缩编码的字符串。其长度为： 0x0009=9，即字符串占用9个字节，则向后取9个字节： 15第15个常量： 0x0C=12，查表为CONSTANT_NameAndType_info，即字段或方法符号引用的一部分。其数据结构共占据4个字节： 前2个字节，0x0007=7，指向该字段或方法名称的CONSTANT_UTF8_info的索引项(name) 后2个字节，0x0008=8，指向该字段或方法描述符的CONSTANT_UTF8_info的索引项(type) 16第16个常量： 0x0C=12，查表为CONSTANT_NameAndType_info，即字段或方法符号引用的一部分。其数据结构共占据4个字节： 前2个字节，0x0005=5，指向该字段或方法名称的CONSTANT_UTF8_info的索引项(name) 后2个字节，0x0006=6，指向该字段或方法描述符的CONSTANT_UTF8_info的索引项(type) 17第17个常量： 0x01=1，查表为CONSTANT_UTF8_info，即用UTF-8压缩编码的字符串。其长度为： 0x000D=13，即字符串占用13个字节，则向后取13个字节： 18第18个常量： 0x01=1，查表为CONSTANT_UTF8_info，即用UTF-8压缩编码的字符串。其长度为： 0x0010=16，即字符串占用16个字节，则向后取16个字节： javap至此，18个常量全部分析完成。实际上，在jdk/bin中提供了工具javap用来分析class文件： 分析文件1内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051Classfile /E:/Test.class Last modified 2017-11-8; size 274 bytes MD5 checksum ba2585a36b64eb15c6657dc8440c38e0 Compiled from &quot;Test.java&quot;public class com.test.Test SourceFile: &quot;Test.java&quot; minor version: 0 major version: 51 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #4.#15 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = Fieldref #3.#16 // com/test/Test.m:I #3 = Class #17 // com/test/Test #4 = Class #18 // java/lang/Object #5 = Utf8 m #6 = Utf8 I #7 = Utf8 &lt;init&gt; #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 inc #12 = Utf8 ()I #13 = Utf8 SourceFile #14 = Utf8 Test.java #15 = NameAndType #7:#8 // &quot;&lt;init&gt;&quot;:()V #16 = NameAndType #5:#6 // m:I #17 = Utf8 com/test/Test #18 = Utf8 java/lang/Object&#123; public com.test.Test(); flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 3: 0 public int inc(); flags: ACC_PUBLIC Code: stack=2, locals=1, args_size=1 0: aload_0 1: getfield #2 // Field m:I 4: iconst_1 5: iadd 6: ireturn LineNumberTable: line 8: 0&#125; 观察常量池Constant pool部分，其内容与上文的分析完全一致。 除了我们所定义的Test类，字段m，方法inc()之外，常量池中还有诸如 12345&lt;init&gt;()VCodeLineNumberTableSourceFile 等我们没有显式声明的有些莫名其妙的东西。这些常量会在内部中间逻辑中被常量池集合本身，字段表(field_info)，方法表(method_info)，属性表(attribute_info)等用到，对用户而言是透明的。它们被用以形容那些不方便用固定字节表示的信息(其实就是更接近于人类自然语言表述的信息)。 access_flags紧接着常量池集合之后的两个字节为访问标志(access_flags)。用于标志一些类或接口层次的访问信息： 2个字节共计16位。因此共可设置16种标志。目前只使用了其中的8种(JDK1.5以前只有上图中的前5种，JDK1.5中又引入了后3种)。没有使用的标志默认为0。 仍然使用常量池集合的代码为例。Test类符合ACC_PUBLIC,ACC_SUPER。即： ACC_PUBLIC=0x0001=0000_0000_0000_0001ACC_SUPER=0x0020=0000_0000_0010_0000则最终为0000_0000_0010_0001=0x0021。即： this_class紧接着访问标志之后的2个字节是类索引(this_class)，用以描述该类的全限定名。其指向常量池集合中的一个CONSTANT_Class_info类型的索引项。 仍然使用常量池集合的代码为例： 0x0003=3。即为com/test/Test。 super_class紧接着类索引之后的2个字节是父类索引(super_class)。用以描述该类父类的全限定名。其指向常量池集合中的一个CONSTANT_Class_info类型的索引项。 因为Java为单继承，因此父类索引仅需1个。又由于所有类都继承自Object，因此除Object之外，其他类的父类索引均不为0。而Object类的父类索引为0，表示没有父类。 仍然使用常量池集合的代码为例： 0x0004=4。即为java/lang/Object。 接口集合紧接着父类索引之后的是接口集合。用来描述该类实现了哪些接口。其内部首先会用2个字节记录implements(若class表示的是接口则是extends)的接口数量interfaces_count。而后是interfaces_count个长度为2字节的interface。每个interface都指向常量池集合中的一个CONSTANT_Class_info类型的索引项。interface的排列顺序与代码中的声明顺序相同。 仍然使用常量池集合的代码为例，Test没有实现接口，即interfaces_count=0，后续没有interface数据项： 字段表集合紧接着接口集合之后的是字段表集合(field_info)，用以描述类或接口中声明的变量。 其内部分为两部分：第一部分为2个字节，表示字段个数(fields_count)。第二部分为fields_count个字段类型(field_info)。 仍然使用常量池集合的代码为例，其fields_count=1： field_info格式如下(排列顺序为先左后右)： 示例代码的字段表集合中只有一个field_info，其结构列举如下： access_flagsfield_info的第一部分占用2字节，其作用及设置方式与类或接口的access_flags非常类似，都是通过设置标志位： 2字节可设置16种标志，只使用了其中的9种。未使用的默认为0。 很显然，ACC_PUBLIC,ACC_PRIVATE,ACC_PROTECTED最多只能3选1，ACC_FINAL,ACC_VOLATILE最多只能2选1。而若class文件表示的是接口，则必须有ACC_PUBLIC,ACC_STATIC,ACC_FINAL。 仍然使用常量池集合的代码为例： 0x0002=0000-0000-0000-0010。即只设置了ACC_PRIVATE。 name_index紧跟着access_flags之后的2字节是name_index，代表字段的简单名称。指向常量池集合中的一个CONSTANT_Utf8_info类型的索引项。 仍然使用常量池集合的代码为例： 0x0005=5，即为m。 descriptor_index用于描述字段及方法的属性。主要有3个： 全限定名 简单名称 描述符 全限定名和简单名称较易于理解，以示例代码为例，类Test的全限定名为com/test/Test。方法inc()的简单名称为inc，字段m的简单名称为m。 描述符所表述的信息则更为复杂。对于字段而言，描述的是字段的数据结构。对于方法而言，描述的是方法的参数列表(数量，类型，顺序)和返回值。 根据描述符规范，基本数据类型(byte,char,double,float,int,long,short,boolean)以及代表无返回值的void(JVM规范将void单独列出，名为VoidDescriptor)都用一个大写字母表示。引用类型则使用大写字母L加对象的全限定名表示： 因引用类型长度不定，故仅有其最后会加上一个;以示结束。 对于数组类型而言，每有一个维度，都将增加一个前置的[。例如： java.lang.String[][]表示为[[Ljava/lang/String; int[]表示为[I 描述方法时，按照先参数列表后返回值的顺序记录。参数列表按参数顺序写入一个()中： 12345void m1()描述为：()V 1234int m2(char[] c, int i1, int i2, String[][] s, double d)描述为：([CII[[Ljava/lang/String;D)I 仍然使用常量池集合的代码为例： 0x0006=6。即为I。至此综合access_flags，name_index及descriptor_index。我们已可记录该字段的基本信息：private int m。 属性表集合descriptor_index之后是属性表集合。其内部分为两部分：首先是u2长度的attributes_count，随后是attributes_count个attribute_info类型。上文已介绍的access_flags，name_index及descriptor_index是field_info必定包含的数据，而属性表集合则是可选数据，若不存在则有attributes_count=0，属性表集合直接结束。仍然使用常量池集合的代码为例： 此时attributes_count=0x0000=0，即不包含属性表。 属性表集合用于存储一些额外信息。例如有类变量： 1final static int f = 123; 则其属性表集合中可能会存在一项名为ConstantValue的属性，其值指向常量池集合中的常量123(详见后文对属性表集合的介绍)。 一些细节字段表集合中不会列出从父类(对于类而言)或父接口(对于接口而言)中继承而来的字段，但是可能会列出没有在代码中显式声明的字段：例如内部类为了保持对外部类的访问性，会自动添加指向外部类实例的字段。 对于Java语言规范而言，字段是无法重载的，两个字段的数据类型，修饰符不管是否相同，都必须使用不同的字段名。而对于JVM规范而言，只要class文件格式中的field_info不同即可，换句话说，字段可以重名。 方法表集合紧跟在字段表集合之后的是方法表集合。方法表集合的存储思路与字段表集合几乎完全相同。 其内部分为两部分：第一部分为2个字节，表示方法个数(methods_count)。第二部分为methods_count个方法类型(method_info)。 仍然使用常量池集合的代码为例，其methods_count=2： method_info格式如下(排列顺序为先左后右)： 示例代码的方法表集合中有2个method_info，现以第一个为例： access_flagsmethod_info的第一部分占用2字节，其存储思路类似于field_info的access_flags： 因字段与方法修饰符的差异，method_info较之field_info在access_flags上做了如下增删： 删除只能修饰字段不能修饰方法的：volatile(ACC_VOLATILE),transient(ACC_TRANSIENT) 增加只能修饰方法不能修饰字段的：synchronized(ACC_SYNCHRONIZED),native(ACC_NATIVE),strictfp(ACC_STRICTFP，即FP-strict，精确浮点计算),abstract(ACC_ABSTRACT) 则第一个方法的access_flags为： 0x0001=0000-0000-0000-0001。即只设置了ACC_PUBLIC。 name_index紧跟着access_flags之后的2字节是name_index，代表方法的简单名称。指向常量池集合中的一个CONSTANT_Utf8_info类型的索引项。 则第一个方法的name_index为： 0x0007=7，即为&lt;init&gt;。 descriptor_index类似于field_info的descriptor_index，方法1的descriptor_index为： 0x0008=8。即为()V。至此综合access_flags，name_index及descriptor_index。我们已可记录该方法的基本信息： 1public void &lt;init&gt;(); 该方法并未在代码中显式声明，是由编译器自动添加的实例构造器。 属性表集合descriptor_index之后是属性表集合。类似于field_info的属性表集合，其内部分为两部分：首先是u2长度的attributes_count，随后是attributes_count个attribute_info类型。上文已介绍的access_flags，name_index及descriptor_index是method_info必定包含的数据，而属性表集合则是可选数据，若不存在则有attributes_count=0，属性表集合直接结束。则对于方法1而言： 此时attributes_count=0x0001=1，即包含1个属性表。 关于属性表信息，详见后文对属性表集合的介绍。 一些细节若没有发生重写(Override)，则子类class文件中的方法表集合中不会出现父类的方法。实际上，如果我们换个思路来思考：和字段表集合一样，方法表集合中同样不会出现父类方法。所谓的重写不过是子类中的方法覆盖了父类中的方法，该方法实际上仍是属于子类的方法，并非父类中的那个方法。 在Java 基础-重载与重写中，规定了重载的判定依据为： 方法的参数：必须一模一样，包括个数，顺序，类型（有继承关系的子类也不行，必须是一模一样的类）。 返回值：一样或为有继承关系的子类。 异常检查：对于Checked Exception而言，可以抛出更少的异常，但不能抛出父类中没有定义的异常。对于Unchecked Exception(RuntimeException)及Error而言则没有限制。 访问权限：应比父类中的权限更宽松，换句话说，即允许被更多人访问(public &gt; protected &gt; default[即没有修饰] &gt; private)。 之所以对方法参数的要求如此严格，就是因为要严格遵循method_info中的descriptor_index中的()中的参数列表值。 类似于字段表集合，方法表集合中也可能会出现没有在代码中显式定义的方法。最典型的就是类构造器方法&lt;clinit&gt;及实例构造器方法&lt;init&gt;。 如前所述，在Java语言规范中，字段是无法重载的。在JVM规范中，字段是可以重载的。而Java语言规范及JVM规范中方法均是可以重载的，重载的前提条件为方法间的简单名称相同，而特征签名不同。 Java语言规范与JVM规范对于特征签名的定义是不同的： Java语言规范：包括方法名称，参数顺序，参数类型(不考虑子类，即参数分别为父类及子类的两个方法间可以发生重载)。 JVM规范：在Java语言规范的基础上，又添加了方法返回值及受查异常表(均不考虑子类)。 通常我们如果只说特征签名，那么指的就是Java语言规范中的特征签名。 类似于字段的重载，由两个规范对特征签名定义的差异可知，在Java语言规范中无法共存的两个方法在class文件中就有可能共存(举个具体的例子，两个方法仅仅依靠返回值类型不同就可以在class文件中共存，却无法通过Java语法的编译)。 属性表集合属性表(attribute_info)集合是class文件中最灵活(相对来说)也是最重要的一部分。其出现在4处地方： 紧跟在方法表集合之后(即整个类文件的最后)，用于描述类的额外信息。 每个字段表的最后，用于描述字段的额外信息。 每个方法表的最后，用于描述方法的额外信息，其中最为重要的一种attribute_info为Code，用于记录方法体内部的代码。 部分attribute_info(例如Code)内部也会包含。 由此可以归纳出class文件的设计套路：每个结构先用尽量工整死板的结构存储必要的信息，然后将较为灵活的信息作为额外数据放在最后。 之所以说属性表最为灵活，是因为不再要求属性表集合中的attribute_info有固定的顺序。甚至只要不与已有的属性表重名，任何人实现的任何编译器都可以向属性表集合中写入自己定义的attribute_info。JVM在运行期若遇到不认识的attribute_info会自动忽略。 属性表集合内部分为两部分：首先是u2长度的attributes_count，随后是attributes_count个attribute_info类型。 每个attribute_info的结构为： 首先是attribute_name_index，占2个字节，它指向常量池集合中的一个CONSTANT_Utf8_info类型的索引项。用于表示attribute_info的名称，也是attribute_info间区分的依据(前文所谓的重名)。随后是attribute_length，占4个字节，用于描述该attribute_info的净长度(即不算attribute_name_index与attribute_length，实际存储数据信息的长度)。最后就是占用attribute_length*u1空间的属性信息本身。 由该定义我们可以再次认识到，属性表的定义确实很灵活。只需要告诉JVM你所要记录的属性信息有多长，给一个从外部划分的边界，至于内容则是黑盒的，JVM规范并未规定。 JVM规范自带的attribute_info如下所示。最初在《Java虚拟机规范(第二版)》中预定义了9种attribute_info，而到了《Java虚拟机规范(Java SE 7)》中，attribute_info扩展到了21种： @Deprecated是一种注释，表示不推荐使用。 以下为其中常用的几种： CodeJava方法的方法体会被以字节码指令的形式存储至class文件方法表的属性表集合中，其属性名为Code。 正如并非所有方法都有方法体一样(例如接口中的方法，或抽象类中的抽象方法)，并非所有方法表都必定包含Code属性。 Code属性的结构如下图所示： 仍然使用常量池集合的代码为例，继续分析方法表集合中的方法1，我们已知其属性表集合中有1个属性表。现继续详细分析该属性表。 attribute_name_index及attribute_length为所有属性表的固定结构，前文已有描述。对于Code属性而言，attribute_name_index固定为Code： 0x0009=9，即Code。 0x0000001D=29。即该属性表的长度为29个字节，则我们可以确定出其外部范围： attribute_length之后的2个字节为max_stack，代表方法操作数栈(Operand Stacks)的最大深度，即操作数栈的大小。运行期该值即为代表方法的栈帧(Stack Frame)中的操作数栈的深度。实例代码中： 0x0001=1，即方法操作数栈最大深度为1。 max_stack之后的2个字节为max_locals，表示局部变量表所需的存储空间。 局部变量表的基本单位为Slot。可以认为一个Slot为32位，因此对于byte,char,float,int,short,boolean,returnAddress这种长度不超过32位的数据类型而言，只需1个Slot即可。而对于double,long这两种64位的数据类型而言，占用2个Slot。 局部变量表用于存储如下信息： 方法参数(若为实例方法，还会包含默认隐藏的this) 显式异常处理器的参数(Exception Handler Parameter)，也就是catch括号中显式声明的异常 方法体中定义的局部变量 对于实例方法而言，初始时0号Slot中默认为this。 max_locals小于等于方法所用的局部变量占用的空间之和，其原因在于每个局部变量在方法中都有自身的作用域，若超出作用域，其所占据的空间就会被其他局部变量复用。 0x0001=1，即局部变量表大小为1。 max_locals之后是字节码指令集合。其分为两部分：第一部分为4个字节的code_length，代表字节码指令流长度。第二部分为code_length*u1个字节，代表具体的字节码指令。 每个字节码指令的长度为u1。每当JVM读入一个字节码，都可以明白其所表征的含义，并能根据该字节码指令的定义了解其后是否需要跟随参数及这些参数的含义。 u1的无符号数的取值范围为[0,255]。即共可表示256种字节码指令。目前已使用了约200种。详见JVM-JVM字节码指令集。 code_length的长度为u4，则理论上最大长度可达2^32-1。但是JVM规范中明确规定1个方法的字节码指令流最大长度为65535，即实际上code_length最大只使用了u2的空间，如果超出了这个限制，javac编译器也会拒绝编译。一般来讲，除非故意为难编译器，一个方法中的字节码指令流是不会超过这个上限的。但是，某些特殊情况，例如在编译一个很复杂的JSP文件时，某些JSP编译器会把JSP内容和页面输出的信息归并于一个方法之中，此时生成的方法中的字节码指令流的长度就有可能超过上限，从而编译失败。 Code属性是class文件中最重要的属性，而字节码指令集合又是Code属性中最为重要的部分。 我们可将1个Java程序分为两部分： 代码(Code)：方法体中的Java代码 元数据(Metadata)：类，字段，方法定义及其他信息 那么映射到class文件，Code属性用于描述方法体中的Java代码，而其他所有部分都是在描述元数据。 实例代码中： code_length=0x00000005=5，因此向后取5个字节作为字节码指令流： 由JVM-JVM字节码指令集得： 2A(aload_0):将局部变量表0号Slot中的引用类型压入操作数栈，对于实例方法而言，初始时0号Slot中默认为this。 B7(invokespecial):以操作数栈栈顶reference类型的数据所指向的对象为方法的接收者，调用此对象的实例构造器&lt;init&gt;方法，私有方法或超类构造方法。该指令之后会紧跟一个u2的参数说明具体调用的是哪个方法，该参数指向常量池集合中的一个CONSTANT_Utf8_info类型的索引项，也就是该方法的方法符号引用。 0001:invokespecial的参数，即为： 1java/lang/Object.&quot;&lt;init&gt;&quot;:()V B1(return):从当前方法返回void，本方法结束。 由上述分析可知，JVM执行字节码是基于栈的，但是与一般的基于堆栈的零字节指令(即每条指令只占一位，没有后续附加信息)所不同，某些指令(如invokespecial)后面还会带有参数。 字节码指令集合之后是异常表集合，其分为两部分，第一部分为2个字节的exception_table_length，代表异常表长度。第二部分为exception_table_length个exception_info。 异常表集合对于Code属性而言不是必须的，若没有该集合，则exception_table_length=0。继续分析示例代码： 即exception_table_length=0。 exception_info的结构如下图所示： 排列顺序为先左后右。其含义为：若[start_pc,end_pc)行之间的字节码出现了类型为catch_type(u2,指向常量池集合中的一个CONSTANT_Utf8_info类型的索引项，若指向第0项，则表示能捕获任意异常)或其子类型的异常，则跳转至第handler_pc行。需要注意的是，此处字节码的行是一种形象化的表示，实际上是字节码较之方法体开始位置的偏移量。 class文件使用exception_info而非简单的跳转命令来实现Java的异常及finally机制。其实例可参见Java 基础-异常。 异常表集合之后是Code属性表内部包含的属性表集合。其内部分为两部分：首先是u2长度的attributes_count，随后是attributes_count个attribute_info类型。属性内部又有个属性表集合，听起来有点绕。但其套路与前文已讨论过的类文件，字段表，方法表一样，都是在结构的最后加一些不方便固定描述的额外信息。 继续分析示例代码第一个方法的Code属性： 0x0001=1，即attributes_count=1，再向后取一个attribute_info类型，在该attribute_info内部，先取u2长度作为attribute_name_index： 0x000A=10，即LineNumberTable。 attribute_name_index之后是u4长度的attribute_length： 0x00000006=6，即attribute_length=6。正好蓝色的区域向后数6个也结束，说明Code属性也结束了，和预期相符。 LineNumberTableLineNumberTable用于描述Java源码的行号与字节码行号(实际是相对于方法体开始处的字节码偏移量)之间的映射关系。 LineNumberTable并非是必须的，但默认会在class文件中生成，在使用javac命令进行编译时，可使用-g:none及-g:lines显式取消或要求生成该属性。若取消生成该属性，则当抛出异常时，堆栈中不会显示出错的行号，并且在调试程序时，也无法按照源码行设置断点。 LineNumberTable的结构如下： 前两项u2长度attribute_name_index及u4长度的attribute_length同其他属性一样，随后是行号表集合。 行号表集合内部由2部分组成，首先是u2长度的line_number_table_length，随后是line_number_table_length个line_number_info。 则继续分析示例代码中的Code属性： 0x0001=1，即line_number_table_length=1。则向后取1个line_number_info。 在line_number_info内部，首先是u2长度的start_pc，代表字节码相对于方法体开始处的偏移量。随后是u2长度的line_number，代表Java源码行号。 则继续分析示例代码中的Code属性： 0x0000=0，即start_pc=0。 0x0003=3，即line_number=3。 至此，实例代码中的第一个方法所包含的Code属性已分析完毕，其结果与javap得到的信息相同： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051Classfile /E:/Test.class Last modified 2017-11-8; size 274 bytes MD5 checksum ba2585a36b64eb15c6657dc8440c38e0 Compiled from &quot;Test.java&quot;public class com.test.Test SourceFile: &quot;Test.java&quot; minor version: 0 major version: 51 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #4.#15 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = Fieldref #3.#16 // com/test/Test.m:I #3 = Class #17 // com/test/Test #4 = Class #18 // java/lang/Object #5 = Utf8 m #6 = Utf8 I #7 = Utf8 &lt;init&gt; #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 inc #12 = Utf8 ()I #13 = Utf8 SourceFile #14 = Utf8 Test.java #15 = NameAndType #7:#8 // &quot;&lt;init&gt;&quot;:()V #16 = NameAndType #5:#6 // m:I #17 = Utf8 com/test/Test #18 = Utf8 java/lang/Object&#123; public com.test.Test(); flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 3: 0 public int inc(); flags: ACC_PUBLIC Code: stack=2, locals=1, args_size=1 0: aload_0 1: getfield #2 // Field m:I 4: iconst_1 5: iadd 6: ireturn LineNumberTable: line 8: 0&#125; 对应方法public com.test.Test()，其中stack代表操作数栈深度，locals代表局部变量表大小，args_size代表传入参数大小。locals及args_size均为1的原因为该方法为实例方法，默认会传入其所属对象的引用this。此时this默认占用局部变量表0号索引的位置。 因示例代码方法表集合的长度为2，则我们继续向后分析第二个方法，第一个方法结束后，紧接着就是第二个方法的method_info。 在该method_info内部，首先是u2长度的access_flags： 即access_flags=0x0001=0000_0000_0000_0001。则该方法的访问标志有ACC_PUBLIC。 access_flags之后是u2长度的name_index： 0x000B=11，即inc。 name_index之后是u2长度的descriptor_index： 0x000C=12，即()I。 至此我们已可得到第二个方法的定义信息： 1public int inc() 随后就是方法2的属性表集合了。其内部首先是u2长度的attributes_count，代表其属性表集合的长度： attributes_count=0x0001=1。即该属性表内部只有一个attribute_info。则向后取一个attribute_info。 在该attribute_info内部，首先是u2长度的attribute_name_index: attribute_name_index=0x0009=9，即Code。随后是该attribute_info的u4长度的attribute_length： attribute_length=0x0000001F=31。即该Code属性的外部边界长度为31： 接着我们详细分析该Code属性，首先是u2长度的max_stack： max_stack=0x0002=2，即操作数栈最大深度为2。 随后是u2长度的max_locals： max_locals=0x0001=1，即局部变量表最大占用空间为1个Slot。 随后是字节码指令集合。其内部首先是u4长度的code_length： code_length=0x00000007=7，即此后的7个字节为该方法方法体中代码的字节码指令流： 依序分析这个字节码指令流，由JVM-JVM字节码指令集得： 前文分析已得，该方法操作数栈最大深度为2，局部变量表最大占用空间为1个Slot。 初始时: 操作数栈：无 局部变量表：this 2A(aload_0):将局部变量表0号Slot中的引用类型压入操作数栈: 操作数栈：this 局部变量表：this B4(getfield):获取指定类的实例域，并将其值压入操作数栈。该指令之后会紧跟一个u2的参数指明实例域的全限定名，该参数指向常量池集合中的一个CONSTANT_Utf8_info类型的索引项。 0002:getfield的参数，即为：com/test/Test.m:I 执行该指令后： 操作数栈：m 局部变量表：this 04(iconst_1):将int型1压入操作数栈: 操作数栈：m,1 局部变量表：this 60(iadd):弹出操作数栈栈顶两int型数值相加并将结果压入操作数栈: 操作数栈：m+1 局部变量表：this AC(ireturn):返回操作数栈栈顶的int类型数值，即返回m+1 随后是异常表集合，其内部首先是u2长度的exception_table_length: exception_table_length=0x0000=0。即没有异常表，则异常表集合结束。 异常表集合之后是Code属性表内部包含的属性表集合。其内部分为两部分：首先是u2长度的attributes_count： 0x0001=1，即attributes_count=1，再向后取一个attribute_info类型，在该attribute_info内部，先取u2长度作为attribute_name_index： 0x000A=10，即LineNumberTable。 attribute_name_index之后是u4长度的attribute_length： 0x00000006=6，即attribute_length=6。正好蓝色的区域向后数6个也结束，说明Code属性也结束了，和预期相符。 在LineNumberTable内部，首先是u2长度的line_number_table_length： line_number_table_length=0x0001=1。则向后取1个line_number_info。 在line_number_info内部，首先是u2长度的start_pc，代表字节码相对于方法体开始处的偏移量。随后是u2长度的line_number，代表Java源码行号。 则： start_pc=0x0000=0。 随后： line_number=0x0008=8。 至此，实例代码中的第二个方法所包含的Code属性已分析完毕，其结果与javap得到的信息相同，也就是其中的inc()： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051Classfile /E:/Test.class Last modified 2017-11-8; size 274 bytes MD5 checksum ba2585a36b64eb15c6657dc8440c38e0 Compiled from &quot;Test.java&quot;public class com.test.Test SourceFile: &quot;Test.java&quot; minor version: 0 major version: 51 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #4.#15 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = Fieldref #3.#16 // com/test/Test.m:I #3 = Class #17 // com/test/Test #4 = Class #18 // java/lang/Object #5 = Utf8 m #6 = Utf8 I #7 = Utf8 &lt;init&gt; #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 inc #12 = Utf8 ()I #13 = Utf8 SourceFile #14 = Utf8 Test.java #15 = NameAndType #7:#8 // &quot;&lt;init&gt;&quot;:()V #16 = NameAndType #5:#6 // m:I #17 = Utf8 com/test/Test #18 = Utf8 java/lang/Object&#123; public com.test.Test(); flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 3: 0 public int inc(); flags: ACC_PUBLIC Code: stack=2, locals=1, args_size=1 0: aload_0 1: getfield #2 // Field m:I 4: iconst_1 5: iadd 6: ireturn LineNumberTable: line 8: 0&#125; 至此示例代码class文件的方法表集合彻底结束。随后就是class文件的最后一部分，即属于类的属性表集合。其内部分为两部分：首先是u2长度的attributes_count，随后是attributes_count个attribute_info类型。 则先取attributes_count： attributes_count=0x0001=1，即该属性表集合中只有一个attribute_info，则继续向后取该attribute_info。 在attribute_info内部，首先是u2长度的attribute_name_index： attribute_name_index=0x000D=13，即SourceFile。 随后是u4长度的attribute_length: attribute_length=0x00000002=2。 SourceFileSourceFile用于记录生成该class文件的源文件的文件名称。本属性可选，但默认是开启的。在使用javac指令生成class文件时可通过-g:none或-g:source选项显式取消或要求该属性。若不生成该属性，当抛出异常时，堆栈中将不会显示出错代码所属的文件名。在Java中，多数情况下类名与其所属的文件名是一致的，但少数情况下(非public类或内部类)例外。 SourceFile为一个定长结构： sourcefile_index指向常量池集合中的一个CONSTANT_Utf8_info类型的索引项。 继续分析示例代码： 0x000E=14，即Test.java。 至此，示例代码全部分析完毕。 Exceptions本属性与Code属性平级，同Code属性中的数据项异常表集合是不同的。 Exceptions的作用为列出方法中可能抛出的受查异常(Checked Exceptions)。更具体的来说，也就是列出方法定义中throws关键字之后跟随的异常。其结构为： 排列顺序为先左后右。该属性的前两项attribute_name_index及attribute_length为所有属性的通用数据项。随后跟随的为受查异常集合。 在受查异常集合内部，首先为u2长度的number_of_exceptions，即受查异常个数。随后是number_of_exceptions个u2长度的exception_index_table，每个exception_index_table都指向常量池集合中的一个CONSTANT_Utf8_info类型的索引项，代表每个受查异常。 LocalVariableTabieLocalVariableTabie用于描述栈帧局部变量表中的变量与Java源码中定义的变量之间的关系。其不是必须的属性，默认不会生成在class文件中。在用javac命令生成class文件时可通过-g:none及-g:vars显式取消或生成本属性。 若没有生成该属性，当其他人引用该方法时，所有参数的名称都将丢失，IDE将会使用诸如arg0,arg1之类的占位符代替原有的参数名。取消本属性不会影响程序的运行，但显然会对编码造成较大不便，且在调试期间也无法根据参数名从上下文中获取参数值。 LocalVariableTabie的结构如下图所示： 该属性的前两项attribute_name_index及attribute_length为所有属性的通用数据项。随后跟随的为本地变量表集合。 在本地变量表集合内部，首先为u2长度的local_variable_table_length，随后为local_variable_table_length个local_variable_table。local_variable_table代表一个源码局部变量到栈帧中的局部变量的映射关系，其结构如下图所示： start_pc代表该局部变量生命周期开始时相对于方法体的字节码偏移量。length代表该局部变量的作用范围长度。二者结合即可确定该局部变量在方法体中的作用域。 name_index及descriptor_index均指向常量池集合中的一个CONSTANT_Utf8_info类型的索引项。分别表示该局部变量的名称及描述符。 index是该局部变量在栈帧局部变量表中的Slot位置。当该局部变量为64位(long或double)时，将占用两个Slot。此时index中记录的是第一个Slot索引值。 顺带一提，自JDK1.5引入泛型后，便增加了一个LocalVariableTabie的姊妹属性：LocalVariableTypeTabie。其与LocalVariableTabie非常相似，不同之处仅仅在于其将局部变量的描述符descriptor_index替换为了局部变量的特征签名(Signature)。对于非泛型类型而言，描述符和特征签名能描述的信息是基本一致的。但是引入泛型后，由于描述符中泛型的参数化类型被擦除了，描述符就无法准确的描述泛型类型了。因此才出现了LocalVariableTypeTabie。 ConstantValue根据JVM规范，ConstantValue属性的作用是通知JVM自动为静态变量赋值。只有被static修饰的变量(即类变量)才能使用该属性。 若变量定义如下： 1int x = 123; 这被称为实例变量，其是在实例构造器&lt;init&gt;中赋值的。 而对于类变量(即上文x再被static修饰)，赋值时机有两个：类构造器&lt;clinit&gt;或使用ConstantValue属性。对于SUN自带的javac编译器而言，对于类变量，如果同时满足如下两个条件： 使用final修饰 数据类型为基本类型或java.lang.String 则使用ConstantValue属性初始化，反之则在&lt;clinit&gt;中初始化。 再次强调，JVM规范与JVM实现是不同的。对于ConstantValue属性，JVM规范只设置static一个限制条件，至于final及数据类型则是SUN实现的javac编译器自身追加的限制。 ConstantValue属性的结构如下图所示： 很显然，这是一个定长属性。constantvalue_index表示常量值，其指向常量池集合中的一个索引项。这也是为什么ConstantValue属性会有类型限制的原因：因为常量池集合中只能存储基本数据类型及字符串类型，即便ConstantValue属性想表示其他类型也无从下手。具体来说，常量池集合中能表示的类型有如下5种： CONSTANT_Double_info CONSTANT_Float_info CONSTANT_Long_info CONSTANT_Integer_info CONSTANT_String_info InnerClassesInnerClasses属性用于记录内部类与宿主类之间的关联。如果一个类包含了内部类，那么编译器会为它及它所包含的内部类生成本属性。InnerClasses属性的结构如下图所示： 在所有属性共有的头两个数据项之后是内部类集合。其由两部分组成，第1部分是u2长度的number_of_classes，代表需要记录多少个内部类信息，随后是number_of_classes个inner_classes_info。inner_classes_info的结构如下图所示： inner_class_info_index及outer_class_info_index均指向常量池集合中的一个CONSTANT_Class_info类型的索引项，分别代表内部类及宿主类的符号引用。 inner_name_index指向常量池集合中的一个CONSTANT_Utf8_info类型的索引项，代表内部类的名称。若其为匿名内部类，则指向常量池集合的索引0。 inner_class_access_flags是内部类的访问标志，类似于类的access_flags，其取值范围如下图所示： Deprecated及SyntheticDeprecated及Synthetic均是标志类型的布尔属性，只有是否存在的区别，没有具体的属性值：有该属性就被认为是true，没有该属性就是false。 Deprecated用于表示被其修饰的类，字段或方法已被代码作者定为不推荐使用，体现在代码中，就是@deprecated注解。 Synthetic表示字段或方法不是依据Java源码生成的，而是由编译器自行添加的。 自JDK1.5起，标志一个类，字段或方法是由编译器自动生成的，也可在它们的访问标志access_flags中设置ACC_SYNTHETIC标志位，其中最典型的例子就是Bridge Method(桥接方法是JDK1.5引入泛型后，为了使Java的泛型方法生成的字节码和JDK1.5前的字节码相兼容，由编译器自动生成的方法)。 除了类构造器方法&lt;clinit&gt;及实例构造器方法&lt;init&gt;之外，其他所有由非源码产生的类，方法及字段都应至少设置Synthetic属性或ACC_SYNTHETIC标志位中的一项。 Deprecated及Synthetic的结构均如下图所示： 即只有所有属性共有的那两个数据结构，且必有attribute_length=0。 StackMapTable自JDK1.6起StackMapTable被加入到class文件规范中，并于JDK1.7时强制代替了原本的基于类型推断的字节码验证器。它是一个复杂的变长属性，位于Code属性的属性表集合中。 StackMapTable属性会在运行期类加载中的连接中的字节码验证阶段被新类型检查验证器(Type Checker)使用。目的在于代替以前比较消耗性能的基于数据流分析的类型推导验证器。简单来说，就是将验证所需的信息的生成及验证逻辑尽可能的提前到编译器并形成StackMapTable属性。 StackMapTable属性的结构如下图所示： 在所有属性共有的头两个数据项之后是栈映射帧(Stack Map Frames)集合。其内部由两部分组成：首先是u2长度的number_of_entries，而后是number_of_entries个stack_map_frame。stack_map_frame也就是所谓的栈映射帧。每个栈映射帧都显式或隐式的包含了一个字节码偏移量，用于表示执行到该字节码时局部变量表及操作数栈需满足的验证类型。 《Java虚拟机规范(Java SE 7版)》中规定，版本号大于等于50(即JDK1.6)的class文件，如果方法Code属性中没有包含StackMapTable属性，那么意味着其包含一个隐式的StackMapTable属性。该StackMapTable属性的number_of_entries=0。该规范同样也规定一个方法的Code属性的属性集合中最多只能包含一个StackMapTable属性，否则将抛出ClassFormatError。 SignatureSignature属性是JDK1.5新增的属性，这是一个可选的定长属性，可能出现于类，字段表及方法表的属性表集合中。 JDK1.5中引入了一个重要的特性-泛型。但是Java语言中的泛型是采用擦除法实现的伪泛型，在Code属性中，泛型信息(类型变量[Type Variables]，参数化类型[Parameterized Types])在编译后都会被通通擦除掉。使用擦除法实现泛型的好处在于简单，较之此前没有泛型的版本修改较小(主要只需修改javac编译器，JVM内部改动很小)，同时也非常易于实现Backport(Backport是将一个软件的补丁应用到比此补丁所对应的版本更老的版本的行为)，运行期也能节省一些类型所占用的内存空间(这个好处听起来就很牵强了，一般来说不会在乎那么点内存的)。然而其坏处却是致命的，也是Java一直被人诟病的点之一：假的就是假的，用一个伪物试图实现真物的功能必然要付出很大的代价，而且即便付出代价了，其结果往往也是似是而非。Java无法像C#等支持真泛型的语言那样，在运行期将泛型类型与用户定义的普通类型同等对待，起码无法走正常渠道直接在运行期通过反射获得泛型信息。 Signature属性就是这个异常渠道，或者说是试图用伪物替代真物所付出的代价。任何类，接口，初始化方法或成员的泛型签名如果包含了类型变量或参数化类型(也就是上文提到的泛型信息)都需记录到Signature属性中。换句话说，该存类型信息的地方因为不想做过多的修改把泛型信息擦除了，而使用的地方又想用，那么怎么办呢？只能再找个地方把泛型信息存起来。Java的反射API能获取泛型类型，最终的数据来源也就是这个属性。 Signature属性的结构如下图所示： 在所有属性共有的头两个数据项之后是u2长度的signature_index。其指向常量池集合中的一个CONSTANT_Utf8_info类型的索引项，若该Signature属性是类文件的属性，则其表示类签名。若该Signature属性是方法表的属性，则其表示方法类型签名。若该Signature属性是字段表的属性，则其表示字段类型签名。 BootstrapMethodsBootstrapMethods属性是JDK1.7新增的属性，它是一个复杂的变长属性，位于类文件的属性表集合中。该属性用于存储invokedynamic指令引用的引导方法限定符。《Java虚拟机规范(Java SE 7版)》规定，如果常量池集合中出现过CONSTANT_InvokeDynamic_info类型的常量，那么类文件的属性表集合中必须出现且只能出现一个BootstrapMethods属性。 BootstrapMethods属性与invokedynamic指令及java.lang.invoke包的关系非常密切。截至JDK1.7为止，javac编译器尚无法生成invokedynamic指令及BootstrapMethods属性，必须通过一些非常规的手段才能使用到它们。 BootstrapMethods属性的结构如下图所示： 在所有属性共有的头两个数据项之后是引导方法集合。其内部由两部分组成：首先是u2长度的num_bootstrap_methods，随后是num_bootstrap_methods个bootstrap_method。bootstrap_method的结构如下图所示： 首先是u2长度的bootstrap_method_ref，其指向常量池集合中的一个CONSTANT_MethodHandle_info类型的索引项。随后是引导参数集合。在引导参数集合内部，首先是u2长度num_bootstrap_arguments，其值可以为0，表示没有引导参数。随后是num_bootstrap_arguments个u2长度的bootstrap_argument。每个bootstrap_argument都指向常量池集合中的一个数据项，且必须为如下常量中的一种： CONSTANT_String_info CONSTANT_Class_info CONSTANT_Integer_info CONSTANT_Long_info CONSTANT_Float_info CONSTANT_Double_info CONSTANT_MethodHandle_info CONSTANT_MethodType_info]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[碎片-编程语言拟人化]]></title>
    <url>%2F2017%2F11%2F07%2F%E7%A2%8E%E7%89%87-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E6%8B%9F%E4%BA%BA%E5%8C%96%2F</url>
    <content type="text"><![CDATA[介绍 支撑着这个世界的女神大人，也被称为”圣母大人”。 关于C的出身年月没有定论。有人说她在创世纪(指1970年1月1日左右)之前就存在于这个世界，也有人说她是在稍后的1972年左右诞生的。 她是女神大人，因此像”1970年左右出生的话，她现在的年龄是……”这样的想法是不信教的行为。绝对不要有这样的想法。 她的名字是字母表的第三个字母”C”。据新约史书上的记载，在她之前还有叫作B的女神大人。一些资料显示”肯和丹尼斯创造了B，但对此并不满足。此后丹尼斯和其它人又合力创造了C”。 世界上有许许多多她的信徒。然而在一段时间内都没有正确传达她的教诲的圣经。当初丹尼斯和布莱恩留下的诗篇虽然担负着这样的使命，人们却希望得到更加明确的指引。此后有许多有识之士将各种逸闻编辑整理、编著出了正确传达她的教义的圣经。本书至今已被修订过多次，根据修订年的不同，被称作C89、C99、C11等。 一般人是不能直接与C对话的。只有积累足够的修行者才会被允许与C交流。修行是十分严格的，需要理解”指针的指针”之类的问题，以及要求100%地成功解决无论多么努力地修行都难以克服的”malloc/free”问题。由于这样的背景，真正能跟她进行日常交流的人非常地少。然而由能够交流的人经手、世界上诞生了多种多样的知识与技术。即使你没有见过她的样子，她的慈爱也确实地每天都围绕在你身边。 犹如宫泽贤治的《不畏风雨》中出现的、性格木讷的女孩子。从小就由于迟钝和大食量等特征被别人当作笨蛋，从小学入学开始进入田径部、坚持跑步，在中长跑中经常取得好成绩，给人以活泼的印象。是十分努力的女孩子。 她的家境并不算好。父亲Sun是有才能的艺术家，但不擅长理财，在她14岁的时候因为苦于借债积劳成疾而去世。她被Oracle叔叔收养，那时还与Google叔叔之间因为对她的抚养权问题而引起争端并闹上法庭。 在周围的人都担心，正值青春期的她在这样的处境下会不会一蹶不振的时候，她却处变不惊、继续着每天练习跑步的生活。 朴素的、认真的、难说是聪明的她，进入高中后不知是不是稍稍开始对异性在意，被人看到她偷偷地学着别的女孩子的时尚穿着在街上行走。虽然会受到”虽然很努力，也许稍微有点过时”、”那衣服与Java的印象不合”之类的否定评价，但感到”意外地很萌？”的好意的人也很多。 喜欢喝咖啡，只喝印度尼西亚产的。其本人曾说过”喜欢咖啡胜过三餐”，不禁让人稍稍担心”这样对健康没问题吗？” 由父亲大人Guido养大的深闺中的大小姐。她出身于荷兰的阿姆斯特丹，但在小时候就搬到了美国，父亲也在家里使用英语，所以不怎么会说荷兰语。 她个性随和。最出名的是她听C++宣布”想出去旅行一趟改变一下形象。200x年回来哦”出门旅行后(结果回来的时候已经2011年了……)，放言说”我也稍稍出门旅行一下，公元3000年再回来哦”后出门数年未归。虽然有着这样冒失的行动，但多亏抱着”养成大家都喜爱的孩子”的心愿的父亲大人Guido的教育，实际上和她接触后会觉得她非常容易亲近。 前些天，她去到某公司打工(她现在似乎在边上大学边打工)，被人们评价为”能充分融入工作、八面玲珑、给我们帮了大忙”。她不怎么说多余的话，彬彬有礼的样子，被评价为是在”天真烂漫、自由第一”的人众多的业界中与众不同的存在。 据说她擅长的科目是数学，经常看到她轻松地解决各种统计相关的难题。喜欢穿白色的连衣裙或浅粉色的开衫这样清新的服装。 实际上她还喜欢爬行动物，据说在家里还有养蛇。粉丝们经常讨论”她会给宠物们起什么样的名字呢？”这样的话题。大多得出的都是”肯定是Monty吧”这样的结论。会不会飞就不得而知了。(注：英国的六人喜剧团体Monty Python的作品The Flying Circus) 以强化Web世界为目的制作出来的女性机器人。竖着的头发是用作天线来随时接收主人的命令的。 为了有与人类相近的触感，使用了硅树脂来制作其皮肤。内部是类似于刀片服务器的构造，常常使用多台服务器进行复用。因此体重比人类更重一些。 在她最初登场的时候，还能看到她关节可动部分的骨架，行动也很僵硬，与人类的形象差别很大。然而经过了18年间6次的大版本升级之后，其行为和言语已经渐渐变得像人了。最近更是达到了像初音未来这样(比起人类仍然有少许违和感但已经十分自然了)的级别。 虽然笨笨的、工作时也磕磕绊绊的，但由于她遵循机器人三原则、服从主人的命令，也有很多人成为她的粉丝。她的粉丝俱乐部官网”PHPer！”无需入会费便可简单入会，是会员数在IT界首屈一指的大团体。 对于她持拒绝态度的人也很多，常有”她的行为在生理上有些难以接受”、”如果再聪明点就好了”、”与她稍有过接触但觉得还是与人类差别很大”这样的评论。 平常穿从Forever12和志村买来的衣服。想着穿便宜的快速时尚(fast fashion)的衣服便可以将省下的钱花在机器开销上。可以说是标准的机器人的效率优先的花钱方式。或许会有她也在意流行、为样子烦恼的那一天吧？ 由松本爸爸养大的日本的女孩子。因为生日在圣诞节，人生最大的烦恼是生日礼物和圣诞节礼物变成一份了。出生地是岛根县松江市，除了旅游和工作以外没有到过其它的县。 由于受的教育是自由奔放式的，她性格好动、好奇心旺盛。平时是一个率真的好孩子，但偶尔也会看到她喜欢恶作剧的一面，这让周围的人十分困扰。看到她的身影时经常会想起IT业的”Just For Fun !”这句话。 小时候过着一个人在荒山野岭到处跑的生活，10岁的时候与一个叫Rails的女孩成为朋友，生活开始变化。两个人在演艺事务所门前玩耍时，谈起可以两个人结对进行演艺活动。因此便以”Ruby与Rails”的艺名出道、主要从事杂志模特，也有拍过电视广告，所以很多人都听过她们名字。 人们想着她在这多愁善感的年龄段体验各种演艺活动、性格多少会产生一些变化吧，但在前些天与她久违的谈话中，却惊讶地发现她仍是与从事演艺活动之前一样行动自由奔放。虽然行为举止多多少少显得更加稳重，其喜欢恶作剧、活泼的本性却和以前一样没有变化。 想着已经是高中生了差不多也要开始穿一些成熟一点的服装的她，对于洋装却和小时候一样穿着Mickey Mouse。虽然她个子小又是娃娃脸与这样的衣服很配，不过这样真像一个女高中生吗？ 她的粉丝也分为想要她一直保持现在的样子，和想要看到她更成熟的样子的两派。 苗条的双腿和协调的五官。被许多人称作”IT界首屈一指的美女”的她，也因为拥有插花、茶道、钢琴和小提琴、柔道、剑道、合气道等等才能而出名。 她的粉丝大多很狂热，还存在着”黑暗军团”这样的粉丝俱乐部。黑暗军团是规模仅次于共济会(Freemason)的巨型团体，一般人无法入会。据说如果能回答出对她非常狂热的问题，就会有察觉到的军团成员来询问”你愿意进入黑暗军团吗？” 与她同父异母的姐妹Objective-C一心专注于弹钢琴，她的专注被IT界的天才史蒂夫乔布斯(也被一部分人称为紫色蔷薇)相中，而一跃成为明星，而C++则是由于其美貌和才能被人关注，长年坐稳业界明星的宝座。姐妹二人真可谓是对比鲜明。 她根据心情不同频繁地变换发型和服装这一点也很出名。昨天还是和服配黑发，今天却是红发哥特系登场之类的，因为她的变身而使轻度的粉丝惊奇道”啊嘞？今天是C++小姐吗？”的事也常有发生。远离业界时私下经常穿HYSTERIC GLAMOUR的服装。 关于她的出生年月日其事务所并不公开。虽然也有出生于1983年一说，本文采用的是在一部分粉丝中流传甚广的1985年10月14日说。其间也流传有”她自己也许也记不清自己的生日……”这样煞有介事的传言。与其说”C++小姐的话记不清自己的生日也不是什么不可思议的事情”，倒不如看作是她天真烂漫的性格的表现。 在著名的微软公司接受精英教育、11岁时便跳级进入大学学习、倍受人们关注的少女。也被称为”IT界的最强幼女”。 因为与C++的名字很像，一段时间内盛传”难道是私生子吗？”的流言，实际上两人没有直接的血缘关系。也有报道称两人是远房亲戚，但实际情况如何则不得而知。 似乎喜欢成熟的行为、讨厌像小孩子一样玩耍。有生日的时候收到父母送的名为安迪的毛绒玩具时说道”这是啥。没sense。不要”的传闻。 然而对于食物的兴趣却仍停留在小孩的阶段，多次目击到她在学校食堂点儿童套餐的样子。不喜欢喝咖啡，就算是甜味的罐装咖啡也会令她皱眉头。 虽然偶尔会见到她意外地孩子气的一面，多数情况下见到的还是她说话、待人接物彬彬有礼的样子。是一个既有成熟的一面又有稚气的一面的孩子。由于还在成长期，见到她时常有”又长高了啊”、”有些像大人的样子了”这样的感慨。一直会期待着再之后见到她时会长成什么样子。 常穿秀兰邓波的洋装。据说都是她本人挑选的，与她自己非常相配。她的可爱让人们无论男女都会成为她的粉丝。 她的志向是在大学毕业后不仅在养育她的微软公司的旗下工作、还要活跃于整个IT界。虽然没有问到更详细的计划，但据说是要做出能让苹果和企鹅等也能和睦相处的东西。到底会做出怎样的东西来呢？ Perl于1987年12月、美国的沃尔夫妇家中诞生。其父亲拉里精通计算机、语言学，母亲也从事中世纪文艺复兴和语言学专业，Perl就是在这样接受了高等教育的父母身边长大的。 父亲的教育虽然严厉，却也给了Perl许多自由。父亲在教育过程中经常说的一句话是：”方法不止有一个(There’s more than one way to do it)”。想要实现什么时，达成的方法不只有一种。可以考虑各种方法。父亲的这种教育方式，对她的性格形成产生了很大的影响。”这样做的话会怎么样？”……”那样做又会如何？”……张开好奇心的翅膀长大的她渐渐发现了自己”发明”方面的天赋。绝代的发明家、Perl诞生了。 从她踏上发明家的道路的20年来，其发明多达128890件(2014年1月统计数)，她的发明，从没什么用处的玩具，到能解决世界上许多问题的有益的发明，应有尽有。她发明的物品的原型，全都捐赠给了CPAN博物馆，任何人都可以阅览。 如今仍然不论实用与否、不断做出想做的新发明的她自嘲地在采访中说道：”我比起发明家，更像是各种破烂的生产装置。”她露出牙齿的笑容，非常振奋人心。 Perl对洋装不怎么讲究，平时因为调整机械时觉得麻烦，会穿便于运动的休闲装。最近常穿的羽绒服据说是在ame横(东京上野的一条商业街)的WEGO买的。喜欢的食物是草莓。她说作业中对因集中注意力而疲劳的大脑来说最适合的食物就是草莓。 她于2000年2月29日出身。正是残存在人们记忆中400年一遇的被诅咒的那一天。虽然出身于非常不吉利的日子，她自己却成长为人见人爱的聪明的孩子。 她的母亲名叫S。虽然在神话的世界里C是在B之后出生的，她的名字却是S的前一位R。这几个都是很难用Google搜出来的名字(因为太短了！)。 她的母亲非常擅长数学，是统计学者的助手，R也延续了这一特性。她从小时候起就很擅长数学，小学时代就已经达到能快速解决高中数学问题的级别。此外，她对几何图形也很感兴趣，经常有人看到她画着各种二维、三维图形、画好后一个人露出满足愉悦的表情。是一个稍微有点奇怪的孩子。 R在擅长数学的同时在语言表达方面则稍显逊色。前些日子采访她的时候，她对提出的问题想要回答却找不着合适的词，取而代之”刷——“地画了一幅散点图说”这样的感觉”。或许在她的眼里，这个世界里用语言来表达就像折叠复杂的数学公式那样复杂吧。 她对服装不怎么讲究，常常穿着不紧不松的连衣裙和衬衫。对于父母给她买的洋装是多少价格、哪儿买的这样的问题没有认识。仅仅是，对于最近买来的喇叭裙的裙摆张开的角度很在意。 她的梦想是将来成为一名统计学者，尽管只有14岁却经常混迹于大学学生中间每天都在解各种问题。最近光是大学已经不能满足、又向父母请求、在各种各样的研究所里进出。 姓氏是Basic，名字是Visual，也有很多人叫她的绰号：VB。小名是Ruby(与那个Ruby没有关系)。从小被某个资产家(不能说他的名字)看上，一家人都寄身于资产家的身边。那时她的名字换了好多次，如今才定下这个名字，有着比较复杂的家庭环境。 关于资产家要收养尚处于幼年的她的原因，据不可靠的传言称，他从她身上看到了从前就很憧憬的Basic女士的影子。收养具有与憧憬的女性相似气质的小孩，也即实行所谓的光源氏计划。 也许年轻人并不了解，Basic女士曾是《微电脑Basic杂志》的封面模特，在当时是每个人都非常向往的麦当娜一样的女性。实际上我认识的人里面年轻时为她倾倒的人非常之多。 VB在接受严格教育的同时，也在兴趣方面拓展天性，她在手工制品、装饰品方面有着独特的才能。看着她制作珠子的装饰品的样子会觉得犹如魔法一般。仅仅是动动手，一瞬间就可以做出一串项链。 在她10岁的时候，资产家的家里来了一位新的养女(人们常说的那位)。由于这个原因，她现在正在家中努力做一位好姐姐。然而本来便懦弱、不擅长说话的她却时常反过来被小她10岁、认真的、发言时间长的妹妹说教。加油啊，VB小姐。 小时候的VB会穿着父母买的Emily Temple的衣服，现在更多时候穿着是自己买的Lowrys Farm的衣服。今年就要大学毕业进入社会了，目标是VB小姐特有的成熟路线。 O教和F教之前有着漫长的宗教战争。Scala是这两个宗教的牧师和修女结婚诞生的异端。她出生后立即引起了两教之间激烈的对立，察觉到危险的父母将她送到私立JVM学校的Odersky老师那儿作为养女寄养。 现在两个宗教比起当时已有了关系改善的征兆，有一部分人也将她视为两家融合的象征。然而抱有强烈的对立心态的人仍然很多，也常常有针对她的存在引起的争论。F教的人们认为她的存在没有充分认识F的本质，而O教的人则对混有F的她感到难以理解。 虽然诞生于这样复杂的环境，她自己对于周围的环境却不关心，而是十分平静地到双方的教会中取面包、坚强地生活着。被她这种天真烂漫的姿态所感动、成为她的粉丝的人也很多。 Scala似乎喜欢同校高年级部的Java小姐，休息时间经常去找她。Java小姐也并不讨厌她，经常会像大姐姐一样让她坐在她的膝盖上温柔地抚摸她的头。虽然在Scala把Java喜欢的Duke的人偶用红绳子绑起来进行恶作剧时把Java惹得十分生气，在此以外则几乎没怎么吵过架。两个人就好像亲生姐妹一样。 有着见多识广的父亲和温柔的姐姐的Scala现在也许是，与其出身的复杂情况相反、实际上非常幸福地生活着吧。 对于洋装她喜欢明快的颜色和花纹，经常穿着Algonquin的衣服。虽然是比较有个性的时装，由与生俱来的有个性的她穿来却不可思议地自然。 在争议地区诞生的13岁女孩子。她的父亲是有名的设计师，但是在她5岁的时候被卷入战火身亡了。幸运的是她那时年纪还小、将她收养的Adobe叔叔非常用心地将她养大，没有在她心中留下很大的伤痕。叔叔和她父亲同样都是设计师。也许在她的记忆中已经把两个人混淆在一起了也说不定。 她所居住的国家与JavaScript所居住的国家是邻国，两国同样是由ECMA人种构成的。在外国人看来JavaScript和ActionScript的外貌非常相似。确实看她们儿童时期的照片，在肤色和五官上都很相像，但如今长大了的照片看了的话会如何呢。 她把”为祖国和叔叔努力”作为座右铭努力着，然而努力却经常得不到回报，是一个运气不太好的孩子。在争论地区盛传将实行新的公用语的时候，她希望为即将到来的和平时代出一份力，比谁都更早开始学习这门语言，然而在好不容易能说好这门语言的时候，这语言被采用为公用语的提案泡汤了。在她刚开始学习移动端上的设计时，她想着在移动方面强大了会对叔叔的工作有用。也可以减少祖国的外贷。在这样的想法中努力的时候，叔叔经营的公司却被某个巨型移动终端公司强行终止的交易，关于移动端的工作也急剧减少。 十分努力却常常得不到回报的她，伫立于这片如今也看不到纷争停止的土地上，继续地前进着。 有朝一日努力会得到回报的吧。祝福她在10年后仍能平安，不断地前进着、生活着。 在争议地区长大的17岁的女孩子。常常面无表情、谈话时总给人以一定的距离感。 虽然与Java的名字很像，两个人之间却没有血缘关系。在当时Java这样的名字很流行，所以父母也给她起了类似的名字。她本人似乎对自己的名字并不在意，有时也以”ECMA”的笔名进行活动。偶尔也会被叫”JS”的外号，对此则更不在意，甚至对这种称法公然无视。 她的生涯非常不幸。刚一出生祖国便爆发战争。懂事之前便母亲去世、离开了父亲。在大人们任性的争斗中，她学会了将自己藏在壳中、保护自己周围的生存之术。同年龄的女孩子随着年龄的变化都在挑战各种风格的时候，她却不顾周围的话语、一个人继续闭锁在壳中。当时就是非得这样才能生存的艰难环境。 由于有了这样的儿童时期，她的说话、思考、待人接物的方式与其它的孩子都稍显不同。有很多人在与她说话时都会烦恼该怎样说才好。不过，也有人对她持有简单的一根筋的思考方式”容易接触”、”某种程度上来说，很好理解”的印象。 现在，她的国家正向努力解决纷争、开拓新的居住土地的方向前进着。大人们虽然仍旧任性地互相斗争，至少在这几年里，已经没有发生像以前那样互相憎恨、互相残杀的战争了。 在开始复兴的祖国里，她如今应该能幸福地生活着吧？什么时候才能看到她像同龄的女孩一样欢笑呢？ 创世纪(1970年1月1日)起经过数年后被目击到的妖精。会寄宿在家中，有着类似于棕精灵(Brownie)的生活方式，向她们拜托家务事或者杂活的时候，会回答两次并接受的温顺的孩子。 她们不常出现在人类存在的地方，因为言语不通，因此往往会用信件交流。如果拜托的事情说得比较含糊的话，有可能会造成误解而发生不得了的事情。对此的技巧是明确地像”做那个|做这个&gt;放在这里”这样有顺序地将要拜托她们做的事写好。如果对拜托的事理解得很好的话，她们会在夜里将事情都处理好。如果很好地完成了工作的话，请别忘了在第二天的晚上放上作为谢礼的方糖。 Shell中有各种各样的种族。现在已确认的种族中比较有名的有：”ba”、”c”、”k”、”tc”、”z”等等。其服装根据种族不同而不同，我所目击到的是一只身高60cm左右、穿着巴宝莉的儿童服装的个体。恐怕人们目击到最多的是”ba”种。个人而言我也想遇到身高更高一些、尖耳朵的”z”种，现在虽然知道如何写信，却从未见过实物。 尽量她们会在同一个屋子里居住，却很少有人有机会见到，也不如何才能遇到他们。有一种说法是，每天都把写程序这一仪式进行到午夜、勉强靠咖啡因支撑着抬起头的状态下突然向屏幕看去，能够看到她的身影。确实我遭遇她，也是在公司里熬夜写程序的时候。 Shell的个体非常地多，据说每家每户都会有一只。在大家的家里，实际上有着许多的她们居住着、等着来信也说不定。 壁纸1920*1080 1366*768 1600*900]]></content>
      <categories>
        <category>碎片</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 基础-原码补码反码]]></title>
    <url>%2F2017%2F11%2F06%2FJava%20%E5%9F%BA%E7%A1%80-%E5%8E%9F%E7%A0%81%E8%A1%A5%E7%A0%81%E5%8F%8D%E7%A0%81%2F</url>
    <content type="text"><![CDATA[Java中的整数(long,int,short,byte)均为有符号数，第一位代表符号位(0:正数,1:负数)。内存中以补码存储。 下文均以byte举例。 原码 原码是给人读的。即符号位+绝对值。 7原码：00000111 -7原码：10000111 反码 反码为原码到补码间的过渡。正数的反码与原码相同。负数符号位不变，其余位取反。 7反码：00000111 -7反码：11111000 补码 补码是机器存储用的。正数的补码与其原码及反码相同。负数的补码为反码加1。进位不会改变符号位。 7补码：00000111 -7补码：11111001 计算机中存储的值均为补码，因此负数求原码的方法为减1取反。 示例123456789public class Test &#123; public static void main(String[] args) &#123; int i = Integer.MAX_VALUE + 1; System.out.println(i); System.out.println(Integer.toBinaryString(i)); &#125;&#125; 输出： 12-214748364810000000000000000000000000000000 推演： Integer.MAX_VALUE为：01111111-11111111-11111111-11111111 加1后为：10000000-00000000-00000000-00000000。该值为负数并以补码的形式在内存中存储。其原码为减1后取反，即： 减1：11111111-11111111-11111111-11111111取反：10000000-00000000-00000000-00000000 即其原码与补码相同。因此这是一个特殊的负数：实际上其表示的为-0。但为0划分正负没有意义。0已由+0表示。则该值就赋予一个特殊值，即负数的最小值-2^31(Integer.MIN_VALUE)。 示例1System.out.println(Integer.toBinaryString(-32)); 输出： 111111111111111111111111111100000 推演： -32原码：10000000-00000000-00000000-00100000-32反码：11111111-11111111-11111111-11011111-32补码：11111111-11111111-11111111-11100000 补码即为计算机中存储的值。]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>原码</tag>
        <tag>补码</tag>
        <tag>反码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 基础-instanceof与isInstance]]></title>
    <url>%2F2017%2F11%2F05%2FJava%20%E5%9F%BA%E7%A1%80-instanceof%E4%B8%8EisInstance%2F</url>
    <content type="text"><![CDATA[instanceof与isInstance通常用于规避类型转换异常(ClassCastException)。 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.test;public class Test &#123; // obj instanceof(Type):对象的实际类型是否为某类型(子类接口均可) // Class.isInstance(obj):该对象的实际类型能否转化为某类(强制自动均可)。Class为类对象 public static void main(String[] args) &#123; A a = new A(); B b = new B(); A ba = new B(); System.out.println(&quot;1------------&quot;); System.out.println(b instanceof B); // true System.out.println(b instanceof A); // true System.out.println(b instanceof Object); // true System.out.println(ba instanceof A); // true System.out.println(ba instanceof B); // true System.out.println(a instanceof B); // false System.out.println(null instanceof Object); // false System.out.println(&quot;2------------&quot;); System.out.println(b.getClass().isInstance(b)); // true System.out.println(b.getClass().isInstance(a)); // false System.out.println(&quot;3------------&quot;); System.out.println(a.getClass().isInstance(ba)); // true System.out.println(b.getClass().isInstance(ba)); // true System.out.println(b.getClass().isInstance(null)); // false System.out.println(&quot;4------------&quot;); System.out.println(A.class.isInstance(a)); // true System.out.println(A.class.isInstance(b)); // true System.out.println(A.class.isInstance(ba)); // true System.out.println(&quot;5------------&quot;); System.out.println(B.class.isInstance(a)); // false System.out.println(B.class.isInstance(b)); // true System.out.println(B.class.isInstance(ba)); // true System.out.println(&quot;6------------&quot;); System.out.println(Object.class.isInstance(b)); // true System.out.println(Object.class.isInstance(null)); // false &#125;&#125;class A &#123;&#125;class B extends A &#123;&#125;]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>instanceof</tag>
        <tag>isInstance</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[碎片-计算机语言发展历史]]></title>
    <url>%2F2017%2F11%2F04%2F%E7%A2%8E%E7%89%87-%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2%2F</url>
    <content type="text"><![CDATA[计算机语言是写给计算机看的，因此必须符合机器阅读的规范。然而计算机语言又是由人写的，因此又必须能让人读得懂。计算机语言越是发展，就越是远离机器的自然语言，靠向人类的自然语言。原因主要有二： 人类想写得更为舒服。将精力更多的放在业务本身，而非语言上。 硬件的高速发展导致人们根本不在乎从人类的自然语言到机器的自然语言之间的翻译导致的那一点点的性能流失。 第一代：机器语言相当于机器的自然语言，由一串01组成。不同的硬件架构有不同的语法。换句话说，正如人类的自然语言不止一种，机器的自然语言也不止一种。 第二代：汇编语言程序员开始使用英文单词作为助记符来标志01。汇编语言已然离开了机器的自然语言的范畴而进入了人类的自然语言，只是语法简单，无法表达复杂的含义。 现在仍然有很多领域在使用汇编语言，比如：操作工业机器人、单片机编程、甚至某些计算机病毒的编写等。 第三代：高级语言面向过程 C:由B语言升级而来，是高级语言的鼻祖。依然在广泛使用。1972年由美国贝尔实验室发明(其还发明了计算机硬件行业的基石-晶体管)。 Fortran:20世纪50年代诞生，当前依然在使用。由IBM(International Business Machines Corporation,国际商业机器公司或万国商业机器公司，1911年创立于美国，是世界上最古老的IT公司)提出。 COBOL:较为古老的语言，当前在一些金融及银行的系统中依然在用。 PASCAL:主要用于大学。当前用的已不多。 ADA:美国国防部提出的语言，基于PASCAL，擅于写控制软件。 面向对象 C++:1983年由贝尔实验室发明，是C引入面向对象思维后的升级。 Java:有人将Java称为C++-。即Java去掉了C++中的一些复杂的让人难以理解的设计。降低了灵活性，但也降低了语言的学习成本。 C#:C Sharp(锋利的C)，也被称为C++++。与Java渊源极深。比尔盖茨本人对Java非常赞许，甚至曾有”Java是我见过的最好的语言”的引战言论。因此微软曾试图在自己的体系中重用Java。在微软与Sun的蜜月期，微软甚至为Java推出了一个Windows上的运行平台Visual J++。后来微软与Sun就Java的版权问题打了旷日持久的官司，微软重用Java的计划也随之告吹。C#是微软在官司失败后山寨的Java，或者说是微软所希望的Java的样子。其各方面与Java都非常相似。因为是微软希望的样子，C#自然就与Windows平台绑定，无法像Java那样保有平台无关性。而服务器领域当前依然是Linux/Unix的天下，因此在该领域，无论其从语法及性能上较之Java是否真的有优势，C#的市场占有率依然很小。 Object-C语言:现在IOS和Mac开发中的主流语言。根据C语言所衍生出来的语言，继承了C语言的特性，是扩充C的面向对象编程语言。它主要使用于Mac OS X和GNUstep这两个使用OpenStep标准的系统，而在NeXTSTEP和OpenStep中它更是基本语言。 第四代(伪)：SQL有人认为SQL是第四代计算机语言，然而更多的人持反对态度：毕竟SQL主要还是用来操作数据库等数据集合，其能实现的功能较之高级语言差之太远。]]></content>
      <categories>
        <category>碎片</category>
      </categories>
      <tags>
        <tag>程序语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM-JDK自带JVM工具]]></title>
    <url>%2F2017%2F11%2F03%2FJVM-JDK%E8%87%AA%E5%B8%A6JVM%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[解决Java程序JVM相关问题时，知识与经验是基础，数据是依据，工具是运用知识与经验处理数据的手段。 JVM相关的数据举例： 运行日志 异常堆栈 GC日志 线程快照(threaddump/javacore) 堆转储快照(heapdump/hprof) 本文所介绍的环境为Windows平台下的JDK1.7.0_80，其bin目录中的内容如下： 这些工具大多只有十几K，之所以能做到如此小巧，是因为它们基本都是对jdk/lib/tools.jar的二次封装，可以对比看一下tools.jar解压后的内容： 命令行工具jps jps(JVM Process Status Tool)类似于Linux的ps命令，用于显示系统中所有的Hotspot VM进程，并显示JVM执行的主类(Main Class，即main()所在的类)及这些JVM进程的本地虚拟机唯一ID(Local Virtual Machine Identifier,LVMID)。LVMID是整个JDK监控工具体系的线索，用于作为后续监控工作的查询条件。 对于本地虚拟机进程而言，LVMID与操作系统的进程ID(Process Identifier,PID)是一致的。Windows下利用资源管理器Linux下利用ps均可得到该PID，但此时无法根据JVM执行的主类进行定位。 运行一个测试用的小程序: 123456789public class Test &#123; /** * -Xms20m -Xmx20m -Xmn10m -XX:+PrintGCDetails -XX:+UseSerialGC -XX:MaxTenuringThreshold=15 */ public static void main(String[] args) &#123; while (true) ; &#125;&#125; 将该程序运行起来后： -q只输出LVMID。 -m输出启动时传递给main()的参数。 -l输出主类的全路径名。若进程执行的是Jar包则输出Jar路径。 -v输出JVM参数 jstat jstat(JVM Statistics Monitoring tool)可用于监控JVM的运行时状态信息。它可以显示本地或远程JVM进程中的类装载，内存，垃圾收集，JIT编译等运行时数据。 123456789public class Test &#123; /** * -Xms20m -Xmx20m -Xmn10m -XX:+PrintGCDetails -XX:+UseSerialGC -XX:MaxTenuringThreshold=15 */ public static void main(String[] args) &#123; while (true) ; &#125;&#125; 6372是LVMID，1000是输出间隔(单位ms)，5是输出次数。 -gcutil：监控堆及方法区的内存使用情况，GC时间等信息。并重点关注已使用空间占总空间百分比。即各内存区域下的数值为已用空间占总空间的百分比。 S0:Survivor0 S1:Survivor1 E:Eden O:old(老年代) P:Permanent(永久代) YGC:Young GC(Minor GC)次数 YGCT:Young GC(Minor GC)耗时。单位为秒。 FGC:Full GC次数 FGCT:Full GC耗时，单位为秒。 GCT:所有GC总耗时，单位为秒。 jinfo jinfo(Configuration Info For Java)可查看JVM参数。jps -v可查看启动时显式指定的JVM参数，而jinfo能查询到包含默认值在内的所有参数。 123456789public class Test &#123; /** * -Xms20m -Xmx20m -Xmn10m -XX:+PrintGCDetails -XX:+UseSerialGC -XX:MaxTenuringThreshold=15 */ public static void main(String[] args) &#123; while (true) ; &#125;&#125; 即老年代与年轻代的比例默认为2:1。 jmap jmap(Memory Map for Java)用于生成堆转储快照(heapdump/dump)。 123456789public class Test &#123; /** * -Xms20m -Xmx20m -Xmn10m -XX:+PrintGCDetails -XX:+UseSerialGC -XX:MaxTenuringThreshold=15 */ public static void main(String[] args) &#123; while (true) ; &#125;&#125; 该命令即在e盘下生成dump文件dumpTest。 jhat 由jmap dump出的堆转储快照无法直接阅读，需使用jhat(JVM Heap Analysis Tool)读取。jhat内置了一个微型的HTTP/HTML服务器用于分析阅读堆转储快照。 分析上小节中jmap产生的dumpTest： 分析内存泄漏问题时主要会用到其中的Show heap histogram，点进去： 该页面可显示进程中所有的同类实例数及总大小。 jstack jstack(Stack Trace for Java)用于生成JVM当前时刻的线程快照(threaddump,javacore)。 12345678910111213141516171819public class Test &#123; public static void main(String[] args) &#123; Thread thread = new Thread() &#123; @Override public void run() &#123; synchronized (Test.class) &#123; try &#123; Test.class.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;; thread.setName(&quot;testThread&quot;); thread.start(); &#125;&#125; 执行： 1./jstack -l 7432 &gt; /e/1.txt 其中7432为LVMID。输出文件1.txt中的内容为： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485862017-11-03 16:35:11Full thread dump Java HotSpot(TM) 64-Bit Server VM (24.80-b11 mixed mode):&quot;DestroyJavaVM&quot; prio=6 tid=0x00000000024ce800 nid=0x1df4 waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE Locked ownable synchronizers: - None&quot;testThread&quot; prio=6 tid=0x000000000c3bc000 nid=0x1d34 in Object.wait() [0x000000000cf7e000] java.lang.Thread.State: WAITING (on object monitor) at java.lang.Object.wait(Native Method) - waiting on &lt;0x00000007d5d9af10&gt; (a java.lang.Class for com.test.Test) at java.lang.Object.wait(Object.java:503) at com.test.Test$1.run(Test.java:11) - locked &lt;0x00000007d5d9af10&gt; (a java.lang.Class for com.test.Test) Locked ownable synchronizers: - None&quot;Service Thread&quot; daemon prio=6 tid=0x000000000acaf800 nid=0x1e8c runnable [0x0000000000000000] java.lang.Thread.State: RUNNABLE Locked ownable synchronizers: - None&quot;C2 CompilerThread1&quot; daemon prio=10 tid=0x000000000acac800 nid=0xcbc waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE Locked ownable synchronizers: - None&quot;C2 CompilerThread0&quot; daemon prio=10 tid=0x000000000acab000 nid=0x1fa4 waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE Locked ownable synchronizers: - None&quot;Attach Listener&quot; daemon prio=10 tid=0x000000000aca8000 nid=0x1df8 waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE Locked ownable synchronizers: - None&quot;Signal Dispatcher&quot; daemon prio=10 tid=0x000000000aca7000 nid=0x1b48 runnable [0x0000000000000000] java.lang.Thread.State: RUNNABLE Locked ownable synchronizers: - None&quot;Finalizer&quot; daemon prio=8 tid=0x000000000ac2f000 nid=0x1b28 in Object.wait() [0x000000000c25e000] java.lang.Thread.State: WAITING (on object monitor) at java.lang.Object.wait(Native Method) - waiting on &lt;0x00000007d5d04858&gt; (a java.lang.ref.ReferenceQueue$Lock) at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:135) - locked &lt;0x00000007d5d04858&gt; (a java.lang.ref.ReferenceQueue$Lock) at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:151) at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:209) Locked ownable synchronizers: - None&quot;Reference Handler&quot; daemon prio=10 tid=0x000000000ac2d800 nid=0x884 in Object.wait() [0x000000000c00e000] java.lang.Thread.State: WAITING (on object monitor) at java.lang.Object.wait(Native Method) - waiting on &lt;0x00000007d5d04470&gt; (a java.lang.ref.Reference$Lock) at java.lang.Object.wait(Object.java:503) at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:133) - locked &lt;0x00000007d5d04470&gt; (a java.lang.ref.Reference$Lock) Locked ownable synchronizers: - None&quot;VM Thread&quot; prio=10 tid=0x000000000ac2a000 nid=0x187c runnable &quot;GC task thread#0 (ParallelGC)&quot; prio=6 tid=0x000000000251d000 nid=0x9b4 runnable &quot;GC task thread#1 (ParallelGC)&quot; prio=6 tid=0x000000000251e800 nid=0x1ffc runnable &quot;GC task thread#2 (ParallelGC)&quot; prio=6 tid=0x0000000002520800 nid=0x1ce4 runnable &quot;GC task thread#3 (ParallelGC)&quot; prio=6 tid=0x0000000002522000 nid=0x1ce8 runnable &quot;VM Periodic Task Thread&quot; prio=10 tid=0x000000000c3b3000 nid=0x1e34 waiting on condition JNI global references: 107 其中： 1234567&quot;testThread&quot; prio=6 tid=0x000000000c3bc000 nid=0x1d34 in Object.wait() [0x000000000cf7e000] java.lang.Thread.State: WAITING (on object monitor) at java.lang.Object.wait(Native Method) - waiting on &lt;0x00000007d5d9af10&gt; (a java.lang.Class for com.test.Test) at java.lang.Object.wait(Object.java:503) at com.test.Test$1.run(Test.java:11) - locked &lt;0x00000007d5d9af10&gt; (a java.lang.Class for com.test.Test) 表明名为testThread的线程wait在了com.test.Test的类对象上。 使用Thread.getAllStackTraces()可通过编程实现jstack的绝大多数功能。例如： 1234567891011121314151617181920212223242526import java.util.Map;public class Test &#123; public static void main(String[] args) throws InterruptedException &#123; Thread thread = new Thread() &#123; @Override public void run() &#123; synchronized (Test.class) &#123; try &#123; Test.class.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;; thread.setName(&quot;testThread&quot;); thread.start(); Thread.sleep(100); // 确保testThread已wait for (Map.Entry&lt;Thread, StackTraceElement[]&gt; stackTrace : Thread.getAllStackTraces().entrySet()) &#123; System.out.println(&quot;=======&quot; + stackTrace.getKey().getId() + &quot;-&quot; + stackTrace.getKey().getName()); for (StackTraceElement element : stackTrace.getValue()) System.out.println(element); &#125; &#125;&#125; 输出如下： 12345678910111213141516171819=======4-Signal Dispatcher=======3-Finalizerjava.lang.Object.wait(Native Method)java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:135)java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:151)java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:209)=======9-testThreadjava.lang.Object.wait(Native Method)java.lang.Object.wait(Object.java:503)com.test.Test$1.run(Test.java:13)=======1-mainjava.lang.Thread.dumpThreads(Native Method)java.lang.Thread.getAllStackTraces(Thread.java:1640)com.test.Test.main(Test.java:23)=======2-Reference Handlerjava.lang.Object.wait(Native Method)java.lang.Object.wait(Object.java:503)java.lang.ref.Reference$ReferenceHandler.run(Reference.java:133)=======5-Attach Listener 可视化工具Jconsole Jconsole(Java Monitoring and Management Console)诞生于JDK1.5。是一种基于JMX(Java Management Extensions，即Java管理扩展)的可视化监视及管理工具。工具位置：jdk/bin/jconsole.exe。 示例代码： 1234567891011121314151617181920public class Test &#123; public static void main(String[] args) &#123; Thread thread = new Thread() &#123; @Override public void run() &#123; synchronized (Test.class) &#123; try &#123; Test.class.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;; thread.setName(&quot;testThread&quot;); thread.start(); while (true) ; &#125;&#125; 再来构造一个死锁的例子： 1234567891011121314151617181920212223242526272829303132333435public class Test &#123; public static void main(String[] args) &#123; Runnable r1 = new Runnable() &#123; @Override public void run() &#123; synchronized (&quot;八云紫&quot;) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (&quot;八云蓝&quot;) &#123; &#125; &#125; &#125; &#125;; Runnable r2 = new Runnable() &#123; @Override public void run() &#123; synchronized (&quot;八云蓝&quot;) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (&quot;八云紫&quot;) &#123; &#125; &#125; &#125; &#125;; new Thread(r1, &quot;r1&quot;).start(); new Thread(r2, &quot;r2&quot;).start(); &#125;&#125; 点击“检测死锁”： 随后多出了一个“死锁”标签。 r1： r2： VisualVM VisualVM(All-in-One Java Troubleshooting Tool)诞生于JDK1.6 Update7。现已成为Sun主力推动的多合一故障处理，性能分析(Profiling)工具，并已从JDK中分离出来成为可以独立发展的开源项目。不需要被监视的程序基于特殊Agent运行，因此它对被监视的程序的实际影响很小。 程序位置为/jdk/bin/jvisualvm.exe。 构建一个死锁的例子： 123456789101112131415161718192021222324252627282930313233343536public class Test &#123; public static void main(String[] args) &#123; Runnable r1 = new Runnable() &#123; @Override public void run() &#123; synchronized (&quot;八云紫&quot;) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (&quot;八云蓝&quot;) &#123; &#125; &#125; &#125; &#125;; Runnable r2 = new Runnable() &#123; @Override public void run() &#123; synchronized (&quot;八云蓝&quot;) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (&quot;八云紫&quot;) &#123; &#125; &#125; &#125; &#125;; new Thread(r1, &quot;r1&quot;).start(); new Thread(r2, &quot;r2&quot;).start(); while (true) ; &#125;&#125; 有两种方式生成堆转储快照： 方法1： 方法2： 生成后： 实例信息需要由类信息点击进入： 生成的堆转储文件会在VisualVM关闭时删除，若欲保存生成的堆转储快照： 装入已存在的快照：]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM-内存分配策略]]></title>
    <url>%2F2017%2F11%2F02%2FJVM-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[JVM的自动内存管理可归结为两部分：自动内存分配及自动内存回收(详见JVM-垃圾收集)。二者互为因果：因为分配了内存才会产生垃圾。而不进行垃圾清理就无法倒出空间用于分配。 从宏观的角度来看，分配和回收的都是对象，分配和回收的区域为堆(暂不考虑JIT优化导致的栈上分配的标量类型)。而主要的分配和回收的战场又可聚焦于Eden：对象生于Eden，绝大多数的对象也死在Eden。少数对象会进入Survivor，更少数的对象会进入老年代。这就是对象分配的基本规则，但是为了提高性能，JVM偶尔也会打破规则。 对象生于Eden这是内存分配的基本规则。当Eden没有空间时会触发一次Minor GC。 示例代码如下： 123456789101112131415public class Test &#123; private static final int _1MB = 1024 * 1024; /** * -Xms20m -Xmx20m -Xmn10m -XX:+PrintGCDetails -XX:+UseSerialGC */ public static void main(String[] args) &#123; byte[] a1, a2, a3, a4; a1 = new byte[2 * Test._1MB]; a2 = new byte[2 * Test._1MB]; a3 = new byte[2 * Test._1MB]; a4 = new byte[4 * Test._1MB]; // 触发Minor GC &#125;&#125; 输出如下： 1234567891011[GC[DefNew: 6816K-&gt;469K(9216K), 0.0055103 secs] 6816K-&gt;6613K(19456K), 0.0055674 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] Heap def new generation total 9216K, used 4893K [0x00000000f9a00000, 0x00000000fa400000, 0x00000000fa400000) eden space 8192K, 54% used [0x00000000f9a00000, 0x00000000f9e51f90, 0x00000000fa200000) from space 1024K, 45% used [0x00000000fa300000, 0x00000000fa375608, 0x00000000fa400000) to space 1024K, 0% used [0x00000000fa200000, 0x00000000fa200000, 0x00000000fa300000) tenured generation total 10240K, used 6144K [0x00000000fa400000, 0x00000000fae00000, 0x00000000fae00000) the space 10240K, 60% used [0x00000000fa400000, 0x00000000faa00030, 0x00000000faa00200, 0x00000000fae00000) compacting perm gen total 21248K, used 2570K [0x00000000fae00000, 0x00000000fc2c0000, 0x0000000100000000) the space 21248K, 12% used [0x00000000fae00000, 0x00000000fb082978, 0x00000000fb082a00, 0x00000000fc2c0000)No shared spaces configured. 日志分析： 发生了一次Minor GC。欲分配a4的空间时的内存区域状况为：Eden使用6816K(a1+a2+a3)，Survivor及老年代均未使用。此时Eden的剩余空间已不足以分配a4所需的4MB空间。因此触发该次Minor GC。因单个Survivor的大小为1MB，不足以容纳a1/a2/a3中的任何一个，因此触发老年代的担保机制，a1,a2,a3均直接进入老年代，新生代大小由6816K减为469K。而因为确实也无法回收什么东西，所以堆总使用空间(6816K-&gt;6613K)几乎没有变化。本次GC后，Eden空出了足以分配a4的空间并将a4分配入其中。 进程结束前的内存使用情况：Eden使用8192*0.54=4424用于存储a4。老年代使用6144K用于存储a1,a2,a3。 大对象直接进入老年代所谓的大对象即是指占用大量内存空间的对象。典型的大对象就是那种很长的字符串或数组。大对象对内存分配而言是灾难：举一个极端的例子，新生代大小为10MB，而程序不断产生大小为15MB的大对象，因为Eden无法分配支撑15MB对象的连续空间(Survivor一般会比Eden小得多，更没可能)，因此这些对象会直接进入老年代。更遭的是，若这些对象又是朝生夕死的，则又需高频度的触发Major GC。因此我们在写程序时应尽可能的避免写大对象，更不要写朝生夕死的大对象。 但也只能是尽量，JVM显然不能规定程序员不能写大对象，也不能在程序员写了大对象后就无法优化。另一个角度来说，到底多大的对象算是大也难于界定。 对于Parallel Scavenge而言，会自动进行优化，无需程序员多操心。而对于Serial及ParNew而言，提供了PretenureSizeThreshold来作为直接晋升老年代对象的大小阀值。即大于该值的对象将直接在老年代分配。该值单位默认为B且无法修改。即设置晋升阀值大小1MB(1024*1024=1048576)为-XX:PretenureSizeThreshold=1048576。设置该值后可避免Eden及Survivor之间发生不必要的大对象复制。 举一个小例子： 123456789101112public class Test &#123; private static final int _1MB = 1024 * 1024; /** * -Xms20m -Xmx20m -Xmn10m -XX:+PrintGCDetails -XX:+UseSerialGC -XX:PretenureSizeThreshold=1048576 * 设定直接晋升老年代的对象大小阀值为1MB */ public static void main(String[] args) &#123; byte[] a = new byte[4 * Test._1MB]; &#125;&#125; 输出如下： 12345678910Heap def new generation total 9216K, used 835K [0x00000000f9a00000, 0x00000000fa400000, 0x00000000fa400000) eden space 8192K, 10% used [0x00000000f9a00000, 0x00000000f9ad0fb8, 0x00000000fa200000) from space 1024K, 0% used [0x00000000fa200000, 0x00000000fa200000, 0x00000000fa300000) to space 1024K, 0% used [0x00000000fa300000, 0x00000000fa300000, 0x00000000fa400000) tenured generation total 10240K, used 4096K [0x00000000fa400000, 0x00000000fae00000, 0x00000000fae00000) the space 10240K, 40% used [0x00000000fa400000, 0x00000000fa800010, 0x00000000fa800200, 0x00000000fae00000) compacting perm gen total 21248K, used 2570K [0x00000000fae00000, 0x00000000fc2c0000, 0x0000000100000000) the space 21248K, 12% used [0x00000000fae00000, 0x00000000fb082920, 0x00000000fb082a00, 0x00000000fc2c0000)No shared spaces configured. 显然，尽管Eden的空间足够，a还是被直接分配进了老年代。 长寿的对象进入老年代按照基本理论，老年代只是一个保人，即只在Eden+一个Survivor的内容无法完全在GC后存入另一个Survivor时才会介入。 为了减少复制量，我们会直接让大对象进入老年代。同理，对于那些长寿的对象，即便Survivor空间足够，我们也没必要反复复制它们：因为挺过越多次GC的对象挺过即将到来的GC的概率越大。 对象初始年龄为0，每经过一次GC则年龄加1。-XX:MaxTenuringThreshold=?用于指定多大年龄的对象有资格晋升入老年代。默认值为15。特别的，若该值设定为0，对象仍需先尝试进入Eden，但在Eden已满时不会进入Survivor而会直接进入老年代。 举个小例子： 12345678910111213public class Test &#123; private static final int _1MB = 1024 * 1024; /** * -Xms20m -Xmx20m -Xmn10m -XX:+PrintGCDetails -XX:+UseSerialGC -XX:MaxTenuringThreshold=0 */ public static void main(String[] args) &#123; byte[] a1 = new byte[Test._1MB / 4]; byte[] a2 = new byte[4 * Test._1MB]; byte[] a3 = new byte[4 * Test._1MB]; // 触发Minor GC &#125;&#125; 输出如下： 1234567891011[GC[DefNew: 5188K-&gt;0K(9216K), 0.0033932 secs] 5188K-&gt;4821K(19456K), 0.0034431 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] Heap def new generation total 9216K, used 4178K [0x00000000f9a00000, 0x00000000fa400000, 0x00000000fa400000) eden space 8192K, 51% used [0x00000000f9a00000, 0x00000000f9e14820, 0x00000000fa200000) from space 1024K, 0% used [0x00000000fa300000, 0x00000000fa300000, 0x00000000fa400000) to space 1024K, 0% used [0x00000000fa200000, 0x00000000fa200000, 0x00000000fa300000) tenured generation total 10240K, used 4821K [0x00000000fa400000, 0x00000000fae00000, 0x00000000fae00000) the space 10240K, 47% used [0x00000000fa400000, 0x00000000fa8b5660, 0x00000000fa8b5800, 0x00000000fae00000) compacting perm gen total 21248K, used 2570K [0x00000000fae00000, 0x00000000fc2c0000, 0x0000000100000000) the space 21248K, 12% used [0x00000000fae00000, 0x00000000fb082960, 0x00000000fb082a00, 0x00000000fc2c0000)No shared spaces configured. 分配a3前的内存分配状态：Eden占用5188K(a1+a2)，Survivor与老年代为空。此时Eden已不足以容纳a3，触发Minor GC。因晋升年龄的阀值为0，因此a1与a2全部进入老年代(即便Survivor可以容纳a1)。 程序退出时的内存分配状况：新生代使用4178K(a3)，Survivor为空，老年代使用4821K(a1+a2)。 对上例稍作修改，让-XX:MaxTenuringThreshold=1，则输出： 1234567891011[GC[DefNew: 5024K-&gt;725K(9216K), 0.0041689 secs] 5024K-&gt;4821K(19456K), 0.0042235 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] Heap def new generation total 9216K, used 5149K [0x00000000f9a00000, 0x00000000fa400000, 0x00000000fa400000) eden space 8192K, 54% used [0x00000000f9a00000, 0x00000000f9e51f90, 0x00000000fa200000) from space 1024K, 70% used [0x00000000fa300000, 0x00000000fa3b5618, 0x00000000fa400000) to space 1024K, 0% used [0x00000000fa200000, 0x00000000fa200000, 0x00000000fa300000) tenured generation total 10240K, used 4096K [0x00000000fa400000, 0x00000000fae00000, 0x00000000fae00000) the space 10240K, 40% used [0x00000000fa400000, 0x00000000fa800010, 0x00000000fa800200, 0x00000000fae00000) compacting perm gen total 21248K, used 2570K [0x00000000fae00000, 0x00000000fc2c0000, 0x0000000100000000) the space 21248K, 12% used [0x00000000fae00000, 0x00000000fb082960, 0x00000000fb082a00, 0x00000000fc2c0000)No shared spaces configured. 显然，a1在GC后进入了Survivor中。 动态对象年龄判定若Survivor中相同年龄的对象大小总和大于单个Survivor大小总空间的一半，则年龄大于等于该值的对象都会晋升入老年代，而不必等待对象的年龄到达MaxTenuringThreshold。 空间分配担保老年代的诞生目的是为年轻代作保，但是却没人为老年代作保，从而可能会导致担保失败(Handle Promotion Failure)。因此在进行内存分配时就有乐观与悲观之别。模拟一个情景：Eden已满，触发一次Minor GC。若当前老年代的可容空间能容纳新生代所有的对象，则老年代这个保人是绝对稳的，无论是乐观或悲观都可以进行GC。但是若无法完全容纳，则对于悲观的策略而言此次Minor GC就有可能失败，将直接转而触发Full GC清理全堆。对于乐观的策略而言，会继续检查老年代最大可用空间是否大于历次Minor GC晋升老年代大小的平均值，若小于，则即便是乐观的策略也无法再乐观下去了：将转而触发一次Full GC。若大于，尽管本次Minor GC有风险，依然会进行Minor GC，若不幸担保失败，则再触发一次Full GC。 开关-XX:+HandlePromotionFailure用于控制这个策略。开启为乐观策略，关闭为悲观策略。 在JDK1.6 Update 24之后，虽然-XX:+HandlePromotionFailure开关依然存在，但已然失效，系统默认为开关打开时的状态。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM-垃圾收集]]></title>
    <url>%2F2017%2F10%2F26%2FJVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[垃圾收集的历史垃圾收集(Garbage Collection, GC)的历史比Java要久远，只是因为近年来Java的高歌猛进让人们产生了一种”GC是Java的产物”的错觉。实际上1960年诞生于MIT的Lisp才是第一门使用内存动态分配及垃圾收集技术的语言。 JVM管理着哪些内存区域？详见JVM-运行时数据区域，包括： 程序计数器(Program Counter Register) 虚拟机栈(Virtual Machine Stack) 本地方法栈(Native Method Stack) 堆(Heap) 方法区(Method Area) 哪些区域需要进行GC？ 程序计数器(Program Counter Register)：线程私有，小到不会抛出内存溢出异常，无需垃圾收集。 虚拟机栈(Virtual Machine Stack)：线程私有，栈中的元素为栈帧，一个栈帧代表线程调用的一个方法。栈帧的大小在编译期就已基本确定(运行期JIT可能会做出一些优化)，方法执行完成栈帧随之销毁，无需垃圾回收。 本地方法栈(Native Method Stack)：同虚拟机栈。 堆(Heap)：线程间共享。特定类型的对象的大小是固定的，然而编译期只能确定静态类型，实际类型要到运行期才能确定，因此对象的大小到运行期才能确定，即需要在运行时动态分配内存，需垃圾收集。 方法区(Method Area)：线程间共享。类的装载及卸载都是在运行期动态进行的，需垃圾收集。 从广义上讲，JVM回收虚拟机栈及本地方法栈的内存也是垃圾收集，只是这部分收集的逻辑简单明了，无需一个复杂的机制来支撑。因此垃圾收集通常是指对运行时动态分配的那部分内存的回收。进而，内存动态分配与垃圾收集往往是成对出现的：内存动态分配迫使垃圾收集的复杂化。 如何判断堆中的哪些对象是垃圾？判断方法有2： 引用计数算法(Reference Counting) 可达性分析算法(Reachability Analysis) 引用计数算法 描述：给每个对象都配备一个引用计数器，每当有一个地方引用它，计数值加1。每当一个引用失效，计数值减1。任何时刻计数值为0的对象就是垃圾。 优点：简单粗暴，判断效率高。 使用案例：微软的COM(Component Object Model)技术，使用ActionScript3的FlashPlayer，Python，在游戏脚本领域被广泛应用的Squirrel。 缺点：难以解决对象间的相互循环引用问题。依对象间的引用关系我们可以将堆中的对象划分为复数张图。当某张图中只有一个点(即没有其他地方引用该对象)，本算法是可以正确判断其为垃圾的，但是若某张图中有复数个点，而这些点全部是垃圾，本算法就很难将这些点均正确判为垃圾。 可达性分析算法 主流的JVM(C#及Lisp等主流商用程序语言也多采用本算法)均采用本算法来判断堆中的垃圾对象。 既然引用计数算法的缺陷在于某张图中有复数个点，且这些点全部为垃圾时难以判断，那么可达性分析算法就人为的设定几个”带头大哥”，告诉JVM没有带头大哥存在的图中的点均为垃圾。即带头大哥不可达的点是垃圾。 这些带头大哥被称为GC Root，GC Root在搜索点时所走过的路径被称为引用链(Reference Chain)。 那么如何筛选带头大哥呢？首要标准自然就是正在被使用着的对象，再次浏览JVM所管理的内存区域： 程序计数器(Program Counter Register)：没有对象引用，不会存在带头大哥。 虚拟机栈(Virtual Machine Stack)：栈帧的本地变量表(执行上下文)中引用的对象为带头大哥。 本地方法栈(Native Method Stack)：JNI(Java Native Interface，即Native方法)引用的对象为带头大哥。 堆(Heap)：欲被回收的区域，无法筛选出带头大哥。 方法区(Method Area)：常量或类静态属性(全局性引用)引用的对象为带头大哥。 例如，如下代码中对象a,b相互持有对方的引用，随后将a，b引用的位置置为空(即中断对象与GC ROOT间的可达性联系)： 12345678910111213141516171819202122public class Test &#123; private Test reference = null; /** * 占据2MB空间。使垃圾收集的效果更为明显 */ private byte[] bigSize = new byte[2 * 1024 * 1024]; /** * -XX:+PrintGCDetails */ public static void main(String[] args) &#123; Test a = new Test(); Test b = new Test(); a.reference = b; b.reference = a; a = null; b = null; System.gc(); &#125;&#125; 运行结果： 1234567891011[GC [PSYoungGen: 5427K-&gt;536K(38400K)] 5427K-&gt;536K(124416K), 0.0090463 secs] [Times: user=0.05 sys=0.00, real=0.01 secs] [Full GC [PSYoungGen: 536K-&gt;0K(38400K)] [ParOldGen: 0K-&gt;468K(86016K)] 536K-&gt;468K(124416K) [PSPermGen: 2563K-&gt;2562K(21504K)], 0.0120810 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] Heap PSYoungGen total 38400K, used 998K [0x00000007d5d00000, 0x00000007d8780000, 0x0000000800000000) eden space 33280K, 3% used [0x00000007d5d00000,0x00000007d5df9a60,0x00000007d7d80000) from space 5120K, 0% used [0x00000007d7d80000,0x00000007d7d80000,0x00000007d8280000) to space 5120K, 0% used [0x00000007d8280000,0x00000007d8280000,0x00000007d8780000) ParOldGen total 86016K, used 468K [0x0000000781800000, 0x0000000786c00000, 0x00000007d5d00000) object space 86016K, 0% used [0x0000000781800000,0x0000000781875228,0x0000000786c00000) PSPermGen total 21504K, used 2569K [0x000000077c600000, 0x000000077db00000, 0x0000000781800000) object space 21504K, 11% used [0x000000077c600000,0x000000077c8826b8,0x000000077db00000) 很明显，GC前本来是存在于年轻代的大小合计大概是4MB的两个对象已被GC回收。 建立对象间的联系：引用 无论是引用计数算法亦或是可达性分析算法，都以对象为点连接成图。而进行连接的线即为引用。 在JDK1.1时，Java中关于引用的定义传统而又纯粹：若某内存区域中存储的数值代表另一块内存区域的起始地址，则这块内存区域代表着一个引用，其类型为引用类型。这种定义下，从引用关系的角度划分，对象的身份只有两个：引用者及被引用者。我们无法建立更为复杂的引用关系，例如：某些引用关系虽然并非是没有，但是并没有那么重要。即当内存充足时，该引用代表一个正常的引用。当内存吃紧时，该引用可以忽略。 因此，从JDK1.2起，Java将引用的概念扩充为4种，强度从强至弱依次为： 强引用(Strong Reference)：即为JDK1.1中的传统意义上的引用。程序中绝大多数的引用(诸如Object o = new Object())均是强引用。垃圾收集器绝不会收集通过强引用可达GC ROOT的对象。 软引用(Soft Reference)：使用SoftReference类实现。该引用即为前文”例如”所描述的那种引用：当某次垃圾收集后内存依然不够用，会进行第二次垃圾收集，此次收集将无视软引用。 弱引用(Weak Reference)：使用WeakReference类实现。也就是所谓的”消耗性引用”：经过一次垃圾收集后，该引用即失效。 虚引用(Phantom Reference)：使用PhantomReference类实现。又名幽灵引用或幻影引用。该引用并不是一个真正的引用，也无法在可达性计算中发挥任何作用，其存在价值仅仅为对象被回收后能发出一个系统通知。 对象逃避被回收的手段通过可达性分析算法被标记为垃圾的对象仅仅只是被打上了一个垃圾的标记，并没有真正的被回收。在垃圾收集器真正动手之前，该对象还有最后一次死里逃生的机会：若对象重写了finalize()方法且该实例方法并未被调用过，则该对象会被放置到一个叫F-Queue的队列中。JVM会在合适的时机自动创建一个低优先级的Finalizer线程执行F-Queue队列中的方法。为了避免因finalize()方法执行得过慢甚至于死循环导致F-Queue中后续的方法无法执行甚至内存回收系统的崩溃，JVM并不承诺一定会等待finalize()方法执行完成，一旦超过其容忍限度JVM会强制终止方法的运行。 之所以说finalize()是对象最后一次死里逃生的机会，是因为对象可以在其finalize()方法中重新与GC ROOT建立可达性关系。垃圾收集器会对F-Queue中已执行完finalize()的对象重新进行可达性标记，若此时对象成功的与GC ROOT建立了可达性联系，则可逃脱被回收的命运。 因为每个对象的finalize()方法最多只会被JVM调用一次，因此这种自救机会最多也只有一次。 下面是一个被标记为垃圾的对象自救的小例子： 12345678910111213141516171819202122232425262728293031323334353637public class Test &#123; /** * 垃圾对象与GC ROOT之间重新建立可达性联系的救命稻草 */ private static Test STRAW; @Override protected void finalize() throws Throwable &#123; super.finalize(); System.out.println(&quot;finalize() 被调用&quot;); Test.STRAW = this; &#125; public static void main(String[] args) throws InterruptedException &#123; Test.STRAW = new Test(); Test.STRAW = null; System.gc(); Thread.sleep(500); // 确保finalize()执行完成 if (null == Test.STRAW) &#123; System.out.println(&quot;垃圾对象被回收&quot;); &#125; else &#123; System.out.println(&quot;垃圾对象未被回收&quot;); &#125; // 完全相同的代码。但test无法再次通过finalize()自救了 Test.STRAW = null; System.gc(); Thread.sleep(500); if (null == Test.STRAW) &#123; System.out.println(&quot;垃圾对象被回收&quot;); &#125; else &#123; System.out.println(&quot;垃圾对象未被回收&quot;); &#125; &#125;&#125; 输出： 123finalize() 被调用垃圾对象未被回收垃圾对象被回收 值得特别说明的是，虽然上例中使用finalize()方法进行自救弥漫着悲壮的艺术色彩，但是却并不推荐大家在程序中使用finalize()方法。最好能在写代码时忘记这个方法。finalize()方法是Java在诞生之初为了照顾C/C++程序员而做出的妥协(人之常情，不是自己所习惯的就会下意识的认为是不对的)，它其实是没必要存在的，运行代价高昂且结果具有不确定性，使用try-finally可以做得更好。 如何判断方法区中哪些数据是垃圾？JVM规范中并没有明确指明方法区的实现方式及是否需要进行垃圾收集。本文讨论的方法区为HotSpot VM在JDK1.7及此前的版本：方法区是以永久代的方式实现的，会进行垃圾收集。 在方法区中进行垃圾收集的性价比通常较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集通常可以回收70%~95%的空间，而永久代的垃圾收集效率远低于此。 永久代的垃圾收集主要回收两部分内容： 废弃常量。类似于回收堆中的对象。以JDK1.6的字符串常量为例(此时字符串常量池尚在方法区中，它是在JDK1.7时被移至堆中的)，假设当前字符串常量池中有字符串”八云紫”，但是此时系统中已没有任何一个String型的变量引用该常量值。如果发生内存回收，且有必要的话，该常量值即会被从字符串常量池中清除。其他的符号引用类似。 无用的类。同时满足如下3个条件可称之为”无用的类”：1.堆中不存在该类的实例。2.加载该类的ClassLoader已被回收。3.该类对应的Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。注意即便同时满足这3个条件也仅仅只是被标记为了无用的类。并非必然会因此被清理。类的回收条件较之堆中的对象及方法区中的常量要苛刻得多。 垃圾收集算法标记-清除算法 标记-清除(Mark-Sweep)算法是最基础的垃圾收集算法。如其名称所示，算法分为标记及清除两步： 标记。扫描所有可能存在垃圾的区域(即上文所总结出的堆及方法区)并标记出其中的垃圾。 清除。待标记完成后，统一回收垃圾。 如下图所示： 其不足主要体现为两点： 效率低下：每次垃圾回收都需要扫描所有可能产生垃圾的内存区域，且清理时需要跳跃式的一小块一小块的清理。 会产生内存碎片。 复制算法 以堆为例，复制(Copying)算法：将堆分为了相等的两块(不妨命名为区域1及区域2)。每次只使用其中的一块。 不妨模拟一种情境：区域1正在使用，区域2闲置。当区域1装满后: 标记区域1中的垃圾。 将区域1中仍存活的对象复制到区域2。 将区域1清空。 进行完上述3步后，区域1及区域2的功能发生了交换：区域2变为了正在使用的区域，区域1闲置。并一直循环下去。 较之标记清除算法，复制算法的改进为： 效率有所提升，清理时直接将某一区域清空即可，简单高效。 不会产生内存碎片：复制后的对象仍然是紧密相邻的。 但是复制算法的缺点也是致命的：可用内存缩小为了原来的一半。 改进的复制算法 IBM公司的研究表明，正常的应用中98%的对象都是朝生夕死，即出生后基本连一次垃圾收集都挺不住。因此其实在复制算法中，闲置的区域通常并不需要一半那么大(这其实是最坏情况，某区域满了且进行垃圾收集后什么都没清理掉)，每次清理后通常只有极为少量的对象能幸存下来。 基于此，可对复制算法的内存划分做出调整，整体上划分为如下两个区域： Eden区。语源为圣经中的伊甸园，即对象诞生的地方。 Survivor区。幸存者区，即挺过至少一次垃圾收集后的幸存对象所处的区域。其承担了复制算法原有的复制功能，因此又将其分为相等的两块(不妨仍以区域1及区域2命名)。每次仅使用其中一块。 结合上文IBM公司的研究结果，显然，Eden要远大于Survivor才合理。HotSpot VM中Eden与Survivor的默认比例为8:2。而Survivor又要分为均等的两份，因此堆被划分为了8:1:1 3小份。 举一个具体的例子：初始时堆中为空。而后新创建的对象被加入Eden。当Eden被装满后，触发垃圾收集，将Eden中经过本次垃圾收集后依然存活的对象加入Survivor的区域1。而后清空Eden。这样新创建的对象又可以进入Eden，当Eden第二次装满后将再次触发垃圾收集，此时的收集区域为Eden及Survivor的区域1，而后将这两个区域中经过本次垃圾收集依然存活的对象加入Survivor的区域2。而后清空Eden及Survivor的区域1。此时Survivor的区域1及区域2的功能发生了互换，随后重复这个步骤。 改进的复制算法极大的弥补了普通的复制算法的缺陷：浪费的内存从50%下降为了10%，通常来说这已经是一个可接受的值了。 但是改进是有前提的：即90%的内存空间在经过垃圾收集后所幸存的对象应能被10%的内存空间所容纳。根据IBM公司的研究，通常情况下这是没问题的。但是若不是通常情况呢？此时明明尚有大量的内存空间(90%的区域)，却无法创建新的对象了。 举个现实中的例子，一个信誉良好的人是可以凭其信誉向银行贷款的，因为通常情况下该人具备还款能力。但如果不是通常情况呢？银行为了减少损失，往往需要贷款人提供担保，要么是担保人，要么是抵押物。总之就是在贷款人无法还款时担保应顶上。 JVM采取的也是类似的机制，名为分配担保(Handle Promotion)。因此此前我们说到的8:1:1的这块空间的内部结构不变，但不再占据所有的堆空间了，而将其统一命名为新生代(young generation)。相对的，它的保人被称为老年代(old/tenured generation)，Minor GC后将按优先顺序(主要是依据年龄)把Survivor无法容纳的对象移入老年代。 HotSpot VM在默认情况下新生代与老年代的比例为1:2(因为保人的实力自然应该雄厚一些)。 除了保人制度外，引入新生代与老年代的划分还可将垃圾收集进行细化，即分代收集(Generational Collection)。从概率论的角度来说，两个对象o1及o2，o1经过了m次垃圾收集依然幸存，而o2经过了n次垃圾收集依然幸存。若有m大于n，即在下一次垃圾收集到来时，o1依然存活的概率应比o2大，其大的幅度将与m大于n的幅度成正相关。 举一个实际的例子，文学作品中的妖怪往往是越长寿的越强力。这种描述其实颠倒了因果关系：不是因为长寿导致了强力，而是因为足够强力的妖怪才不容易死，长寿的可能才更大。所以实际上强力才是因，而长寿为果。 类比到垃圾收集机制中，若将对象看作上例中的”妖怪”，每经过一次垃圾收集看作涨了一岁(其实更像是在渡劫)，那么很显然若有两个对象，其一很长寿，其二刚诞生，那么在下一次垃圾收集到来时，自然是已经很长寿的对象活下去的概率更大。 因此，从效果最大化的角度来看(即每次垃圾收集时可收集的内存占扫描总内存的比例应尽可能的高)。对于新生代中对象的收集应频繁一些，这被称为Minor GC。而对老年代中的长寿对象的收集的频率应低一些，这被称为Major GC。 还有一个名词名为Full GC。指得是清理整个堆空间—包括年轻代和老年代。但Major GC之前往往(注意仅是往往，Parallel架构的收集器就有直接只进行Major GC的策略)都会进行至少一次的Minor GC，因此通常二者是相连的，所以多数情况下我们会将Full GC与Major GC视为同一个概念。 除了堆区外，Full GC还会顺带收集方法区。 模拟一个情境。Eden已满，触发Minor GC，幸存的对象超过了Survivor一个区的容纳能力，则按长者优先的原则将无法容纳的对象加入老年代。若此时老年代也已满，则触发Major GC回收老年代的空间。 除了Survivor无法容纳以外，对象还可以其他方式进入老年代： 足够长寿了。即使Survivor空间足够，反复试图收集那些足够长寿的对象也是在浪费时间。倒不如直接将它们移入老年代。HotSpot VM进入老年代的默认年龄为15岁。 大对象。Survivor毕竟是一块较小的内存，因此占用内存空间巨大的大对象并不会进入Survivor，而是直接进入老年代。 标记-整理算法 改进的复制算法采用老年代作为保人，其内存空间不足时会触发Major GC回收老年代的空间。那么具体的回收算法是什么呢？当然不能再是改进的复制算法了，因为采用该算法的话就要再整出个老老年代来作为老年代的保人，系统将变得更为复杂，且这种复杂是不值得的：老年代的回收频率本就不高。但是采用普通的复制算法其缺陷又过于明显：浪费了一半的空间不说，老年代的回收效率不高导致每次都需要复制大量的对象。 因此老年代可采用标记-清除算法，为避免其缺陷基于其又改进出了标记-整理(Mark-Compact)算法。其中标记与标记-清除算法相同。随后的整理则会将所有的存活对象向一端移动。而后清理掉后端边界以外的内存。这样便避免了内存碎片问题。 Stop The World所谓Stop The World(下文简称STW)即是指垃圾收集过程中停顿所有的除垃圾收集线程以外的一切线程：正如其字面意思所述，整个世界都静止了，只有垃圾收集线程在活动。 STW是必要的，因为垃圾收集器在分析垃圾时必须要在一个能保证一致性的快照中进行：这个快照中对象的引用关系不能在分析的过程中发生变化，否则分析结果的准确性就无从保证。 但STW的缺陷又是致命的。用户程序将会被强制的中断以等待垃圾收集的完成，在响应时间要求较高的场景里有时这种停顿是不可接受的。 为此，垃圾收集器的一个重要使命就是尽量的减少STW对用户程序的干扰，但是直至现在，所有的垃圾收集器(无论是新生代的，老年代的，抑或是不分代的)都无法完全消除STW，即便是号称几乎不会发生停顿的CMS也仅仅只能说是”几乎”，其在用可达性分析算法枚举根节点时也必须STW。 oopMap 既然无法避免STW，那么只能让这个时间尽可能的短。而缩短这一时间的有效手段之一就是尽可能的减小搜索范围。这也是JVM采用准确式GC的原因。所谓准确式GC即是指垃圾收集器可以明确知道某块内存区域中到底是引用还是实际值。这样在枚举根节点时就可以不用搜索非引用的内存区域。 准确式GC依托于准确式内存管理(Exact Memory Management)。所谓准确式内存管理即是指JVM可以明确知道某内存空间存储的数据的类型是什么。例如可明确知道123456究竟是代表一个整数值还是一个引用的地址值。 HotSpot使用oopMap这个数据结构来实现准确式内存管理的功能。oopMap中存储了执行到某条指令时内存中各变量的类型。 安全点 为每一条指令都生成一个oopMap是最简单的方法：这样仅从枚举根节点的角度来看，线程就可以断在任意一条指令上。但是需要生成大量的oopMap，占用大量的额外空间。 因此，HotSpot VM只会为特定的指令生成oopMap，这些指令所处的位置被称为安全点(Safepoint)。当程序需要进行垃圾收集时，非垃圾收集线程只能在安全点上停顿(因为只能在安全点上枚举根节点。严格来说，不包括正在执行native代码的用户线程，因为native代码一般不会改变Java对象间的引用关系，因此没有必要特意挂起它们。只要保证在GC的过程中不让它们从native方法中离开即可。若需要读取oopMap从上一个安全点处读取即可)。 关于安全点的设置需要满足一个平衡：既不能因设置得过多而占用过大的额外内存，也不能因设置得过少而导致GC线程等待过久。选取的要点为两个安全点之间为一个相对完整的小模块，即： 循环的末尾 方法临返回前或调用方法的call指令后 可能抛异常的位置 为确保STW发生时非垃圾收集线程都在安全点上，可采取的策略有两种： 抢先式中断(Preemptive Suspension)。中断所有非垃圾收集线程，若发现某个线程未中断在安全点上则恢复线程，让其跑到安全点上后再次中断。 主动式中断(Voluntary Suspension)：欲STW时将中断标志设为true。各非垃圾收集线程在运行时会主动去轮询这个标志。当发现其为true后即中断自身。轮询的位置为创建对象分配内存时及各安全点处。 HotSpot VM采用主动式中断(现在几乎已经没有JVM采用抢先式中断了)。 安全区域 使用安全点进入STW有一个前提条件：即非垃圾收集线程是能”跑”的(已获得CPU的)，若设置了中断标志后线程正处于Sleep,wait,block等状态，那么它就不能跑到最近的安全点上，让GC等待其获得CPU显然是不合理的。 为此引入了安全区域(Safe Region)。安全区域是指这样的一段代码：在该段代码内部，引用关系不会发生变化(因此，调用native方法的过程也会被定义为安全区域)。即只要线程没有离开安全区域，在其内部任意位置开始GC都是安全的。安全区域可以视为安全点的扩展。 当线程进入安全区域时，会为自身打上已经入安全区域的标志。这样GC就不必在意在安全区域中的线程了，也无须强制要求其中断。只是，当线程欲离开安全区域时，必须查看系统是否正处于STW中，若正处于STW中，则必须等待系统退出STW才能向下运行。 垃圾收集器垃圾收集器是对上文所讨论的垃圾收集算法的具体实现。JVM规范中并未对垃圾收集器的实现细节做任何规定，因此各厂商的各代JVM之间的垃圾收集器均有较大的差异。本文讨论的垃圾收集器是JDK1.7中HotSpot VM所实现的垃圾收集器。其提供了多个垃圾收集器供使用者依需求组合使用，如下图所示： 图中两个垃圾收集器间若存在连线则证明可以组合使用。 顺带一提，JDK1.7，JDK1.8及JDK1.9中的默认垃圾收集器分别为： JDK1.7 : Parallel Scavenge + Parallel Old JDK1.8 : Parallel Scavenge + Parallel Old JDK1.9 : G1 Serial 最基本，发展历史最为悠久的新生代收集器。在JDK1.3.1之前，是唯一的新生代收集器。 如其名”连续的”所示，这是一个单线程收集器。整个GC过程将仅使用一个线程完成，采用的算法为改进的复制算法，在整个GC期间都需要STW。 Serial的缺点很明显：单线程无法利用多CPU的并发计算能力，全程STW，停顿时间过长。但是在JDK1.7中其依然是Clinet模式下的默认新生代垃圾收集器。原因就在于在单线程的环境下其实现简单高效，且在用户的桌面应用场景中，分配给JVM的内存通常不会太大，其中新生代通常也就在几十兆到几百兆之间，使用Serial收集器的停顿时间基本都能控制在几十毫秒至多两百毫秒之内，这个停顿时间通常都是可接受的。 ParNew收集器 ParNew即为Parallel New，是Serial的多线程版本。除了使用多线程完成GC过程以外，其余部分可认为与Serial一样(实际上二者确实也共用了相当多的代码)，采用的算法为改进的复制算法，GC依然全程STW。 在单CPU环境中ParNew往往是不如Serial的，而在并发环境中，ParNew较之Serial会有所提升，这与所有串行代码及其被改造为的并行代码的比较结论相同。默认情况下，ParNew开启的线程数与系统可用的CPU数相等。 由上文的收集器关系图可知，老年代收集器CMS只能与Serial或ParNew配合使用，所以在并发环境下，如果老年代选择CMS，则新生代的最优选择只能为ParNew。事实上，使用-XX:+UseConcMarkSweepGC指定CMS为老年代收集器后，新生代收集器自动的就会被指定为ParNew。 Parallel Scavenge Parallel Scavenge(并发清理，下文简称为PS)如其名所示，是一个多线程的新生代收集器。其与其他的所有垃圾收集器的目标均不相同。 大多数的垃圾收集器的目标在于降低STW的停顿时间，或者具体来说，减少用户在使用时的卡顿感。而PS的目标在于提高系统的吞吐量，因此PS收集器又名吞吐量优先收集器。 所谓吞吐量(Throughput)即是指CPU运行用户代码的时间与CPU消耗的总时间的比值，其概念类似于内燃机中的有效功率。 举个例子，假设在100秒内有两种系统运行状况： 系统停顿了1次用于GC，这1次停了10秒。其余时间都在运行用户程序，则这100秒的吞吐量为0.9。 系统停顿了200次用于GC，每次0.1秒，合计停顿了20秒。其余时间都在运行用户程序，则这100秒内的吞吐量为0.8。 以停顿时间为优化目标的收集器会认为情况2更优。而以吞吐量为优化目标的收集器会认为情况1更优。 PS提供了-XX:MaxGCPauseMillis参数来设置最大的单次停顿时间。这是一个大于0的整数值，代表最大的停顿毫秒值。JVM将尽量保证单次GC时间不超过该值。这里的注意点有2： 注意这仅仅是尽量。 如上例所示，减少停顿往往是以牺牲吞吐量为代价的。另外可行的策略还有减小新生代的大小(需扫描的总空间小了收集自然快了)。 PS提供了-XX:GCTimeRatio参数用以精确控制吞吐量。该值是一个取值范围在(0,100)之间的整数。GC收集时间默认为1，非GC时间为该参数值。即若该值=2，则GC最多占总时间的1/3。默认该值为99，即GC最多占总时间的1/100。 PS提供了GC自适应的调节策略(GC Ergonomics)。用开关参数-XX:+UseAdaptiveSizePolicy开启。开启该参数后，只需要指定基本的参数(例如最大堆-Xmx)即可。其他小区域上的参数，例如新生代的大小-Xmn，新生代中Eden与一个Survivor的比例-XX:SurvivorRatio，晋升老年代的对象大小-XX:PretenureSizeThreshold等均无需手动设置，JVM会根据系统当前的运行情况做出动态的调整。 Serial Old 与Serial所配对的单线程的，基于标记-整理算法的老年代收集器。 类似于Serial的原因，Serial Old主要在Client模式下使用。 而在Server模式下，其用途主要有以下两点： 在JDK1.5及此前的版本，与PS配合使用(可以这样想，PS NTR 了Serial)：与PS所配对的老年代收集器Parallel Old诞生于JDK1.6。换言之，在JDK1.5及此前的版本，PS并没有与之配对的老年代收集器。此时PS使用其自带的PS MarkSweep(MSC)进行老年代垃圾的收集。该收集器与Serial Old的实现非常接近，因此在官方的资料中往往也会以Serial Old来代指PS MarkSweep。 使用CMS作为老年代收集器时，若其在并发收集的过程中发生了Concurrent Mode Failure，则Serial Old会作为后备收集器被使用。 Parallel Old 与PS所配对的多线程的，基于标记-整理算法的，诞生于JDK1.6的老年代收集器。 在Parallel Old诞生之前，PS只能与Serial Old(PS MarkSweep)配合使用，这就导致了很尴尬的局面：新生代以多线程收集，老年代以单线程收集。单线程环境中PS收集器拖累了Serial Old，而并发环境中Serial Old又拖累了PS。而且PS以吞吐量为优化目标，Serial Old以缩短STW为优化目标，二者的追求也不同。换句话说，NTR虽然很爽，但终究不伦不类，没有原配和谐：PS+Serial Old在单线程环境中不如Serial+Serial Old，在并发环境中不如ParNew+CMS。 PS+Parallel Old是吞吐量优先的程序的最优选择。 Concurrent Mark Sweep Concurrent Mark Sweep(后文简称为CMS)是一种多线程的老年代收集器。 CMS基于标记-清除算法，为了最大限度的减少STW的时间，其将”标记”与”清除”又细化为如下4步。核心思想就是能并发着做的就尽量并发着做。 初始标记(CMS initial mark)：必须STW，只标记GC ROOT能直接关联的对象，相当于稍微扩大一下搜索的范围，因此该步速度很快。 并发标记(CMS concurrent mark)：无需STW。根据可达性分析算法从GC ROOT开始完成对象的标记，在此期间用户程序可正常运行。 重新标记(CMS remark)：必须STW。对并发标记过程中因用户线程活动导致的标记错误进行修正。很显然，这是一种乐观的加锁思维。若用户线程在并发标记阶段对标记的影响很小，那么重新标记很快就可完成。反之重新标记就可能会花费很长的时间。 并发清除(CMS concurrent sweep)：无需STW。在此期间用户程序可正常运行。 除非特别的不幸，否则可并行的时间(并发标记+并发清除)是远大于必须STW的时间的。因此总体来说，STW对用户程序的影响下降到了一个非常低的程度，故而CMS又被称为并发低停顿收集器(Concurrent Low Pause Collector)。目前很大一部分的Java应用集中在互联网站或B/S架构的Server端上，这类程序对服务响应时间非常敏感，因此对它们而言CMS是非常友好的。 当然，为了”减少STW”这一优化目标，CMS也付出了不小的代价： 虽然CMS会保证用户程序在GC期间尽可能的始终处于运行状态，但是终究无法运行得那么舒服：毕竟还要分出CPU资源来执行GC。默认情况下CMS创建的用于GC的线程数为(CPU数+3)/4的下取整。即若是在单CPU环境下用户依然相当于被完全的STW了，而在CPU较少时，例如只有2个，此时GC和用户程序各占用一个CPU，用户程序能利用的CPU资源直接减半。曾产生过这样的解决方案：增量式并发收集器(Incremental Concurrent Mark Sweep，简称为i-CMS)。类似于操作系统使用时间片轮转等抢占式机制在单CPU中模拟多任务环境，在并发标记及并发清除时垃圾收集线程无法完全独占CPU，从而尽量提高用户程序所能掌控的CPU资源。但是效果却不太理想：该机制延长了垃圾收集时间，例如独占一个CPU的情况下并发GC操作需要1毫秒，若采用交替执行的方式平均分配CPU，并发GC操作所需的时间并非2毫秒，而是一个更大的值：因为线程的切换与恢复也需耗费CPU时间。因此JDK1.7中，i-CMS已被标记为deprecated，即不推荐开发人员使用。 无法处理浮动垃圾(Floating Garbage)。并发运行期间用户程序仍然可能产生新的垃圾，若重新标记动作已过，CMS就无法在本次GC中收集这部分垃圾而只能推迟至下一次。这一部分垃圾就被称为浮动垃圾。 垃圾收集动作提前。因为GC过程中用户程序尚在运行，那么在没有发生STW的并发运行期间CMS就必须为用户线程预留出足够的内存。其他老年代收集器可在老年代将满时才触发GC，而CMS必须将GC动作提前。JDK1.5中CMS在老年代使用68%时即触发GC，而到了JDK1.6中这个值已提升为92%。可通过-XX:CMSInitiatingOccupancyFraction参数手动设置该值。 可能出现Concurrent Mode Failure。CMS收集GC的阀值设置得过低会导致垃圾收集过于频繁，设置得过高又容易导致用户线程在GC期间的内存不足。无论该值设置为多大都只是一个经验值，且只要不是0，就无法完全确保用户线程的内存供应：即发生Concurrent Mode Failure。此时CMS将启动备用方案：对于本次GC而言，后续垃圾的收集将由Serial Old完成。显然，这是一个乐观锁的并发控制策略：先依经验设置一个GC阀值，而后乐观的认为不会或只会导致很少的Concurrent Mode Failure。若符合预期则性能不会受到太大的影响。若不符合预期性能会大幅下降。 CMS采用的算法为标记-清除。这意味着CMS会产生内存碎片。为解决(或者说是缓解)这个问题，CMS提供了开关参数-XX:+UseCMSCompactAtFullCollection用于在因内存碎片而不得不产生新一次的Full GC之前允许进行压缩，默认该开关是打开的。CMS还提供了另一个参数-XX:CMSFullGCsBeforeCompaction用于控制压缩频率，这是一个自然数值，即每隔多少次不压缩的GC之后跟着一次压缩的GC。默认值为0，即每次GC后都需进行压缩。这样就完全避免了内存碎片问题，但每次GC的运行时间也不得不增长。 Garbage-First Garbage-First(后文简称G1)管理下的堆的内存结构与其他垃圾收集器均有较大的差异，虽然逻辑上依然有新生代和老年代的概念，但是这两个区域不再在物理上隔离。在物理上，G1将堆划分为了多个大小相等的独立区域(Region)，新生代和老年代实际上是由一个个不连续的Region拼接而成的逻辑概念。因此，和其他所有的垃圾收集器都不同，G1可以收集整个堆的垃圾，而不仅仅是只有新生代或老年代。 G1是一款面向服务端应用的垃圾收集器。JDK1.6 6u14提供了G1的Early Access版本供开发人员体验，G1的这种Experimental状态持续了数年的时间直至JDK1.7 7u4才移除变为商用正式版。Sun期望其在未来能取代JDK1.5时诞生的CMS(Sun的继任者Oracle完成了这一点，JDK1.9的默认垃圾收集器已经变为了G1)。 G1的核心特点如下： G1以和CMS类似的策略实现了与CMS类似的缩短STW的功能。所不同的是CMS只能在老年代降低停顿，而G1将这个福利扩展为全堆。 G1在逻辑上依然分为新生代及老年代，且对新生代及老年代中的对象有不同的收集策略。 从整体上看，G1采用标记-整理算法。从局部来看(两个Region之间)，G1采用标记-复制算法。因此，无论是从整理上还是局部上，G1都不会产生内存碎片。 除了尽可能的降低STW之外，G1还能建立可预测的停顿时间模型：能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在GC上的时间不超过N毫秒。 在物理层面上不区分新生代与老年代并没有增大每次GC所需扫描的内存区域，恰恰相反，G1还采用化整为零的思想大幅减少了每次GC需扫描的内存区域。这也是G1能建立可预测的停顿时间模型的原因。G1根据已获得的统计数据(每次回收获得的空间大小及所需时间等)预估出各Region的回收收益，并将其按回收收益由高至低排序维护一个优先列表。根据用户指定的停顿时间，选择出回收收益最大的区域组合(这也是Garbage-First这一名称的由来)。 G1之外的收集器在物理上将堆划分为了彼此隔离的新生代及老年代，表面上来说各收集器仅仅只需要扫描自己负责的区域即可。但是实现上却并非能这么简单：若新生代的某对象是通过老年代的某对象而被加入GC ROOT的引用链，那么起码必须要扫描到老年代中的那个对象才能保证标记的准确。而G1的矛盾则更为突出，因为其将堆在物理上划分为了远多于两个的Region，将需扫描的区域限定在一个Region之内更为困难。所有收集器都使用一个名为Remembered Set的数据结构来避免不必要的扫描。每个物理上隔离的区域都维护一份属于自身的Remembered Set。每当对对象的引用类型字段进行写操作时，都会产生一个Write Barrier暂时中断写操作，检查引用实际所引用的对象是否处于物理隔离的不同区域，若是，则将相关引用信息加入到被引用对象所在区域的Remembered Set中。当对某一区域进行垃圾收集时，将其他区域Remembered Set中被本区域对象引用的对象也设置为本次GC的GC ROOT即可。 类似于CMS，G1分为如下4步： 初始标记(Initial Marking)：必须STW，只标记GC ROOT能直接关联的对象，因此该步速度很快。 并发标记(Concurrent Marking)：无需STW。根据可达性分析算法从GC ROOT开始完成对象的标记，在此期间用户程序可正常运行。 最终标记(Final Marking)：必须STW。对并发标记过程中因用户线程活动导致的标记错误进行修正。很显然，这是一种乐观的加锁思维。若用户线程在并发标记阶段对标记的影响很小，那么重新标记很快就可完成。反之重新标记就可能会花费很长的时间。 筛选回收(Live Data Counting and Evacuation)：根据用户指定的GC停顿时间结合垃圾收集收益优先列表确定回收计划。其实本步是可以不用STW的，但是计划制定后时间本就是可控在用户指定的范围之内了，因此G1会在本步STW以提升垃圾收集效率。 G1转为正式版的时间较短，因此在商业生产环境中的应用并不多，主流依然是使用ParNew+CMS实现替代的功能。 阅读GC日志文件-XX:+PrintGCDetails：显式打印GC日志细节。 不同收集器的GC日志有细节上的差异，但总体来说有一个共性的规范。 以如下的GC日志片段为例： 12[GC [PSYoungGen: 5427K-&gt;536K(38400K)] 5427K-&gt;536K(124416K), 0.0090463 secs] [Times: user=0.05 sys=0.00, real=0.01 secs] [Full GC [PSYoungGen: 536K-&gt;0K(38400K)] [ParOldGen: 0K-&gt;468K(86016K)] 536K-&gt;468K(124416K) [PSPermGen: 2563K-&gt;2562K(21504K)], 0.0120810 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] 开头的[GC及[Full GC表示GC类型。[GC是新生代GC，[Full GC是全内存GC。 随后的[PSYoungGen，[ParOldGen，[PSPermGen等表示本次GC所涵盖的区域。 不管大区域还是小区域，后续的都是：GC前本区域所用空间-&gt;GC后本区域所用空间(本区域总空间)。再随后的是GC耗时，单位为秒。 则仔细分析上述GC日志片段： 1[GC [PSYoungGen: 5427K-&gt;536K(38400K)] 5427K-&gt;536K(124416K), 0.0090463 secs] [Times: user=0.05 sys=0.00, real=0.01 secs] 本行GC代表新生代GC([GC)，新生代使用Parallel Scavenge收集器([PSYoungGen)，该收集器的收集情况为：进行GC前占用内存5427K，GC完成后占用内存536K(新生代总大小38400K)。从整个堆的角度看：进行GC前占用内存5427K，GC完成后占用内存536K(堆总大小124416K)。本次GC耗时0.0090463秒。 [Times: user=0.05 sys=0.00, real=0.01 secs]与Linux的time命令所输出的时间含义一致，即： user:用户态消耗的CPU时间 sys:内核态消耗的CPU时间 real:操作从开始到结束所经过的墙钟时间(Wall Clock Time) CPU时间与墙钟时间的区别在于，CPU时间就是指CPU运算所需的时间。而墙钟时间在此基础上又加入了各种非运算的等待耗时，例如磁盘I/O，线程阻塞等。 如果有多个CPU或CPU为多核的话，CPU时间是指这复数个CPU时间的总和，因此并发环境下CPU时间往往反而会超过墙钟时间。 垃圾收集参数-XX:+UseSerialGC 打开此开关后，将使用Serial+Serial Old的收集器组合进行垃圾收集。这也是Client模式下的默认值。示例代码如下： 123456789101112131415161718public class Test &#123; private static final int _1MB = 1024 * 1024; /** * -Xms20m -Xmx20m -Xmn10m -XX:+PrintGCDetails -XX:+UseSerialGC */ public static void main(String[] args) &#123; byte[] a1, a2, a3, a4,a5,a6,a7; a1 = new byte[2 * Test._1MB]; a2 = new byte[2 * Test._1MB]; a3 = new byte[2 * Test._1MB]; a4 = new byte[2 * Test._1MB]; // 触发Minor GC a5 = new byte[2 * Test._1MB]; a6 = new byte[2 * Test._1MB]; a7 = new byte[2 * Test._1MB]; // 触发Full GC &#125;&#125; 输出如下： 123456789101112[GC[DefNew: 6980K-&gt;469K(9216K), 0.0046578 secs] 6980K-&gt;6613K(19456K), 0.0047158 secs] [Times: user=0.00 sys=0.02, real=0.01 secs] [GC[DefNew: 6787K-&gt;6787K(9216K), 0.0000141 secs][Tenured: 6144K-&gt;8192K(10240K), 0.0048865 secs] 12931K-&gt;12755K(19456K), [Perm : 2563K-&gt;2563K(21248K)], 0.0049309 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] Heap def new generation total 9216K, used 6693K [0x00000000f9a00000, 0x00000000fa400000, 0x00000000fa400000) eden space 8192K, 81% used [0x00000000f9a00000, 0x00000000fa0896d0, 0x00000000fa200000) from space 1024K, 0% used [0x00000000fa300000, 0x00000000fa300000, 0x00000000fa400000) to space 1024K, 0% used [0x00000000fa200000, 0x00000000fa200000, 0x00000000fa300000) tenured generation total 10240K, used 8192K [0x00000000fa400000, 0x00000000fae00000, 0x00000000fae00000) the space 10240K, 80% used [0x00000000fa400000, 0x00000000fac000c8, 0x00000000fac00200, 0x00000000fae00000) compacting perm gen total 21248K, used 2570K [0x00000000fae00000, 0x00000000fc2c0000, 0x0000000100000000) the space 21248K, 12% used [0x00000000fae00000, 0x00000000fb0829c8, 0x00000000fb082a00, 0x00000000fc2c0000)No shared spaces configured. -XX:+UseParNewGC 打开此开关后，将使用ParNew+Serial Old的收集器组合进行垃圾收集。示例代码如下： 123456789101112131415161718public class Test &#123; private static final int _1MB = 1024 * 1024; /** * -Xms20m -Xmx20m -Xmn10m -XX:+PrintGCDetails -XX:+UseParNewGC */ public static void main(String[] args) &#123; byte[] a1, a2, a3, a4,a5,a6,a7; a1 = new byte[2 * Test._1MB]; a2 = new byte[2 * Test._1MB]; a3 = new byte[2 * Test._1MB]; a4 = new byte[2 * Test._1MB]; a5 = new byte[2 * Test._1MB]; a6 = new byte[2 * Test._1MB]; a7 = new byte[2 * Test._1MB]; &#125;&#125; 输出如下： 123456789101112[GC[ParNew: 6980K-&gt;479K(9216K), 0.0039713 secs] 6980K-&gt;6623K(19456K), 0.0040409 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC[ParNew: 6797K-&gt;6797K(9216K), 0.0000098 secs][Tenured: 6144K-&gt;8192K(10240K), 0.0046224 secs] 12941K-&gt;12755K(19456K), [Perm : 2563K-&gt;2563K(21248K)], 0.0046706 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] Heap par new generation total 9216K, used 6693K [0x00000000f9a00000, 0x00000000fa400000, 0x00000000fa400000) eden space 8192K, 81% used [0x00000000f9a00000, 0x00000000fa0896d0, 0x00000000fa200000) from space 1024K, 0% used [0x00000000fa300000, 0x00000000fa300000, 0x00000000fa400000) to space 1024K, 0% used [0x00000000fa200000, 0x00000000fa200000, 0x00000000fa300000) tenured generation total 10240K, used 8192K [0x00000000fa400000, 0x00000000fae00000, 0x00000000fae00000) the space 10240K, 80% used [0x00000000fa400000, 0x00000000fac000c8, 0x00000000fac00200, 0x00000000fae00000) compacting perm gen total 21248K, used 2570K [0x00000000fae00000, 0x00000000fc2c0000, 0x0000000100000000) the space 21248K, 12% used [0x00000000fae00000, 0x00000000fb0829c8, 0x00000000fb082a00, 0x00000000fc2c0000)No shared spaces configured. -XX:+UseConcMarkSweepGC 打开此开关后，将使用ParNew+CMS(Serial Old为发生Concurrent Mode Failure时的后备)的收集器组合进行垃圾收集。示例代码如下： 123456789101112131415161718public class Test &#123; private static final int _1MB = 1024 * 1024; /** * -Xms20m -Xmx20m -Xmn10m -XX:+PrintGCDetails -XX:+UseConcMarkSweepGC */ public static void main(String[] args) &#123; byte[] a1, a2, a3, a4,a5,a6,a7; a1 = new byte[2 * Test._1MB]; a2 = new byte[2 * Test._1MB]; a3 = new byte[2 * Test._1MB]; a4 = new byte[2 * Test._1MB]; a5 = new byte[2 * Test._1MB]; a6 = new byte[2 * Test._1MB]; a7 = new byte[2 * Test._1MB]; &#125;&#125; 输出如下： 12345678910[GC[ParNew: 6816K-&gt;490K(9216K), 0.0031159 secs] 6816K-&gt;6636K(19456K), 0.0032050 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC[ParNew: 6888K-&gt;6888K(9216K), 0.0000282 secs][CMS: 6146K-&gt;8192K(10240K), 0.0080740 secs] 13034K-&gt;12756K(19456K), [CMS Perm : 2564K-&gt;2563K(21248K)], 0.0081410 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] [GC [1 CMS-initial-mark: 8192K(10240K)] 14804K(19456K), 0.0005862 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] Heap par new generation total 9216K, used 6775K [0x00000000f9a00000, 0x00000000fa400000, 0x00000000fa400000) eden space 8192K, 82% used [0x00000000f9a00000, 0x00000000fa09df78, 0x00000000fa200000) from space 1024K, 0% used [0x00000000fa300000, 0x00000000fa300000, 0x00000000fa400000) to space 1024K, 0% used [0x00000000fa200000, 0x00000000fa200000, 0x00000000fa300000) concurrent mark-sweep generation total 10240K, used 8192K [0x00000000fa400000, 0x00000000fae00000, 0x00000000fae00000) concurrent-mark-sweep perm gen total 21248K, used 2570K [0x00000000fae00000, 0x00000000fc2c0000, 0x0000000100000000) -XX:+UseParallelOldGC 打开此开关后，将使用Parallel Scavenge+Parallel Old的收集器组合进行垃圾收集。这也是Server模式(JDK的默认模式)下的默认值。另，-XX:+UseParallelGC文档上说将使用Serial Old收集老年代(估计是文档写得比较早，后来忘记改了)，但是实测该参数与-XX:+UseParallelOldGC效果一致。 示例代码如下： 123456789101112131415161718public class Test &#123; private static final int _1MB = 1024 * 1024; /** * -Xms20m -Xmx20m -Xmn10m -XX:+PrintGCDetails */ public static void main(String[] args) &#123; byte[] a1, a2, a3, a4,a5,a6,a7; a1 = new byte[2 * Test._1MB]; a2 = new byte[2 * Test._1MB]; a3 = new byte[2 * Test._1MB]; a4 = new byte[2 * Test._1MB]; a5 = new byte[2 * Test._1MB]; a6 = new byte[2 * Test._1MB]; a7 = new byte[2 * Test._1MB]; &#125;&#125; 输出如下： 123456789101112[GC [PSYoungGen: 6980K-&gt;600K(9216K)] 6980K-&gt;6744K(19456K), 0.0032780 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC [PSYoungGen: 600K-&gt;0K(9216K)] [ParOldGen: 6144K-&gt;6612K(10240K)] 6744K-&gt;6612K(19456K) [PSPermGen: 2563K-&gt;2562K(21504K)], 0.0113665 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] [Full GC [PSYoungGen: 6317K-&gt;4096K(9216K)] [ParOldGen: 6612K-&gt;8659K(10240K)] 12929K-&gt;12755K(19456K) [PSPermGen: 2562K-&gt;2562K(21504K)], 0.0070159 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] Heap PSYoungGen total 9216K, used 6226K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000) eden space 8192K, 76% used [0x00000000ff600000,0x00000000ffc148c8,0x00000000ffe00000) from space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000) to space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000) ParOldGen total 10240K, used 8659K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000) object space 10240K, 84% used [0x00000000fec00000,0x00000000ff474ed0,0x00000000ff600000) PSPermGen total 21504K, used 2569K [0x00000000f9a00000, 0x00000000faf00000, 0x00000000fec00000) object space 21504K, 11% used [0x00000000f9a00000,0x00000000f9c82640,0x00000000faf00000) -XX:SurvivorRatio=? Eden与Survivor的一个区的比值。默认值为8。 -XX:+PrintGCDetails 打印如下信息至控制台： 发生GC时打印GC日志。 进程退出时打印当前内存各区域的分配情况。 显式调用GC1System.gc(); 或 1Runtime.getRuntime().gc(); 显式调用GC只是建议而非命令，因此JVM可能会屏蔽掉显式垃圾回收调用，因此并非调用了就一定会有效。 不推荐采用显式调用的方式进行垃圾回收，推荐将垃圾回收完全托管给JVM。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM-堆中对象的创建及布局]]></title>
    <url>%2F2017%2F10%2F18%2FJVM-%E5%A0%86%E4%B8%AD%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E5%8F%8A%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[注意： 本文描述的是HotSpot实现下的情况。 对象指的是普通的实例对象，不包括类对象及数组对象。 对象的创建可以模拟一个实际场景： 1Ob o = new Ob(); 这行代码在JVM中实际的执行步骤如下： 1.确保用于生成实例的模版已准备好 检查Ob是否能在方法区的运行时常量池中定位到一个类的符号引用，并检查这个符号引用所代表的类是否已完成了加载，解析，初始化。若没有，则完成。 2.JVM为实例分配内存 某类的实例所需的内存大小在类加载完成后便已完全确定，因此对于同一个类的不同实例，JVM所分配的内存空间都是完全相同的。 有如下两种划分方式： 指针碰撞(Bump the Pointer)：若堆中已用内存及空闲内存的划分是规整的，即我们可以设置一个指针作为分界线，在指针的一边的内存空间全部为已用空间，另一边的空间则全部为空闲空间。那么只要将指针向空闲空间那边移动相应空间的距离即可完成内存分配。 空闲列表(Free List)：若堆中已用内存及空闲内存的划分不是规整的，那么JVM就需要维护一张空闲列表，每次需要分配新的内存空间时，就从空闲列表中找到一份足够大的空间，分配后再更新这个列表。 而堆是否规整主要由垃圾收集器是否有压缩整理的功能而决定。因此使用Serial及ParNew等带有压缩整理的垃圾收集器时采用指针碰撞。使用CMS这种基于Mark-Sweep算法的垃圾收集器时则采用空闲列表。 分配内存空间时还应关注线程安全问题：例如采用指针碰撞时，线程1为对象a申请内存空间，指针还没来得及移动，线程2又为对象b申请了内存空间。解决策略主要有二： 采用CAS配上失败重试的方式保证内存分配的原子性。 为每个线程在堆中分配一小块内存，称为本地线程分配缓冲(Thread Local Allocation Buffer, TLAB)。只有当分配给某线程的堆空间不足需要扩展时才会进行同步控制。虚拟机 开启/关闭 TLAB可通过 -XX:+/-UseTLAB 参数设置。 3.初始化内存空间 除对象头外，JVM会将分配出去的内存空间都初始化为零值。该操作也是对象的实例成员变量未在代码中显式初始化也能直接使用的原因(当然，读到的结果为对应类型的零值)。相对的，方法中的局部变量就没有这个初始化的操作，因此必须显式声明，否则无法通过编译。 4.初始化对象头 对象头(Object Header)相当于该对象的描述信息，例如： 这个对象是哪个类的实例 如何才能找到类的元数据信息(即与方法区中存储的类的模版信息进行关联) 对象的哈希码 对象的GC分代年龄 等。 根据JVM当前运行状态的不同，例如是否启用偏向锁等，对象头会有不同的设置方式。 至此，从JVM的角度来看，对象分配已然结束了，再接下来就是对象内部操作自己得到的内存了。 5.赋初值 &lt;init&gt;方法会将对象按照程序员的意愿进行初始化，即赋上程序员为实例字段设置的值，其内部会调用对象对应的构造函数。 至此，一个对象的创建已经完成。 对象的内存布局在HotSpot中，内存中存储的对象可分为3块：对象头(Header)，实例数据(Instance Data)和对齐填充(Padding)。 对象头 对象头又可分为两部分：Mark Word及类型指针。 所谓Mark Word即为对象的运行时描述信息，如哈希码(HashCode)，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等。在32位及64位(未开启指针压缩)的JVM上的长度分别为32及64位。实际上Mark Word中所存储的全部状态信息已无法用32位或64位完全表示，而Mark Word又只是一个与对象实际信息无关的描述信息，为了节省内存空间，Mark Word采用了一种非固定的数据结构：对象处于不同状态时需存储的状态信息不同，数据结构也不同。对象的状态列举如下： 例如标志为01，即对象状态为未锁定时，对于32位的JVM而言，2位用于存储标志信息，25位用于存储对象的哈希码，4位用于存储对象的分代年龄，1位固定为0。 类型指针并非对象头中的必要元素。这牵涉到对象的访问定位。我们通过栈上的reference来访问堆上的对象，而如何定位，定位到哪里，JVM规范中并没有具体规定。目前主流的访问方式有两种： 使用句柄： 使用直接指针(此时对象头中就要存储类型指针了)： 使用句柄的好处为reference中存储的为稳定的句柄地址，在对象被移动时(垃圾收集时移动对象是很常见的行为)只需要修改句柄中对象的实际地址，而reference中存储的句柄地址则无需修改。 使用直接指针的好处为减少了一次指针定位。由于对象的访问非常频繁，因此积少成多这也节省了一笔非常可观的时间开销。 HotSpot使用直接指针的方式来定位对象，因此对象头中需要存储类型指针。 除Mark Word及类型指针外，若对象为数组，那么对象头中还必须有一块记录数组长度的区域。因为JVM可以通过普通对象的元数据确定其大小，却无法通过数组对象的元数据确定其大小。 实例数据 对象真正存储的有效信息，即各种类型的字段信息，包括从父类中继承而得的及在自身类中定义的。 字段的存储顺序由JVM的分配策略参数(FieldsAllocationStyle)所确定，依分配策略参数无法确定顺序的字段则由字段在代码中的定义顺序而定(父类中定义的变量会出现在子类之前)。 HotSpot默认的分配策略参数依类型所占用内存空间的大小降序排列： long/double ,int, short/char , byte/boolean ,oop(Ordinary Object Pointer，普通对象指针，即reference类型)。这样分配的好处在于宽度临近的类型总被分配在附近。 对齐填充 HotSpot的自动内存管理系统要求对象的起始地址必须是8字节的整数倍。因此当 对象头+实例数据 不是8字节的整数倍时，就以对齐填充的方式补全。该部分仅仅起到一个占位符的作用，不是必然会存在的(若 对象头+实例数据 恰好为8字节的整数倍该部分就不需要存在)。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM-运行时数据区域]]></title>
    <url>%2F2017%2F10%2F17%2FJVM-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[JVM的运行时数据区域即是指JVM所管理的内存区域。JVM规范依功能又将其分为如下几部分： 程序计数器(Program Counter Register) 虚拟机栈(Virtual Machine Stack) 本地方法栈(Native Method Stack) 堆(Heap) 方法区(Method Area) 实现是基于规范的，但是一来规范中本来就会有一些供实现自行发挥的弹性部分；二来即便是规范中明确要求的，具体的实现也会根据自己的实际需求做一些变通。因此基于同一个JVM规范得到的不同实现之间会有着不小的差异。 若非特别指明，本文所讨论的实现为Sun公司的HotSpot。 程序计数器这是一块很小的内存区域，可看作是线程所执行字节码的行号指示器，用于记录线程正在执行的字节码的行号。 不同线程的待执行的字节码行号通常是不同的，因此这块区域是线程私有的，其生命周期与拥有其的线程相同。 若某线程正在执行的字节码属于一个Java方法，则该线程的程序计数器中存储的是该字节码指令的地址。若某线程正在执行的字节码属于一个本地方法，此时该线程的程序计数器中的值为空(Undefined)。 因为存储的数据简单明确，程序计数器是运行时数据区域中唯一不会抛出内存相关Error的区域。 虚拟机栈每当线程调用Java方法，就会产生一个栈帧(Stack Frame)压入其自身的虚拟机栈，方法执行结束后对应的栈帧出栈。栈帧中记录了该方法的信息： 局部变量表 操作数栈 动态链接(记录符号引用所对应的实际地址，编译期不可知，运行期生成) 方法出口 等。 不同线程的方法调用情况是不同的(即便是调用同一个方法，也是产生各自不同的栈帧)，因此虚拟机栈是线程私有的。虚拟机栈的生命周期与拥有其的线程相同。 局部变量表中存放了其所属方法用到的基本数据类型，对象引用及returnAddress(指向一条字节码指令的地址，用于在代码发生跳跃并局部运行完成后指定返回的位置。例如try后跳入finally执行，finally执行完成后returnAddress会指示需要返回到的字节码指令的地址，JDK1.7中已取消returnAddress，改以冗余复制的方式完成try-catch-finally的功能)。其中64位的long和double会占用两个Slot(局部变量表的基本单位)，其余则占用1个Slot。 操作数栈是和执行器关系最为密切的数据存储单元，执行器只能看到操作数栈中的数据。而操作数栈所需的数据则来源于局部变量表。操作数栈与局部变量表的关系有些类似于CPU的寄存器与内存(在此我们不妨将缓存视为内存的一部分)。例如，某方法欲计算1+2+4，那么可能的执行顺序是这样的： 局部变量表中存入1,2,4 从局部变量表中取出1与2压入操作数栈进行加法计算得到结果3 将计算得到的3存入局部变量表 从局部变量表中取出3与4压入操作数栈进行加法计算得到结果7 将7存入局部变量表 全程执行器可见的只有操作数栈，而操作数栈中的值也必须通过存入局部变量表才能传递到外界。 局部变量表的大小及操作数栈的深度在编译期(.java –&gt; .class)即可完全确定，运行期不会发生变化。 有人会将运行时数据区域比较粗旷的分为堆(Heap)及栈(Stack)。这种划分去掉了他们认为”不那么重要的”程序计数器及方法区。堆是我们通常认识的那个堆，而栈则去掉了本地方法栈仅仅指虚拟机栈。换句话说，这种划分认为Java运行时数据区域最重要的是如下两部分：堆及虚拟机栈。进一步的，更有人将虚拟机栈中的”不那么重要的”部分也去掉了，具体特指局部变量表。 虚拟机栈可能抛出的和内存相关的Error有两种： 压入的栈帧数超过了虚拟机栈允许的最大深度，将抛出StackOverflowError。 扩展栈(虚拟机栈默认即为可扩展的，当然也允许设置虚拟机栈为固定长度)或创建新栈时无法申请到足够的内存空间，则抛出OutOfMemoryError。 OOM小例子 因为HotSpot将虚拟机栈及本地方法栈合二为一，因此虽然-Xoss(设置本地方法栈大小)依然存在，但实际是无效的。栈容量只由-Xss控制。 栈可能会报的异常有两种：StackOverflowError，OutOfMemoryError。但从一个更大的角度来看，这两个错误描述的都是同一件事：无法分配新的栈空间了。至于具体原因，可能是因为空间不够了，也可能是因为压入的栈帧太多了。 为了使错误更容易出现，即更容易的促成”无法分配新的栈空间”。可行的方法有两种。 第一种是减少每个栈的总容量： 123456789101112131415161718192021public class Test &#123; private static int STACK_LENGTH; private static void stackTest() &#123; Test.STACK_LENGTH++; Test.stackTest(); &#125; /** * -Xss256k */ public static void main(String[] args) &#123; try &#123; Test.stackTest(); &#125; catch (Error e) &#123; System.out.println(&quot;stack length=&quot; + Test.STACK_LENGTH); throw e; &#125; &#125;&#125; 其中设置的-Xss256k是一个相对靠谱的正常的栈大小，运行后输出如下： 1234567stack length=2728Exception in thread &quot;main&quot; java.lang.StackOverflowError at com.test.Test.stackTest(Test.java:8) at com.test.Test.stackTest(Test.java:9) at com.test.Test.stackTest(Test.java:9) at com.test.Test.stackTest(Test.java:9) ... 若改为-Xss8k，则输出： 1The stack size specified is too small, Specify at least 104k 很显然，如果过于小的话那么是连启动都启动不起来的。于是改为-Xss65k(比错误信息里的最小值还要小不少，这是我的环境下试出的最小值，可见那个描述只是推荐值，实际没那么精确)，输出： 1234567Exception in thread &quot;main&quot; stack length=1097java.lang.StackOverflowError at com.test.Test.stackTest(Test.java:8) at com.test.Test.stackTest(Test.java:9) at com.test.Test.stackTest(Test.java:9) at com.test.Test.stackTest(Test.java:9) ... 此时能触及的最大深度显然就小很多了。 第二种是增大每个栈帧的大小，最简便的方法就是疯狂的创建基本类型的局部变量(创建引用类型先爆的八成会是堆)，撑爆栈空间：尚未找到有效的测试代码，因为最先爆掉的总是堆。不过根据[深入理解Java虚拟机第二版]的说法，最终抛出的错误也是StackOverflowError(姑且先信了他，不知道他是怎么测的)。 无论如何，在单线程环境下都只能模拟出StackOverflowError的异常(尝试了将-Xss设置为一个极大的值，但貌似没有生效)。可以这样理解：例如-Xss256k，那么系统只要足以分配这256k的空间，超过该值抛出的错误都是StackOverflowError。而只有当系统连这最大的256k都无法分配的时候才会抛出OutOfMemoryError。因此自然想到使用创建多线程来触发这个错误： 12345678910111213141516public class Test &#123; /** * -Xss3m */ public static void main(String[] args) &#123; while (true) &#123; new Thread() &#123; @Override public void run() &#123; while (true) ; &#125; &#125;.start(); &#125; &#125;&#125; 因为在Windows平台的JVM中，Java线程是映射到操作系统的内核线程上的。因此执行上述代码时我的电脑壮烈的死机了。强制关机并重启才恢复了正常。因此自然也没有得到输出。不过同样是根据[深入理解Java虚拟机第二版]的说法，这段代码可以得到如下输出： 1Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: unable to create new native thread 本地方法栈本地方法栈与虚拟机栈的功能非常类似：同样是线程私有的，同样会抛出StackOverflowError及OutOfMemoryError。虚拟机栈为JVM执行Java方法(即字节码)服务，本地方法栈为JVM使用本地方法服务。 HotSpot VM将虚拟机栈与本地方法栈合二为一。 堆该区域的唯一目的就是存储对象实例，虚拟机规范对其的描述为：”所有的对象实例及数组都要在堆上分配内存”。但是在实际实现中，随着JIT编译器的发展，逃逸分析技术的日渐成熟，诸如栈上分配，标量替换等优化措施使得这个描述不那么准确了。不过我们仍可说，在具体实现中，”绝大多数的对象实例及数组都是在堆上分配内存的”。 对绝大多数应用而言，堆都是占用内存最大的一块区域。堆随着JVM的启动而创建，生命周期与JVM相同。很显然，堆中的对象实例是被所有线程所共享的。 堆是垃圾收集器收集垃圾的主要区域，因此堆有时也被称为GC堆(Garbage Collected Heap)。 根据JVM规范中的规定，类似于磁盘空间，堆可以处于物理上不连续的内存空间中，只要逻辑上连续即可。具体实现时，既可以是固定大小的，也可以是可扩展的。不过当前主流的JVM实现都是可扩展的(Hotspot通过-Xmx及-Xms控制)。 若当前堆无法满足分配需求且无法扩展，则抛出OutOfMemoryError。 OOM小例子 12345678910111213import java.util.ArrayList;import java.util.List;public class Test &#123; /** * -Xms20m -Xmx20m */ public static void main(String[] args) &#123; List&lt;Test&gt; list = new ArrayList&lt;Test&gt;(); while (true) list.add(new Test()); &#125;&#125; 执行后输出： 12345678Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space at java.util.Arrays.copyOf(Arrays.java:2245) at java.util.Arrays.copyOf(Arrays.java:2219) at java.util.ArrayList.grow(ArrayList.java:242) at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:216) at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:208) at java.util.ArrayList.add(ArrayList.java:440) at com.test.Test.main(Test.java:13) 方法区JVM规范将方法区描述为堆的一个逻辑组成部分，但是方法区与堆中所存储的对象实例又有明显区别。简单来说，只要能从具体实例中抽象出的属于类的模版信息都应存储在方法区中。 说方法区是堆的逻辑组成部分，是因为堆和方法区中描述的都是对象信息。方法区是干细胞，堆是由干细胞产生的具体的细胞实例。但方法区与堆存储的数据又存在明显的界限，因此它才会在分类时被完全并列出来单独列举，并且它还有一个别名：非堆(Non-Heap)。 特别的，用于描述类信息的，与每个类一一对应的Class类的实例，也被称为该类的类对象，作为一个普通的实例对象也是存在于堆中的，只不过其所封装的信息都来源于方法区。 很显然，方法区中的数据也是线程共享的。和堆相同，方法区也可以处于物理上不连续的内存空间中，只要逻辑上连续即可。具体实现时，既可以是固定大小的，也可以是可扩展的。 在JDK1.6及此前的版本，HotSpot VM的方法区大致可分为如下两部分： 永久代：方法区中存储类的模版信息，例如类的描述信息，常量，静态变量。粗略的看，可认为是.class文件读入内存后存放在了永久代。所谓的对方法区的垃圾回收实际管理的就是这个区域，主要回收的内存为运行时常量池及类的卸载。 代码缓存：即时编译器(JIT)编译后的代码。 JVM规范中并未明确规定方法区该如何实现，也未规定垃圾收集器是否该收集这个区域的内容。具体到HotSpot VM，其方法区是以永久代(Permanent Generation)实现的，并将垃圾收集器的垃圾收集范围扩展到方法区。这样做的好处是垃圾收集器可以像管理堆一样来管理方法区，而不用特地为方法区去编写内存管理代码。但这样做却更容易发生内存溢出：永久代有-XX:MaxPermSize的上限，达到该上限后即便尚有内存空间也无法再行分配了。 因此，HotSpot VM在逐步废弃永久代。在JDK1.7中，储存在永久代中的部分数据就已经转移到了堆(例如字符串常量池，类的静态变量)或本地内存(例如符号引用)中。但永久代依然存在，并未完全移除。 我们不妨以String.intern()这个方法来证明该变化。该方法的作用为返回该字符串所对应的字符串常量池中的那个字符串的引用。具体来说，当我们调用： 1str.intern() 会先检查str所对应的值是否已在字符串常量池中存在，若已存在则返回那个已存在的字符串值对应的对象引用。若不存在，JDK1.6时，字符串常量池尚在方法区中，因此需要以str的值为基础在方法区的字符串常量池中创建一个新的字符串对象，而后把这个对象的引用返回回去；而JDK1.7时字符串常量池本就在堆中，因此只需将该str对象的引用加入到字符串常量池中即可。 首先验证的就是字符串常量池的位置： 1234567891011121314import java.util.ArrayList;import java.util.List;public class Test &#123; /** * -XX:PermSize=10m -XX:MaxPermSize=10m */ public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); int i = 0; while (true) list.add(String.valueOf(i++).intern()); &#125;&#125; 在JDK1.6中，运行结果为： 12Exception in thread &quot;main&quot; java.lang.OutOfMemoryError:PermGen space... 而在JDK1.7中，除非触碰到堆内存的分配上限(即便真的触碰上限抛出了Error，Error的区域也是Heap space而非PermGen space)，否则代码会一直运行下去。 其次验证的是String.intern()的功能： 1234567public class Test &#123; public static void main(String[] args) &#123; String str = new String(&quot;紫婆婆&quot;); System.out.println(str.intern() == str); &#125;&#125; 此时因为在创建str对象时代表”紫婆婆”这个字符串常量的字符串已然创建过并将其作为该常量值的引用加入到了字符串常量池，因此无论是JDK1.6抑或是JDK1.7，返回的都是false。因为str.intern()返回的是”紫婆婆”这个常量值代表的字符串引用而非str。 为保证创建的字符串未曾在字符串常量池中出现过，可做如下修改： 1234567public class Test &#123; public static void main(String[] args) &#123; String str = new StringBuilder(&quot;紫&quot;).append(&quot;婆婆&quot;).toString(); System.out.println(str.intern() == str); &#125;&#125; 在调用str.intern()时，”紫婆婆”并未被加入字符串常量池(此前出现的字符串常量只有”紫”及”婆婆”)，因此对于JDK1.6会以”紫婆婆”为基础在方法区的字符串常量池中创建一个新的对象并返回该对象的引用，因其并非str，因此依然输出false。而对于JDK1.7，由于直接将str的引用加入到了字符串常量池并返回，因此输出true。 特别的，若代码如下： 1234567public class Test &#123; public static void main(String[] args) &#123; String str = new StringBuilder(&quot;ja&quot;).append(&quot;va&quot;).toString(); System.out.println(str.intern() == str); &#125;&#125; 此时对于str的值”java”看似是在调用str.intern()时第一次出现在字符串常量池，但实际上此前像”java”这类有特殊含义的单词已然作为常量在字符串常量池中出现过了，只不过出现的地方并非用户程序所写的代码而已。因此此种情况实际相当于此前”紫婆婆”的例子，JDK1.6及JDK1.7均会输出false。 而到了JDK1.8永久代完全被元空间所替代。元空间是一块本地内存(Native Memory)，因此元空间的扩展极限是本机内存空间的扩展极限，垃圾收集器依然可以对其进行管理。自然，以前那些和永久代相关的设置参数及异常也不复存在了。 特别的，JDK1.8中字符串常量池依然在堆中。上文中关于String.intern()的测试代码在JDK1.8中的返回值均同JDK1.7。 方法区中最重要的一部分空间为运行时常量池(Runtime Constant Pool)。很多人将其与.class文件中的常量池(Constant Pool Table)等同看待，这是错误的：运行时常量池并不一定会读取常量池中的所有内容，它可能会根据本次加载的需求有所删减；同时除了编译期生成的.class文件外，运行期程序员也可以添加新的内容至运行时常量池(例如上文提到的JDK1.6及此前版本中的String类的intern方法)。 当方法区无法满足内存分配请求时会抛出OutOfMemoryError。拥有大量JSP或动态产生JSP文件的应用(JSP第一次运行时需要编译为Java类)容易触发这个Error。下面使用CGLib直接操作字节码在运行时生成大量的动态类来触发这个Error： 12345678910111213141516171819202122232425262728import java.lang.reflect.Method;import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;public class Test &#123; /** * -XX:PermSize=10m -XX:MaxPermSize=10m */ public static void main(String[] args) &#123; while (true) &#123; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(OOMObject.class); enhancer.setUseCache(false); enhancer.setCallback(new MethodInterceptor() &#123; @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; return proxy.invokeSuper(obj, args); &#125; &#125;); enhancer.create(); &#125; &#125;&#125;class OOMObject &#123;&#125; 输出： 12Exception in thread &quot;main&quot; Exception: java.lang.OutOfMemoryError thrown from the UncaughtExceptionHandler in thread &quot;main&quot; 本地内存本地内存(Native Memory)并不是JVM运行时数据区域的一部分，JVM要操作这部分内存需要一些本地函数库的辅助。但是这块内存和JVM的内存管理又息息相关：例如上文提到的方法区中的元空间。 同样的例子还有JDK1.4中引入的NIO(New Input/Output)模式，该模式引入了一种基于通道(Channel)与缓冲区(Buffer)的I/O方式，它可以通过本地函数库直接分配本地内存，然后通过一个存于堆中的对象作为引用操作这块本地内存，这样就可以避免在Java堆及本地内存之间来回的复制数据，从而提升了程序的运行效率。 既然是内存空间，那么一定有其上限，对本地内存的申请超出其承载上限时会抛出OutOfMemoryError。 下面的例子越过了DirectByteBuffer类，直接通过反射获取Unsafe实例进行内存分配(Unsafe的getUnsafe()限制了只有引导类加载器才会返回实例，即Unsafe类设计者希望只有rt.jar中的类才能使用Unsafe的功能)。之所以这么做，是因为DirectByteBuffer类在分配内存时虽然也会抛出内存溢出异常，但是它并没有真正的向操作系统申请分配内存，而是通过计算得知内存不够了。作为操作系统而言并不知道曾有这样的一次内存分配操作。真正直接向操作系统申请分配内存的方法是Unsafe类的实例方法allocateMemory()。 12345678910111213141516171819import java.lang.reflect.Field;import sun.misc.Unsafe;public class Test &#123; private static final int _1MB = 1024 * 1024; /** * -Xmx20m -XX:MaxDirectMemorySize=10m * 本地内存可由MaxDirectMemorySize指定，若未显式指定则与堆的最大值一致。 */ public static void main(String[] args) throws IllegalArgumentException, IllegalAccessException &#123; Field unsafeField = Unsafe.class.getDeclaredFields()[0]; unsafeField.setAccessible(true); Unsafe unsafe = (Unsafe)unsafeField.get(null); while (true) unsafe.allocateMemory(Test._1MB); &#125;&#125; 运行结果 123Exception in thread &quot;main&quot; java.lang.OutOfMemoryError at sun.misc.Unsafe.allocateMemory(Native Method) at com.test.Test.main(Test.java:19)]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 基础-发展历史]]></title>
    <url>%2F2017%2F10%2F16%2FJava%20%E5%9F%BA%E7%A1%80-%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2%2F</url>
    <content type="text"><![CDATA[1991.4 —– Java前身OakSun公司(Sun Microsystems，Sun的由来为斯坦福大学校园网[Stanford University Network])的James Gosling领导的绿色计划(Green Project)开发出了一种面向消费性电子产品(如机顶盒，冰箱，收音机)的语言Oak(橡树)，反响平平。 1995.5.23 —– Java语言1.0随着互联网大潮的袭来，Oak迅速找到了自身的市场定位，并在Sun World大会上改名为Java并发布了1.0版本。同时Java也提出了它那句最为著名的广告语：Write Once,Run Anywhere。 1996.1.23 —– JDK1.0JDK(Java Development Kit)是JVM+Java语言语法+Java API类库中的核心类库的统称。至此Java终于拥有了完整的官方运行环境。 JDK1.0所使用的JVM为Sun Classic VM，这是一个纯解释执行的虚拟机，因此执行代码较慢，给很多人留下了Java运行慢的第一印象并直至今日。实际上，随着JIT及各种优化策略的引入，当今Java在执行速度上已不弱于其他主流语言。 JDK1.0的代表技术包括： Applet：包含在Html页面中的Java小程序。 AWT(Abstract Window Toolkit，抽象窗口工具集)：Java的图形用户界面(Graphical User Interface,GUI)的根基。 1996.3微软申请并获得了Java许可证。 1996.410个最主要的操作系统供应商申明将在其产品中嵌入Java技术。 1996.5月底Sun公司于美国旧金山举行了首届JavaOne大会，自此其成为了Java使用者每年一度的技术盛会。 1996.9已有大约8.3万个网页应用了Java技术。 1997.2.19 —– JDK1.1JDK1.1发布了大量Java中最为基础的技术支撑点，例如： JDBC(Java DataBase Connectivity)。 JAR(Java Archive)：java归档文件格式。 JavaBean。 RMI(Remote Method Invoke，远程方法调用)。 内部类(Inner Class)。 反射(Reflection)。 1997.9.12 —– JDK1.1.4截至1997年9月12日为止，共发布了3个JDK1.1的升级版本：JDK1.1.1~JDK1.1.3。 1997年9月12日JDK1.1.4发布，自此开始基本每个版本都会有一个工程代号，JDK1.1.4的工程代号为Sparkler(宝石)。 1997.10Sun状告微软于1997年发布的Visual J++对Java做出了”不恰当的修改”，这些修改将Java绑定在了Windows平台下，违背了JVM平台无关性的基本规划。 1997.12.03 —– JDK1.1.5工程代号Pumpkin(南瓜)。 1998.4.24 —– JDK1.1.6工程代号Abigail(阿比盖尔，女性名)。 1998.9.28 —– JDK1.1.7工程代号Brutus(布鲁图，古罗马政治家，将军)。 1998.12.4 —– JDK1.2工程代号Playground(竞技场)。 JDK1.2将Java的技术体系依应用平台划分为3个方向：J2ME(Java 2 Platform, Micro Edition)，J2SE(Java 2 Platform, Standard Edition)，J2EE(Java 2 Platform, Enterprise Edition)。详见Java 基础-技术体系。 JDK1.2的代表性技术包括： EJB(Enterprise JavaBean)：J2EE平台下对JavaBean技术的扩展。 Java Plug-in：因官司纠纷的原因IE不支持JAVA2的特征，所以Sun设计了该插件以解决这个问题。 Java IDL(Interface Definition Language)：实现网络上不同平台不同语言之间的交互。 Swing：新一代GUI，AWT的升级版。 strictfp(strict float point,精确浮点)关键字。 Collection框架。 JDK1.2在整个周期中曾存在过3个JVM： Sun Classic VM：JDK1.0~JDK1.1中的唯一JVM，JDK1.2中依然以其为默认JVM。 HotSpot VM。 Exact VM：只在Solaris平台上出现过。因使用准确式内存管理(Exact Memory Management)而得名(详见JVM-垃圾收集)。 JDK1.2首次引入了JIT(Just In Time)编译器。Sun Classic VM只能以外挂的形式使用JIT编译器，且编译器与解释器无法混合使用，即要么纯编译，要么纯解释(因此执行效率依然糟糕)。HotSpot VM及Exact VM则内置了JIT编译器，且编译器与解释器可以混合执行。 1999.3.30 —– JDK1.2.1无工程代号。 1999.4.8 —– JDK1.1.8工程代号Chelsea(切尔西，城市名)。 1999.4.27 —– HotSpot VM发布HotSpot VM最初由一家名为Longview Technologies的小公司所开发，后该公司于1997年被Sun收购。 与Sun自行研发的Exact VM相比，HotSpot VM具备作为Exact VM名称由来的准确式内存管理技术。相对的，Exact VM同样具备作为HotSpot VM名称由来的热点探测技术。因此二者在核心竞争力上其实相去不远。关于二者究竟哪一个会作为后续版本的主力JVM在Sun内部还曾有过激烈的争论。因此HotSpot VM最终的胜利并非是依托于压倒性的技术优势，而是带有一些”总得选一个吧，那就它吧”的小幸运。 所谓热点探测技术，就是指可以通过执行计数器找到最具编译价值的代码，然后通过JIT编译器以方法为单位进行编译。若方法被频繁调用将会触发标准编译。若方法中的有效循环次数很多，将会触发栈上替换(OSR)。 1999.7.8 JDK1.2.2工程代号Cricket(板球)。 2000.5.8 JDK1.3.0工程代号Kestrel(美洲红隼)。自JDK1.3.0起，HotSpot VM成为默认JVM，Classic VM则作为可选JVM提供。 本次大版本的更新主要集中在类库上，例如数学运算和新的Timer API等。 JNDI(Java Naming and Directory Interface,Java命名和目录接口)开始被作为一项平台级服务被提供(此前仅仅是一项扩展)。 使用CORBA IIOP(Internet Inter-ORB Protocol,互联网内部对象请求代理协议)实现RMI的通信协议。 提供了大量新的Java 2D API(然并卵)，并新增JavaSound类库。 自本版本起，Sun维持了一个习惯：大约每隔两年发布一个大版本，以动物命名工程代号；期间的小版本则以昆虫命名工程代号。 2001.5.17 JDK1.3.1工程代号Ladybird(瓢虫)。 2001.1Sun与微软达成和解。微软承诺会逐步在其产品中移除Java技术。 2001.7微软公布新版的Windows XP将不再支持Sun的JVM，并且推出了.NET平台与Java分庭抗礼。 2002.2.13 JDK1.4.0工程代号Merlin(灰背隼)。在这个大版本的更新中，JDK真正的摆脱了成长期走入了成熟。Compaq(康柏电脑)，Fujitsu(富士通)，SAS(STATISTICAL ANALYSIS SYSTEM)，Symbian(塞班)，IBM(International Business Machines Corporation,国际商业机器公司)等都参与甚至实现了自己独立的JDK1.4。正因为如此，JDK1.4.0至今仍能基本被主流应用(Spring等)所兼容。 JDK1.4带来了很多新特性，例如正则表达式，异常链，NIO(java non-blocking IO或New IO，用以替代此前的阻塞式IO)，日志系统，XML解析器，XSLT(XSL指EXtensible Stylesheet Language,扩展样式表语言，其为XML的扩展。T指转换)转换器等。 JVM方面，彻底移除了Classic VM。 2002.9.16 JDK1.4.1工程代号Grasshopper(蚱蜢)。 2003.6.26 JDK1.4.2工程代号Mantis(螳螂)。 2004.9.29 JDK1.5.0工程代号Tiger(老虎)。自本版本起，官方在宣发上已不再采取类似于JDK1.5.0的命名方式，取而代之的是采用JDK5。只有在程序内部使用的开发版本号(Developer Version，例如java -version的输出)才继续沿用此前的命名方式。为了行文统一，本文在后续描述中将沿用此前的命名方式。 JDK1.5做出了自JDK1.2以来在语法层面上最大幅度的改进。引入了自动装箱，泛型，动态注解，枚举，可变长参数，foreach等新功能点。 JVM层面改进了Java的内存模型JMM(Java Memory Model)。 API层面引入了java.util.concurrent并发包实现了一个粗粒度的并发框架。 2006.11.13 开源在当日的JavaOne大会上，Sun宣布将对Java进行开源。并建立起OpenJDK组织管理这些开源代码。在随后的一年多的时间内，除了极少量的私有的与语言特性基本无关的代码以外，OpenJDK基本可与官方的JDK等同。 OpenJDK中所用的JVM与官方的JDK相同，即也为HotSpot VM。 2006.12.11 JDK1.6.0工程代号Mustang(野马)。自本版本起sun终结了J2SE,J2ME,J2EE，转而使用Java SE 6,Java ME 6,Java EE 6。 该版本新增的功能包括：通过内置Mozilla JavaScript Rhino引擎的方式提供动态语言支持。提供编译APT。提供微型HTTP服务器API。 JVM方面，改进了锁与同步，垃圾收集，类加载等方面的算法。 2009.4.20 Oracle收购Sun此前Oracle已收购了BEA并从其手中接收了三大商用JVM之一的JRockit(主要面向的市场为服务器端，因此可以不必考虑启动时间及响应时间，JRockit内部仅有即时编译器而没有解释器)。收购Sun后Oracle又从其手中接收了三大商用JVM中的第二个，也是最为流行的HotSpot。Oracle计划未来将会将这两款JVM合二为一，形成HotRockit。合并后的JVM将兼具两家之长，譬如使用JRockit的垃圾回收器与MissionControl(任务控制，是一种调优工具)。使用HotSpot的JIT编译器等。 三大商用JVM中的最后一个为IBM公司的J9，该虚拟机主要用于支持IBM自身的Java设备。其应用范围和HotSpot基本一致。 2011.7.28 JDK1.7.0工程代号Dolphin(海豚)。 JDK1.7.0立项时共计划了10个里程碑，原始计划至2010年9月9日完成所有里程碑。2009年2月19日完成了第一个里程碑后，因为Sun公司经营上的问题，进度将无法如期完成。 在Sun被Oracle收购后，为保证JDK1.7.0能在2011年7月28日准时发布，只能放弃部分计划中的功能点：例如Lambda项目(Lambda表达式，函数式编程)，Jigsaw项目(虚拟机模块化支持)，Coin项目(语言细节进化)等。 最终，JDK1.7的功能为：动态语言支持，GarbageFirst(G1)收集器(刚推出时G1依然处于Experimental状态，直到2012年4月的Update 4才转为正式版)，加强对非Java语言的调用支持(JSR-292，直至JDK1.7周期结束也未完全完成)，改进类加载架构等。 API层面引入了java.util.concurrent.forkjoin包完善了java.util.concurrent的并发框架。]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 基础-技术体系]]></title>
    <url>%2F2017%2F10%2F16%2FJava%20%E5%9F%BA%E7%A1%80-%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[JVM的两个无关性大家较为熟知的是平台无关性。即JVM屏蔽了下层操作系统的技术细节，正如其广告语所言：Write Once,Run Anywhere。 另一个无关性是语言无关性。即实际编写代码的语言并非必须是Java，只要最终给出的是符合规范的平台无关的字节码(ByteCode)文件(Java中特指class文件)，JVM就能正确运行。正因为如此，描述class文件的字节码指令所能表示的语义肯定比Java语法要强，因为其不仅仅可以描述Java语法，还需支持其他语言的语义。详见JVM-类文件结构。语言无关性并没有平台无关性那么普及，主要原因在于其推广很不理想：JVM的设计者是很具野心及攻击性的，其希望将JVM做成一个通用的平台，所有语言都可在其上运行。因此打从一开始，Java虚拟机规范(Java Virtual Machine Specification)与Java语言规范(Java Language Specification)就是分开发布的。从纯技术的角度而言，理论上这是可行的。但目前已成熟的主流语言(C，C++，Python等)，即便有可在JVM上运行的版本，让它们放弃已经非常成熟的自有体系转而投入这个需要做二次转换的平台是很不现实的。 当然，语言无关性也并非一无所成。一些新兴的小众语言(Clojure，JRuby，Groovy，Scala等)选择依托Java这个成熟而又完整的体系来帮助自己节约成本，迅速起飞。从广义上讲，这些语言都是Java技术体系中的一员。 举个小例子：JVM就好比微信公众平台。对于订餐软件而言，理论上都可以使用该平台进行推广。但是对于美团，饿了吗之类的巨头，其投入重点自然是自家的APP而非微信公众号。相反，对于一些小的创业性质的订餐软件而言，独立开发一款APP需要付出高昂的成本，此时利用微信平台所积累的技术及用户基础全力推广公众号将是更好的选择。 虽然一直受挫，但JVM的语言无关性寄托了一个非常美好的愿景：在一个平台上可运行多种语言，意味着同一个程序的不同模块可分别使用不同语言完成，每个语言都做它最擅长的那一部分。同时因为各语言身处同一平台之上，相互之间的沟通也将毫无障碍：跨语言的协作将像调用自身语言原生的API那样自然。 通常我们所说的Java技术体系是狭义的(本文也是如此)：即编写代码的语言特指Java。毕竟这是JVM最为广泛的应用。 Java技术体系依功能划分 即站在软件开发人员的角度思考问题，分为： JVM。 class文件(字节码文件)格式。 Java语言语法。 Java API类库。又可细分为核心类库及扩展类库。核心类库一般以java.*作为包名，主要面向Java SE。扩展类库一般以javax.*作为包名，主要是针对Java EE对核心类库所作出的补充。但由于历史原因，一部分曾经的扩展类库进入到了核心类库，因此核心类库中也会包含部分javax.*的代码。 第三方Java类库。例如Spring，Mybatis及Maven仓库中的众多框架。 JVM+Java语言语法+Java API类库中的核心类库统称为JDK(Java Development Kit)。JDK是官方所定义的开发一个标准Java应用的最小集，也是Java技术体系中最为重要的一部分，因此很多时候我们都会用JDK来代指Java技术体系。 相对应的，JVM+Java API类库中的核心类库统称为JRE(Java Runtime Environment)，JRE是官方所定义的运行一个标准Java应用的最小集。较之JDK之所以少了Java语言语法，是因为JVM的语言无关性：如果仅仅只为运行程序的话，JVM只需拿到class格式的文件即可。 依应用平台划分 即站在用户的角度思考问题，分为： Java Card：支持Java小程序(Applet)运行在小内存设备(如智能卡)上的平台。 Java ME(Micro Edition)：最初被称为J2ME(Java 2 Platform, Micro Edition)。支持Java程序运行在移动终端上的平台。其Java API类库有所精简，并会加入针对移动终端的特殊支持。Java ME与同样是以Java为基础，面向移动终端的安卓(Android)相比是完全不同的两种平台。Java ME所使用的JVM遵循Java虚拟机规范，而安卓则是完全另起炉灶。虽然Java ME的诞生时间较之安卓要早，但近年来安卓如日中天，Java ME则处于不断衰落的边缘化状态。 Java SE(Standard Edition)：最初被称为J2SE(Java 2 Platform, Standard Edition)。支持面向桌面级应用(使用JDK开发的标准Java应用)的平台。 Java EE(Enterprise Edition)：最初被称为J2EE(Java 2 Platform, Enterprise Edition)。支持使用多层架构的企业应用(如ERP[Enterprise Resource Planning,企业管理系统])的平台。可看作是Java SE的升级复杂版。]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 反射-基础]]></title>
    <url>%2F2017%2F10%2F13%2FJava%20%E5%8F%8D%E5%B0%84-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[JVM-类加载机制的第一阶段加载是整个类加载过程中最为灵活的一个阶段。JVM-类加载机制中具体介绍了在类信息来源上可以玩的花活，其实总结一下，来源主要可分为两大类： 编译期已知。或者具体来说，就是由javac编译器生成的class文件。 编译期未知。会在运行期类加载-加载阶段动态的从某一特定数据源获取class文件。 前者也被称作RTTI(Run-Time Type Identification，即运行时类型识别)，后者则被称作反射。 在Java API中，反射的功能大多集中在包java.lang.reflect中。 获得一个类的类对象 类型.class，例如：String.class 对象.getClass()，例如：str.getClass() Class.forName()，例如：Class.forName(“java.lang.String”) 大多的反射操作基本都是通过这个类对象完成的。 通过反射创建对象类对象.newInstance()，例如：String.class.newInstance()。默认调用无参构造函数，因此要求被调用类中必须有可调用的无参构造函数。违反该规定可通过编译，但是运行时会抛出异常： 123456789public class Test &#123; public Test(int i) &#123; &#125; public static void main(String[] args) throws InstantiationException, IllegalAccessException &#123; Test.class.newInstance(); &#125;&#125; 输出： 123Exception in thread &quot;main&quot; java.lang.InstantiationException: com.test.Test at java.lang.Class.newInstance(Class.java:368) at com.test.Test.main(Test.java:9) 类对象.getConstructor()：返回指定参数类型、具有public访问权限的构造器对象。 类对象.getDeclaredConstructor()：返回指定参数类型、所有声明的(包括private)构造器对象。 获得构造器对象(Constructor)后调用其newInstance()方法创建对象。例如： 1234567891011121314151617181920import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;public class Test &#123; private int i; /** * 若类型为int则会报错: * java.lang.NoSuchMethodException: com.test.Test.&lt;init&gt;(java.lang.Integer) */ public Test(Integer i) &#123; this.i = i; &#125; public static void main(String[] args) throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SecurityException &#123; Constructor&lt;Test&gt; constructor = Test.class.getConstructor(Integer.class); System.out.println(constructor.newInstance(5).i); &#125;&#125; 输出： 15 通过反射获取和设置对象私有字段123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import java.lang.reflect.Constructor;import java.lang.reflect.Field;public class Test &#123; /** * 通过反射获取对象指定字段(变量)的值 * @param target 目标对象 * @param fieldName 字段的名字 * @throws 如果取不到对象指定字段的值则抛出异常 * @return 字段的值 */ public static Object getValue(Object target, String fieldName) &#123; Class&lt;?&gt; clazz = target.getClass(); String[] fs = fieldName.split(&quot;\\.&quot;); try &#123; for(int i = 0; i &lt; fs.length - 1; i++) &#123; Field f = clazz.getDeclaredField(fs[i]); f.setAccessible(true); target = f.get(target); clazz = target.getClass(); &#125; Field f = clazz.getDeclaredField(fs[fs.length - 1]); f.setAccessible(true); return f.get(target); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 通过反射给对象的指定字段赋值 * @param target 目标对象 * @param fieldName 字段的名称 * @param value 值 */ public static void setValue(Object target, String fieldName, Object value) &#123; Class&lt;?&gt; clazz = target.getClass(); String[] fs = fieldName.split(&quot;\\.&quot;); try &#123; for(int i = 0; i &lt; fs.length - 1; i++) &#123; Field f = clazz.getDeclaredField(fs[i]); f.setAccessible(true); Object val = f.get(target); if(val == null) &#123; Constructor&lt;?&gt; c = f.getType().getDeclaredConstructor(); c.setAccessible(true); val = c.newInstance(); f.set(target, val); &#125; target = val; clazz = target.getClass(); &#125; Field f = clazz.getDeclaredField(fs[fs.length - 1]); f.setAccessible(true); f.set(target, value); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; public static void main(String[] args) &#123; &#125;&#125; 通过反射调用对象的方法12345678910import java.lang.reflect.Method;public class Test &#123; public static void main(String[] args) throws Exception &#123; String str = &quot;hello&quot;; Method m = str.getClass().getMethod(&quot;toUpperCase&quot;); System.out.println(m.invoke(str)); // 输出HELLO &#125;&#125;]]></content>
      <categories>
        <category>Java 反射</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java JDBC-碎片]]></title>
    <url>%2F2017%2F10%2F12%2FJava%20JDBC-%E7%A2%8E%E7%89%87%2F</url>
    <content type="text"><![CDATA[JDBC能否处理Blob和Clob？ Blob是为存储大的二进制数据而设计的二进制大对象(Binary Large Object)。Clob是为存储大的文本数据而设计的大字符对象(Character Large Object)。JDBC的PreparedStatement和ResultSet都提供了相应的方法来支持Blob和Clob操作。 例如，表设计如下： 123456create table person_photo(id int primary key auto_increment,name varchar(20) unique not null,photo longblob); 程序如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.test;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.SQLException;public class Test &#123; public static void main(String[] args) &#123; Connection connection = null; PreparedStatement ps = null; try &#123; Class.forName(&quot;com.mysql.jdbc.Driver&quot;); connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8&quot;, &quot;root&quot;, &quot;&quot;); ps = connection.prepareStatement(&quot;insert into person_photo values (default, ?, ?)&quot;); ps.setString(1, &quot;八云紫&quot;); try (InputStream in = new FileInputStream(&quot;d:\\0.jpg&quot;)) &#123; ps.setBinaryStream(2, in); System.out.println(ps.executeUpdate() == 1 ? &quot;插入成功&quot; : &quot;插入失败&quot;); &#125; catch(IOException e) &#123; e.printStackTrace(); &#125; &#125; catch (ClassNotFoundException | SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; if (null != ps) &#123; try &#123; ps.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; if (null != connection) &#123; try &#123; connection.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 输出： 1插入成功 数据库受影响变为：]]></content>
      <categories>
        <category>Java JDBC</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java JDBC-事务]]></title>
    <url>%2F2017%2F10%2F12%2FJava%20JDBC-%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[只有存在并发数据访问时才需要事务。 事务的ACID 原子性(Atomic)：事务中各项操作，要么全做要么全不做，任何一项操作的失败都会导致整个事务的失败。 一致性(Consistent)：事务必须使数据库从一个一致性状态变到另一个一致性状态。 隔离性(Isolated)：并发执行的事务彼此无法看到对方的中间状态。 持久性(Durable)：事务完成后所做的改动都会被持久化。即使发生灾难性的失败，都可以通过日志和同步备份在故障发生后重建数据。 事务常见问题当多个事务访问同一数据时，可能会存在5类问题：包括3类数据读取问题(脏读，不可重复读和幻读)和2类数据更新问题(第1类丢失更新和第2类丢失更新)。 脏读(Dirty Read) A事务读取B事务尚未提交的数据并在此基础上操作，而B事务执行回滚，那么A读取到的数据就是脏数据。 不可重复读(Unrepeatable Read) 事务A重新读取前面读取过的数据，发现该数据已经被另一个已提交的事务B修改过了。 幻读(Phantom Read) 事务A重新执行一个查询，返回一系列符合查询条件的行，发现其中插入了被事务B提交的行。 第1类丢失更新 事务A撤销时，把已经提交的事务B的更新数据覆盖了。 第2类丢失更新 事务A覆盖事务B已经提交的数据，造成事务B所做的操作丢失。 常见问题的对策数据库通常会通过锁机制来解决数据并发访问问题。按锁定对象不同可以分为表级锁和行级锁；按并发事务锁定关系可以分为共享锁和独占锁。 直接使用锁是非常麻烦的，为此数据库为用户提供了自动锁机制，只要用户指定会话的事务隔离级别，数据库就会通过分析SQL语句然后为事务访问的资源加上合适的锁。ANSI/ISO SQL 92标准定义了4个等级的事务隔离级别，如下表所示： JDBC中的事务处理Connection提供了事务处理的方法，通过调用setAutoCommit(false)可以设置手动提交事务，当事务完成后用commit()显式提交事务。如果在事务处理过程中发生异常则通过rollback()进行事务回滚。除此之外，从JDBC 3.0开始还引入了Savepoint(保存点)的概念，允许通过代码设置保存点并让事务回滚到指定的保存点。]]></content>
      <categories>
        <category>Java JDBC</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>事务</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 并发-回显服务器]]></title>
    <url>%2F2017%2F10%2F12%2FJava%20%E5%B9%B6%E5%8F%91-%E5%9B%9E%E6%98%BE%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[用套接字(Socket)编程实现一个多线程的回显(echo)服务器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.io.BufferedReader;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.ServerSocket;import java.net.Socket;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class EchoServer &#123; private final static Logger LOGGER = LoggerFactory.getLogger(EchoServer.class); private static class ClientHandler implements Runnable &#123; private Socket client; public ClientHandler(Socket client) &#123; this.client = client; &#125; @Override public void run() &#123; try(BufferedReader br = new BufferedReader(new InputStreamReader(client.getInputStream())); PrintWriter pw = new PrintWriter(this.client.getOutputStream())) &#123; String msg = br.readLine(); LOGGER.info(&quot;server get &quot; + this.client.getInetAddress() + &quot;:&quot; + msg); pw.println(&quot;已处理 [&quot; + msg + &quot;]&quot;); pw.flush(); &#125; catch(Exception e) &#123; LOGGER.error(&quot;fail to get data&quot;, e); &#125; finally &#123; try &#123; client.close(); &#125; catch (Exception e) &#123; LOGGER.error(&quot;fail to close client&quot;, e); &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; ExecutorService es = null; try(ServerSocket server = new ServerSocket(6789)) &#123; LOGGER.info(&quot;server start...&quot;); es = Executors.newFixedThreadPool(10); while(true) &#123; Socket client = server.accept(); es.submit(new ClientHandler(client)); &#125; &#125; catch (Exception e) &#123; LOGGER.error(&quot;server catch error&quot;, e); &#125; finally &#123; es.shutdown(); &#125; &#125;&#125; 12345678910111213141516171819202122232425import java.io.BufferedReader;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.Socket;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class EchoClient &#123; private final static Logger LOGGER = LoggerFactory.getLogger(EchoClient.class); public static void main(String[] args) throws Exception &#123; Socket client = new Socket(&quot;localhost&quot;, 6789); PrintWriter pw = new PrintWriter(client.getOutputStream()); String msg = &quot;八云蓝请求更多的鱼豆腐&quot;; pw.println(msg); pw.flush(); LOGGER.info(&quot;client send:&quot; + msg); BufferedReader br = new BufferedReader(new InputStreamReader(client.getInputStream())); LOGGER.info(&quot;server return:&quot; + br.readLine()); br.close(); client.close(); &#125;&#125; 日志输出： 12342017-10-12 17:14:59 echo.EchoServer:49 [INFO] - server start...2017-10-12 17:15:04 echo.EchoServer:31 [INFO] - server get /127.0.0.1:八云蓝请求更多的鱼豆腐2017-10-12 17:15:04 echo.EchoClient:21 [INFO] - client send:八云蓝请求更多的鱼豆腐2017-10-12 17:15:04 echo.EchoClient:23 [INFO] - server return:已处理 [八云蓝请求更多的鱼豆腐]]]></content>
      <categories>
        <category>Java 并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>回显</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 算法题-字符串在文件中的出现次数]]></title>
    <url>%2F2017%2F10%2F12%2FJava%20%E7%AE%97%E6%B3%95%E9%A2%98-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9C%A8%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728import java.io.BufferedReader;import java.io.FileReader;public class Test &#123; public static int countWordInFile(String filename, String word) &#123; int count = 0; try (FileReader fr = new FileReader(filename)) &#123; try (BufferedReader br = new BufferedReader(fr)) &#123; String line = null; while ((line = br.readLine()) != null) &#123; int index = -1; while (line.length() &gt;= word.length() &amp;&amp; (index = line.indexOf(word)) &gt;= 0) &#123; count++; line = line.substring(index + word.length()); &#125; &#125; &#125; &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; return count; &#125; public static void main(String[] args) &#123; System.out.println(countWordInFile(&quot;e:\\blog\\test\\temp.txt&quot;, &quot;public&quot;)); &#125;&#125;]]></content>
      <categories>
        <category>Java 算法题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java IO-流]]></title>
    <url>%2F2017%2F10%2F12%2FJava%20IO-%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Java中有几种类型的流？ 字节流，继承于InputStream，OutputStream。 字符流，继承于Reader，Writer。 文件复制123456789101112131415161718192021222324252627282930313233343536373839import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.nio.ByteBuffer;import java.nio.channels.FileChannel;public class Test &#123; public static void fileCopy(String source, String target) throws IOException &#123; try (InputStream in = new FileInputStream(source)) &#123; try (OutputStream out = new FileOutputStream(target)) &#123; byte[] buffer = new byte[4096]; int bytesToRead; while((bytesToRead = in.read(buffer)) != -1) out.write(buffer, 0, bytesToRead); &#125; &#125; &#125; public static void fileCopyNIO(String source, String target) throws IOException &#123; try (FileInputStream in = new FileInputStream(source)) &#123; try (FileOutputStream out = new FileOutputStream(target)) &#123; FileChannel inChannel = in.getChannel(); FileChannel outChannel = out.getChannel(); ByteBuffer buffer = ByteBuffer.allocate(4096); while(inChannel.read(buffer) != -1) &#123; buffer.flip(); outChannel.write(buffer); buffer.clear(); &#125; &#125; &#125; &#125; public static void main(String[] args) throws IOException &#123; fileCopyNIO(&quot;e:\\1.txt&quot;, &quot;e:\\2.txt&quot;); &#125;&#125; Scanner接受键盘输入1234567891011121314151617import java.util.Scanner;public class Test &#123; public static void main(String[] args) &#123; try (Scanner scanner = new Scanner(System.in)) &#123; System.out.println(&quot;String Line:&quot; + scanner.nextLine()); System.out.println(&quot;String:&quot; + scanner.next()); System.out.println(&quot;Boolean:&quot; + scanner.nextBoolean()); System.out.println(&quot;Byte:&quot; + scanner.nextByte()); System.out.println(&quot;short:&quot; + scanner.nextShort()); System.out.println(&quot;Integer:&quot; + scanner.nextInt()); System.out.println(&quot;Long:&quot; + scanner.nextLong()); System.out.println(&quot;float:&quot; + scanner.nextFloat()); System.out.println(&quot;double:&quot; + scanner.nextDouble()); &#125; &#125;&#125; 输出： 123456789101112131415161718lineString Line:linereimuString:reimutrueBoolean:true12Byte:1214short:1422Integer:22342Long:3422.1float:2.14.5double:4.5 线程执行至scanner.nextXXX()时会阻塞(基本数据类型中没有针对char的操作)，等待用户输入。当接收到回车时认为用户输入完成。用户在此期间输入的内容会作为scanner.nextXXX()的返回值返回。当传入字节流对应的数据不符合接收函数的类型规范时会抛出异常。]]></content>
      <categories>
        <category>Java IO</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IO</tag>
        <tag>流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 算法题-查找链表中的倒数第k个结点]]></title>
    <url>%2F2017%2F10%2F12%2FJava%20%E7%AE%97%E6%B3%95%E9%A2%98-%E6%9F%A5%E6%89%BE%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class Test &#123; public static Node reGetKthNode(Node head, int k) &#123; if (k &lt;= 0) throw new IllegalArgumentException(&quot;k &lt;= 0&quot;); if (null == head) return null; Node p = head; Node q = head; // p移动k-1次。即保证p指在正数第k个结点上 for (int i = 1; i &lt; k; i++) &#123; if (null == p) break; p = p.next; &#125; // 链表没有正数第k个结点，自然不会有倒数第k个结点 if (null == p) return null; // 记忆时，可依k=1的特例记忆 while (null != p.next) &#123; p = p.next; q = q.next; &#125; return q; &#125; public static void main(String[] args) &#123; Node head = Node.createList(new int[] &#123;1, 2, 3, 4, 5&#125;); System.out.println(reGetKthNode(head, 5).data); &#125;&#125;class Node &#123; public int data; public Node next; public static Node createList(int[] a) &#123; Node head = new Node(); Node temp = head; for (int i = 0; i &lt; a.length; i++) &#123; temp.data = a[i]; if (i == a.length - 1) &#123; temp.next = null; &#125; else &#123; temp.next = new Node(); temp = temp.next; &#125; &#125; return head; &#125; public void show() &#123; Node temp = this; while (null != temp) &#123; System.out.print(temp.data + &quot;\t&quot;); temp = temp.next; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java 算法题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 算法题-查找]]></title>
    <url>%2F2017%2F10%2F12%2FJava%20%E7%AE%97%E6%B3%95%E9%A2%98-%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[二分查找时间复杂度：O(logN) 12345678910111213141516171819202122public class Search &#123; public static int serch(int[] a, int key) &#123; if (null == a) throw new NullPointerException(&quot;a is null&quot;); return search(a, key, 0, a.length - 1); &#125; private static int search(int[] a, int key, int begin, int end) &#123; if (begin &gt; end) return -1; int mid = begin + (end - begin) / 2; if (key == a[mid]) return mid; if (key &lt; a[mid]) return search(a, key, begin, mid - 1); if (key &gt; a[mid]) return search(a, key, mid + 1, end); return -1; &#125; public static void main(String[] args) &#123; int[] a = &#123;1, 2, 3, 5&#125;; System.out.println(serch(a, 3)); &#125;&#125;]]></content>
      <categories>
        <category>Java 算法题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 算法题-翻转单链表]]></title>
    <url>%2F2017%2F10%2F11%2FJava%20%E7%AE%97%E6%B3%95%E9%A2%98-%E7%BF%BB%E8%BD%AC%E5%8D%95%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class Test &#123; /** * 递归 */ public static Node reverse(Node node) &#123; if (null == node || null == node.next) return node; Node head = reverse(node.next); node.next.next = node; node.next = null; return head; &#125; /** * 遍历 */ public static Node reverse2(Node node) &#123; if (null == node || null == node.next) return node; Node p = node; // 前一个结点 Node c = node.next; // 当前结点 Node n = c; // 后一个结点 while (null != c) &#123; n = c.next; c.next = p; p = c; c = n; &#125; node.next = null; return p; &#125; public static void main(String[] args) &#123; Node head = Node.createList(new int[] &#123;1, 2, 3, 4, 5&#125;); head.show(); System.out.println(); reverse2(head).show(); &#125;&#125;class Node &#123; public int data; public Node next; public static Node createList(int[] a) &#123; Node head = new Node(); Node temp = head; for (int i = 0; i &lt; a.length; i++) &#123; temp.data = a[i]; if (i == a.length - 1) &#123; temp.next = null; &#125; else &#123; temp.next = new Node(); temp = temp.next; &#125; &#125; return head; &#125; public void show() &#123; Node temp = this; while (null != temp) &#123; System.out.print(temp.data + &quot;\t&quot;); temp = temp.next; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java 算法题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 算法题-跳线数组中的最大值]]></title>
    <url>%2F2017%2F10%2F11%2FJava%20%E7%AE%97%E6%B3%95%E9%A2%98-%E8%B7%B3%E7%BA%BF%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%2F</url>
    <content type="text"><![CDATA[求形如4,5,6,1,2,3中的最大值，可能会包含重复值。 123456789101112131415161718public static int serchMax(int[] a) &#123; if (null == a) throw new NullPointerException(&quot;a is null&quot;); return serchMax(a, 0, a.length - 1);&#125;private static int serchMax(int[] a, int begin, int end) &#123; if (a[end] &gt; a[begin]) return a[end]; while (begin &lt; end &amp;&amp; a[begin] == a[begin + 1]) begin++; if (begin == end) return a[begin]; while (a[end] == a[end - 1]) end--; int mid = begin + (end - begin) / 2; if (a[mid] &gt; a[mid + 1]) return a[mid]; if (a[mid] &gt;= a[begin]) &#123; return serchMax(a, mid + 1, end); &#125; else &#123; return serchMax(a, begin, mid - 1); &#125;&#125;]]></content>
      <categories>
        <category>Java 算法题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 基础-抽象类及接口]]></title>
    <url>%2F2017%2F10%2F10%2FJava%20%E5%9F%BA%E7%A1%80-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%8F%8A%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[接口接口可以继承接口，而且支持多重继承。 接口默认隐含的修饰符为public abstract，且只能是public abstract。 接口中的字段默认隐含了public,static,final，且只能被这3个修饰符修饰。 接口中的方法默认隐含了public abstract(其实就是比普通的抽象方法多了public这个限制条件)，且只能被这两个修饰符修饰。 抽象类抽象类可以实现接口。 抽象类可继承具体类也可继承抽象类。 抽象类可以包含构造函数，但不能用来new实例，只能被子类的构造函数调用。看下面的小例子： 12345678public abstract class Test &#123; public abstract void m1(); public void m2() &#123; this.m1(); &#125;&#125; 编译是不会报错的。因为抽象方法无法new实例，而欲调用实例方法又必须先实例化，因此m2中的this必然是该抽象类的某个非抽象的孩子。 抽象方法抽象方法不可以是静态方法，被final修饰的方法，私有方法。因为这些方法不可以被继承，而抽象方法必须要依靠继承才得以实现。 抽象方法不可以是本地方法，因为本地方法已有本地方法实现，而抽象方法没有实现。 抽象方法不可以被synchronized修饰，因为同步控制必须涉及实现细节，而抽象方法没有实现。]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>抽象类</tag>
        <tag>接口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 基础-方法参数的值传递及引用传递]]></title>
    <url>%2F2017%2F10%2F10%2FJava%20%E5%9F%BA%E7%A1%80-%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92%E5%8F%8A%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%2F</url>
    <content type="text"><![CDATA[本质上，只有值传递这一种传递方式，所谓的引用传递是值传递的一种。即： 123456// 将2这个值复制一份传递给mint a = 2;m(a);// 将引用o复制一份并将其值传递给mm(o); 值传递的核心就在于”复制”。传递的并不是原始数据，而是复制出的，与原始数据相等的东西。因此方法对这个克隆体所做的一切操作都不会影响原始数据。 虽然理论基础是统一的，但是当传递的是引用时，可能会让人产生一些迷茫。这也是为什么很多人将引用传递从值传递中提出来单独论述的原因。例如： 12O o = new O();m(o); 执行m(o)时，会复制出一份引用o的副本o_c并将其传递给m。自此o与o_c就是两个完全独立的个体，不会再有任何瓜葛。但是问题在于，初始时，因为o_c是o的副本，因此其空间中存放的对象地址必然与o相同。进而，如果m中有如下操作： 1o = new O(); 此举相当于将o_c中存放的对象地址指向了一个新的对象。而由于o与o_c已完全独立，因此并不会导致o中存放的对象地址发生变化。 但是，如果我们在m中做如下操作： 1o.setName(&quot;八云紫&quot;); 此时o_c并没有修改其内部存放的对象地址，而是直接操作了该对象中的数据。对此o中存放的对象地址依然没有发生变化，但由于其所存放的对象本身被o_c的操作所修改，看起来仿佛是传递进方法的引用影响了原始引用一样。但是即便如此，o_c也没有真正修改o中存储的值。 举一个生活中的小例子：小王手中有一个神秘网站的网址，从这个网站可以下载神奇的影片。本质上，小王所拥有的并非网站本身，而仅仅是网址这个字符串。小刘抄到了这个网址，那么无论小刘做什么事，对小王所拥有的那个字符串都不会造成影响。注意：这里所说的不会被影响的事物是小王的”网址字符串”。若小刘仅仅只是修改他拿到的网址为另一个网址，那么对小王完全没影响。如果小刘因为没钱充会员导致无法下载神奇的影片而一怒之下黑进了这个网站并将其中的影片全部换成了金刚葫芦娃，那么小王也无法在这个网站下载神奇的影片了。此时，小李所改变的是网站本身，并不是小王所持有的网址字符串。]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>值传递</tag>
        <tag>引用传递</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 基础-hashCode与equals]]></title>
    <url>%2F2017%2F10%2F10%2FJava%20%E5%9F%BA%E7%A1%80-hashCode%E4%B8%8Eequals%2F</url>
    <content type="text"><![CDATA[hashCode()与equals(Object obj)的设计原则在设计hashCode()及equals(Object obj)时，应满足如下两点： hashCode()相等，equals(Object obj)不一定相等。 equals(Object obj)相等，hashCode()必然相等。 如果违背了第一条，即强行要求hashCode()相等必有equals(Object obj)相等，那么配合第二条，hashCode()与equals(Object obj)就变成一回事了。换句话说，我们为了能够区分两个对象，必须保证能为其分配一个唯一的int型数字，这样做的成本太高了，对于集合型的对象而言，这甚至几乎是不可做到的。 如果违背了第二条，那么基于该规则定义的法则将受到动摇，程序可能发生难以预期的错误。 例如，Map之所以能快速找到作为key的对象，是因为其查找过程分为两步：首先通过hashCode()计算出对象在散列表中的位置，然后在该位置中使用equals(Object obj)进行线性查找。插入过程也类似：首先通过hashCode()计算出对象在散列表中的位置，然后通过equals(Object obj)判断该位置是否已有待插入对象，若已有则拒绝插入。 显然，如果违背了第二条，在插入时equals(Object obj)相等的对象因为不在同一个散列值下都可以插入Map中了，这违背了Map的key不可重复的原则。而查到时，自然也无法正确定位到满足equals(Object obj)相等的对象。例如： 1234567891011121314151617181920212223242526272829import java.util.HashMap;import java.util.Map;public class Test &#123; private int hashCode; public Test(int hashCode) &#123; this.hashCode = hashCode; &#125; @Override public boolean equals(Object obj) &#123; return true; &#125; @Override public int hashCode() &#123; return this.hashCode; &#125; public static void main(String[] args) &#123; Map&lt;Test, Object&gt; map = new HashMap&lt;Test, Object&gt;(); map.put(new Test(0), null); map.put(new Test(1), null); System.out.println(map.size()); // 输出2 System.out.println(map.containsKey(new Test(2))); // 输出false &#125;&#125; equals(Object obj)必须满足的原则 自反性：x.equals(x)必须返回true。 对称性：x.equals(y)返回true时，y.equals(x)也必须返回true。 传递性：x.equals(y)和y.equals(z)都返回true时，x.equals(z)也必须返回true。 一致性：当x和y引用的对象信息没有被修改时，多次调用x.equals(y)应该得到同样的返回值。而且对于任何非null值的引用x，x.equals(null)必须返回false。 equals(Object obj)设计技巧 使用==操作符检查参数是否为这个对象的引用。 使用instanceof操作符检查参数是否为正确的类型。 对于类中的关键属性，检查参数传入对象的属性是否与之相匹配。 编写完equals方法后，确认是否满足自反性，对称性，传递性及一致性。 重写equals时总是要重写hashCode。 不要将equals方法参数中的Object对象替换为其他的类型，在重写时不要忘掉@Override注解。 为何hashCode()常用素数31？以java.util.AbstractList中的hashCode()为例： 123456public int hashCode() &#123; int hashCode = 1; for (E e : this) hashCode = 31*hashCode + (e==null ? 0 : e.hashCode()); return hashCode;&#125; 为何是素数：素数减少了相乘后质因数分解的个数，和合数相比减少了冲突的概率。 为何是31：如果仅仅是为了避免冲突，理论上越大的素数越利于避免冲突。但是过大的素数又有导致溢出的风险。31就是这样一个大小适中的素数。同时，31 * num 等价于(num &lt;&lt; 5) – num，JVM对这个计算做过特殊的优化。]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>hashCode</tag>
        <tag>equals</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 基础-重载与重写]]></title>
    <url>%2F2017%2F10%2F10%2FJava%20%E5%9F%BA%E7%A1%80-%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%87%8D%E5%86%99%2F</url>
    <content type="text"><![CDATA[关于重载和重写的底层实现，可参见JVM-运行期方法调用，本文将从解题技巧的角度上分析重载与重写。 解题技巧不妨设计一种通用的场景： 12G0 o = new G0/G1();o.m(P p); 其中G1为G0的孩子(儿子，孙子，重孙…)。 总体思路 解重载(Overload)与重写(Override)问题其实就是模拟运行期JVM的方法调用操作：首先，无论如何都会在类加载的连接-解析阶段进行静态多分派(如果需要重载则重载)。随后，如果有必要(实际类型与静态类型不同)，在运行到该调用指令时进行动态单分派(即重写)。 静态方法，私有方法，构造方法，被final修饰的方法不可被子类继承，连接方式被称为解析。解析在类加载的连接-解析阶段完成，采用的手段为静态多分派(其间可能会发生重载)。但绝不会有重写(不能被子类继承，自然也不能出现静态类型与实际类型不同的情况)。换句话说，这些方法只会进行解题步骤中的第一步。 对于其他能被子类继承的方法而言，除了依然要进行静态多分派之外，在运行到该调用指令时，如果有必要(实际类型与静态类型不同)，还需进行动态单分派(即重写)。因此解题步骤中的两步都要进行。 问题的实质其实是确定两个”哪个”：调用”哪个类”的”哪个方法”。 解题步骤： 1.模拟静态多分派 只考虑方法调用者o的静态类型，本步骤的所有操作都局限在这个类(即例子中的G0)中。在G0中定位出具体的m(P p)，所找寻的方法不仅仅是显式写在G0中的，G0从父类中继承到的也算。若G0中有若干个同名的方法，即需要重载。参数数量及顺序不同导致的重载易于判断，而对于存在继承关系的类型判断，寻找与P p在血缘中最为亲密的那一个。在进行类型判断时，不需要考虑方法参数P的实际类型，只以其静态类型为依据。 实质上，无论是o还是p，该阶段都只需要判断静态类型，因为只要没有实际运行到这一行字节码指令，JVM就无法知道实际类型到底是什么。 一旦该阶段完成，重载便已彻底完成其使命，后续的判断中不再涉及重载，”哪个方法”的问题也已解决一大半。不妨设此阶段决定的方法为G0类中的x，则在本次解题中，G0中对后续操作有意义的方法只有x，其余方法都可以作为干扰项剔除。 本步所模拟的过程是在类加载的连接-解析阶段完成的，其判断依据完全来自于编译期。因此称之为”静态”；本步的判断依据为静态类型及方法参数两个宗量，因此称之为”多分派”。 2.模拟动态单分派 如果静态类型与实际类型相同，即不存在重写的可能，则”哪个类”为G0，”哪个方法”为步骤1确定的x。 如果静态类型与实际类型不同，或者具体的说，实际类型是静态类型的子类，则此时存在重写的可能(注意仅仅是可能)。G1继承了源自G0的x(再次强调，只关注x，G0中的其他方法已与本题无关)，若发生了重写，则G1中的x将覆盖从G0中继承的x。换句话说，G1中的x已经是被G1覆盖过之后的了。最终，”哪个类”为实际类型，”哪个方法”为实际类型中的x。 所以简单来说，本步主要回答了以下两点问题：实际类型是否和静态类型一样？若不一样，是否发生了重写？判断重写的规则如下： 方法的参数：必须一模一样，包括个数，顺序，类型(有继承关系的子类也不行，必须是一模一样的类)。 返回值：一样或为有继承关系的子类。 异常检查：对于Checked Exception而言，可以抛出更少的异常，但不能抛出父类中没有定义的异常。对于Unchecked Exception(RuntimeException)及Error而言则没有限制。 访问权限：应比父类中的权限更宽松，换句话说，即允许被更多人访问(public &gt; protected &gt; default[即没有修饰] &gt; private)。 本步所模拟的过程是在具体执行到当行调用方法的字节码指令时完成的，因此称之为”动态”；本步的判断依据仅为实际类型这一个宗量(第三次强调，方法x在步骤1已确定，其参数自然也已确定，重写的判断依据之一就是要求参数必须一模一样)，因此称之为”单分派”。 例题1123456789101112public class Test &#123; public boolean equals(Test test) &#123; System.out.println(&quot;Test equals&quot;); return true; &#125; public static void main(String[] args) &#123; Object o = new Test(); System.out.println(o.equals(new Test())); &#125;&#125; 输出： 1false 分析： 步骤1，模拟静态多分派:静态类型为Object，调用的方法为equals(Test test)，Object中与之血缘关系最亲近的方法为equals(Object obj)。 步骤2，模拟动态单分派：实际类型为Test，步骤1中确定的方法在Test中没有被重写(方法参数的类型不完全相同)。因此，最终确定被调用的方法为Test类中继承自Object类的equals(Object obj)，或者更准确的说，调用的方法为Object类中的equals(Object obj)。因为该类中的比较是基于对象地址的，因此两个不同的对象的比较结果自然为false。 深入分析一下，做如下修改： 12345678910111213public class Test &#123; @Override public boolean equals(Test test) &#123; System.out.println(&quot;Test equals&quot;); return true; &#125; public static void main(String[] args) &#123; Object o = new Test(); System.out.println(o.equals(new Test())); &#125;&#125; 此时无法通过编译，Eclipse下的提示为： 1The method equals(Test) of type Test must override or implement a supertype method。 因此，如果我们试图重写父类方法，那么总是在新方法前面加上@Override是很正确的做法，因为它会在编译阶段就给出检查。 如果，想要重写，那么应做如下修改： 12345678910111213public class Test &#123; @Override public boolean equals(Object obj) &#123; System.out.println(&quot;Test equals&quot;); return true; &#125; public static void main(String[] args) &#123; Object o = new Test(); System.out.println(o.equals(new Test())); &#125;&#125; 输出： 12Test equalstrue 分析： 步骤1，模拟静态多分派:静态类型为Object，调用的方法为equals(Test test)，Object中与之血缘关系最亲近的方法为equals(Object obj)。 步骤2，模拟动态单分派：实际类型为Test，步骤1中确定的方法在Test中被重写，因此，最终确定被调用的方法为Test类中的equals(Object obj)。 例题212345678910111213141516171819202122public class Test &#123; public static void main(String[] args) &#123; G00 g00 = new G10(); G10 p = new G10(); g00.print(p); &#125;&#125;class G00 &#123; public void print(G00 g00) &#123; System.out.println(&quot;G00 G00&quot;); &#125;&#125;class G10 extends G00 &#123; public void print(G00 g00) &#123; System.out.println(&quot;G10 G00&quot;); &#125;&#125; 输出： 1G10 G00 分析： 步骤1，模拟静态多分派:静态类型为G00，调用的方法为print(G10 p)，G00中与之血缘关系最亲近的方法为print(G00 g00)。 步骤2，模拟动态单分派：实际类型为G10，步骤1中确定的方法在G10中被重写，因此，最终确定被调用的方法为G10类中的print(G00 g00)。 稍加修改： 1234567891011121314151617181920212223242526public class Test &#123; public static void main(String[] args) &#123; G00 g00 = new G10(); G10 p = new G10(); g00.print(p); &#125;&#125;class G00 &#123; public void print(G00 g00) &#123; System.out.println(&quot;G00 G00&quot;); &#125; public void print(G10 g10) &#123; System.out.println(&quot;G00 G10&quot;); &#125;&#125;class G10 extends G00 &#123; public void print(G00 g00) &#123; System.out.println(&quot;G10 G00&quot;); &#125;&#125; 输出： 1G00 G10 分析： 步骤1，模拟静态多分派:静态类型为G00，调用的方法为print(G10 p)，G00中与之血缘关系最亲近的方法为print(G10 g10))。 步骤2，模拟动态单分派：实际类型为G10，步骤1中确定的方法在G10中没有被重写。因此，最终确定被调用的方法为G10类中继承自G00类的print(G10 g10)，或者更准确的说，调用的方法为G00类中的print(G10 g10)。]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>重载</tag>
        <tag>重写</tag>
        <tag>分派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 并发-线程阻塞工具类LockSupport]]></title>
    <url>%2F2017%2F10%2F07%2FJava%20%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E9%98%BB%E5%A1%9E%E5%B7%A5%E5%85%B7%E7%B1%BBLockSupport%2F</url>
    <content type="text"><![CDATA[Java 并发-Thread类中介绍过一对挂起-恢复线程的方法，它们是Thread类的suspend()及resume()方法。因为线程在使用suspend()方法挂起时不会让出任何资源，因此这一对方法现在已被标记为废弃。 那么该如何做到线程的挂起-恢复呢？Object类的wait()及notify()虽然也能起到挂起-恢复的功能，但它们最本质的功能是为synchronized机制提供通信，即便做到了线程的挂起-恢复也仅仅只是附带的结果，而非手段。而且wait()及notify()必须在synchronized代码块的范围内由其所从属的监视器对象调用，不仅灵活度不够，也不合理：线程的挂起及恢复是线程自身意愿的体现，不应该必须限制在synchronized同步代码块内，因为事实上二者并没有必然的联系。 LockSupport就是Java API针对这个问题提供的解决策略。它是一个方便使用的线程阻塞工具，可以看作是suspend()及resume()的替代品，它同样可以在线程内任意位置让线程挂起。和suspend()及resume()相比，它还有如下改进： 被挂起的线程将让出一切资源，即处于WAITING状态。 不会出现类似于resume()被先调用导致唤醒信号丢失的情况。 和wait()及notify()相比，LockSupport的不同之处在于： 不会抛出InterruptedException。 和synchronized机制无关。不需局限在synchronized代码块的范围内。 可以这样认为，在线程的挂起-恢复这个问题上，LockSupport吸收了suspend()/resume()及wait()/notify()的优点。 java.util.concurrent.locks.LockSupport的类定义为： 1public class LockSupport 常用方法如下： 12345678910111213/** * 挂起当前线程 */public static void park()public static void parkNanos(long nanos)public static void parkUntil(long deadline)/** * 恢复传入线程 */public static void unpark(Thread thread) 下面来看一个小例子： 1234567891011121314151617import java.util.concurrent.locks.LockSupport;public class Test &#123; public static void main(String[] args) &#123; Runnable r = new Runnable() &#123; @Override public void run() &#123; LockSupport.park(); System.out.println(&quot;线程恢复并结束&quot;); &#125; &#125;; Thread t = new Thread(r); t.start(); LockSupport.unpark(t); &#125;&#125; 输出： 1线程恢复并结束 关于这个小例子，需要注意的是：事实上我们无法保证unpark()一定会在park()之前被调用。对于suspend()/resume()而言，这可能会导致恢复消息的丢失。然而对于LockSupport而言，无论unpark()与park()的调用顺序为何，都能保证恢复消息生效。其原因就在于LockSupport使用了类似于信号量的机制，每个线程都有一个唯一的信号量，可以称之为许可。unpark()会将该许可置为可用，park()会检查这个许可，若不可用则挂起并等待，若可用则消费这个许可并继续进行。 park()会将线程转为WAITING状态，如果我们将此时的线程dump出来，还会发现这个WAITING状态被贴心的标记为是由park()引起的。如果我们想在dump时获得更多的信息，还可使用如下方法： 1public static void park(Object blocker) blocker被称为被挂起线程的阻塞对象，这样在分析问题时，就能更加的方便。 前文在比较LockSupport与wait()/notify()的差异时，提到LockSupport不会抛出InterruptedException，这并不意味着park()不响应中断，它只是不抛出InterruptedException：它会什么都不做，默默的返回。例子如下： 1234567891011121314151617import java.util.concurrent.locks.LockSupport;public class Test &#123; public static void main(String[] args) &#123; Runnable r = new Runnable() &#123; @Override public void run() &#123; LockSupport.park(); System.out.println(&quot;线程继续，中断标志=&quot; + Thread.interrupted()); &#125; &#125;; Thread t = new Thread(r); t.start(); t.interrupt(); &#125;&#125; 输出： 1线程继续，中断标志=true]]></content>
      <categories>
        <category>Java 并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>阻塞</tag>
        <tag>LockSupport</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 并发-守护线程]]></title>
    <url>%2F2017%2F10%2F07%2FJava%20%E5%B9%B6%E5%8F%91-%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[守护线程(Daemon)：完成系统性服务。例如垃圾回收线程，JIT线程。 用户线程：完成应用程序的业务操作。 当用户线程全部结束时，也就意味着程序员指定的需求都已完成了。守护线程要守护的对象已经不存在了，守护线程也会结束。整个应用程序也就自然结束了。 小例子： 1234567891011121314public class Test &#123; public static void main(String[] args) &#123; Thread daemon = new Thread() &#123; @Override public void run() &#123; while (true) ; &#125; &#125;; // 手动将自定义的线程设置为守护线程。 daemon.setDaemon(true); daemon.start(); &#125;&#125; 执行后，程序会随着main线程的结束而结束。 注意守护线程的设置必须在其启动之前，如果按如下方式改写代码： 123456789101112131415public class Test &#123; public static void main(String[] args) &#123; Thread daemon = new Thread() &#123; @Override public void run() &#123; while (true) ; &#125; &#125;; daemon.start(); // 手动将自定义的线程设置为守护线程。 daemon.setDaemon(true); System.out.println(&quot;后续&quot;); &#125;&#125; 运行后程序抛出运行时异常： 123Exception in thread &quot;main&quot; java.lang.IllegalThreadStateException at java.lang.Thread.setDaemon(Thread.java:1388) at com.test.Test.main(Test.java:14) 此时程序无法随着main线程的结束而结束。换言之daemon.setDaemon(true);失败了。daemon并非作为守护线程而是普通的用户线程在运行着。 main线程因抛出异常而终止，因此其后续的语句无法执行；daemon线程作为普通应用线程不受影响，因此程序会无限循环下去。]]></content>
      <categories>
        <category>Java 并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>守护线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 并发-线程组]]></title>
    <url>%2F2017%2F10%2F06%2FJava%20%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E7%BB%84%2F</url>
    <content type="text"><![CDATA[线程组与线程池的区别 线程组关注的是线程在逻辑上的从属，使用线程组可让程序的逻辑结构更清晰，更利于模拟复杂的现实环境；线程池关注的是线程的管理，使用线程池可以避免线程频繁的创建与关闭，提高系统性能。 美好的猜想：从线程池处获得线程，而后交由线程组进行业务上的划分管理。 实际上：向线程池提交的是Runnable，具体Thread是由线程池内部创建的。而关联Thread与ThreadGroup需要在新建Thread时显示声明。因此当前尚未找到能让二者协调工作的方法。 或者说，这个猜想本质上是错误的：线程池管理的并非一个个已经成型的线程。即用以构建线程池中的线程所需提供的素材并非线程本身，而是生成线程的核心部件Runnable。也就是说线程池并不希望我们确定下来线程再交给它，这样它也就没法管理了。使用线程池时我们只管从池子里取线程即可，该线程是基于我们传入的Runnable生成的，因此可以满足我们的业务需求，至于这个线程是何时生成的，怎么生成的我们一概不管。而线程组是在明确的给线程打上编号：即某某线程属于某某组。一定要先有一个明确的线程才行。因此二者是无法协同工作的。 线程池适用的场景：大量的量产型工人迅速的出生死亡做着流程化的工作，我们不关心干活的工人是谁，甚至于我们认为新出生的工人其实不是新出生的，而是一个我们以为已经死了的工人其实没死复用的，这都无所谓，只要核心部件Runnable相同，线程池创造出的工人能力就是相同的，他们都可以毫不违和的做其他工人的工作，他们没有”自我”，没有某个工作只有这个线程才能做的情况，他们之间可以互相替代。 线程组适用的场景：固定的几个精英人士长时间生存，他们的工作是独一无二的，只有他们才能做，因此比起他们做的事，对他们本身的管理更为重要，因为他们的人和他们做的事是一一对应的，管理了他们的人，自然相当于管理了他们做的事。 下面的示例说明了这个问题。 线程组示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class Test implements Runnable &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + &quot; start...&quot;); synchronized(Test.class) &#123; try &#123; Test.class.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; private static void showThreadGroup(ThreadGroup threadGroup) &#123; System.out.println(&quot;=========== &quot; + threadGroup.getName() + &quot; ===========&quot;); // 已启动而未终止的线程数，阻塞状态或等待状态均算。 // 由于线程是动态的，因此这个值只是估计值，无法保证精确。 System.out.println(&quot;当前活跃线程数&quot; + threadGroup.activeCount()); System.out.println(&quot;包含线程信息:&quot;); threadGroup.list(); &#125; public static void main(String[] args) throws InterruptedException &#123; ThreadGroup hongMoGuan = new ThreadGroup(&quot;红魔馆&quot;); ThreadGroup yongYuanTing = new ThreadGroup(&quot;永远亭&quot;); for (String name : new String[]&#123;&quot;蕾米莉亚&quot;, &quot;芙兰朵露&quot;, &quot;帕秋莉&quot;&#125;) new Thread(hongMoGuan, new Test(), name).start(); for (String name : new String[]&#123;&quot;蓬莱山辉夜&quot;, &quot;八意永琳&quot;, &quot;铃仙&quot;&#125;) new Thread(yongYuanTing, new Test(), name).start(); Thread.sleep(10); Test.showThreadGroup(hongMoGuan); Test.showThreadGroup(yongYuanTing); Thread.sleep(10); System.out.println(&quot;=========== 罪袋在工作 ===========&quot;); ExecutorService zuidaiEs = Executors.newFixedThreadPool(3); Runnable zuidai = new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;罪袋 &quot; + Thread.currentThread().getId() + &quot; 完成工作，被回收...&quot;); &#125; &#125;; // 需要干出10个罪袋的工作量的活。 // 我们不关心到底有几个罪袋真正工作了：也许有10个罪袋各干了一人份的活；也许只有两个罪袋每人干了5人份。 // 只要结果上干完了就行。 for (int i = 0; i &lt; 10; i++) zuidaiEs.submit(zuidai); &#125;&#125; 输出结果： 12345678910111213141516171819202122232425262728293031芙兰朵露 start...蕾米莉亚 start...蓬莱山辉夜 start...八意永琳 start...铃仙 start...帕秋莉 start...=========== 红魔馆 ===========当前活跃线程数3包含线程信息:java.lang.ThreadGroup[name=红魔馆,maxpri=10] Thread[蕾米莉亚,5,红魔馆] Thread[芙兰朵露,5,红魔馆] Thread[帕秋莉,5,红魔馆]=========== 永远亭 ===========当前活跃线程数3包含线程信息:java.lang.ThreadGroup[name=永远亭,maxpri=10] Thread[蓬莱山辉夜,5,永远亭] Thread[八意永琳,5,永远亭] Thread[铃仙,5,永远亭]=========== 罪袋在工作 ===========罪袋 15 完成工作，被回收...罪袋 17 完成工作，被回收...罪袋 17 完成工作，被回收...罪袋 16 完成工作，被回收...罪袋 16 完成工作，被回收...罪袋 17 完成工作，被回收...罪袋 17 完成工作，被回收...罪袋 15 完成工作，被回收...罪袋 17 完成工作，被回收...罪袋 16 完成工作，被回收... 终止线程组中的线程(stop)ThreadGroup类提供如下方法： 1public final void stop() 类似于Thread类提供的stop()，ThreadGroup类提供的stop()会强制终止线程组中的所有线程。理所当然的该方法也会有Thread类中stop()类似的问题。因此和Thread类中的stop()一样，该方法也是废弃方法。]]></content>
      <categories>
        <category>Java 并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>线程组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 并发-Thread类]]></title>
    <url>%2F2017%2F10%2F05%2FJava%20%E5%B9%B6%E5%8F%91-Thread%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[123java.lang.Threadpublic class Thread implements Runnable 线程终止(stop)Thread类提供了终止线程的方法： 1public final void stop() 类似于linux中的kill -9对进程的处理，调用该方法后，会由JVM强制从外部粗暴的杀掉线程。被杀掉的线程没有机会对其已做的事情做妥善的处理，可能会导致数据不一致的问题(已经改到一半的数据没机会回滚)。因此stop()是一个被废弃的方法。 用户程序可自己实现安全停止线程的方法： 12345678910111213141516171819202122public class Test extends Thread &#123; private volatile boolean ifStop; public void stopMe() &#123; this.ifStop = true; &#125; @Override public void run() &#123; while (true) &#123; if (this.ifStop) break; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; Test test = new Test(); test.start(); Thread.sleep(3000); test.stopMe(); // 经过3s的睡眠后，线程终止 &#125;&#125; 线程中断(interrupt)stop()方法之所以只能强制停止线程是因为JVM无法了解用户程序的业务逻辑，即无法判断何时才算是”告一段落”，何时终止线程才不会写坏数据。而上文中实现的安全停止线程的方法其实思路很简单，也很机械：在合适的，不会写坏数据的位置设置一个停止的标记，然后在合适的时机激活它。除了自己实现外，JDK也提供了一套中断机制来实现这个功能。 Thread类中和中断有关的方法有3个： 1public void interrupt() 和上文的stopMe()类似，仅仅将中断标记设置为true，如果没有具体的中断处理逻辑的话单纯调用该方法是没有意义的。 1public boolean isInterrupted() 实例方法：通过中断标记判断线程是否已被标记为中断。 1public static boolean interrupted() 类方法：通过当前线程的中断标记判断当前线程是否已被中断。 如果使用Java的中断机制，上文中实现的安全停止线程的方法变为： 12345678910111213141516public class Test extends Thread &#123; @Override public void run() &#123; while (true) &#123; if (this.isInterrupted()) break; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; Test test = new Test(); test.start(); Thread.sleep(3000); test.interrupt(); // 经过3s的睡眠后，线程终止 &#125;&#125; 或： 12345678910111213141516public class Test extends Thread &#123; @Override public void run() &#123; while (true) &#123; if (Thread.interrupted()) break; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; Test test = new Test(); test.start(); Thread.sleep(3000); test.interrupt(); // 经过3s的睡眠后，线程终止 &#125;&#125; 除了减少代码量外，因为中断机制是JDK所实现的基本功能，自然也能配合JDK的其他功能。sleep(), wait()/wait(long millis), join()/join(long millis) 等均可以响应中断。 sleep()响应中断的例子： 123456789101112131415161718public class Test extends Thread &#123; @Override public void run() &#123; try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; System.out.println(&quot;线程被中断&quot;); System.out.println(&quot;此时的中断标志为：&quot; + this.isInterrupted()); &#125; &#125; public static void main(String[] args) &#123; Test test = new Test(); test.start(); test.interrupt(); &#125;&#125; 执行后的输出为： 12线程被中断此时的中断标志为：false 这段代码的结果说明两点问题： 处于睡眠状态的线程在接到中断信息后会以抛出受检查异常InterruptedException的方式响应中断(这也是为什么sleep()要强制检查InterruptedException的原因)。 sleep()响应过中断后，线程的中断标记被重新置为false。可以理解为一次中断请求仅会被处理一次。 wait()响应中断的例子： 1234567891011121314151617181920public class Test extends Thread &#123; @Override public void run() &#123; synchronized (Test.class) &#123; try &#123; Test.class.wait(); &#125; catch (InterruptedException e) &#123; System.out.println(&quot;线程被中断&quot;); System.out.println(&quot;此时的中断标志为：&quot; + this.isInterrupted()); &#125; &#125; &#125; public static void main(String[] args) &#123; Test test = new Test(); test.start(); test.interrupt(); &#125;&#125; 执行后的输出为： 12线程被中断此时的中断标志为：false 对该代码的分析同sleep()的例子。 join()响应中断的例子： 1234567891011121314151617181920212223242526272829303132333435363738public class Test implements Runnable &#123; private Thread t; public Test(Thread t) &#123; this.t = t; &#125; @Override public void run() &#123; try &#123; this.t.join(); &#125; catch (InterruptedException e) &#123; System.out.println(Thread.currentThread().getName() + &quot;被中断&quot;); this.t.interrupt(); &#125; &#125; public static void main(String[] args) &#123; Runnable r1 = new Runnable() &#123; @Override public void run() &#123; try &#123; synchronized (Test.class) &#123; Test.class.wait(); &#125; &#125; catch (InterruptedException e) &#123; System.out.println(Thread.currentThread().getName() + &quot;被中断&quot;); &#125; &#125; &#125;; Thread t1 = new Thread(r1, &quot;t1&quot;); Thread t2 = new Thread(new Test(t1), &quot;t2&quot;); t1.start(); t2.start(); t2.interrupt(); &#125;&#125; 执行后程序会在极短的时间内结束，且输出如下： 12t2被中断t1被中断 对该代码的分析同wait()的例子。因为调用t.join()实质上就是让当前线程wait在了t的等待队列上。 该代码首先t2.interrupt();触发了this.t.join();的中断，因为其实质上是将当前线程(即t2)加入到了t1的等待队列中，因此响应中断的实质是t1的wait()。在this.t.join();的中断处理逻辑中又触发了t1的中断，此时t1在Test.class的等待队列中等待，触发中断后t1也进入中断响应逻辑处理代码，程序得以结束。 挂起(suspend)与继续执行(resume)Thread提供了如下方法： 123public final void suspend()public final void resume() 挂起(suspend)与继续执行(resume)所实现的功能基本与Object类的wait()及notify()相同。不同之处主要有两点： wait()及notify()必须与synchronized配合使用。suspend()及resume()则没有限制。 处于可运行(RUNNABLE)状态的线程调用wait()后进入无限期等待(WAITING)状态，并放弃CPU和已获得的监视器对象的认可；处于可运行(RUNNABLE)状态的线程调用suspend()后依然还是可运行(RUNNABLE)状态，且不会放弃任何已获得的资源；也就是说，suspend()纯粹是线程内部的打算，和用户程序自己设计实现的忙等待并发程序很类似：在JVM看来，进入挂起状态的程序依然是在运行的，和非挂起状态没什么不同。正因为如此，挂起(suspend)与继续执行(resume)被标记为了废弃方法。 等待线程结束(join)Thread提供了如下方法： 12345public final void join() throws InterruptedException &#123; join(0);&#125;public final synchronized void join(long millis) throws InterruptedException t.join()相当于让当前线程一直等到t执行结束后再继续向下执行。 join()本质上是由join(long millis)实现的，而join(long millis)本质上是由wait(long millis)。换句话说t.join()的本质为：将当前线程加入t的等待队列，再直白些说，就是调用了t.wait()，在t执行结束后再调用t.notifyAll()唤醒所有线程。这种逻辑带来了两个比较糟糕的问题： 问题1：notifyAll()唤醒的是所有挂在t等待队列上的线程，也就是说不是因为join()被挂上去的线程也被唤醒了，代码求证如下： 12345678910111213141516171819202122232425public class Test &#123; public static void main(String[] args) &#123; Runnable r1 = new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; Thread t1 = new Thread(r1); t1.start(); synchronized (t1) &#123; try &#123; t1.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(&quot;after wait on t1&quot;); &#125;&#125; 设定的1s过去后，输出了after wait on t1。而如果注掉t1.start();，程序将不会有输出，且main线程会因等待t1而无法完成。其原因就在于t1为了支持join()方法，会在结束时调用t1.notifyAll()方法，此时本不希望被唤醒的main方法线程就被意外唤醒了。 问题2：如果我们主动调用了notifyAll()唤醒了join()在t上的线程，甚至于我们足够不幸，调用notify()时随机唤醒了join()在t上的线程，这都不是我们所希望的(仅是理论分析，代码求证失败了，可能是还有其他保护机制)。 为了避免这两种情况的出现，不要将Thread的实例对象作为监视器对象。 谦让(yield)Thread类提供了如下方法： 1public static native void yield(); 运行(RUNNING)状态的当前线程调用yield()后会进入就绪(READY)状态，即主动让出CPU。需要注意的有两点： 无论运行(RUNNING)抑或就绪(READY)，都是可运行(RUNNABLE)。调用yield()后只是让出了已占有的CPU资源，并没有让出其他资源。 调用yield()进入就绪(READY)状态的线程依然还会依据基本法进行下一轮的资源竞争。 CPU只会被让给具有相同或更高优先级的线程。 无需运行于synchronized代码块中。]]></content>
      <categories>
        <category>Java 并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>线程</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EditPlus-配置]]></title>
    <url>%2F2017%2F10%2F04%2FEditPlus-%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[配色方案修改editplus_u.ini为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116[Options]Placement=2C0000000200000003000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF140000000000000000050000A8020000FFWindow List=00000000000000000000000000000000FFMarker List=00000000000000000000000000000000FFFunction List=00000000000000000000000000000000FFOpen Remote=5C020000550100006404000067030000FFExpand=00000000000000000000000000000000FFProject Pos=00000000000000000000000000000000FFWorkspace Path=D:\work\EditPlusCliptext Window=224Cliptext Window 2=489Output=90Output 2=170Folding=1FindX=586FindY=429Find=alignTab Index=1Cliptext=2Custom colors=6D6D7200FFFFFF00FFFFFF00FFFFFF00FFFFFF00FFFFFF00FFFFFF00FFFFFF0031282700FFFFFF00FFFFFF00FFFFFF00FFFFFF00FFFFFF00FFFFFF00FFFFFF00FFMatching Brace=1Indent guide=1Cliptext Edit=00000000000000000000000000000000FF[Files]Encoding=65001Backup=0Backup Remote=0[Fonts]Edit Window=F0FFFFFF00000000000000000000000090010000000000000302013143006F007500720069006500720020004E0065007700000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFPrinter=F4FFFFFF00000000000000000000000090010000000000000000003143006F007500720069006500720020004E0065007700000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFOutput Window=F4FFFFFF00000000000000000000000090010000000000000000003143006F007500720069006500720020004E0065007700000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFCliptext Window=F4FFFFFF0000000000000000000000009001000000000001000000004D006900630072006F0073006F006600740020005900610048006500690020005500490000000000000000000000000000000000000000000000000000000000FFDocument Selector=F4FFFFFF0000000000000000000000009001000000000001000000004D006900630072006F0073006F006600740020005900610048006500690020005500490000000000000000000000000000000000000000000000000000000000FFHex Viewer=F4FFFFFF00000000000000000000000090010000000000010000003143006F007500720069006500720020004E0065007700000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFCustom 1=F4FFFFFF00000000000000000000000090010000000000000000002241007200690061006C000000720020004E0065007700000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFCustom 2=F5FFFFFF000000000000000000000000900100000000000000000022560065007200640061006E00610000004E0065007700000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFCustom 3=F4FFFFFF000000000000000000000000900100000000000000000012540069006D006500730020004E0065007700200052006F006D0061006E0000000000000000000000000000000000000000000000000000000000000000000000FFCustom 4=F5FFFFFF0000000000000000000000009001000000000000000000224D0053002000530061006E0073002000530065007200690066000000000000000000000000000000000000000000000000000000000000000000000000000000FFCustom 5=F3FFFFFF00000000000000000000000090010000000000FF000000315400650072006D0069006E0061006C00000065007700000000000000000000000000000000000000000000000000000000000000000000000000000000000000FF[Tool Option]Top Selector=1[Colors\Text]Background=2238503Default=0Foreground=16777215[Colors\Keyword 1]Foreground=8272368Default=0[Colors\Embedded script]Foreground=16777215Default=0[Colors\Keyword 3]Foreground=16777215Default=0[Colors\Keyword 6]Foreground=8716287Default=0[Colors\Keyword 7]Foreground=8716287Default=0[Colors\Keyword 8]Foreground=8716287Default=0[Colors\Keyword 9]Foreground=8454143Default=0[Colors\Keyword 10]Foreground=8716287Default=0[Colors\Quotation]Foreground=8454143Default=0[Colors\Quotation 2]Foreground=5107956Default=0[Colors\Line comment]Foreground=10789024Default=0[Colors\Line number]Foreground=12632256Background=2238503Default=0[Colors\Folding mark -]Background=2238503Default=0[Colors\Matching words]Default=0Background=718314[Colors\Keyword 2]Foreground=16379142Default=0[Colors\Folding mark +]Background=2238503Default=0[Colors\Text selection]Background=7039851Default=0[Colors\Number]Foreground=16524240Default=0[Colors\Block comment]Foreground=8421504Default=0[Colors\Keyword 5]Foreground=15574913Default=0[Colors\Ruler]Foreground=12632256Default=0Background=2566187[Colors\Cursor indicator]Background=16777215Default=0[Colors\Indent Guide]Foreground=7499117Default=0]]></content>
      <categories>
        <category>EditPlus</category>
      </categories>
      <tags>
        <tag>EditPlus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 并发-并发级别]]></title>
    <url>%2F2017%2F10%2F04%2FJava%20%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E7%BA%A7%E5%88%AB%2F</url>
    <content type="text"><![CDATA[临界区被多线程并发请求时可能导致糟糕结果的资源被称为临界区。最稳妥的做法是，同一时间点仅有一个线程能请求到临界区。 从狭义的角度上讲，临界区并不等同于被多线程并发请求的资源。临界区是其的子集。若被多线程并发请求的资源不可能因为并发访问产生不可预期的结果，那么程序员完全可以不将其设置为临界区。从这个角度而言，一个资源是否是被多线程并发请求的资源是客观事实，不因人的意志而转移；但是其是否是临界区则主要依托于人的判断：对于我而言，这个共享资源是否会因并发访问而产生不可预期的结果？ 多线程的活跃性问题下面我们就重点说下这个”糟糕”，从糟糕程度由重到轻，依次为：死锁(Deadlock) –&gt; 饥饿(Starvation) –&gt; 活锁(Livelock)。 死锁 简单的小例子：线程A持有资源x而欲请求资源y。线程B持有资源y而欲请求资源x。不巧的是x，y均为临界区。如果现状得不到改善(AB均不愿意放弃已到手的资源)，那么死锁将一直进行下去，永远看不到解决的希望。因此死锁是活跃性问题中最糟糕的情况：它会直接导致被锁住的线程卡死。 饥饿 分为两种情况： 线程优先级不够高，导致其始终无法获得临界区。在自然界中，母鸟给小鸟喂食时，强壮的小鸟总会更容易的抢到食物，而瘦弱的小鸟则不得不忍受饥饿。这也是并发中”饥饿”这个概念的出处。 已占有临界区的线程迟迟不肯让出临界区，导致其他线程无法获得该临界区。 与死锁不同，饥饿总还是有希望解除的，起码不能像断言死锁那样断定饥饿的话这个程序就没救了。但是饥饿仍然是有着残酷的竞争的：列举的两种情况说明该资源确实足够抢手，也就是所谓的”狼多肉少”。往乐观了想，强壮的小鸟吃饱了，不乐意抢了，瘦弱的小鸟就有机会吃上饭了；但是往悲观了想，若母鸟带来的食物并没有那么充足，或者那些强壮的小鸟是吃撑了也要继续下去的吃货，此时瘦弱的小鸟就有被饿死的可能。 活锁 举一个生活中的小例子：一个狭窄的过道，仅容两人通过。此时有两人相对而行又恰好走在同一边。于是二人均产生了给对方让路的行为。于是两人同时的让向另一边。于是二人又把刚才的剧情重演了一遍：又撞上了。通常情况下，如果这两个人情商正常的话，往往会进行简单的眼神或言语沟通，然后两人就能很好的通行了。 然而计算机并不具备这种在人类看来最简单的”情商”。如果程序设计不得当，两个线程会无休止的这样谦让下去。 之所以说”活锁”没有”饥饿”那么糟，是因为本质上来说，”活锁”中并不存在资源竞争：资源是足够的，仅仅只是程序的设计不当而已。 并发级别并发级别描述的是面对上文中并发的缺陷，我们”该怎么办”，或者说”有何对策”。因此并发级别表达的是”请求方请求资源”时”请求方”的意愿。换成具体的情境，表达的就是”线程请求临界区”时线程的意愿及策略，属于主观愿望，也就是想不想的问题；而临界区中定义的”同一时间点仅有一个线程能请求到临界区”是临界区的客观情况，是能不能做得到的问题。线程在设定并发级别时如果足够”乐观”，那么便可能会任性的无视临界区的客观定义。 在应对并发问题的态度上，我们可以画一条数轴。负无穷大代表绝对的悲观：并发程序又复杂问题又多，咱们别并发了吧，如果实在要搞咱们就必须事无巨细把所有(注意是所有)可能的情况都catch住；正无穷大代表绝对的乐观：不要怂，就是干！问题，不存在的！ 这种绝对的二元论的说法显然很极端，但是它们却为我们提供了标杆，我们在设计并发程序时总会偏向其中一方一点。简单来说，越是悲观对并发的检查就越严格；越是乐观对并发的检查就越宽松。从悲观到乐观排序的话并发级别大致有如下几类：阻塞(Blocking) –&gt; 无饥饿(Starvation-Free) –&gt; 无障碍(Obstruction-Free) –&gt; 无锁(Lock-Free) –&gt; 无等待(Wait-Free)。 阻塞(Blocking) 临界区同一时刻仅有一个线程能进入。其他请求该临界区的线程全部等着。简单粗暴，使得对临界区的访问又变回了串行的状态。 无饥饿(Starvation-Free) 在简单粗暴的阻塞的基础上，增加了对多线程的活跃性问题中的饥饿情况的处理(换句话说，无饥饿依然是阻塞的，其仅仅只是对饥饿的情况做出了改善)。假设当前正在使用Java的锁机制实现并发(synchronized是监视机制，并非锁。其也无法做到后文提到的公平锁)，如果说普通的阻塞级别的锁是非公平锁(判断线程执行与否仅看其优先级)的话，那么无饥饿实现的就是所谓的公平锁。最简单的公平锁是完全无视线程的优先级，而完全只按时间上的先后顺序执行，此时相当于用时间上的先后顺序作为新的优先级替换了线程原有的优先级。较为复杂的实现会把时间作为优先级的一个分量和线程原有的优先级进行融合：也就是综合考虑线程优先级和其已等待的时间。 我们常说的公平锁是由重入锁(ReentrantLock)所实现的，该锁属于最简单的那类公平锁。 无障碍(Obstruction-Free) 无障碍是检查最为严格的非阻塞调度。 先来说阻塞与非阻塞的区别。模拟一个场景，两个线程并发请求临界区。阻塞级别的并发(阻塞及无饥饿)会切实遵守临界区的客观规定，老老实实的等着。而非阻塞则是两个线程都进入临界区，没出问题最好，出了问题再想办法解决。而”解决策略”的不同就在非阻塞这个大的概念下又分化出了不同的并发级别。 如果真实情况是并发冲突的频率并不高，也即临界区中所描述的”被多线程并发请求，且有可能因此导致糟糕结果的资源”中的”可能”并不常出现，那么非阻塞是优于阻塞的；但是如果这个”可能”的出现概率很高，那么非阻塞时的”解决策略”相应的登场就更为频繁。无论设计得多为巧妙。这个”解决策略”也是决计比不上一开始便谨慎的进行悲观处理的阻塞调度的。此时非阻塞调度便劣于阻塞调度了。 相对于阻塞而言，非阻塞已经足够乐观了。但是在非阻塞内部却仍可细分。无障碍便是非阻塞中最为悲观的那一个。其”解决策略”多种多样，一种可行的方案是依赖于”一致性标记”。假如当前临界区的一致性标记值为0。当线程1进入临界区后，会先更新这个值，例如改为1，代表线程1已进入，而后线程在临界区中操作(无论是读操作还是写操作)，当其完事决定退出时会再看一眼这个标记，若仍为1，说明在此期间没有别的线程进入临界区，也就是满足”乐观”的预期，可以自然的退出；但是如果在此期间线程2也进入了临界区，那么它会在进入后将标记值更新为2。此时线程1在完事后回看时就会发现值对不上了，此时它便会采用fail-fast原则(不管新来的那个线程做了什么，也许人家只是读，也许人家写的东西和你没关系。总之只要检测到有其他线程进来了就算失败)，回滚此前已做的操作，然后从头再来。 无障碍在冲突激烈时会导致临界区中的所有线程都不停的在回滚，极大的影响了程序的性能。严重时，没有一个线程能走出这个回滚的泥潭，形成一种伪死锁的状态。 无锁(Lock-Free) 无锁是一种特殊的无障碍。其诞生的目的就是为了解决无障碍”没有一个线程能走出这个回滚的泥潭”的问题。也就是说在任意时刻，无锁都能保证临界区中的线程中至少有一个可以在有限的步骤内离开临界区。因为仅能保证1个，因此排在后面的线程可能会面临饥饿的问题。 无等待(Wait-Free) 无等待在无锁的基础上又做了进一步的优化，其解决了无锁中的”饥饿”问题。无锁仅保证同一时刻内只有一个线程能在有限步骤内退出临界区，而无等待更进一步，要求临界区中的所有线程都能在有限的步骤内退出临界区。 无等待所采取的一种典型的”解决策略”就是RCU(Read-Copy-Update)：想要修改临界区的数据时，不能直接在临界区上修改，而是copy出一份当前的副本，而后在这个副本上修改，随后再在合适的时机写回。这样保证临界区不是”脏”的，也不会是写线程写到一半的中间态。因此读线程在进入临界区时就不需要任何并发控制了。这个做法与Git等代码版本控制库的做法很类似，大家可以对比着理解。]]></content>
      <categories>
        <category>Java 并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 并发-同步异步阻塞非阻塞]]></title>
    <url>%2F2017%2F10%2F03%2FJava%20%E5%B9%B6%E5%8F%91-%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E%2F</url>
    <content type="text"><![CDATA[同步(Synchronous)与异步(ASynchronous)是一组相对的概念，阻塞(Blocking)与非阻塞(Non-Blocking)是另一组相对的概念。 通常，同步异步被用以形容一次方法调用。阻塞非阻塞被用以形容多线程间的相互影响。但本质上，这两组概念都是在从不同角度描述同一类事件：请求方请求资源。 同步异步是资源的固有属性，或者说是资源的能力状态。和请求方打算怎么做无关：不管你请求的人有什么打算，我能提供的也就这样了。 阻塞非阻塞是请求方采取的策略，和资源的固有属性或能力状态无关：不管你能提供给我怎么样的资源，或者干脆提供不了，我不管我就要这么做。 因此，若以请求方为主视角的话，同步异步描述的是客观情况下被请求资源”能不能”的问题；阻塞非阻塞描述的请求方自身打算怎么做，也就是”想不想”的问题。 小例子：线程调用方法本例中，线程即为请求方，方法即为资源。 为了便于描述，不妨以日常生活中的例子：”小王烧水”来模拟这个小例子。”小王”代表”线程”，”水壶”代表”方法”。而小王烧水的这个行为代表线程对方法的调用。 同步异步是”水壶”的固有属性： 同步：普通水壶，烧开水后无提示。 异步：响铃水壶，烧开水后会响铃提示。 阻塞非阻塞是”小王”采取的策略： 阻塞：小王在水壶边等着直至水烧开。 非阻塞：小王开始烧水后即离开做别的事情。 同步/异步 阻塞/非阻塞 一共有如下4种排列组合： 同步阻塞小王用普通水壶烧水，他决定在水壶边等着直至水烧开。 同步非阻塞小王用普通水壶烧水，按照水壶本身的设计初衷，他本该在水壶边等着直至水烧开，但是可能会有如下情况：水烧开所需的时间长到无法忍受，例如水烧开需要1小时。显然在水壶边站1小时是很sb的行为，因此小王决定去客厅看电视，因为水壶没有响铃提示，小王只能在感觉差不多的时候”轮询”着反复回厨房看水烧开了没有。 异步非阻塞小王用响铃水壶烧水，烧上水后他就去客厅看电视了，响铃后他再回厨房取水。 异步阻塞明明水壶可以响铃，此时还站在水壶边上等貌似是很不理智的行为，但是可能会有如下情况导致在水壶边等着反而更好： 水烧开的时间灰常灰常短。短到和小王打算去做的事不成比例。例如水烧开需要10秒，而小王从厨房走到客厅需要1分钟。此时小王如果去客厅的话那么10秒后铃便响了，他还要再花10秒走回来，不仅没看上电视，还搭上了10秒(一直呆在水壶边只需要等10秒就好了)。 小王接下来要去做的事需要这壶水。]]></content>
      <categories>
        <category>Java 并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>同步</tag>
        <tag>异步</tag>
        <tag>阻塞</tag>
        <tag>非阻塞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 并发-线程池]]></title>
    <url>%2F2017%2F10%2F03%2FJava%20%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[线程池的产生背景在使用线程时，我们常会遇到以下的业务需求：以runnable1为核心声明thread1。不久后，我们又需要runnable1的功能了，但是此时thread1尚未执行完，或已因run()的结束被JVM回收，总之是没办法再利用了，我们只能以runnable1为核心声明一个新的线程thread2…类比下去，我们还可能需要生成thread3，thread4，thread5… 乍看下来似乎没毛病，然而，如果线程执行完成的速度跟不上线程创建的速度，程序所使用的线程数就会不断上升，但更底层操作系统所能承载的线程总数一定是有限的，持续下去，必然会导致没有充分的资源分配新的线程，使得程序崩溃。 即便线程执行完成的速度跟得上线程创建的速度，依然还会存在问题，只是没那么糟糕了而已：虽然与进程相比，线程是一种轻量级的工具，但其创建与回收依然需要花费时间与资源，而这其实是没有必要的。在我们所模拟的场景中，真正重要的只有runnable1，至于thread1，thread2…不过是为了完成runnable1功能的载体，事实上，如果我们能做到thread1在run()结束后不被回收，同时也能容忍只有一个线程串行执行的效率的话，那么只用thread1串行执行完全可以完成功能。 我们当然不能接受串行执行(否则引入线程的意义何在？)，不过照顾底层操作系统的承受能力，为runnable1设置一个允许创建的最大线程数还是很合理的，比如我们规定最大线程数是2，那么可能会有如下执行流程： 需求1:需要runnable1的功能，创建thread1。 需求2:需要runnable1的功能，创建thread2。 需求3:需要runnable1的功能，但是能创建的线程数已达上限。且thread1及thread2仍未执行完，只能继续等待。 需求2率先执行完了，这样thread2便空了出来，可以用来执行需求3。 这便是线程池的雏形了，它是系统性能与程序执行效率之间制衡的结果。使用线程池后，创建线程变为向线程池讨要线程，销毁线程变为向线程池归还线程。至于线程创建，销毁的真正细节都交由线程池管理。这与数据库连接池等连接池的理念是相同的。 Java API中线程池的层次结构Java API提供了完善的线程池组件，其顶层为接口Executor，它的代码很简单，全部代码如下： 123456package java.util.concurrent;public interface Executor &#123; void execute(Runnable command);&#125; 这便是我们在上文讨论的线程池所欲实现的核心内容了：使用者向线程池提交核心功能command，它自行创建(或者是复用，总之与使用者无关)线程实现对应的功能。 它的子接口为ExecutorService，全部代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package java.util.concurrent;import java.util.List;import java.util.Collection;import java.security.PrivilegedAction;import java.security.PrivilegedExceptionAction;public interface ExecutorService extends Executor &#123; /** * 关闭线程池 * 注意这只是不再接受新的请求了，已在执行的线程会执行完成 */ void shutdown(); List&lt;Runnable&gt; shutdownNow(); /** * 线程池已关闭(已调用过shutdown()或shutdownNow())返回true，反之返回false */ boolean isShutdown(); /** * 若未调用过shutdown()或shutdownNow()则返回false * 若已调用过shutdown()或shutdownNow()，则所有线程执行完成返回true，反之返回false */ boolean isTerminated(); boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException; &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task); &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result); Future&lt;?&gt; submit(Runnable task); &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException; &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException; &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException, ExecutionException; &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;&#125; execute，submit，invoke均是用来执行线程的，其不同之处主要在于是否能得到线程执行后的返回值Future，可详见Java 并发-Future。简单来说，如果我们不需要收集线程的执行结果，则使用execute就好。 ExecutorService有一个子接口ScheduledExecutorService，它在ExecutorService的基础上扩展了在给定时间执行某任务的功能：如在某个固定的延时之后执行，或者周期性的执行某个任务。 实现ExecutorService接口骨架功能的类为java.util.concurrent.AbstractExecutorService，其类定义如下： 1public abstract class AbstractExecutorService implements ExecutorService 这是一个抽象类，其最常用的非抽象子类为java.util.concurrent.ThreadPoolExecutor，其类定义如下： 1public class ThreadPoolExecutor extends AbstractExecutorService 这便是我们最常用的线程池的实现了。不过Java API为了简化程序员的操作，还贴心的为我们提供了线程池的生产工厂java.util.concurrent.Executors，它的类定义如下： 1public class Executors 该工厂能生产我们最需要的那几种线程池，例如： 123456789public static ExecutorService newFixedThreadPool(int nThreads)public static ExecutorService newSingleThreadExecutor()public static ExecutorService newCachedThreadPool()public static ScheduledExecutorService newSingleThreadScheduledExecutor()public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) 上文所述的接口与类均位于java.util.concurrent包中，我们可以用一张图来描述这些类/接口之间的关系： 其中，实线是继承，虚线是实现接口。 Executors提供的常用线程池下面我们来依次详细讨论下Executors所提供的最常用的那些线程池。 1public static ExecutorService newFixedThreadPool(int nThreads) 返回一个固定线程数量的线程池。当有一个新的任务被提交时，若此时已没有空闲线程，则该任务会被暂存于一个等待队列中，待有线程空闲后再处理该任务。 1public static ExecutorService newSingleThreadExecutor() 返回一个只有一个线程的线程池，可类比理解为newFixedThreadPool中nThreads=1的情况(只是帮助理解，实际还是有区别的)。 1public static ExecutorService newCachedThreadPool() 返回一个根据实际情况调整线程数量的线程池：当有一个新的任务被提交时，若此时已没有空闲线程，则会创建新线程。创建的线程在执行完成后默认再保存60秒，若在此期间有复用请求则复用该线程，反之则在到时间后销毁。 1public static ScheduledExecutorService newSingleThreadScheduledExecutor() 返回一个只有一个线程的，有定时任务功能的线程池。 1public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) 返回一个可指定线程数量的，有定时任务功能的线程池。 下面我们以newFixedThreadPool为例，给出一个小例子： 123456789101112131415161718192021222324import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class Test &#123; private static Long BEGIN = System.currentTimeMillis(); public static void main(String[] args) &#123; ExecutorService es = Executors.newFixedThreadPool(5); Runnable r = new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;[&quot; + (System.currentTimeMillis() - Test.BEGIN) + &quot;]&quot; + Thread.currentThread().getId() + &quot; run&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; for (int i = 0; i &lt; 10; i++) es.execute(r); es.shutdown(); &#125;&#125; 输出： 12345678910[5]12 run[5]11 run[6]9 run[7]13 run[7]10 run[1005]11 run[1005]12 run[1006]9 run[1007]13 run[1007]10 run 程序被分为两组，两组间的间隔约为1秒。且第二组其实并未创建新线程，只是对第一组线程的复用。 我们不妨将上例的线程池换为newCachedThreadPool，其余不做改动： 123456789101112131415161718192021222324import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class Test &#123; private static Long BEGIN = System.currentTimeMillis(); public static void main(String[] args) &#123; ExecutorService es = Executors.newCachedThreadPool(); Runnable r = new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;[&quot; + (System.currentTimeMillis() - Test.BEGIN) + &quot;]&quot; + Thread.currentThread().getId() + &quot; run&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; for (int i = 0; i &lt; 10; i++) es.execute(r); es.shutdown(); &#125;&#125; 输出： 12345678910[5]9 run[6]13 run[5]10 run[5]11 run[6]14 run[6]15 run[6]12 run[6]18 run[6]17 run[6]16 run 几乎在同时创建了10个新线程。 通览Executors工厂提供的线程池，可分为两大类：一类是上文给出过小例子的，诸如newFixedThreadPool，newCachedThreadPool等普通的线程池，这类线程池会在有空闲线程后立即执行。另一类就是方法名中包含关键字Scheduled，返回ScheduledExecutorService的定时任务线程池，这类线程池所实现的功能类似于linux中的crontab命令。 ScheduledExecutorService的全部代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142package java.util.concurrent;import java.util.concurrent.atomic.*;import java.util.*;public interface ScheduledExecutorService extends ExecutorService &#123; /** * 在延迟时间delay之后，对任务进行一次调度 */ public ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit); /** * 在延迟时间delay之后，对任务进行一次调度 */ public &lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit); /** * 创建一个周期性任务 * 任务开始于给定的初始延时initialDelay之后 * 后续的任务按照给定的周期进行： * 后续第一个任务于initialDelay+period执行 * 后续第二个任务于initialDelay+2*period执行 * 依此类推 */ public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit); /** * 创建一个周期性任务 * 任务开始于给定的初始延时initialDelay之后 * 每当前一个任务完成后，再过延时delay后，开始下一个任务 */ public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit);&#125; 下面给出一个scheduleAtFixedRate的小例子，例子中任务执行耗时1秒，初始延迟2秒，每隔3秒执行一次： 123456789101112131415161718192021222324import java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;import java.util.concurrent.TimeUnit;public class Test &#123; private static Long BEGIN = System.currentTimeMillis(); public static void main(String[] args) &#123; Runnable r = new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;[&quot; + (System.currentTimeMillis() - Test.BEGIN) + &quot;]&quot; + Thread.currentThread().getId() + &quot; run&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; ScheduledExecutorService ses = Executors.newScheduledThreadPool(10); ses.scheduleAtFixedRate(r, 2, 3, TimeUnit.SECONDS); &#125;&#125; 截取最开始的那部分输出： 12345678910[2007]9 run[5007]9 run[8008]11 run[11008]9 run[14008]12 run[17008]11 run[20009]13 run[23009]9 run[26009]14 run[29010]12 run 确实是按照预期执行了。不过需要注意的是，尽管其实只需1个线程就足够了，线程池仍然创建了新的其他线程(知道有这么个事就行了，具体的决策交给线程池)。 在完成这个小例子后，我们不禁会想：如果任务的执行时间大于循环周期的话，那么会出现任务堆叠的现象吗？我们可以将任务耗时调整为5秒，其余不变： 123456789101112131415161718192021222324import java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;import java.util.concurrent.TimeUnit;public class Test &#123; private static Long BEGIN = System.currentTimeMillis(); public static void main(String[] args) &#123; Runnable r = new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;[&quot; + (System.currentTimeMillis() - Test.BEGIN) + &quot;]&quot; + Thread.currentThread().getId() + &quot; run&quot;); try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; ScheduledExecutorService ses = Executors.newScheduledThreadPool(10); ses.scheduleAtFixedRate(r, 2, 3, TimeUnit.SECONDS); &#125;&#125; 截取最开始的那部分输出： 123456[2009]9 run[7009]9 run[12010]11 run[17010]9 run[22010]12 run[27010]11 run 循环周期被自动调整为了5秒，并没有出现任务堆叠的情况。这样设计是很合理的：因为任务的执行时间大于循环周期的话，随着时间的推移，积压的任务会越来越多(能用于执行任务的线程毕竟是有限的)，无法执行的话还不如最开始就不要积压，降低执行频率。 最后，在使用定时任务，尤其是周期性循环的周期任务时，要尤为注意异常的捕获，因为只要一个任务抛出了未被捕获的异常，后续任务都会停止。 Executors提供的常用线程池的内部实现Executors工厂所提供的常用线程池本质上是Java API为我们创建的套路化的，常见功能的线程池，其内部还是需要创建ExecutorService的具体实现。以newFixedThreadPool，newSingleThreadExecutor，newCachedThreadPool这3个方法为例，他们均返回了ExecutorService的实现，源码为： 123456789101112131415161718public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125;public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125;public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; 原来如此，这3种线程池本质上都是调用同一个构造函数新建了一个ThreadPoolExecutor对象(newSingleThreadExecutor在外面又包了一层，不过影响不大)。也就是说它们3个本质上是一回事，只是生成的参数有所不同。它们所调用的ThreadPoolExecutor的构造函数为： 12345678public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);&#125; 哦，原来只是一个壳子，它内部调用的那个构造函数为： 123456789101112131415161718192021public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; 这次不是壳子了，不过所做的也无非就是给对象赋个值，没什么别的逻辑，确实很有构造函数的样子。我们需要重点关注的是它的入参。 先说相对简单的，threadFactory指线程工厂，用于创建线程。handler指拒绝策略，指明当任务超出线程池的承载能力时该如何应对。这两个参数也是上文那个壳子函数中少掉的两个参数，用的都是系统的默认值，并未由用户指定。 corePoolSize指预期中该线程池通常情况下会包含的线程数。当一个新的任务被提交至线程池，若有空闲线程则直接复用。在没有空闲线程的情况下，若此时已有线程数在[0,corePoolSize)之间，说明仍在预期的范围之内，可直接创建新线程。若已有线程数已达到corePoolSize，则说明超过了预期，新任务会被放入阻塞队列workQueue中，等待执行时机。 上文叙述的是在预期范围内的正常情况，而异常情况指得就是阻塞的任务数量超出了workQueue的承载极限。对于这种情况，ThreadPoolExecutor并没有直接判定失败进而调用handler的拒绝策略，而是又给出了一个弹性的空间：若此时已有线程数量在[corePoolSize,maximumPoolSize)的范围内，那么仍允许创建新线程。而若线程数已达maximumPoolSize而仍要创建新线程，则会判定失败并调用handler的拒绝策略。 不过，异常状况终究是异常状况，在(corePoolSize,maximumPoolSize]范围内的线程是紧急事态下的紧急应对，因此为它们设置了失效时间keepAliveTime(unit就是这个时间的单位)：一旦它们闲置的时间超过了这个失效时间，换句话说，危机应该是已经过去了，它们就会被销毁。 上文所述的调度逻辑可通过ThreadPoolExecutor中下述的核心调度代码得以体现： 1234567891011121314151617181920public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); int c = ctl.get(); // c代表当前线程池 // workerCountOf(c)为当前线程池持有的线程总数 if (workerCountOf(c) &lt; corePoolSize) &#123; if (addWorker(command, true)) // 创建新线程 return; c = ctl.get(); &#125; if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; // 欲进入等待队列 int recheck = ctl.get(); if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; else if (!addWorker(command, false)) // 进入等待队列失败，将任务交还给线程池，判断是否达到maximumPoolSize reject(command);&#125; 在上文所述的ThreadPoolExecutor的入参中，还需特别展开论述的就是workQueue了，通常情况下，会传给ThreadPoolExecutor的阻塞队列有如下几种： ArrayBlockingQueue 即有界任务队列。该队列的构造函数均包含一个容量参数，表示该队列所能承载的极限容量： 123456public ArrayBlockingQueue(int capacity)public ArrayBlockingQueue(int capacity, boolean fair)public ArrayBlockingQueue(int capacity, boolean fair, Collection&lt;? extends E&gt; c) LinkedBlockingQueue 即无界任务队列。除非系统资源耗尽，否则LinkedBlockingQueue可一直插入新元素。 PriorityBlockingQueue 即优先任务队列。它是一个特殊的无界任务队列，可以按照自身设定好的优先级计算规则控制任务执行的先后顺序。不过更确切的说，也可以认为无界任务队列是一种特殊的优先任务队列：它的优先计算规则为时间上的FIFO。 SynchronousQueue 即直接提交队列。其实这已经不能算作一种队列了：它并没有容量，即容量为0。换句话说，任何一个对SynchronousQueue的写需要等待一个对SynchronousQueue的读，反之亦然。因此，SynchronousQueue与其说是一个队列，更像是一个数据的中转站。 了解了线程池的生成方式后，我们终于可以逐一的分析上文列出的那3种线程池了： 12345public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; 线程数在[0,nThreads)范围内时(nThreads即为设定好的容量)，当有新任务提交又没有空闲线程时(其实有空闲线程时也有可能创建新线程，一切看线程池的调度)，会创建新线程。当线程数已达nThreads，又没有空闲线程，此时新任务会被提交给阻塞队列LinkedBlockingQueue，这是一个无界任务队列，只要系统资源没有崩溃，理论上可以无限的提交下去。这样一来参数2，3，4即maximumPoolSize，keepAliveTime，unit实际上等同于无效了：因为不可能出现阻塞队列满了的情况。 使用LinkedBlockingQueue虽然不会导致线程池失败，然而在任务提交速度远大于消费速度的场合却有可能导致系统因资源耗尽而崩溃，需要谨慎使用。 123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; 不看外面包的那层FinalizableDelegatedExecutorService的话，完全可以按照nThreads=1的newFixedThreadPool来分析，就不再赘述了。 12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; corePoolSize=0，这意味着该线程池稳定状态下的线程数是0，即所有线程都是临时工。新任务会被无条件的送入阻塞队列。而它的阻塞队列又是SynchronousQueue，所以立刻又会被踢皮球一样送回来，进入所谓的战时状态，最多可创建Integer.MAX_VALUE个线程。这个数字基本就可被视为无限大了(因为不会有系统能顶得住开这么多的线程的)。这些线程在闲置后均会被保持60秒，若无人使用则销毁。 在任务提交速度远大于消费速度的场合下，系统可能会因创建线程过多而卡死崩溃。这个问题比使用newFixedThreadPool时可能遇到的资源耗尽问题要更严峻一些：因为线程资源往往是更易于耗尽的。 线程池的拒绝策略前文我们提到了线程池实现类ThreadPoolExecutor的构造函数： 123456789101112131415161718192021222324252627282930public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);&#125;public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; 其中有一个参数名为handler，代表着线程池的拒绝策略，在使用线程池工厂Executors创建常用线程池时并不需要关注这个参数，Executors会自动为我们补上默认的拒绝策略defaultHandler。 所谓的拒绝策略，就是当任务提交量超出了线程池的承载能力时需要做的补救策略。相当于是一种变相的try-catch。 拒绝策略的顶层接口为RejectedExecutionHandler，它的全部代码如下： 1234567891011package java.util.concurrent;public interface RejectedExecutionHandler &#123; /** * * @param r Runnable, 导致请求失败的那个任务 * @param executor ThreadPoolExecutor, 当前线程池 */ void rejectedExecution(Runnable r, ThreadPoolExecutor executor);&#125; Java API提供了4种实现类： java.util.concurrent.ThreadPoolExecutor$AbortPolicy 最为简单粗暴的拒绝策略：直接抛出异常，停止线程池。这也是Java API默认使用的策略。 我们可以追溯下源码： 12345678public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);&#125; 其中的defaultHandler为ThreadPoolExecutor对象的字段： 12private static final RejectedExecutionHandler defaultHandler = new AbortPolicy(); java.util.concurrent.ThreadPoolExecutor$CallerRunsPolicy 该策略会将无法完成的任务交还给调用者线程。这样做不会使线程池关闭，也不会丢弃任务，但却会使调用者线程的压力增大，也就是俗称的甩锅策略。 java.util.concurrent.ThreadPoolExecutor$DiscardOldestPolicy 该策略会丢弃最老的一个请求(也就是即将被执行的请求)。 java.util.concurrent.ThreadPoolExecutor$DiscardPolicy 该策略会丢弃无法处理的请求(也就是最新提交的那个请求)。 当然，我们也可以自己实现RejectedExecutionHandler： 12345678910111213141516171819202122232425262728293031323334import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.RejectedExecutionHandler;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;public class Test &#123; private static long BEGIN = System.currentTimeMillis(); public static void main(String[] args) &#123; Runnable r = new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;[&quot; + (System.currentTimeMillis() - Test.BEGIN) + &quot;]&quot; + Thread.currentThread().getId() + &quot; start...&quot;); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; RejectedExecutionHandler reh = new RejectedExecutionHandler() &#123; @Override public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) &#123; System.out.println(&quot;[&quot; + (System.currentTimeMillis() / Test.BEGIN) + &quot;]&quot; + r.toString() + &quot; is discard&quot;); &#125; &#125;; ExecutorService es = new ThreadPoolExecutor(5, 5, 0L, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(3), Executors.defaultThreadFactory(), reh); for (int i = 0; i &lt; 10; i++) es.execute(r); es.shutdown(); &#125;&#125; 输出： 12345678910[3]10 start...[1]com.test.Test$1@620a9239 is discard[3]13 start...[3]12 start...[3]11 start...[3]9 start...[1]com.test.Test$1@620a9239 is discard[103]11 start...[106]10 start...[105]12 start... 需要注意的一个点是reh的rejectedExecution()是在main方法线程中被执行的：因为线程池es就是main方法线程创建的。 线程创建工厂我们继续分析线程池实现类ThreadPoolExecutor的构造函数： 123456789101112131415161718192021222324252627282930public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);&#125;public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; 上文已分析了handler，那么我们索性将其分析完，再来说一说另一个默认的参数：threadFactory。 在Java 并发-线程组中，我在比较线程组与线程池的区别时曾说到： 线程池管理的并非一个个已经成型的线程。即用以构建线程池中的线程所需提供的素材并非线程本身，而是生成线程的核心部件Runnable。也就是说线程池并不希望我们确定下来线程再交给它，这样它也就没法管理了。使用线程池时我们只管从池子里取线程即可，该线程是基于我们传入的Runnable生成的，因此可以满足我们的业务需求，至于这个线程是何时生成的，怎么生成的我们一概不管。而线程组是在明确的给线程打上编号：即某某线程属于某某组。一定要先有一个明确的线程才行。因此二者是无法协同工作的。 结合本文，相信大家会有一个更深入的了解。 不过，虽然线程池不希望使用者看到它所持有的线程的细节，但为了执行任务，它总是要创建线程的，所用的就是下面要说的这个默认参数threadFactory。 ThreadFactory是一个接口，它的全部代码如下： 123456package java.util.concurrent;public interface ThreadFactory &#123; Thread newThread(Runnable r);&#125; 够简洁，我喜欢！我们可以先来看看ThreadPoolExecutor的默认实现是什么样子的，也就是Executors.defaultThreadFactory()方法： 123public static ThreadFactory defaultThreadFactory() &#123; return new DefaultThreadFactory();&#125; 依然灰常的直接，而这个DefaultThreadFactory全称为java.util.concurrent.Executors$DefaultThreadFactory。它的全部代码如下： 1234567891011121314151617181920212223242526static class DefaultThreadFactory implements ThreadFactory &#123; private static final AtomicInteger poolNumber = new AtomicInteger(1); private final ThreadGroup group; private final AtomicInteger threadNumber = new AtomicInteger(1); private final String namePrefix; DefaultThreadFactory() &#123; SecurityManager s = System.getSecurityManager(); group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup(); namePrefix = &quot;pool-&quot; + poolNumber.getAndIncrement() + &quot;-thread-&quot;; &#125; public Thread newThread(Runnable r) &#123; Thread t = new Thread(group, r, namePrefix + threadNumber.getAndIncrement(), 0); if (t.isDaemon()) t.setDaemon(false); if (t.getPriority() != Thread.NORM_PRIORITY) t.setPriority(Thread.NORM_PRIORITY); return t; &#125;&#125; 大概看下来，它的newThread()所创建的线程就是普通的线程，还特意确保了它的普通性：不是守护线程，优先级为NORM_PRIORITY。 理所当然的，我们也可以自己写ThreadFactory的实现类： 12345678910111213141516171819202122232425262728293031323334import java.util.concurrent.ExecutorService;import java.util.concurrent.LinkedBlockingQueue;import java.util.concurrent.ThreadFactory;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;public class Test &#123; private static long BEGIN = System.currentTimeMillis(); public static void main(String[] args) &#123; Runnable r = new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;[&quot; + (System.currentTimeMillis() - Test.BEGIN) + &quot;]&quot; + Thread.currentThread().getName() + Thread.currentThread().getId() + &quot; start...&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; ThreadFactory tf = new ThreadFactory() &#123; @Override public Thread newThread(Runnable r) &#123; Thread t = new Thread(r, &quot;tf制造&quot;); t.setDaemon(true); return t; &#125; &#125;; ExecutorService es = new ThreadPoolExecutor(5, 5, 0L, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), tf); for (int i = 0; i &lt; 10; i++) es.execute(r); &#125;&#125; 输出： 12345[2]tf制造10 start...[2]tf制造12 start...[2]tf制造11 start...[2]tf制造9 start...[3]tf制造13 start... 这个输出就比较有意思了，因为线程均被设置为了守护线程，因此在main方法结束后正在sleep的那5个线程会被强制终止，线程池也被强制关闭，已提交在阻塞队列中的另5个任务自然也失去了执行的机会。 线程池的继承与扩展讨论了这么多，不知大家是否会产生这样的疑问：线程池究竟是如何执行提交给它的任务的呢？ 在ThreadPoolExecutor这个实现中，执行任务的工作交于了它的内部类Worker： 1private final class Worker extends AbstractQueuedSynchronizer implements Runnable 它实现了Runnable接口。每个任务在执行时都会对应一个Worker实例。并通过该实例的run()方法执行： 123public void run() &#123; runWorker(this);&#125; runWorker()方法在ThreadPoolExecutor中，它的全部代码如下： 123456789101112131415161718192021222324252627282930313233343536373839final void runWorker(Worker w) &#123; Thread wt = Thread.currentThread(); Runnable task = w.firstTask; w.firstTask = null; w.unlock(); boolean completedAbruptly = true; try &#123; while (task != null || (task = getTask()) != null) &#123; w.lock(); if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) wt.interrupt(); try &#123; beforeExecute(wt, task); Throwable thrown = null; try &#123; task.run(); &#125; catch (RuntimeException x) &#123; thrown = x; throw x; &#125; catch (Error x) &#123; thrown = x; throw x; &#125; catch (Throwable x) &#123; thrown = x; throw new Error(x); &#125; finally &#123; afterExecute(task, thrown); &#125; &#125; finally &#123; task = null; w.completedTasks++; w.unlock(); &#125; &#125; completedAbruptly = false; &#125; finally &#123; processWorkerExit(w, completedAbruptly); &#125;&#125; task就是实际要执行的任务本体。有趣的是runWorker()方法会在task.run()开始前添加beforeExecute(wt, task)，而在task.run()执行完成后执行afterExecute(task, thrown)。这样线程池就可以在任务开始前及结束后插入一些套路化的东西。这两个方法均属于ThreadPoolExecutor，它们的代码如下： 123protected void beforeExecute(Thread t, Runnable r) &#123; &#125;protected void afterExecute(Runnable r, Throwable t) &#123; &#125; 这是两个权限为protected的空方法。很显然，Java API其实没什么套路，不过它为使用者留好了途径，使得他们可以通过继承ThreadPoolExecutor并重写这两个方法的方式实现自身的套路。 这实在是一个很有用的功能。我通常用它来更精细化的记录线程池及其中线程的状态变化，这对日志分析极为有益。 beforeExecute及afterExecute实际上是在每个任务开始前及结束后插入的AOP方法，通常它们会配合ThreadPoolExecutor中的另一个方法一起被重写： 1protected void terminated() &#123; &#125; terminated默认也是空方法，它会在线程池关闭时被触发。我们不妨以ThreadPoolExecutor中最常用的shutdown()方法为起点，来看一下调用terminated()的方法链。 首先shutdown()方法的代码为： 12345678910111213public void shutdown() &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; checkShutdownAccess(); advanceRunState(SHUTDOWN); interruptIdleWorkers(); onShutdown(); &#125; finally &#123; mainLock.unlock(); &#125; tryTerminate();&#125; 然后我们进入ThreadPoolExecutor.tryTerminate()： 1234567891011121314151617181920212223242526272829final void tryTerminate() &#123; for (;;) &#123; int c = ctl.get(); if (isRunning(c) || runStateAtLeast(c, TIDYING) || (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty())) return; if (workerCountOf(c) != 0) &#123; interruptIdleWorkers(ONLY_ONE); return; &#125; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) &#123; try &#123; terminated(); // AOP方法 &#125; finally &#123; ctl.set(ctlOf(TERMINATED, 0)); termination.signalAll(); &#125; return; &#125; &#125; finally &#123; mainLock.unlock(); &#125; &#125;&#125; 在其内部可以找到terminated()。 下面给出一个应用beforeExecute，afterExecute，terminated的小例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import java.util.concurrent.BlockingQueue;import java.util.concurrent.LinkedBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;public class Test &#123; static Long BEGIN = System.currentTimeMillis(); public static void main(String[] args) throws InterruptedException &#123; MyPool myPool = new MyPool(5, 5, 0L, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); for (int i = 0; i &lt; 5; i++) &#123; myPool.execute(new MyTask(&quot;task&quot; + i)); Thread.sleep(10); &#125; myPool.shutdown(); &#125;&#125;class MyTask implements Runnable &#123; String name; MyTask(String name) &#123; this.name = name; &#125; @Override public void run() &#123; System.out.println(&quot;[&quot; + (System.currentTimeMillis() - Test.BEGIN) + &quot;]&#123;&quot; + Thread.currentThread().getId() + &quot;&#125;&quot; + this.name + &quot; start...&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;[&quot; + (System.currentTimeMillis() - Test.BEGIN) + &quot;]&#123;&quot; + Thread.currentThread().getId() + &quot;&#125;&quot; + this.name + &quot; finish&quot;); &#125;&#125;class MyPool extends ThreadPoolExecutor &#123; MyPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue); &#125; @Override protected void beforeExecute(Thread t, Runnable r) &#123; System.out.println(&quot;[&quot; + (System.currentTimeMillis() - Test.BEGIN) + &quot;]=======AOP=======prepare work for &quot; + ((MyTask)r).name); &#125; @Override protected void afterExecute(Runnable r, Throwable t) &#123; System.out.println(&quot;[&quot; + (System.currentTimeMillis() - Test.BEGIN) + &quot;]=======AOP=======after work for &quot; + ((MyTask)r).name); &#125; @Override protected void terminated() &#123; System.out.println(&quot;[&quot; + (System.currentTimeMillis() - Test.BEGIN) + &quot;]=======AOP=======after work for myPool shutdown&quot;); &#125;&#125; 输出： 123456789101112131415161718192021[4]=======AOP=======prepare work for task0[4]&#123;9&#125;task0 start...[14]=======AOP=======prepare work for task1[14]&#123;10&#125;task1 start...[24]=======AOP=======prepare work for task2[24]&#123;11&#125;task2 start...[34]=======AOP=======prepare work for task3[34]&#123;12&#125;task3 start...[44]=======AOP=======prepare work for task4[44]&#123;13&#125;task4 start...[1005]&#123;9&#125;task0 finish[1005]=======AOP=======after work for task0[1014]&#123;10&#125;task1 finish[1014]=======AOP=======after work for task1[1024]&#123;11&#125;task2 finish[1024]=======AOP=======after work for task2[1035]&#123;12&#125;task3 finish[1036]=======AOP=======after work for task3[1044]&#123;13&#125;task4 finish[1045]=======AOP=======after work for task4[1045]=======AOP=======after work for myPool shutdown 合理选择线程池中线程的数量纯粹从性能的角度来看，线程数的极限值为可用CPU的数量。Java API提供了获取可用CPU的方法： 123456public class Test &#123; public static void main(String[] args) &#123; System.out.println(Runtime.getRuntime().availableProcessors()); &#125;&#125; 输出： 14 因为一个CPU同时只能运行一个线程，因此设定多于CPU数的线程通常都是伪并行，不仅无法得到性能的提升，反而还会因CPU在线程间的切换而导致性能的下降。 当然，这只是理论上的数值。设置线程数这种东西最重要的还是经验。通常有以下两种情况会导致我们设置多于上文极限值的线程数： 从逻辑建模的角度而言，就需要设置这么多的线程。此时虽然会损失机器性能，但是却能更好的模拟现实环境，利于程序的开发及维护。 生成的线程并非是一直占据CPU的，在它的生存周期中可能会让出CPU做一些无需CPU的操作(例如各种I/O中断)。此时适当的提高线程数可以提高系统性能。 查看线程池中线程的堆栈信息我们先来看一个小例子： 1234567891011121314151617181920212223242526272829303132import java.util.concurrent.LinkedBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;public class Test &#123; public static void main(String[] args) &#123; ThreadPoolExecutor te = new ThreadPoolExecutor(5, 5, 0, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); for (int i = 0; i &lt; 5; i++) te.submit(new MyTask(&quot;task&quot; + i, 100, i)); te.shutdown(); &#125;&#125;class MyTask implements Runnable &#123; String name; int d1; int d2; MyTask(String name, int d1, int d2) &#123; this.name = name; this.d1 = d1; this.d2 = d2; &#125; @Override public void run() &#123; System.out.println(&quot;[&quot; + Thread.currentThread().getId() + &quot;]&quot; + this.name + &quot; result=&quot; + (this.d1 / d2)); &#125;&#125; 输出： 1234[10]task1 result=100[12]task3 result=33[11]task2 result=50[13]task4 result=25 这可真是一个扎心的结果：我们提交了5个任务，最后只有4组输出。很显然有一组因为除0异常导致线程崩了。之所以说这个结果扎心，并非因为抛出了异常，而在于系统对于异常无动于衷：单看输出天下太平，并没抛出任何异常。 这真的是最为糟心的情况了：程序出问题了，但是从日志来看到处都是正常的。一种最简单的，可以让我们获得部分异常堆栈的做法是用execute替换submit： 1234567891011121314151617181920212223242526272829303132import java.util.concurrent.LinkedBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;public class Test &#123; public static void main(String[] args) &#123; ThreadPoolExecutor te = new ThreadPoolExecutor(5, 5, 0, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); for (int i = 0; i &lt; 5; i++) te.execute(new MyTask(&quot;task&quot; + i, 100, i)); te.shutdown(); &#125;&#125;class MyTask implements Runnable &#123; String name; int d1; int d2; MyTask(String name, int d1, int d2) &#123; this.name = name; this.d1 = d1; this.d2 = d2; &#125; @Override public void run() &#123; System.out.println(&quot;[&quot; + Thread.currentThread().getId() + &quot;]&quot; + this.name + &quot; result=&quot; + (this.d1 / d2)); &#125;&#125; 此时的输出为： 123456789[11]task2 result=50[12]task3 result=33[10]task1 result=100[13]task4 result=25Exception in thread &quot;pool-1-thread-1&quot; java.lang.ArithmeticException: / by zero at com.test.MyTask.run(Test.java:32) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615) at java.lang.Thread.run(Thread.java:745) 好多了，虽然无法精确定位，但是起码让我们知道线程池中有线程出异常了。 原因其实很好理解，submit与execute最大的不同之处就在于submit有返回值，而execute没有。因此execute必须要将线程的异常信息抛出，否则就是彻底没了。而submit的异常信息实际上是在它的结果中： 12345678910111213141516171819202122232425262728293031323334353637383940import java.util.concurrent.ExecutionException;import java.util.concurrent.LinkedBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;public class Test &#123; public static void main(String[] args) &#123; ThreadPoolExecutor te = new ThreadPoolExecutor(5, 5, 0, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); for (int i = 0; i &lt; 5; i++) &#123; try &#123; System.out.println(te.submit(new MyTask(&quot;task&quot; + i, 100, i)).get()); &#125; catch (InterruptedException | ExecutionException e) &#123; e.printStackTrace(); &#125; &#125; te.shutdown(); &#125;&#125;class MyTask implements Runnable &#123; String name; int d1; int d2; MyTask(String name, int d1, int d2) &#123; this.name = name; this.d1 = d1; this.d2 = d2; &#125; @Override public void run() &#123; System.out.println(&quot;[&quot; + Thread.currentThread().getId() + &quot;]&quot; + this.name + &quot; result=&quot; + (this.d1 / d2)); &#125;&#125; 输出： 12345678910111213141516171819java.util.concurrent.ExecutionException: java.lang.ArithmeticException: / by zero at java.util.concurrent.FutureTask.report(FutureTask.java:122) at java.util.concurrent.FutureTask.get(FutureTask.java:188) at com.test.Test.main(Test.java:14)Caused by: java.lang.ArithmeticException: / by zero at com.test.MyTask.run(Test.java:40) at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471) at java.util.concurrent.FutureTask.run(FutureTask.java:262) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615) at java.lang.Thread.run(Thread.java:745)[10]task1 result=100null[11]task2 result=50null[12]task3 result=33null[13]task4 result=25null 此时除0异常在get()时被捕获，随后该方法向上层抛出ExecutionException，进而被我们的程序捕获。 虽然上述两种做法能获得部分异常堆栈，但这”部分信息”对于我们的异常分析基本是然并卵的。上述异常信息只能定位到核心Runnable的位置(MyTask.run)，但却定位不到是哪个线程池抛出的异常，无法提供线程池的详细信息。 对此，我们同样可以通过继承ThreadPoolExecutor获得更多的堆栈信息： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import java.util.concurrent.BlockingQueue;import java.util.concurrent.Future;import java.util.concurrent.LinkedBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;public class Test &#123; public static void main(String[] args) &#123; MyPool mp = new MyPool(5, 5, 0, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); for (int i = 0; i &lt; 5; i++) mp.execute(new MyTask(&quot;task&quot; + i, 100, i)); mp.shutdown(); &#125;&#125;class MyPool extends ThreadPoolExecutor &#123; MyPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue); &#125; @Override public String toString() &#123; return &quot;pool=&quot; + this.getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode()); &#125; public void execute(MyTask task) &#123; super.execute(this.hull(task, this.baseTrace(task))); &#125; public Future&lt;?&gt; submit(MyTask task) &#123; return super.submit(this.hull(task, this.baseTrace(task))); &#125; private Exception baseTrace(MyTask task) &#123; return new Exception(&quot;[&quot; + Thread.currentThread().getId() + &quot;]&quot; + this.toString() + &quot;-------task=&quot; + task.name); &#125; private Runnable hull(final MyTask task, final Exception baseTrace) &#123; return new Runnable() &#123; @Override public void run() &#123; try &#123; task.run(); &#125; catch (Exception e) &#123; baseTrace.printStackTrace(); throw e; &#125; &#125; &#125;; &#125;&#125;class MyTask implements Runnable &#123; String name; int d1; int d2; MyTask(String name, int d1, int d2) &#123; this.name = name; this.d1 = d1; this.d2 = d2; &#125; @Override public void run() &#123; System.out.println(&quot;[&quot; + Thread.currentThread().getId() + &quot;]&quot; + this.name + &quot; result=&quot; + (this.d1 / d2)); &#125;&#125; 输出： 1234567891011121314[10]task1 result=100[12]task3 result=33[11]task2 result=50[13]task4 result=25java.lang.Exception: [1]pool=com.test.MyPool@470ae2bf-------task=task0 at com.test.MyPool.baseTrace(Test.java:38) at com.test.MyPool.execute(Test.java:30) at com.test.Test.main(Test.java:13)Exception in thread &quot;pool-1-thread-1&quot; java.lang.ArithmeticException: / by zero at com.test.MyTask.run(Test.java:72) at com.test.MyPool$1.run(Test.java:46) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615) at java.lang.Thread.run(Thread.java:745) 该输出中同时打出了出错的线程池及任务。一般是不需要打出任务的：因为通常我们只会向线程池提交一种任务。 事实上，这并不能被称之为一个功能，这只是一个小技巧而已：我们仅仅只是在默认的ThreadPoolExecutor之外又包了一层外壳，外壳中记录下当前线程池的信息(如上文代码所示，如果有必要也可以特化外壳类中execute，submit等接受的Runnable的类型，这样就可以打印出更多的任务相关的信息)，当发生异常时，将该线程池的堆栈信息打印出来。 同理，使用submit时的代码为： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import java.util.concurrent.BlockingQueue;import java.util.concurrent.ExecutionException;import java.util.concurrent.Future;import java.util.concurrent.LinkedBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;public class Test &#123; public static void main(String[] args) &#123; MyPool mp = new MyPool(5, 5, 0, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); for (int i = 0; i &lt; 5; i++) &#123; try &#123; System.out.println(mp.submit(new MyTask(&quot;task&quot; + i, 100, i)).get()); &#125; catch (InterruptedException | ExecutionException e) &#123; e.printStackTrace(); &#125; &#125; mp.shutdown(); &#125;&#125;class MyPool extends ThreadPoolExecutor &#123; MyPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue); &#125; @Override public String toString() &#123; return &quot;pool=&quot; + this.getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode()); &#125; public void execute(MyTask task) &#123; super.execute(this.hull(task, this.baseTrace(task))); &#125; public Future&lt;?&gt; submit(MyTask task) &#123; return super.submit(this.hull(task, this.baseTrace(task))); &#125; private Exception baseTrace(MyTask task) &#123; return new Exception(&quot;[&quot; + Thread.currentThread().getId() + &quot;]&quot; + this.toString() + &quot;-------task=&quot; + task.name); &#125; private Runnable hull(final MyTask task, final Exception baseTrace) &#123; return new Runnable() &#123; @Override public void run() &#123; try &#123; task.run(); &#125; catch (Exception e) &#123; baseTrace.printStackTrace(); throw e; &#125; &#125; &#125;; &#125;&#125;class MyTask implements Runnable &#123; String name; int d1; int d2; MyTask(String name, int d1, int d2) &#123; this.name = name; this.d1 = d1; this.d2 = d2; &#125; @Override public void run() &#123; System.out.println(&quot;[&quot; + Thread.currentThread().getId() + &quot;]&quot; + this.name + &quot; result=&quot; + (this.d1 / d2)); &#125;&#125; 输出为： 123456789101112131415161718192021222324java.lang.Exception: [1]pool=com.test.MyPool@620a9239-------task=task0 at com.test.MyPool.baseTrace(Test.java:46) at com.test.MyPool.submit(Test.java:42) at com.test.Test.main(Test.java:16)java.util.concurrent.ExecutionException: java.lang.ArithmeticException: / by zero at java.util.concurrent.FutureTask.report(FutureTask.java:122) at java.util.concurrent.FutureTask.get(FutureTask.java:188) at com.test.Test.main(Test.java:16)Caused by: java.lang.ArithmeticException: / by zero at com.test.MyTask.run(Test.java:80) at com.test.MyPool$1.run(Test.java:54) at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471) at java.util.concurrent.FutureTask.run(FutureTask.java:262) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615) at java.lang.Thread.run(Thread.java:745)[10]task1 result=100null[11]task2 result=50null[12]task3 result=33null[13]task4 result=25null 同一个线程池execute()的Runnable可以不同通常情况下，我们只会向一个线程池提供一种Runnable，即该线程池产生的线程的能力都相同。这是Java推荐的使用方式，一个线程池只产生单一功能的线程有利于程序逻辑的划分。但是这仅仅是推荐，而非必须。事实上，我们可以向线程池提交任意的，不同的Runnable： 1234567891011121314151617181920212223242526import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class Test &#123; public static void main(String[] args) &#123; ExecutorService es = Executors.newFixedThreadPool(1); Runnable r1 = new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;r1&quot;); &#125; &#125;; Runnable r2 = new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;r2&quot;); &#125; &#125;; for (int i = 0; i &lt; 4; i++) &#123; if (i % 2 == 0) es.execute(r1); else es.execute(r2); &#125; es.shutdown(); &#125;&#125; 输出： 1234r2r1r2r1 可以这样理解：线程池管理的只是线程的壳子，而Thread与Runnable是解耦的。我们可以将Thread看作人的肉体，Runnable看作人的灵魂。线程池管理的仅仅是人的肉体，在需要使用时赋予不同的灵魂(上例中的线程池只管理了一个线程)。]]></content>
      <categories>
        <category>Java 并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 并发-线程实现方式]]></title>
    <url>%2F2017%2F10%2F03%2FJava%20%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[JDK1.5以前实现多线程有两种方法：一种是继承Thread类；另一种是实现Runnable接口。两种方式都要通过重写run()方法来定义线程的行为，推荐使用后者，因为Java中的继承是单继承，一个类只有一个父类，如果继承了Thread类就无法再继承其他类了，显然使用Runnable接口更为灵活。 JDK1.5以后创建线程还有第三种方式：实现Callable接口，该接口中的call方法可以在线程执行结束时产生一个返回值，代码如下所示： 1234567891011121314151617181920212223242526272829303132333435import java.util.ArrayList;import java.util.List;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;public class Test &#123; public static void main(String[] args) throws InterruptedException, ExecutionException &#123; List&lt;Future&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); ExecutorService executorService = Executors.newFixedThreadPool(10); for(int i = 0; i &lt; 10; i++) list.add(executorService.submit(new MyTask(100))); int sum = 0; for(Future&lt;Integer&gt; future : list) sum += future.get(); System.out.println(sum); &#125;&#125;class MyTask implements Callable&lt;Integer&gt; &#123; private int upperBounds; public MyTask(int upperBounds) &#123; this.upperBounds = upperBounds; &#125; @Override public Integer call() throws Exception &#123; int sum = 0; for(int i = 1; i &lt;= upperBounds; i++) sum += i; return sum; &#125;&#125; 输出： 150500]]></content>
      <categories>
        <category>Java 并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>Thread</tag>
        <tag>Runnable</tag>
        <tag>Callable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 并发-ReentrantLock]]></title>
    <url>%2F2017%2F10%2F03%2FJava%20%E5%B9%B6%E5%8F%91-ReentrantLock%2F</url>
    <content type="text"><![CDATA[123java.util.concurrent.locks.ReentrantLock;public class ReentrantLock implements Lock, java.io.Serializable JDK1.5引入了显式的锁机制。该机制以Lock接口及其实现类为代表。 ReentrantLock使用显式锁机制实现了synchronized的所有功能，在此基础上又增加了新功能，因此ReentrantLock可以视为synchronized的功能增强版：synchronized所监视的监视器对象可以是任何对象，那么能不能特化出一种对象就是专门用来处理锁，只作为锁对象使用呢？这个锁对象就是ReentrantLock。 实际上，Lock接口比synchronized更接近于底层：synchronized在软件层面依赖JVM实现锁，而Lock在硬件层面依赖特殊的CPU指令(CAS操作)实现锁。 不妨设有ReentrantLock的示例lock对象。lock.lock()在位置1立起了一道门，门上有一把锁即为lock对象。lock对象有一把唯一与之配对的钥匙，存放在lock对象的专有空间中。当线程执行到此处时，它会被这道门挡住，此时若钥匙还在专有空间中，它就可以拿起这把钥匙打开锁向下进行，因为唯一的一把钥匙在这个线程身上，那么后续所有被这把锁挡住的线程都无法进行(不仅仅是被位置1挡住的线程，若该锁也在位置2立起了门，那么被挡在位置2的线程也进行不下去，因为钥匙只有一把)。当持有钥匙的线程走到位置1对应的lock.unlock()处时，它将把钥匙还回lock对象的专有空间。 如果按照这个思路，竞争的其实不是锁，因为只要被门挡了，不论线程是否乐意，锁就在它们面前。真正竞争的其实是唯一配对的那一把钥匙(仅仅是用于理解，日常描述时我们还是会说线程持有了锁而非钥匙)。正如使用synchronized关键字时线程竞争的是监视器对象唯一的认可。 线程在等锁池等待的实现原理是阻塞原语线程挂起park()及线程恢复unpark()。详见Java 并发-线程阻塞工具类LockSupport。 简单的小例子 123456789101112131415161718192021222324252627import java.util.concurrent.locks.ReentrantLock;public class Test extends Thread &#123; private static ReentrantLock LOCK = new ReentrantLock(); private static int COUNT; @Override public void run() &#123; for (int i = 0; i &lt; 100000; i++) &#123; Test.LOCK.lock(); Test.COUNT++; Test.LOCK.unlock(); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; Test t1 = new Test(); Test t2 = new Test(); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(Test.COUNT); &#125;&#125; 输出： 1200000 判断锁(的钥匙)是否被当前线程持有12345678910111213import java.util.concurrent.locks.ReentrantLock;public class Test &#123; public static void main(String[] args) &#123; ReentrantLock lock = new ReentrantLock(); System.out.println(&quot;加锁前：&quot; + lock.isHeldByCurrentThread()); lock.lock(); System.out.println(&quot;已获得锁：&quot; + lock.isHeldByCurrentThread()); lock.unlock(); System.out.println(&quot;释放锁后：&quot; + lock.isHeldByCurrentThread()); &#125;&#125; 输出： 123加锁前：false已获得锁：true释放锁后：false 中断响应使用synchronized时，如果一个线程在等待监视器对象的认可，那么等待的结果只有两种：要么获得认可结束等待；要么无限期的等下去。换句话说，等待监视器对象认可的线程是没有中断机制的。 ReentrantLock在加锁时可使用lockInterruptibly()使得所加的锁可响应中断： 12345678910111213141516171819202122232425262728293031import java.util.concurrent.locks.ReentrantLock;public class Test extends Thread &#123; private static ReentrantLock LOCK = new ReentrantLock(); public Test(String name) &#123; super(name); &#125; @Override public void run() &#123; try &#123; Test.LOCK.lockInterruptibly(); while(true) ; &#125; catch (InterruptedException e) &#123; System.out.println(Thread.currentThread().getName() + &quot;在等锁时被中断&quot;); &#125; System.out.println(Thread.currentThread().getName() + &quot;执行结束&quot;); &#125; public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Test(&quot;t1&quot;); Thread t2 = new Test(&quot;t2&quot;); t1.start(); Thread.sleep(1000); t2.start(); Thread.sleep(1000); t2.interrupt(); &#125;&#125; 执行后输出如下。且程序不会结束：因为t1不会停止。 12t2在等锁时被中断t2执行结束 注意响应中断的是等锁的这一行为，即卡在Test.LOCK.lockInterruptibly();这一行时发生了中断，卡在这一行的线程并没有获得锁。 限时等待为了避免在申请不到锁时无限等待，上文中响应中断是其中一种方法，另一种方法是设置限时等待锁。 最为暴躁的等待方式为不等，即只要没申请到锁，立刻判为失败放弃申请，即： 12345678910111213141516171819202122232425262728293031323334import java.util.concurrent.locks.ReentrantLock;public class Test extends Thread &#123; private static ReentrantLock LOCK = new ReentrantLock(); public Test(String name) &#123; super(name); &#125; @Override public void run() &#123; if (Test.LOCK.tryLock()) &#123; System.out.println(System.currentTimeMillis() + &quot; -- &quot; + Thread.currentThread().getName() + &quot;获得锁&quot;); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; LOCK.unlock(); System.out.println(System.currentTimeMillis() + &quot; -- &quot; + Thread.currentThread().getName() + &quot;正常执行结束&quot;); &#125; else &#123; System.out.println(System.currentTimeMillis() + &quot; -- &quot; + Thread.currentThread().getName() + &quot;无法获得锁，执行结束&quot;); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Test(&quot;t1&quot;); Thread t2 = new Test(&quot;t2&quot;); t1.start(); Thread.sleep(1000); t2.start(); &#125;&#125; 输出： 1231507366890797 -- t1获得锁1507366891815 -- t2无法获得锁，执行结束1507366893817 -- t1正常执行结束 不那么粗暴的方式是设置一个等待时间： 1234567891011121314151617181920212223242526272829303132333435import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.ReentrantLock;public class Test extends Thread &#123; private static ReentrantLock LOCK = new ReentrantLock(); public Test(String name) &#123; super(name); &#125; @Override public void run() &#123; try &#123; if (Test.LOCK.tryLock(5, TimeUnit.SECONDS)) &#123; System.out.println(System.currentTimeMillis() + &quot; -- &quot; + Thread.currentThread().getName() + &quot;获得锁&quot;); Thread.sleep(3000); LOCK.unlock(); System.out.println(System.currentTimeMillis() + &quot; -- &quot; + Thread.currentThread().getName() + &quot;正常执行结束&quot;); &#125; else &#123; System.out.println(System.currentTimeMillis() + &quot; -- &quot; + Thread.currentThread().getName() + &quot;无法获得锁，执行结束&quot;); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Test(&quot;t1&quot;); Thread t2 = new Test(&quot;t2&quot;); t1.start(); Thread.sleep(1000); t2.start(); &#125;&#125; 输出： 12341507367395772 -- t1获得锁1507367398777 -- t1正常执行结束1507367398777 -- t2获得锁1507367401784 -- t2正常执行结束 公平锁synchronized及普通的ReentrantLock是非公平的，即当许可或钥匙空出后，哪一个线程获得它是随机的。线程优先级只能影响获得概率的大小，无法确保先进入等待队列的线程就一定能先获得资源。因此可能产生饥饿的现象。 公平锁严格遵守FIFO原则，即不会因插队现象导致饥饿的发生(已获得资源的线程不愿意释放而导致的饥饿就没办法了)。 公平锁的构建方式：new ReentrantLock(true)。默认的new ReentrantLock()相当于传入了false，即默认为非公平锁。之所以这么设计是因为公平锁为了实现功能必然需要维护一个有序队列，如果不需要FIFO，则这是不必要的开销。 如下代码实现了公平锁，输出基本为t1,t2交替进行。如果改为new ReentrantLock();即使用非公平锁，因为锁机制的优化，线程会更容易获得其曾经持有过的锁，此时的输出为大块的连续t1及大块的连续t2交替进行。 123456789101112131415161718192021222324import java.util.concurrent.locks.ReentrantLock;public class Test extends Thread &#123; private static ReentrantLock LOCK = new ReentrantLock(true); public Test(String name) &#123; super(name); &#125; @Override public void run() &#123; while (true) &#123; Test.LOCK.lock(); System.out.println(Thread.currentThread().getName() + &quot;获得了锁&quot;); Test.LOCK.unlock(); &#125; &#125; public static void main(String[] args) &#123; new Test(&quot;线程1&quot;).start(); new Test(&quot;线程2&quot;).start(); &#125;&#125;]]></content>
      <categories>
        <category>Java 并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>锁</tag>
        <tag>Lock</tag>
        <tag>ReentrantLock</tag>
        <tag>重入锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 并发-线程优先级]]></title>
    <url>%2F2017%2F09%2F29%2FJava%20%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[用户可指定不同线程间的优先级，高优先级的线程在竞争资源时更有利。注意这仅仅是”有利”，即高优先级线程较之低优先级线程有更高的概率获得资源，而非在资源争夺中一定会获胜。Java将线程的优先级分为1-10的十个级别，并且提供了3个内置在Thread类中的静态标量： 123public final static int MIN_PRIORITY = 1;public final static int NORM_PRIORITY = 5;public final static int MAX_PRIORITY = 10; 默认情况下，线程的优先级为NORM_PRIORITY = 5。 Java中的线程优先级是一个相对不靠谱的东西： 但凡是牵扯到概率，程序就无法精确控制。我们并不能确定高优先级的线程就一定会先于低优先级的线程获得资源。 本质上，Java线程的优先级必须要映射到操作系统底层的线程优先级才能发挥作用。但是很多操作系统的线程优先级的分级根本就没有10个那么多。这就导致复数个Java层面的线程优先级在操作系统看来实际是一回事。即程序员将两个线程的优先级分别设置为5,6并期望二者能在优先级上有所差异，但其实底层操作系统在实现时也许二者的优先级就完全一样了。这也是Java提供3个静态标量的原因：无论操作系统多么糟心，3个档次的优先级一般还是有的。因此推荐用静态标量的方式设置优先级，而不要自己指定数字。 所以，在要求严格的场合，还是要程序员自己在应用层面通过代码逻辑来控制线程的优先级。 小例子： 1234567891011121314151617181920212223242526272829public class Test extends Thread &#123; public Test(String name) &#123; super(name); &#125; @Override public void run() &#123; int count = 0; while (true) &#123; synchronized (Test.class) &#123; count++; if (count &gt; 10000000) &#123; System.out.println(Thread.currentThread().getName() + &quot; finish.&quot;); break; &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; Thread low = new Test(&quot;low&quot;); low.setPriority(Thread.MIN_PRIORITY); Thread high = new Test(&quot;high&quot;); high.setPriority(Thread.MAX_PRIORITY); low.start(); high.start(); &#125;&#125; 绝大多数情况，输出如下： 12high finish.low finish.]]></content>
      <categories>
        <category>Java 并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>线程</tag>
        <tag>优先级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 并发-3个并发相关的定律]]></title>
    <url>%2F2017%2F09%2F29%2FJava%20%E5%B9%B6%E5%8F%91-3%E4%B8%AA%E5%B9%B6%E5%8F%91%E7%9B%B8%E5%85%B3%E7%9A%84%E5%AE%9A%E5%BE%8B%2F</url>
    <content type="text"><![CDATA[Amdahl定律及Gustafson定律主要探讨的是并发程序对性能的提升。 摩尔定律 摩尔定律是由英特尔(Intel)创始人之一的戈登·摩尔(Gordon Moore)所提出的。其内容为：当价格不变时，集成电路上可容纳的元器件的数目，约每隔24个月便会增加一倍，性能也将提升一倍。 经常被引用的18个月，出自英特尔首席执行官大卫·豪斯。 Amdahl定律 其中： T1:1个CPU时的耗时。Tn：n个CPU时的耗时。F：程序中只能串行执行的比例。 首先分析F的极端情况。若F=0，即程序全部为可并行执行的代码，那么有T1=nTn，即加速比=n，即有几个CPU，程序的速度就被提升了几倍。若F=1，即程序代码全部都只能串行执行，那么有T1=Tn，即加速比=1，此时无论有多少个CPU，程序的效率都不会提升。 然后分析n的极端情况。若n=1，即只有一个CPU，那么有T1=Tn，即加速比=1，此时无论可并行执行的代码比例有多高，程序的效率都不会提升。若n=正无穷大，此时Tn=FT1，即加速比=1/F，与串行化代码的比例成反比，串行化比例越低，程序执行效率越高。 由此可得出：程序串行化代码比例越低，CPU数越多，并行执行的效率越高。 Gustafson定律 其中： 执行时间：并行程序优化后的耗时。总执行时间：未并行化前的耗时。 首先分析F的极端情况。若F=0，即程序全部为可并行执行代码，那么有加速比=n，即有几个CPU，程序的速度就被提升了几倍。若F=1，即程序代码全部都只能串行执行，那么有加速比=1，此时无论有多少个CPU，程序的效率都不会提升。 然后分析n的极端情况。若n=1，即只有一个CPU，那么有加速比=1，此时无论可并行执行的代码比例有多高，程序的效率都不会提升。若n=正无穷大，此时加速比=(1-F)n+F，若F也取极端值，即若F=1，则加速比=1；若F=0，加速比=n。至此还和预期相同，但是当F在(0,1)时，加速比依然为无穷大，只是这个无穷大受F的影响：F越大，增长越慢，但是无穷大依然还是无穷大，与预期的结果不同。 由此可得出：程序串行化代码比例越低，CPU数越多，并行执行的效率越高。 Amdahl定律及Gustafson定律是否矛盾本质上，两个定律描述的都是加速比，CPU数n，串行化执行代码的比例F三者之间的关系。但是二者不仅公式不同，在某些极限值情况下的结果也不同，那么二者是否矛盾？ 首先需要说明的是，所谓的”在某些极限值情况下的结果也不同”其实是弱极限情况。本质上这两个公式都是在用n与F来描述加速比。而前文的极限情况都是n，F其中之一达到极限值，另一个依然是可变的。若n与F都达到极限值，那么这两个定律的结论是相同的。前文推断出的认为Gustafson定律有问题的极限情况其实只有：n达到了正无穷，F未在极限值的状态下这一种。 造成这个差异的原因是因为两个公式在看待这个问题时从一开始的出发点就不同。Amdahl定律着重强调的是F的重要性，即F一定的情况下，无论CPU数怎么折腾，程序都会有一个理论的极限值。Gustafson定律强调的是n的重要性，即当F所占比重足够少时，程序执行的效率将随n线性增长。]]></content>
      <categories>
        <category>Java 并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>摩尔定律</tag>
        <tag>Amdahl定律</tag>
        <tag>Gustafson定律</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 并发-碎片]]></title>
    <url>%2F2017%2F09%2F29%2FJava%20%E5%B9%B6%E5%8F%91-%E7%A2%8E%E7%89%87%2F</url>
    <content type="text"><![CDATA[并发与并行并发(Concurrency)是指在一个”时间段”内多任务同时进行。并行(Parallelism)是指在一个”时间点”上多任务同时进行。 显然我们可以认为并行是并发的子集，因为一个时间段涵盖了无数的时间点。并发如果能做到在其时间段内的每个时间点都是多任务同时进行，那么就会特化为并行；如果做不到，那么在那些做不到的时间点上，任务其实还是串行的，只是通过CPU的调度轮转让各任务都有机会执行，如果这个轮转的时间间隔足够短，就会给观测的人造成”这些任务都是在并行执行”的错觉。 因为一个CPU(多核架构中指CPU的一个核)一次只能执行一条指令。因此如果只有一个CPU，那么只能实现并发，无论如何也无法实现并行。 从外部观测者的视角来看，并行和并发的结果是一致的：除非强迫症患者，一般我们是不会纠结于是否真的”同时在进行”。因此通常并不严格区分并发与并行。更常见的情况是，我们往往只会使用并发这个说法。 并发的意义 充分利用多处理器的性能。 我们所身处的世界本质上就是并发的，因此如果所要模拟实现的系统已经较为复杂，使用并发也是更自然合理的做法。]]></content>
      <categories>
        <category>Java 并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 基础-集合]]></title>
    <url>%2F2017%2F09%2F29%2FJava%20%E5%9F%BA%E7%A1%80-%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[阐述ArrayList、Vector、LinkedList的存储性能和特性。 ArrayList 和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector中的方法由于添加了synchronized修饰，因此Vector是线程安全的容器，但性能上较ArrayList差，因此已经是Java中的遗留容器。LinkedList使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。Vector属于遗留容器(Java早期的版本中提供的容器，除此之外，Hashtable(可简单的看作是线程安全的HashMap)、Dictionary、BitSet、Stack、Properties都是遗留容器)，已经不推荐使用，但是由于ArrayList和LinkedListed都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类Collections中的synchronizedList方法将其转换成线程安全的容器后再使用(这是对装潢模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强实现)。 补充：遗留容器中的Properties类和Stack类在设计上有严重的问题，Properties是一个键和值都是字符串的特殊的键值对映射，在设计上应该是关联一个Hashtable并将其两个泛型参数设置为String类型，但是Java API中的Properties直接继承了Hashtable，这很明显是对继承的滥用。这里复用代码的方式应该是Has-A关系而不是Is-A关系，另一方面容器都属于工具类，继承工具类本身就是一个错误的做法，使用工具类最好的方式是Has-A关系(关联)或Use-A关系(依赖)。同理，Stack类继承Vector也是不正确的。 Collection和Collections的区别？Collection是一个接口，它是Set、List等容器的父接口；Collections是个一个工具类，提供了一系列的静态方法来辅助容器操作，这些方法包括对容器的搜索、排序、线程安全化等等。 List、Map、Set三个接口存取元素时，各有什么特点？List以特定索引来存取元素，可以有重复元素。Set不能存放重复元素(用对象的equals()方法来区分元素是否重复)。Map保存键值对(key-value pair)映射，映射关系可以是一对一或多对一。Set和Map容器都有基于哈希存储和排序树的两种实现版本，基于哈希存储的版本理论存取时间复杂度为O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键(key)构成排序树从而达到排序和去重的效果。 TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？TreeSet(可以简单的看作有序的集合)要求存放的对象所属的类必须实现Comparable接口，该接口提供了比较元素的compareTo()方法，当插入元素时会回调该方法比较元素的大小。TreeMap(可以简单的看作有序的Map)要求存放的键值对映射的键必须实现Comparable接口从而根据键对元素进行排序。Collections工具类的sort方法有两种重载的形式，第一种要求传入的待排序容器中存放的对象比较实现Comparable接口以实现元素的比较；第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数必须实现Comparator接口(需要重写compare方法实现元素的比较)，相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用(Java中对函数式编程的支持)。 123456789101112131415161718192021222324252627282930313233343536import java.util.Set;import java.util.TreeSet;public class Test &#123; public static void main(String[] args) throws Exception &#123; Set&lt;Person&gt; set = new TreeSet&lt;&gt;(); // Java7的钻石语法(构造器后面的尖括号中不需要写类型) set.add(new Person(&quot;博丽灵梦&quot;, 16)); set.add(new Person(&quot;八云紫&quot;, 999999999)); set.add(new Person(&quot;雾雨魔理沙&quot;, 15)); set.add(new Person(&quot;十六夜咲夜&quot;, 18)); for(Person person : set) System.out.println(person); &#125;&#125;class Person implements Comparable&lt;Person&gt; &#123; private String name; private int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public String toString() &#123; return &quot;Student [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;; &#125; @Override public int compareTo(Person o) &#123; return this.age - o.age; // 比较年龄(年龄的升序) &#125;&#125; 输出： 1234Student [name=雾雨魔理沙, age=15]Student [name=博丽灵梦, age=16]Student [name=十六夜咲夜, age=18]Student [name=八云紫, age=999999999] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;import java.util.List;public class Test &#123; public static void main(String[] args) throws Exception &#123; List&lt;Person&gt; list = new ArrayList&lt;&gt;(); // Java 7的钻石语法(构造器后面的尖括号中不需要写类型) list.add(new Person(&quot;博丽灵梦&quot;, 16)); list.add(new Person(&quot;八云紫&quot;, 999999999)); list.add(new Person(&quot;雾雨魔理沙&quot;, 15)); list.add(new Person(&quot;十六夜咲夜&quot;, 18)); // 通过sort方法的第二个参数传入一个实现Comparator接口的对象 // 相当于是传入一个比较对象大小的算法到sort方法中 // 由于Java中没有函数指针、仿函数、委托这样的概念 // 因此要将一个算法传入一个方法中唯一的选择就是通过接口回调 Collections.sort(list, new Comparator&lt;Person&gt; () &#123; @Override public int compare(Person o1, Person o2) &#123; return o1.age - o2.age; // 比较年龄(年龄的升序) &#125; &#125;); for(Person person : list) System.out.println(person); &#125;&#125;class Person &#123; private String name; public int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public String toString() &#123; return &quot;Student [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;; &#125;&#125; 输出： 1234Student [name=雾雨魔理沙, age=15]Student [name=博丽灵梦, age=16]Student [name=十六夜咲夜, age=18]Student [name=八云紫, age=999999999]]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Collection</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 基础-异常]]></title>
    <url>%2F2017%2F09%2F29%2FJava%20%E5%9F%BA%E7%A1%80-%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[首先做一个约定： 设计者：可能会抛出Throwable的代码的编写者。 使用者：使用代码的人。 所谓异常机制，就是设计者明确自己所写的代码有何风险，应该由自己处理的就自己处理，不该自己处理的抛出给使用者。从而使程序更加健壮。 Throwablejava.lang.Throwable是异常机制的顶层类，常见的java.lang.Error与java.lang.Exception均为其子类。 以Throwable本身为例，Throwable一系通常都有如下两个构造函数： 123public Throwable()public Throwable(String message) 对于Throwable的实例t而言，直接打印t与打印t.toString()等同。而t.getMessage()则返回生成t时所用的字符串message。 无论是t，t.toString()亦或是t.getMessage()，在打印时都是返回一个字符串。另一个常用的异常打印方法为t.printStackTrace()，该方法的返回值为null，它会在自身的内部将t的堆栈轨迹信息打印至控制台上。 throw与throws若程序在执行到某行代码时产生了Throwable，则会自动将其抛出，程序中断。这样虽然简单方便，易于理解，然而却将异常机制的一切都交由JVM处理，问题直至运行期才会暴露出来，不可控性太大。因此Java提供了throw与throws关键字供程序员手动抛出Throwable，从而可以在编写代码时就手动处理这些Throwable。 throw出现在方法体内部的代码逻辑中，可以精确指定程序执行到该行代码时会抛出哪种Throwable。throws则出现在方法定义中。 当程序员在编写代码时遇到了一个在代码中显式抛出的Throwable，都需依序考虑如下两个问题： 是否需要处理这个Throwable？ 如果需要，如何处理这个Throwable？ 首先需要明确的是，无论是设计者亦或是使用者，无论Throwable抛出的方式是throw还是throws，这两个问题的处理思路都是一致的： 对于第一个问题。Throwable依严重性由大至小被分为Error与Exception，Exception依严重性由大至小又分为受检查异常(Checked Exception)及运行时异常(RuntimeException，为与受检查异常对应，也被称为Unchecked Exception，从这个角度来看，Error都是Unchecked)。所谓受检查，实际指得是受编译器检查：编译器认为这个Throwable非常重要，无论是向更上一层抛出也好，try-catch自行处理也罢，程序员不能无视。而Unchecked则是指编译器不会检查，程序员可自行决定是否无视：Error被设定为Unchecked是因为问题太大程序员已无法处理，而运行时异常被设定为Unchecked是因为问题不大程序员可以不用处理。 所谓不处理就是无视，个人并不推荐这种方式。也就是说虽然从语法的角度上讲可以无需处理运行时异常及Error，但均推荐显式处理它们。 然后进入第二个问题。处理方式有以下两种： 应该由自己处理的使用try-catch在内部将这个Throwable消化，对于更上层的观测者而言，他们是感知不到抛出过这个Throwable的。 不应该由自己处理的通过throws抛出给更上层的观测者。 这个”应该”取决于具体的代码逻辑。通常来说，以AOP形式存在的切面方法，比如与主业务流程无关的工具型类方法，都会将Throwable throws出去。因为主业务流程最好能够掌控全局：知道工具方法可能产生的Throwable，并制定合理的对策，同时也可以在主流程的日志文件中留下记录。而若工具类方法通过try-catch将Throwable自己消化掉，那么主业务流程将完全不知道发生了什么，它只知道我求这个工具类方法办个事，那边回复办不到(有些时候甚至连这点也确认不了。比如工具类方法返回的不是代表成功或失败的标志，而是一个具体的对象，那么若这个对象为null，是无法判断到底是因为出错了返回null还是没出错就该是null)。同时因为主流程拿不到Throwable，那么错误日志也要由工具类方法打印。这样就会使得能够打印错误日志的类增多，错误信息打印得过于松散，不利于日志分析。更本质的来说，错误信息就不该工具类方法打印，工具类方法就是一个个简单的，处理某个小功能的函数，应该是随时复制粘贴到一个新的工程中直接就能用的，不应与日志系统做这么强的耦合。当然也可以要求工具类方法在其返回值内部包装错误信息，不过这么做显然太过复杂了。 ErrorError是设计者认为的严重错误：这类错误一旦发生，程序便无法继续下去而应停止。这里的重点在于”认为”两个字，也就是说这是设计者的主观判断，而非客观事实。对于优秀的设计者而言，客观上确实会导致程序无法进行下去的错误，例如Java虚拟机栈溢出等严重的JVM错误，系统崩溃，所需内存空间不足等自然应该被设定为Error。不过还有一些Error是设计者纯从业务角度上设置的，比较典型的就是Java的断言机制：满足断言所需的条件从业务的角度上考虑极其重要，只要断言结果失败，程序便需停止。 纯粹从try-catch的机制上考虑，它能捕获所有的Throwable，自然也可以捕获Error，例如： 12345678910111213141516public class Test &#123; /** * 启动参数：-ea * 该参数用于开启断言 */ public static void main(String[] args) &#123; int a = 0; try &#123; assert a &gt; 0 : &quot;a小于等于0&quot;; &#125; catch (Error e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;继续&quot;); &#125;&#125; 输出： 123java.lang.AssertionError: a小于等于0 at com.test.Test.main(Test.java:8)继续 不过我并不推荐大家在代码中强行使用try-catch处理Error。关于Error，很多人都搞反了一个因果关系：并非因为是Error而不推荐使用try-catch捕获，而是因为设计者不推荐使用try-catch，所以才将其设定为Error。因此如果在编码中遇到了需要捕获Error的场景，最佳的解决方案应该是联系设计者将其改为Exception：因为此时这个问题已经是可处理的了，应该从本质上修改它的含义，而非由使用者强制捕获。 那么Java异常机制又为什么允许try-catch捕获Error呢？为什么不从语法上干脆将其判为非法呢？这样不是更符合Error的初衷吗？这样不是能迫使更多的程序员遵守良好的规范吗？个人推测原因主要有以下两点： 其一，虽然程序必须因Error而停止，但是允许使用者在停止前做点收尾工作还是很合理的。实际上，Error最为常见的处理方式就是用try-catch捕获，在完成收尾工作后再在catch中将其throw出去。 其二，Throwable是否严重依靠的是设计者的主观判断，而设计者和使用者往往不是一个人，有着不同的身份，对同样一个问题的严重性的判断自然也不同。 我们不妨用一个小例子来说明这个问题。假如程序员A写了工具类方法m，该方法可能会抛出Error。又有程序员B，C，D使用A的m。某天B找到A，说你这个m抛出的那个错误吧，在我这看没什么大不了的，顶多算个Exception，要不你给改成Exception吧。A说那可不行，m是我写的，到底怎么样算严重错误自然应该我来把控，我抛出了Error就说明它确实就是有这么严重。而且不仅是我这么想，你看C，D他们俩也没有意见啊，难道我能为了你而让C，D他俩难办吗？B一想确实是这么个理，便自己用try-catch机制捕获并处理了这个Error。 上例虽然打破了前文说的那个规范，但却不能因此说规范便不重要了。恰恰相反，这正证明了规范的重要之处：若B不遵守规范，他就不会去找A并希望A将Error改为Exception，而是直接就用try-catch将Error处理了。虽然结果上来看是一样的，但是过程却有巨大的不同：上例中B最后捕获并处理Error的前提是建立在他去找了A并进行了细致的沟通，可以说这是一个大家都认可的结果。能做到这一点便已经完成了整个Java异常机制中最重要的目标：让使用者明确他们所欲使用的代码有何风险，并做出合理的应对。正如异常机制的顶层类Throwable的名字所表达的：所谓异常就是设计者将自己的代码可能的问题”抛出”给使用者，让他们心里有点B数。 ExceptionException表示设计者认为的，程序可以处理的异常。使用者可以通过捕获异常将灾害控制在尽量小的范围内。 和上文说的Error同理，Exception的这个”可处理”依然是设计者的主观判断。换句话说，围绕Throwable类所构建的整个异常机制都来自于设计者的主观判断，所以使用者其实是默认相信设计者的判断的。如果设计者对问题严重性的判断有误，那么自然就会影响到整个代码的健壮性。 Throwable依严重性由大至小被分为Error与Exception，Exception依严重性由大至小又分为受检查异常(Checked Exception)及运行时异常(RuntimeException)。 Exception有一个名为java.lang.RuntimeException的子类，所有继承自RuntimeException的类都被称为运行时异常，其他的Exception的子类被称为受检查异常。 程序员可以无视被抛出的运行时异常，却必须显式的处理被抛出的受检查异常：使用try-catch自行处理或者使用throws抛给更上一层。 例如以下代码： 123456public class Test &#123; public static void main(String[] args) &#123; Thread.sleep(-100); &#125;&#125; 此时无法通过编译，Eclipse下提示 1Unhandled exception type InterruptedException。 而java.lang.Thread类的sleep方法是这样的： 1public static native void sleep(long millis) throws InterruptedException; InterruptedException就是设计者显式声明的受检查异常。换句话说，就是设计者在提醒使用者：我的代码可能会出如下的问题！你必须想好合理的应对措施。那么作为使用者，我们可以这样做： 123456public class Test &#123; public static void main(String[] args) throws InterruptedException &#123; Thread.sleep(-100); &#125;&#125; 此时，使用者不处理这个异常，而是将其向更高的层次抛去。在上例中，调用位置main方法已经是顶级层次了，因此这样写就相当于没管这个异常，设计者是否将其抛出结果都一样。不过类似于上文中提到的ABCD四个程序员的例子，即便如此，设计者抛出异常InterruptedException依然是有意义的：因为此时使用者将该异常继续向上抛出是在明确了这个风险后思考的结果，而非真的是在什么都不知道的情况下什么都不做。 当然，我们也可以选择处理这个异常： 12345678910public class Test &#123; public static void main(String[] args) &#123; try &#123; Thread.sleep(-100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 然后我们运行上述代码，输出： 123Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: timeout value is negative at java.lang.Thread.sleep(Native Method) at test.Test.main(Test.java:7) try-catch并未生效，程序还是因异常而中断了。因为此时抛出的异常并非设计者显示抛出的那个InterruptedException，而是IllegalArgumentException：时间当然不可能是负数。这是一个运行时异常。 这种未被使用者显式处理的异常就像是一颗炸弹，只有当程序产生异常时才会因无法处理而挂到，这实在是一件让人很遗憾的事：上线新功能后观察了1个小时运行情况，哦耶一切正常，然后开开心心的下班回家，半夜的时候出现了异常，服务跪掉，然后被领导一个电话拎起来跪着改bug直到天明。 那么，设计者能否将自身代码所有可能产生的问题都显式声明出来呢(写在注释里或在方法定义中throws出去)？这显然是不可能做到的，没有人可以在编码阶段就考虑到所有情况，算无遗策，设计者只能根据他自身的判断，尽可能的将必须处理的问题挑出来。 不过上面那个半夜起床改bug的问题实在是过于让人忧郁了，为此伟大的前辈们总结了这样一个套路： 1234567891011121314public class Test &#123; public static void main(String[] args) &#123; try &#123; Thread.sleep(-100); &#125; catch (InterruptedException e) &#123; System.out.println(&quot;捕获并处理InterruptedException&quot;); &#125; catch (IllegalArgumentException e) &#123; System.out.println(&quot;捕获并处理IllegalArgumentException&quot;); &#125; catch (Exception e) &#123; System.out.println(&quot;捕获并处理未知的Exception&quot; + e); &#125; &#125;&#125; 输出： 1捕获并处理IllegalArgumentException 这其实是利用了Java的继承机制，其思路很明显：先处理设计者显式声明的异常，随后如果使用者有什么不放心的，也可在与设计者沟通或者看设计者提供的文档后写几个自己认为可能会出现的异常。最后用所有异常类的父类Exception兜底，将可能产生的运行时异常一网打尽，并用一个公共的，稳妥的方式处理它。其效果拔群：起码基本是不会在半夜被拎起来了，而是可以在第二天偷摸的通过日志发现异常，然后再偷摸的改掉这个bug。 当然，如果某些异常的处理策略确实就是相同的，也可将它们写到一起： 123456789101112public class Test &#123; public static void main(String[] args) &#123; try &#123; Thread.sleep(-100); &#125; catch (InterruptedException | IllegalArgumentException e) &#123; System.out.println(&quot;捕获并处理&quot; + e); &#125; catch (Exception e) &#123; System.out.println(&quot;捕获并处理未知的Exception&quot; + e); &#125; &#125;&#125; 输出： 1捕获并处理java.lang.IllegalArgumentException: timeout value is negative 那么又有人说了，用Exception兜底很稳啊，那还费什么劲，只捕获Exception不行吗： 12345678910public class Test &#123; public static void main(String[] args) &#123; try &#123; Thread.sleep(-100); &#125; catch (Exception e) &#123; System.out.println(&quot;捕获并处理未知的Exception:&quot; + e); &#125; &#125;&#125; 输出： 1捕获并处理未知的Exception:java.lang.IllegalArgumentException: timeout value is negative 这样做确实可以让代码更简洁，然而问题也很致命：使用者只能用公共的处理模块处理所有异常，不能根据不同的异常设置不同的对策了。因此在这里我还是建议大家不要怕麻烦，除非某些异常确实就是要用通用的模块处理，否则还是单独写处理逻辑更利于维护。 异常机制使用技巧首先我们来看如下这段代码： 123456789public class Test &#123; public static void main(String[] args) &#123; int a = 0; int b = 100; if (a == 0) System.out.println(b / (a + 1)); else System.out.println(b / a); &#125;&#125; 当然也可以这样写： 123456789101112public class Test &#123; public static void main(String[] args) &#123; int a = 0; int b = 100; try &#123; System.out.println(b / a); &#125; catch (ArithmeticException e) &#123; System.out.println(b / (a + 1)); &#125; &#125;&#125; 这两种写法均能实现相同的功能，看似没有什么区别，但是事实上，写代码不仅仅要看当前的业务逻辑，更要遵守语法本身的基本规范。第二段代码最本质的问题根本就不是什么异常机制占用资源高，降低程序性能之类的具体原因，因为如果问题是这些的话，那么是不是说如果程序不大，机器硬件资源很充足，第二段代码就没问题了？当然不是，第二段代码最本质的问题在于它违反了Java异常机制的设计初衷，这两段代码中的除零根本就不是异常，而是一个正常的业务逻辑，换句话说，尽量不要用异常机制去处理正常逻辑的代码，即不要把异常机制当成正常逻辑下的条件分支去用。这里之所以用了尽量，是因为写代码也要有灵性，某些特殊情况下取个巧，将异常机制融入正常逻辑会更好。不过上例显然不属于这种情况。 正如上文所说的不要用异常机制处理正常的业务逻辑那样，Throwable终究是一种无可避免的情况下产生的不正常的东西，所以能用正常业务代码处理的就不要显式声明为Throwable。例如有人不进行边界判断，而是直接用异常机制去控制非法的方法入参，这是不可取的。比如如下代码： 12345678910public class Test &#123; public static int m(int a, int b) &#123; return a / b; &#125; public static void main(String[] args) &#123; int c = Test.m(1, 0); &#125;&#125; 输出： 123Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero at com.test.Test.m(Test.java:6) at com.test.Test.main(Test.java:10) 显然这是最糟的写法，调用者对于m可能会抛出ArithmeticException这一运行时异常完全没有准备。因此自然而言想要这么写： 1234567891011121314public class Test &#123; public static int m(int a, int b) &#123; if (b == 0) &#123; System.out.println(&quot;除数不能为0，m执行失败&quot;); return 0; &#125; return a / b; &#125; public static void main(String[] args) &#123; int c = Test.m(1, 0); &#125;&#125; 输出： 1除数不能为0，m执行失败 我想，大家在看到方法m里的那句输出时心里可能就会隐隐觉得不妥了，这代码似乎依然不怎么样。没错，这种处理方式对于调用者而言异常是透明的。那么怎么写比较好呢？笔者比较认可如下的写法： 1234567891011121314public class Test &#123; /** * @throws ArithmeticException */ public static int m(int a, int b) &#123; if (b == 0) throw new ArithmeticException(); return a / b; &#125; public static void main(String[] args) &#123; int c = Test.m(1, 0); &#125;&#125; 输出： 123Exception in thread &quot;main&quot; java.lang.ArithmeticException at aaa.Test.m(Test.java:6) at aaa.Test.main(Test.java:11) 需要注意的是，上述代码是先进行了边界判断，再依具体的代码逻辑选择抛出ArithmeticException这一具体的异常。和直接使用异常机制代替边界判断是不同的。 正如我所信奉的那句仿佛是出自于圣经一般的格言：Thou Shalt Comment(汝应注释)所说，设计者一定要为异常写好注释。 catch代码块的内容不要为空。最不济也要打一行日志，记录下错误。 自定义异常优先使用Java API提供的标准Throwable，尽量不要自造Throwable。因为设计者只要自造了Throwable，使用者就必须引入这个Throwable，平添复杂性。实际上，根据我自身的经验，Java API提供的标准Throwable基本上已经能满足所有业务需求了。如果实在是需要自造Throwable，建议也只是自造Exception。 在真正开始自造Exception之前，我们不妨以IOException为例，看看Java API中的异常是怎么写的。因为代码都很短，我们可以从更上层的Exception开始贴起(Throwable就有些长了) Exception: 123456789101112131415161718192021222324252627package java.lang;public class Exception extends Throwable &#123; static final long serialVersionUID = -3387516993124229948L; public Exception() &#123; super(); &#125; public Exception(String message) &#123; super(message); &#125; public Exception(String message, Throwable cause) &#123; super(message, cause); &#125; public Exception(Throwable cause) &#123; super(cause); &#125; protected Exception(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) &#123; super(message, cause, enableSuppression, writableStackTrace); &#125;&#125; IOException: 12345678910111213141516171819202122package java.io;publicclass IOException extends Exception &#123; static final long serialVersionUID = 7818375828146090155L; public IOException() &#123; super(); &#125; public IOException(String message) &#123; super(message); &#125; public IOException(String message, Throwable cause) &#123; super(message, cause); &#125; public IOException(Throwable cause) &#123; super(cause); &#125;&#125; 实在是有趣！ 一共没几行代码不说，还没有任何独有的逻辑，全部都是super。看来Java API的思路就是在Throwable中设计一个套路，然后它的小弟们都沿着这个套路走。仔细想想确实也够用了，我们在查看异常信息时需要的无非就是异常类型及描述字符串。 仿造IOException，我们很容易的就可以写出一个自定义异常： 1234567891011121314151617181920212223242526272829import java.io.IOException;public class Test &#123; public static void main(String[] args) throws MyIOException &#123; throw new MyIOException(&quot;自造的IOException&quot;); &#125;&#125;class MyIOException extends IOException &#123; private static final long serialVersionUID = 1L; public MyIOException() &#123; super(); &#125; public MyIOException(String message) &#123; super(message); &#125; public MyIOException(String message, Throwable cause) &#123; super(message, cause); &#125; public MyIOException(Throwable cause) &#123; super(cause); &#125;&#125; 输出： 12Exception in thread &quot;main&quot; com.test.MyIOException: 自造的IOException at com.test.Test.main(Test.java:8) 默认调用的是toString()方法，它位于Throwable中： 12345public String toString() &#123; String s = getClass().getName(); String message = getLocalizedMessage(); return (message != null) ? (s + &quot;: &quot; + message) : s;&#125; 我们当然也可以重写它： 123456789101112131415161718192021222324252627282930313233343536import java.io.IOException;public class Test &#123; public static void main(String[] args) throws MyIOException &#123; throw new MyIOException(&quot;描述信息&quot;); &#125;&#125;class MyIOException extends IOException &#123; private static final long serialVersionUID = 1L; public MyIOException() &#123; super(); &#125; public MyIOException(String message) &#123; super(message); &#125; public MyIOException(String message, Throwable cause) &#123; super(message, cause); &#125; public MyIOException(Throwable cause) &#123; super(cause); &#125; @Override public String toString() &#123; String s = &quot;一种特殊的IOException&quot;; String message = super.getLocalizedMessage(); return (null != message) ? (s + &quot;: &quot; + message) : s; &#125;&#125; 输出： 12Exception in thread &quot;main&quot; 一种特殊的IOException: 描述信息 at com.test.Test.main(Test.java:8) try-catch-finally中的return12345678910111213141516171819202122public class Test &#123; private static String test() &#123; String result = null; try &#123; result = &quot;try&quot;; System.out.println(result); return result; &#125; catch (Exception e) &#123; result = &quot;catch&quot;; System.out.println(result); return result; &#125; finally &#123; result = &quot;finally&quot;; System.out.println(result); &#125; &#125; public static void main(String[] args) &#123; System.out.println(&quot;method result = &quot; + Test.test()); &#125;&#125; 输出： 123tryfinallymethod result = try 上例的执行顺序为： return前将待return的值保存。 将待return的值复制一份给finally。 执行finally。类似于Java 基础-方法参数的值传递及引用传递。finally中所有的操作都是基于这份复制后的新值，与原有待返回的值无关。 执行返回。 那么上述执行顺序的底层实现是什么样的呢？我们再来看如下代码： 123456789101112131415public class Test &#123; public int inc() &#123; int x; try &#123; x = 1; return x; &#125; catch (Exception e) &#123; x = 2; return x; &#125; finally &#123; x = 3; &#125; &#125;&#125; 为从字节码层面分析该问题，我们先用javap生成该类class文件的反编译文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152Classfile /D:/Test.class Last modified 2017-11-17; size 397 bytes MD5 checksum c86c2f92295c441780b75728395e2c1f Compiled from &quot;Test.java&quot;public class Test SourceFile: &quot;Test.java&quot; minor version: 0 major version: 51 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #4.#16 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = Class #17 // java/lang/Exception #3 = Class #18 // Test #4 = Class #19 // java/lang/Object #5 = Utf8 &lt;init&gt; #6 = Utf8 ()V #7 = Utf8 Code #8 = Utf8 LineNumberTable #9 = Utf8 inc #10 = Utf8 ()I #11 = Utf8 StackMapTable #12 = Class #17 // java/lang/Exception #13 = Class #20 // java/lang/Throwable #14 = Utf8 SourceFile #15 = Utf8 Test.java #16 = NameAndType #5:#6 // &quot;&lt;init&gt;&quot;:()V #17 = Utf8 java/lang/Exception #18 = Utf8 Test #19 = Utf8 java/lang/Object #20 = Utf8 java/lang/Throwable&#123; public Test(); flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 1: 0 public int inc(); flags: ACC_PUBLIC Code: stack=1, locals=5, args_size=1 0: iconst_1 // 将int型1压入操作数栈 // 操作数栈(自底向上)：1 // 局部变量表：this 1: istore_1 // 将栈顶int型数值弹出并存入局部变量表1号索引处 // 操作数栈(自底向上)：无 // 局部变量表：this,1 2: iload_1 // 将局部变量表1号索引位置的int型数值压入操作数栈 // 操作数栈(自底向上)：1 // 局部变量表：this,1 3: istore_2 // 将栈顶int型数值弹出并存入局部变量表2号索引处 // 操作数栈(自底向上)：无 // 局部变量表：this,1,1 4: iconst_3 // 将int型3压入操作数栈 // 操作数栈(自底向上)：3 // 局部变量表：this,1,1 5: istore_1 // 将栈顶int型数值弹出并存入局部变量表1号索引处 // 操作数栈(自底向上)：无 // 局部变量表：this,3,1 6: iload_2 // 将局部变量表2号索引位置的int型数值压入操作数栈 // 操作数栈(自底向上)：1 // 局部变量表：this,3,1 7: ireturn // 返回操作数栈栈顶的int类型数值 8: astore_2 // [0,3]产生异常跳入本行，跳入时默认会将异常对象压入操作数栈 // 假设压入异常对象之前的操作数栈及局部变量表保持指令2结束时的样子。 // 本指令为：将栈顶引用型值弹出并存入局部变量表2号索引处 // 操作数栈(自底向上)：1 // 局部变量表：this,1,e 9: iconst_2 // 将int型2压入操作数栈 // 操作数栈(自底向上)：1,2 // 局部变量表：this,1,e 10: istore_1 // 将栈顶int型数值弹出并存入局部变量表1号索引处 // 操作数栈(自底向上)：1 // 局部变量表：this,2,e 11: iload_1 // 将局部变量表1号索引位置的int型数值压入操作数栈 // 操作数栈(自底向上)：1,2 // 局部变量表：this,2,e 12: istore_3 // 将栈顶int型数值弹出并存入局部变量表3号索引处 // 操作数栈(自底向上)：1 // 局部变量表：this,2,e,2 13: iconst_3 // 将int型3压入操作数栈 // 操作数栈(自底向上)：1,3 // 局部变量表：this,2,e,2 14: istore_1 // 将栈顶int型数值弹出并存入局部变量表1号索引处 // 操作数栈(自底向上)：1 // 局部变量表：this,3,e,2 15: iload_3 // 将局部变量表3号索引位置的int型数值压入操作数栈 // 操作数栈(自底向上)：1,2 // 局部变量表：this,3,e,2 16: ireturn // 返回操作数栈栈顶的int类型数值 17: astore 4 // [0,3]或[8,12]产生异常跳入本行，跳入时默认会将异常对象压入操作数栈 // 假设压入异常对象之前的操作数栈及局部变量表保持指令11结束时的样子。 // 本指令为：将栈顶引用型值弹出并存入局部变量表4号索引处 // 操作数栈(自底向上)：1,2 // 局部变量表：this,2,e,空,e2 // 其中e为try中抛出的异常，e2为catch中抛出的异常 19: iconst_3 // 将int型3压入操作数栈 // 操作数栈(自底向上)：1,2,3 // 局部变量表：this,2,e,空,e2 20: istore_1 // 将栈顶int型数值弹出并存入局部变量表1号索引处 // 操作数栈(自底向上)：1,2 // 局部变量表：this,3,e,空,e2 21: aload 4 // 将局部变量表4号索引位置的引用型值压入操作数栈 // 操作数栈(自底向上)：1,2,e2 // 局部变量表：this,3,e,空,e2 23: athrow // 将操作数栈栈顶的异常抛出 Exception table: from to target type 0 4 8 Class java/lang/Exception 0 4 17 any 8 13 17 any 17 19 17 any LineNumberTable: line 6: 0 line 7: 2 line 12: 4 line 8: 8 line 9: 9 line 10: 11 line 12: 13 StackMapTable: number_of_entries = 2 frame_type = 72 /* same_locals_1_stack_item */ stack = [ class java/lang/Exception ] frame_type = 72 /* same_locals_1_stack_item */ stack = [ class java/lang/Throwable ]&#125; 程序可能的执行流程及返回结果有如下4种： try中未产生异常，则流程为try-finally。返回1。即： [0,3]:try [4,5]:finally [6,7]:try返回1。 try中产生Exception及其子类的异常则进入catch，若catch未产生异常，则进入finally，返回2。 [0,x]:try,x取值范围为[0,3] [8,12]:catch [13,14]:finally [15,16]:catch返回2。 try中产生Exception及其子类的异常则进入catch，若catch产生异常，则进入finally，而后抛出该异常，无返回值。 [0,x]:try,x取值范围为[0,3] [8,y]:catch，y取值范围为[8,12] [17]:记录异常 [19,20]:finally 21,23:抛出异常，无返回值 try中产生不属于Exception及其子类的异常，则进入finally，而后抛出该异常，无返回值。 [0,x]:try,x取值范围为[0,3] [17]:记录异常 [19,20]:finally 21,23:抛出异常，无返回值 在JDK1.4.2之前JVM采用jsr及ret指令来实现finally。JDK1.4.2中虽然jsr及ret仍有效，但javac编译器已经不再生成了这两个指令了，它会在finally可能出现的所有路径上冗余添加finally代码。而到了JDk1.7，jsr及ret已被完全禁用，若class文件中出现了这两个指令，JVM会在类加载-连接-验证-字节码校验阶段抛出异常。 实例代码的执行流程分析也证明了这一点。[4,5]，[13,14]，[19,20]就是冗余存储的finally逻辑。 这样我们便从字节码的层面上验证了最开始描述的执行顺序，同时还知道了不仅try到finally对于return值会采取值传递的方式，catch到finally时也一样。 因为finally会被无条件执行，所以最好不要在finally中使用return语句：虽然语法上没什么问题，却会造成逻辑混乱，不利于代码的维护。 最后我们可以再一起来做一个小练习： 12345678910111213141516171819202122public class Test &#123; public static void main(String[] args) &#123; try &#123; throw new ESon(); &#125; catch (ESon e) &#123; System.out.println(&quot;ESon&quot;); &#125; catch (EFather e) &#123; System.out.println(&quot;EFather&quot;); &#125; &#125;&#125;class EFather extends Exception &#123; private static final long serialVersionUID = 6536621933798974349L;&#125;class ESon extends EFather &#123; private static final long serialVersionUID = 6091571391764298719L;&#125; 此时Eclipse下程序会报警告： 1Unreachable catch block for EFather. Only more specific exceptions are thrown and they are handled by previous catch block(s). 输出： 1ESon 若将catch的顺序交换，即： 12345678910111213141516171819202122public class Test &#123; public static void main(String[] args) &#123; try &#123; throw new ESon(); &#125; catch (EFather e) &#123; System.out.println(&quot;EFather&quot;); &#125; catch (ESon e) &#123; System.out.println(&quot;ESon&quot;); &#125; &#125;&#125;class EFather extends Exception &#123; private static final long serialVersionUID = 6536621933798974349L;&#125;class ESon extends EFather &#123; private static final long serialVersionUID = 6091571391764298719L;&#125; 程序将无法通过编译，Eclipse下报： 1Unreachable catch block for ESon. It is already handled by the catch block for EFather。 若按如下修改： 12345678910111213141516171819202122232425262728public class Test &#123; public static void main(String[] args) throws Exception &#123; try &#123; try &#123; throw new ESon(); &#125; catch (EFather f) &#123; System.out.println(&quot;Caught Father&quot;); throw f; &#125; &#125; catch (ESon s) &#123; System.out.println(&quot;Caught Son&quot;); return; &#125; finally &#123; System.out.println(&quot;Hello World!&quot;); &#125; &#125;&#125;class EFather extends Exception &#123; private static final long serialVersionUID = 6536621933798974349L;&#125;class ESon extends EFather &#123; private static final long serialVersionUID = 6091571391764298719L;&#125; 输出： 123Caught FatherCaught SonHello World! try-catch-finally常用情景：文件读写按照上文讨论的结果，Throwable是由代码的设计者抛出的。其中一个很常见的应用场景就是文件的读写。 之所以这么说，是因为文件读写的程序出了错，很多时候锅往往不会在代码本身：比如要操作的文件没有读写权限，或者干脆就没有。对于设定好要读写文件的代码而言，这确实是异常情况，而且无论代码写得多么健壮都无法避免。 下面我们来看一个简单的小例子： 123456789101112131415161718192021222324252627282930import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;public class Test &#123; public static void main(String[] args) &#123; FileReader fileReader = null; try &#123; fileReader = new FileReader(&quot;d:/a.txt&quot;); &#125; catch (FileNotFoundException e) &#123; System.out.println(&quot;异常点1&quot;); e.printStackTrace(); return; &#125; try &#123; // 方法返回int，强转为char System.out.println((char)fileReader.read()); &#125; catch (IOException e) &#123; System.out.println(&quot;异常点2&quot;); e.printStackTrace(); &#125; try &#123; if(null != fileReader) fileReader.close(); &#125; catch (IOException e) &#123; System.out.println(&quot;异常点3&quot;); e.printStackTrace(); &#125; &#125;&#125; 然后我们创建d:/a.txt，并在其中写入内容”博丽灵梦”。然后运行程序，输出为: 1博 这是符合预期的正常情况，没毛病。不过，如果我们删掉d盘下的a.txt，再运行程序，将输出： 1234567异常点1java.io.FileNotFoundException: d:\a.txt (系统找不到指定的文件。) at java.io.FileInputStream.open(Native Method) at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:146) at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:101) at java.io.FileReader.&lt;init&gt;(FileReader.java:58) at com.test.Test.main(Test.java:12) 上述代码已可以健壮的实现所需功能了，不过还有可以改进的地方：文件的关闭被独立出去了，如果分支处理不当可能会有漏关的风险。而实际上它与创建应是一一对应的关系。我们可以使用finally的特性来确保这一点： 1234567891011121314151617181920212223242526import java.io.FileReader;import java.io.IOException;public class Test &#123; public static void main(String[] args) &#123; FileReader fileReader = null; try &#123; fileReader = new FileReader(&quot;d:/a.txt&quot;); // 方法返回int，强转为char System.out.println((char)fileReader.read()); &#125; catch (IOException e) &#123; // FileNotFoundException是IOException的子类，因此合并了 System.out.println(&quot;异常点1&quot;); e.printStackTrace(); return; &#125; finally &#123; try &#123; if(null != fileReader) fileReader.close(); &#125; catch (IOException e) &#123; System.out.println(&quot;异常点2&quot;); e.printStackTrace(); &#125; &#125; &#125;&#125; 看起来好多了。不过我们仍然可以让它更为简洁。因为对于文件操作这一类的资源读取而言，关闭读入源是如此的常见，因此语言的API中往往会提供对应的快捷方式。比如Python中就有对应的try-with，可以在资源使用完毕后(代码执行出try的范围)由系统自动关闭资源，而无需程序员显式设置。在JDK1.7中，Java终于也提供了类似的功能： 1234567891011121314151617import java.io.FileReader;import java.io.IOException;public class Test &#123; public static void main(String[] args) &#123; try (FileReader fileReader = new FileReader(&quot;d:/a.txt&quot;);) &#123; // 方法返回int，强转为char System.out.println((char)fileReader.read()); &#125; catch (IOException e) &#123; // FileNotFoundException是IOException的子类，因此合并了 System.out.println(&quot;异常点1&quot;); e.printStackTrace(); return; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 基础-断言]]></title>
    <url>%2F2017%2F09%2F29%2FJava%20%E5%9F%BA%E7%A1%80-%E6%96%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[断言是一种常见的调试方式，很多语言(C,C++,Python,Java)都支持这种机制。因为是调试机制，因此断言默认是不开启的。若要开启断言，则需在启动参数中添加-enableassertions，或简写为-ea。 Java中的断言可有如下两种形式： 第一种： 1assert a &gt; 0; 失败时输出： 12Exception in thread &quot;main&quot; java.lang.AssertionError at test.Test.main(Test.java:7) 第二种： 1assert a &gt;= 0 : &quot;a小于0&quot;; 失败时输出： 12Exception in thread &quot;main&quot; java.lang.AssertionError: a小于0 at test.Test.main(Test.java:8) 断言失败后，JVM会抛出一个AssertionError错误，它继承自Error。注意，这是一个错误，是不可恢复的。也就表示这是一个严重的问题，开发者必须予以关注并解决之。 断言的设计初衷为辅助调试，因此断言不应影响代码的执行结果。]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>断言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 基础-日期和时间]]></title>
    <url>%2F2017%2F09%2F29%2FJava%20%E5%9F%BA%E7%A1%80-%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[简单来说，Java的时间API可归结为以下3个类： Date:时间API的核心类。最初很强大，几乎包含了时间API的所有功能。后来被拆分，只保留与核心long类型毫秒数相关的功能，其余功能均已标记为废弃方法。 DateFormat:负责进行Date与格式化字符串之间的转换。主要用于将Date展示为各种人类易于阅读的格式，基本不承载具体的功能。 Calendar:字面含义是日历类。是Java时间API中功能最强大的类。可以这么理解，除了Date及DateFormat所实现的那一点功能之外，其余的功能都在Calendar中。 Date一个java.util.Date类的实例表示一个精确的时刻，单位为毫秒。核心字段用long类型存储，记录自标准纪元1970年1月1日0时0分0秒起到该特定时刻的毫秒数。 若有如下代码： 1Date date = new Date(); 该无参构造函数的源码为： 123public Date() &#123; this(System.currentTimeMillis());&#125; 即默认以当前时刻创建了Date实例。当然我们也可以指定时刻： 12345Date date = new Date(666);date.setTime(1000);System.out.println(date.getTime());System.out.println(date.toString()); // 当前系统环境(中国)时区System.out.println(date.toGMTString()); // 默认时区(仅用于举例，已废弃，不推荐使用) 输出： 1231000Thu Jan 01 08:00:01 CST 19701 Jan 1970 00:00:01 GMT 时刻前后比较： 1234Date date1 = new Date(1);Date date2 = new Date(2);System.out.println(date1.before(date2));System.out.println(date1.after(date2)); 输出： 12truefalse 比较2： 12345Date date1 = new Date(1);Date date2 = new Date(1);System.out.println(date1.before(date2));System.out.println(date1.after(date2));System.out.println(date1.equals(date2)); 输出： 123falsefalsetrue 实际上，Date的比较就是在比其内部的毫秒数的先后。 DateFormat利用java.text.DataFormat的子类SimpleDateFormat可将Date与特定格式的字符串进行相互转化： Date–&gt;特定格式的字符串：format方法。 特定格式的字符串–&gt;Date：parse方法。 Date转字符串 12345678910import java.text.SimpleDateFormat;import java.util.Date;public class Test &#123; public static void main(String[] args) &#123; String dateFormat = new SimpleDateFormat(&quot;yyyy/MM/dd-HH:mm:ss&quot;).format(new Date()); System.out.println(dateFormat); &#125;&#125; 输出： 12017/09/29-15:06:03 其中”yyyy/MM/dd-HH:mm:ss”被称为格式化字符串，全字符含义如下图所示： 字符串转Date 1234567891011121314import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;public class Test &#123; public static void main(String[] args) throws ParseException &#123; String dateStr = &quot;1990年06月05日 07:07:07&quot;; DateFormat dateFormat1 = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;); Date date = dateFormat1.parse(dateStr); System.out.println(date); &#125;&#125; 输出： 1Tue Jun 05 07:07:07 CDT 1990 Calendar在上文已叙述的两个类中，DateFormat只用于格式转换，不承载实际的逻辑。Date中的时间是以1个long类型的整数存储的。这种存储格式是给计算机看的，更关心时间流逝的本质，因此基本计数单位也仅采用毫秒一种，人类几乎无法理解。 为扩展时间API的功能，设计者又添加了日历类Calendar，表示日期的概念(其实也能精确到时分秒)，较之Date类，其更关心人类在历法上的逻辑。功能为进行某一特定时刻与各种日期(年月周日时分秒)之间的转化。 需要注意的是，Calendar这一族的类中的月份是从0开始的，即月份的取值范围为0,11。而星期则是从1开始的，即周日是1，周一是2…周六是7。为了避免开发人员记忆过多这种纯规则性的东西，Calendar内部以不可变int型类变量的方式提供了全部日期类型： 1234public final static int YEAR = 1;public final static int SUNDAY = 1;public final static int FEBRUARY = 1;... 这里我故意抽取了3个值一样的类变量。这是不会产生歧义的，因为它们3个的使用场景不同。 Calendar本身是抽象类，GregorianCalendar是Calendar的一个子类，表示世界上大部分国家及地区均采用的标准日历系统(即所谓的公历)。我们在日常开发中用到的也就是这个类。 1234567891011121314import java.util.Calendar;import java.util.Date;import java.util.GregorianCalendar;public class Test &#123; public static void main(String[] args) &#123; Calendar calendar = new GregorianCalendar(); calendar.set(1990, Calendar.JUNE, 5, 7, 7, 7); // 1990年6月5日 07:07:07 System.out.println(calendar.getTimeInMillis()); // 1970年1月1日0时0分0秒到calendar对应时刻的毫秒数 Date date = calendar.getTime(); // Date类是时间API中各组件间的桥梁 System.out.println(date); &#125;&#125; 输出： 12644537227223Tue Jun 05 07:07:07 CDT 1990 除此之外，也常采用以下方法设置Calendar： 123456789101112import java.util.Calendar;import java.util.GregorianCalendar;public class Test &#123; public static void main(String[] args) &#123; Calendar calendar = new GregorianCalendar(); calendar.set(Calendar.YEAR, 1990); System.out.println(calendar.get(Calendar.YEAR)); System.out.println(calendar.getTime()); &#125;&#125; 输出： 121990Wed Dec 05 23:07:25 CST 1990 这种设置方式便于只设置某几种时间类型。上例中我只设置了年。其余的时间类型均与构建时的当前时间相同(由此也可见在新建GregorianCalendar类时，类似于Date类，无参构造函数默认取当前时刻)。 最后一种常用的设值方式就是直接注入Date对象或毫秒数： 12calendar.setTime(new Date()); // Date类型calendar.setTimeInMillis(1000L); // 毫秒数 因日常开发所用的大多也就是GregorianCalendar类，因此设计者在Calendar中为我们添加了一个快捷方式： 1Calendar calendar = Calendar.getInstance(); 这种方式得到的同样是GregorianCalendar类的实例。也就是说等价于： 1Calendar calendar = new GregorianCalendar(); add方法 第一个参数是待修改的类型，第二个参数是较之calendar的值加减的值 123calendar.add(Calendar.YEAR, 10); // calendar中的值加10年calendar.add(Calendar.YEAR, -10); // calendar中的值减10年calendar.add(Calendar.DATE, 10); // calendar中的值加10天 getActualMinimum与getActualMaximum方法 calendar的值对应所属传入类型的最小/最大值 123calendar.getActualMinimum(Calendar.DAY_OF_MONTH) // calendar中的值所属月份中的日期的最小值calendar.getActualMaximum(Calendar.DAY_OF_MONTH) // calendar中的值所属月份中的日期的最大值(例如11月为30,12月为31)calendar.getActualMaximum(Calendar.DAY_OF_WEEK) // calendar中的值所属星期中的日期的最大值(默认为7) 小例子：输出特定日期当月日历1234567891011121314151617181920import java.text.SimpleDateFormat;import java.util.Calendar;public class Test &#123; public static void main(String[] args) throws Exception &#123; Calendar calendar = Calendar.getInstance(); calendar.setTime(new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).parse(&quot;1990-06-05&quot;)); int day = calendar.get(Calendar.DATE); int month = calendar.get(Calendar.MONTH); calendar.set(Calendar.DATE, calendar.getActualMinimum(Calendar.DAY_OF_MONTH)); System.out.println(&quot;日\t一\t二\t三\t四\t五\t六&quot;); for (int i = 1; i &lt;= calendar.get(Calendar.DAY_OF_WEEK) - 1; i++) System.out.print(&quot; \t&quot;); while (calendar.get(Calendar.MONTH) == month) &#123; System.out.print(calendar.get(Calendar.DATE) + (calendar.get(Calendar.DATE) == day ? &quot;*\t&quot; : &quot;\t&quot;)); if (calendar.get(Calendar.DAY_OF_WEEK) == Calendar.SATURDAY) System.out.println(); calendar.add(Calendar.DATE, 1); &#125; &#125;&#125; 输出： 123456日 一 二 三 四 五 六 1 2 3 4 5* 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>日期</tag>
        <tag>时间</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eclipse-下载及配置]]></title>
    <url>%2F2017%2F09%2F29%2FEclipse-%E4%B8%8B%E8%BD%BD%E5%8F%8A%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[下载及安装 Eclipse官网下载地址 Windows 64位安装包个人存档 解压即可完成安装。 设置workspace第一次运行时会提示指定workspace，若此后需要再次修改，则配置： 1Window—&gt;Preferences—&gt;General—&gt;Startup and Shutdown—&gt;Workspaces—&gt;选中Prompt for workspace on startup 删除已有workspace后，重启Eclipse即可重新选workspace路径。 设置编码1Window—&gt;Preferences—&gt;General—&gt;workspace 将Text file encoding设置为utf-8。 设置Java版本123Window—&gt;Preferences—&gt;java—&gt;Compiler 将编译器版本设定为所需版本Window—&gt;Preferences—&gt;java—&gt;Installed JREs 指向对应版本的JDK目录 设置Maven见Maven-Maven安装。 设置缩进为4个空格123Window—&gt;Preferences—&gt;General—&gt;Editors—&gt;Text Editors，选中右侧的insert space for tabs并保存Window—&gt;Preferences—&gt;java—&gt;code style—&gt;formatter 设置缩进为4个空格 设置字体1Window—&gt;Preferences—&gt;General—&gt;Appearance—&gt;Colors and Fonts 修改Basic下的Text Font 设置主题1Window—&gt;Preferences—&gt;General—&gt;Appearance—&gt;Color Theme 选择主题，个人推荐NightLion Aptana Theme 若没有这个选项，则需要先下载插件： 1Help—&gt;Eclipse Marketplace 搜索并安装Eclipse Color Theme]]></content>
      <categories>
        <category>Eclipse</category>
      </categories>
      <tags>
        <tag>Eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 算法题-翻转字符串中的单词]]></title>
    <url>%2F2017%2F09%2F28%2FJava%20%E7%AE%97%E6%B3%95%E9%A2%98-%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223public static String reverse(String str) &#123; if(null == str || str.length() &lt;= 1) return str; char[] strArr = str.toCharArray(); reverse(strArr, 0, strArr.length - 1); int begin = 0; for (int i = 1; i &lt; strArr.length; i++) &#123; if (strArr[i] == &apos; &apos;) &#123; reverse(strArr, begin, i - 1); begin = i + 1; &#125; &#125; return new String(strArr);&#125;private static void reverse(char[] strArr, int begin, int end) &#123; while(begin &lt; end) &#123; char temp = strArr[begin]; strArr[begin] = strArr[end]; strArr[end] = temp; begin++; end--; &#125;&#125;]]></content>
      <categories>
        <category>Java 算法题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 算法题-翻转字符串]]></title>
    <url>%2F2017%2F09%2F28%2FJava%20%E7%AE%97%E6%B3%95%E9%A2%98-%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[使用系统方法 1234public static String reverse(String str) &#123; if(null == str || str.length() &lt;= 1) return str; return new StringBuilder(str).reverse().toString();&#125; 递归1234public static String reverse(String str) &#123; if(null == str || str.length() &lt;= 1) return str; return reverse(str.substring(1)) + str.charAt(0);&#125; 转为char数组12345678910111213public static String reverse(String str) &#123; if (null == str || str.length() &lt;= 1) return str; char[] strArr = str.toCharArray(); int begin = 0, end = strArr.length - 1; while (begin &lt; end) &#123; char temp = strArr[begin]; strArr[begin] = strArr[end]; strArr[end] = temp; begin++; end--; &#125; return new String(strArr);&#125;]]></content>
      <categories>
        <category>Java 算法题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 基础-序列化]]></title>
    <url>%2F2017%2F09%2F28%2FJava%20%E5%9F%BA%E7%A1%80-%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[如何实现对象克隆？ 有两种方式： 实现Cloneable接口并重写Object类中的clone()。Object类中的clone()是浅克隆。 实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，代码如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable; public class CloneBySerializable &#123; @SuppressWarnings(&quot;unchecked&quot;) public static &lt;T&gt; T clone(T object) &#123; if (null == object) return null; try &#123; // 调用ByteArrayInputStream或ByteArrayOutputStream对象的close方法没有任何意义 // 这两个基于内存的流只要垃圾回收器清理对象就能够释放资源，这一点不同于对外部资源(如文件流)的释放 ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); new ObjectOutputStream(byteArrayOutputStream).writeObject(object); ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray()); return (T) new ObjectInputStream(byteArrayInputStream).readObject(); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; public static void main(String[] args) &#123; Person person = new Person(&quot;八云紫&quot;, new Book(&quot;永远的17岁&quot;)); System.out.println(&quot;原始：&quot; + person); Person personCopy = CloneBySerializable.clone(person); System.out.println(&quot;copy：&quot; + personCopy); personCopy.name = &quot;八云紫（笑）&quot;; personCopy.book.name = &quot;其实是个老婆婆&quot;; System.out.println(&quot;copy改变后-原始：&quot; + person); System.out.println(&quot;copy改变后-copy：&quot; + personCopy); &#125;&#125;class Person implements Serializable &#123; private static final long serialVersionUID = -9198259586220345266L; public String name; public Book book; public Person(String name, Book book) &#123; this.name = name; this.book = book; &#125; @Override public String toString() &#123; return &quot;Person [name=&quot; + name + &quot;, book=&quot; + book + &quot;]&quot;; &#125;&#125;class Book implements Serializable &#123; private static final long serialVersionUID = -8536837238716978714L; public String name; public Book(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;Book [name=&quot; + name + &quot;]&quot;; &#125;&#125; 输出： 1234原始：Person [name=八云紫, book=Book [name=永远的17岁]]copy：Person [name=八云紫, book=Book [name=永远的17岁]]copy改变后-原始：Person [name=八云紫, book=Book [name=永远的17岁]]copy改变后-copy：Person [name=八云紫（笑）, book=Book [name=其实是个老婆婆]] 基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种方案明显优于使用Object类的clone方法克隆对象。让问题在编译的时候暴露出来总是优于把问题留到运行时。 Java中如何实现序列化，有什么意义？序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决对象流读写操作时可能引发的问题(如果不进行序列化可能会存在数据乱序的问题)。 要实现序列化，需要让一个类实现Serializable接口，该接口是一个标识性接口，标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象输出流并通过writeObject(Object)方法就可以将实现对象写出(即保存其状态)；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过readObject方法从流中读取对象。]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 基础-内部类]]></title>
    <url>%2F2017%2F09%2F28%2FJava%20%E5%9F%BA%E7%A1%80-%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[内部类可分为如下3类：成员内部类，局部内部类，匿名内部类。而成员内部类又可分为实例成员内部类及静态成员内部类。 成员内部类实例成员内部类 123456789public class Out &#123; private class In &#123; &#125; public static void main(String[] args) &#123; new Out().new In(); &#125;&#125; 实例成员内部类中是无法定义类变量的： 1234567public class Out &#123; private class In &#123; private static int V = 1; &#125;&#125; 这段代码无法通过编译，提示 12The field V cannot be declared static in a non-static inner type, unless initialized with a constant expression。 静态成员内部类 123456789public class Out &#123; private static class In &#123; &#125; public static void main(String[] args) &#123; new Out.In(); &#125;&#125; 成员内部类的访问权限 成员内部类，顾名思义，首先是个成员(即实例变量或类变量)，其次才是类。从更大的视角上看，成员内部类就是其外部类的一个成员。因此二者其实是同一个类。进而二者均有权限访问对方内部被private修饰的字段或方法。 下面以外部类访问静态成员内部类中的私有变量为例： 1234567891011121314public class Out &#123; private static class In &#123; private String v0 = &quot;实例&quot;; private static String V_1 = &quot;静态&quot;; &#125; public static void main(String[] args) &#123; System.out.println(Out.In.V_1); System.out.println(new Out.In().v0); &#125;&#125; 输出： 12静态实例 外部类(其实也就是普通的Java类)的修饰符只能为public或无修饰符。而成员内部类本质上是成员，因此同其他变量一样，可被private,protected,无修饰符,public修饰，并且访问权限也与一般变量一般无二。 内部类与外部类之间同名字段问题 在叙述具体的解决策略之前，我想先表达一下个人看法。如果我是Java语法的设计者，那么我可能会禁止内部类与外部类之间存在同名字段。因为这与因继承导致的重复不同：继承牵扯到复数个类，同时父类与子类之间又有明确的ISA关系，因此允许字段重名是合理的。而内部类与外部类之间则是HASA的关系，二者并没有什么血缘关系，从逻辑上无需重名。同时内部类与外部类共存于一个Java源文件中，也基本不会造成因需要兼顾的代码量太大而漏掉字段的可能，毕竟需要检查的代码范围也就是一个Java源文件那么大，综上，我认为允许内部类与外部类的字段重名稍稍有些灵活过了(通常Java在和C++做比较时，没那么灵活往往是Java的优势，可以让程序员节约很多学习成本)。同时，我也建议大家在编码时，即便没有编译器的强制规范，也不要编写出重名的字段。 若发生了重名，如果什么都不处理的话，则会默认调用当前代码所在类的字段： 12345678910111213141516171819202122232425262728293031public class Out &#123; private String v0 = &quot;外部实例&quot;; private static String V_1 = &quot;外部静态&quot;; private static class In &#123; private String v0 = &quot;内部实例&quot;; private static String V_1 = &quot;内部静态&quot;; private void m0() &#123; System.out.println(v0); &#125; private static void m1() &#123; System.out.println(V_1); &#125; &#125; public static void main(String[] args) &#123; System.out.println(&quot;外部类中调用情况&quot;); System.out.println(new Out().v0); System.out.println(V_1); System.out.println(&quot;==========================&quot;); System.out.println(&quot;内部类中调用情况&quot;); new Out.In().m0(); Out.In.m1(); &#125;&#125; 输出： 1234567外部类中调用情况外部实例外部静态==========================内部类中调用情况内部实例内部静态 如果我就是想在外部类中调内部类的字段，内部类中调外部类的字段呢？ 1234567891011121314151617181920212223242526public class Out &#123; private String v0 = &quot;外部实例&quot;; private static String V_1 = &quot;外部静态&quot;; private static class In &#123; private String v0 = &quot;内部实例&quot;; private static String V_1 = &quot;内部静态&quot;; private static void m1() &#123; System.out.println(Out.V_1); &#125; &#125; public static void main(String[] args) &#123; System.out.println(&quot;外部类中调用情况&quot;); System.out.println(new Out.In().v0); System.out.println(Out.In.V_1); System.out.println(&quot;==========================&quot;); System.out.println(&quot;内部类中调用情况&quot;); Out.In.m1(); &#125;&#125; 此时该成员内部类是无法访问到其外部类的实例变量，究其原因，还是因为该成员内部类是静态成员内部类。因此我们略作修改： 12345678910111213141516171819public class Out &#123; private String v0 = &quot;外部实例&quot;; private class In &#123; private String v0 = &quot;内部实例&quot;; private void m0() &#123; System.out.println(Out.this.v0); &#125; &#125; public static void main(String[] args) &#123; Out out = new Out(); Out.In in = out.new In(); in.m0(); &#125;&#125; 输出： 1外部实例 局部内部类局部内部类是定义在一个方法或者一个作用域里面的类。如果说从宏观上来看成员内部类的本质是字段，那么局部内部类的本质就是局部变量。 因为本质是局部变量，那么对于局部内部类而言，自然不存在访问修饰符的概念。不过，局部内部类中的私有数据与其外部类的私有数据之间依然是相互可见的。 局部内部类中不能定义类变量，即便其所处的外部类方法是静态的也不行： 12345678public class Out &#123; private static void m() &#123; class In &#123; private static String v_1_I = &quot;内部静态&quot;; &#125; &#125;&#125; 无法通过编译，提示 1The field v_1_I cannot be declared static in a non-static inner type, unless initialized with a constant。 测试访问权限的代码如下： 123456789101112131415161718192021222324252627public class Out &#123; private String vo = &quot;外部实例&quot;; private static String V = &quot;外部静态&quot;; private void m() &#123; class In &#123; private String vi = &quot;内部实例&quot;; public void mi(Out out) &#123; System.out.println(out.vo); System.out.println(Out.V); &#125; &#125; In in = new In(); System.out.println(&quot;外部类中调用情况&quot;); System.out.println(in.vi); System.out.println(&quot;==========================&quot;); System.out.println(&quot;内部类中调用情况&quot;); in.mi(this); &#125; public static void main(String[] args) &#123; new Out().m(); &#125;&#125; 输出： 123456外部类中调用情况内部实例==========================内部类中调用情况外部实例外部静态 匿名内部类匿名内部类(Anonymous Inner Class)可以继承其他类或实现其他接口，在Swing编程和Android开发中常用此方式来实现事件监听和回调。 下面是一个小例子： 12345678910public abstract class Test &#123; public static void main(String[] args) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; &#125; &#125;).start(); &#125;&#125; 匿名内部类是唯一一种没有构造器的类。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调。上例中的匿名内部类在编译的时候由系统自动起名为Test$1.class。一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。 final修饰符问题局部内部类或匿名内部类中只能引用其所在方法中被final修饰的局部变量： 123456789101112public class Test &#123; public void test(final int b) &#123; final int a = 10; new Thread()&#123; public void run() &#123; System.out.println(a); System.out.println(b); &#125;; &#125;.start(); &#125;&#125; 上述代码，如果去掉b或a的final修饰符，将无法通过编译，并提示 1Cannot refer to the non-final local variable a defined in an enclosing scope。 究其原因，匿名内部类或局部内部类在使用外部局部变量时，依靠的是将其传入自身的实例构造函数方法&lt;init&gt;。我们知道Java在进行方法传值时使用的是值传递(详见Java 基础-方法参数的值传递及引用传递)，这样可以保证即便是在本例这样的并发环境下，test方法可能已执行完成，局部变量a或b已被销毁，匿名内部类所起的线程中的a或b依然可用：因为这已然是个全新的复制值了。 但是这样便引入了新的问题：即若a或b在复制了一份传入匿名内部类或局部内部类后发生了改变怎么办？为了保证线程安全，才强制规定局部内部类或匿名内部类中只能引用其所在方法中被final修饰的局部变量。]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>内部类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM-碎片]]></title>
    <url>%2F2017%2F09%2F27%2FJVM-%E7%A2%8E%E7%89%87%2F</url>
    <content type="text"><![CDATA[JVM参数 -Xms/-Xmx : 堆的初始大小/堆的最大大小 -Xmn : 堆中年轻代的大小 -XX:-DisableExplicitGC : 让System.gc()不产生任何作用 -XX:+PrintGCDateStamps : 打印GC操作的时间戳 -XX:NewSize/XX:MaxNewSize : 设置新生代大小/新生代最大大小 -XX:NewRatio : 设置老年代和新生代的比例 -XX:PrintTenuringDistribution : 每次新生代GC后输出幸存区中对象年龄的分布 -XX:InitialTenuringThreshold/-XX:MaxTenuringThreshold：设置晋升到老年代的对象的年龄阀值的初始值和最大值 -XX:TargetSurvivorRatio：设置幸存区的目标使用率 JVM规范与实现JVM规范中详细指明了每条虚拟机指令的执行过程，执行前后对操作数栈及局部变量表的影响。Sun最早的JVM Sun Classic VM基本严格遵循这一规范。然而随着技术的发展及对性能的追求，高性能JVM真正的实现细节已与JVM规范产生了很大的差异。虽然”能做到什么”依然遵循JVM规范，然而”如何做到的”已不完全遵循规范的指引。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础-基本数据类型]]></title>
    <url>%2F2017%2F09%2F27%2FJava%20%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[4类8种基本数据类型除此之外，特别的，Java中存在一种基本数据类型void，它所对应的包装类为java.lang.Void。不过我们无法直接对它进行操作。 四种整数类型 byte：8位有符号 [-2^7 , 2^7-1] –&gt; [-128 , 127]。 short：16位有符号 [-2^15 , 2^15-1] –&gt; [-32768 , 32767]。 int：32位有符号 [-2^31 , 2^31-1] –&gt; [-2,147,483,648 , 2,147,485,647]。默认整数型。 long：64位有符号 [-2^63 , 2^63-1] –&gt; [-9,223,372,036,854,775,808 , 9,223,372,036,854,775,807]。可用L或l显式声明。 若需要表示long范围之外的数字，可使用java.math.BigInteger，其可表示任意长度的整数。 默认采用十进制计数。0开头为八进制。0x或0X开头为16进制。进制间转换示例： 123456789public class Test &#123; public static void main(String[] args) &#123; int a = 17; System.out.println(&quot;2进制=&quot; + Integer.toBinaryString(a)); // 转为2进制字符串 System.out.println(&quot;8进制=&quot; + Integer.toOctalString(a)); // 转为8进制字符串 System.out.println(&quot;16进制=&quot; + Integer.toHexString(a)); // 转为16进制字符串 &#125;&#125; 输出: 1232进制=100018进制=2116进制=11 JDK1.7中新增0b/0B开头表示二进制数： 123456public class Test &#123; public static void main(String[] args) &#123; System.out.println(0b10); &#125;&#125; 输出： 12 JDK1.7中新增数字分割符，可用下划线按照自己的习惯随意分割一个数： 12int a = 111_222_333;double b = 123_456.123_45; 两种浮点数类型 float：32位有符号单精度。[1.4E-45 , 3.4028235E38]。又被称为单精度类型，尾数可以精确到7位有效数字。可用F或f显式声明。 double：64位有符号双精度。[4.9E-324 , 1.7976931348623157E308]。又被称为双精度类型，尾数可以精确到14位有效数字。默认浮点型。可用D或d显式声明。 浮点型存在舍入误差(例如，无法精确表示0.1，0.01这种10的负数次方幂)，因此应尽量避免用于比较，若实在需比较浮点数，可使用java.math.BigDecimal，其可精确表示任意精度的浮点数。 123456789public class Test &#123; public static void main(String[] args) &#123; double d = 1.0 /10; System.out.println(d == 0.1); // true System.out.println(d == 0.1F); // false System.out.println(0.1 == 0.1F); // false &#125;&#125; 可用科学计数法表示浮点型： 123456public class Test &#123; public static void main(String[] args) &#123; System.out.println(3.14e-2); &#125;&#125; 输出： 10.0314 一种字符类型(char) 16位无符号[0 , 2^16-1] –&gt; [0, 65535]。可以当整数来用，它的每一个字符都对应一个数字。换言之也可将[0, 65535]的整数转换为char。 12345678public class Test &#123; public static void main(String[] args) &#123; System.out.println((int)&apos;a&apos;); System.out.println(&apos;a&apos; + 1); // &apos;a&apos;直接作为一个整数参与四则运算。换句话说，char可自动向上转换为int System.out.println((char)97); &#125;&#125; 输出： 1239798a char本质上就是个二进制的数，显示的时候处理为字符。char在参与四则运算时会被转换为int型。 char与Java所使用的字符集Unicode同为两字节表示(不考虑扩展集)，一个char对应Unicode的一个字符。 12&apos;A&apos;表示字符，是char类型。&quot;A&quot;表示字符串，是String类型，该字符串由一个字符组成。 String类，其实是字符序列(char sequence)。 1System.out.println(&apos;&apos;); // 无法通过编译 \u表示Unicode编码值，以16进制表示： 1System.out.println(&apos;\u0061&apos;); // 输出a 123456789public class Test &#123; public static void main(String[] args) &#123; // char可用于存储换行等转义字符 System.out.println(&apos;\n&apos;); System.out.println(&apos;\&apos;&apos;); System.out.println(&apos;\\&apos;); &#125;&#125; 输出： 1234&apos;\ 一种布尔类型(boolean) 关于boolean的大小，有以下几种说法： 1个bit(1/8个字节)：boolean只有true和false两种逻辑值，在编译后会使用1和0来表示，这两个数在内存中按位算，仅需1bit即可存储，位是计算机最小的存储单位。 1个字节：虽然编译后1和0只需占用1位空间，但计算机处理数据的最小单位是1个字节，1个字节等于8位，实际存储的空间是：用1个字节的最低位存储，其他7位用0填补，如果值是true的话则存储的二进制为：0000 0001，如果是false的话则存储的二进制为：0000 0000。 4个字节：JVM规范中规定：虽然定义了boolean这种数据类型，但是只对它提供了非常有限的支持。在JVM中没有任何供boolean值专用的字节码指令，Java语言表达式所操作的boolean值，在编译之后都使用JVM中的int数据类型来代替，而boolean数组将会被编码成JVM的byte数组，每个元素占8位。JVM使用int而非更小的整型代指boolean的原因为：对于当下32位的CPU而言，一次处理的数据为32位(这里的32不是指操作系统的32位与64位，而是指CPU硬件层面)，因此32位最为合理高效，即便使用了更小的位数最终也会被填充为32位。 自动类型转换 上图中黑色的实线表示不会发生精度丢失的自动转换，红色表示可能会发生精度丢失的自动转换(是否精度丢失主要是看转换双方的相对大小)。 浮点型间的类型转换 1float f = 3.4; 无法通过编译。Eclipse提示： 1Type mismatch: cannot convert from double to float 3.4默认是双精度数，将双精度型(double)赋值给浮点型(float)属于下转型(down-casting)，也可称为窄化。该操作会造成精度损失，因此无法通过编译。 解决办法有2： 12345// 强制类型转换float f = (float)3.4;// 显示声明类型float f = 3.4F; 整型间的类型转换 1short s = 1; // 正确。除非涉及四则运算符，否则可自动关联关键字类型。这与float不同。 12int i = 1;short s = i; // 错误，无法通过编译 123// 错误// 1是int型，s + 1的运算结果为int型，需要强制类型转换才能赋值给short型。s = s + 1; 1234// 正确// 本句等价于s = (short)(s + 1);其中有隐含的强制类型转换。// s++;同理也是正确的。s += 1; 12345short s1 = 1;short s2 = 2;// 无法通过编译// Type mismatch: cannot convert from int to shortshort s3 = s1 + s3; 同理，上例中的short换成byte后相关结果依然成立。 基本数据类型与其包装类型Java并非纯粹的面向对象语言，因此类似于”Java中一切都是对象，对象就是一切”这样的言论更像是宣传口号，实际上是有些绝对了。 比如，Java中的基本数据类型就不是面向对象的(这样的好处是在处理一些涉及基本数据类型的操作时效率更高)，但是有时(比如基本数据类型作为集合类的元素)，我们又希望能够像操作对象那样操作它们。因此，Java为每一个基本数据类型都提供了对应的包装类型(wrapper class)，从JDK1.5开始又引入了自动装箱/拆箱机制，使得二者可以相互转换。 这些包装类型都位于java.lang包中： boolean-Boolean char-Character byte-Byte short-Short int-Integer long-Long float-Float double-Double 自动装箱/拆箱机制123456Integer a = new Integer(3);Integer b = 3; // 将3自动装箱成Integer类型int c = 3;System.out.println(a == b); // false 两个引用没有引用同一对象System.out.println(a == c); // true Integer与int比较时，a自动拆箱(调用a.intValue())成int类型再和c比较(实际上是两个int在比) // 此处将3换为一个大于127的数结果不变。 123Integer f1 = 100, f2 = 100, f3 = 150, f4 = 150;System.out.println(f1 == f2); // true 取常量池中的结果System.out.println(f3 == f4); // false new新对象 装箱的本质是什么呢？当我们给一个Integer对象赋一个int值的时候，javac编译器会调用Integer类的静态方法valueOf，如果整型字面量的值在[-128,127]之间，那么不会new新的Integer对象，而是直接引用常量池中的Integer对象，所以f1==f2的结果是true，而f3==f4的结果是false。 char 型变量中能不能存贮一个中文汉字，为什么？char类型可以存储一个中文汉字，因为Java中使用的编码是Unicode(不选择任何特定的编码，直接使用字符在字符集中的编号，这是统一的唯一方法)，一个char类型占2个字节(16比特)，所以放一个中文是没问题的。 使用Unicode意味着字符在JVM内部和外部有不同的表现形式，在JVM内部都是Unicode，当这个字符被从JVM内部转移到外部时(例如存入文件系统中)，需要进行编码转换。所以Java中有字节流和字符流，以及在字符流和字节流之间进行转换的转换流，如InputStreamReader和OutputStreamReader，这两个类是字节流和字符流之间的适配器类，承担了编码转换的任务。 例题:long12long a = 10000000000; // 错误，超过了int类型长度long b = 10000000000L; // 正确 取余操作浮点型也可取余，例如： 123456public class Test &#123; public static void main(String[] args) &#123; System.out.println(10.5 % 3); System.out.println(10.2 % 3); // 精度丢失 &#125;&#125; 输出： 121.51.1999999999999993 Java中余数的计算公式为： 1a%b=a-(a/b)*b 正数易于理解。举几个负数参与运算的小例子： 123System.out.println(-5 % 3); // -2System.out.println(5 % -3); // 2System.out.println(-5 % -3); // -2 小技巧：取余计算的结果的符号总与被除数相同，可以此验证计算结果的准确性。]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基本数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 基础-碎片]]></title>
    <url>%2F2017%2F09%2F27%2FJava%20%E5%9F%BA%E7%A1%80-%E7%A2%8E%E7%89%87%2F</url>
    <content type="text"><![CDATA[面向对象的特征 面向过程的程序是由事件驱动的。即先发生事件1，再发生事件2，然后是事件3…直至程序结束。面向过程中的过程即为事件依序执行的过程。定义每一个事件执行行为的规则称为”算法”，事件的核心意义在于对”数据”的处理：事件导致数据的值发生了变化。 面向对象的程序的核心为对象。面向过程中的”数据”变成了对象的”属性”，面向过程中的”算法”变成了对象的”行为”。即对象1做出了行为1，对象2做出了行为2…各对象的行为影响了自己或他人的属性，直至程序结束。 举个小例子：小王打了小李。面向过程关注的是”打人”这件事，具体到事件内部，打人者为小王，被打者为小李。面向对象关注的是小王和小李这两个人，小王做出了打小李的行为。很显然，面向过程及面向对象都能准确的描述这件事，只是思考的角度不同。 封装 面向过程的核心为”算法处理数据”，算法与数据均为最顶级的概念，即没有一个概念能让这二者从属于它。面向对象的核心为”对象”。一切都是对象，对象就是一切。对象是最顶级的概念，属性及行为均从属于对象。换句话说，对象封装了属性及行为。 对象就像一个黑盒。优秀的代码会隐藏一切可隐藏的属性或行为而只暴露必要的对外可见的部分。 继承 类似于生物学分类中的”界门纲目科属种”， 子类/派生类 继承 父类/超类/基类 ，表明子类默认拥有父类的属性及行为。同时如果有必要，子类也可以通过重写父类的属性及行为的方式展现自身不同于父类的个性。 多态 多态是指同样的静态类型因实际类型的不同在调用同一个方法时做出了不同的行为。实质上，多态是动态单分派的体现，其核心为重写。关于重写，详见Java基础-重载与重写。 抽象 面向对象的核心特征只有封装继承多态，抽象是一个不那么”特”的特征。因此有时并不会算上抽象。 抽取各具特色的对象之间的共性形成类这一模版的过程称为抽象。因为对象内封装了属性及行为，因此抽象也可细分为数据抽象及行为抽象。 访问修饰符 无访问修饰符的情况也称其修饰符为 default/friendly 。 Math.round(double a)的原理round表示就近取整。实现原理为a加上0.5后再下取整(不大于传入值的最大整数)。 Math.round(-11.7)：-11.2下取整，返回-12。 Math.round(-11.2)：-10.7下取整，返回-11。 Math.round(11.7)：12.2下取整，返回12。 Math.round(11.2)：11.7下取整，返回11。 switch的可作用类型[JDK1.1,JDK1.5)时，switch(expr)的expr只能是char,byte,short,int。其实对于switch而言，能接收的仅仅就只有int。char,byte,short在传入时会发生自动类型转换被转为int。 JDK1.5新定义了枚举类型。从JDK1.5开始，expr也可以是enum类型。 从JDK1.7开始，expr还可以是字符串。 小例子： 12345678910111213141516public class Test &#123; public static void main(String[] args) &#123; String str = &quot;八云紫&quot;; switch (str) &#123; case &quot;雾雨魔理沙&quot;: System.out.println(&quot;此为少女&quot;); break; case &quot;八云紫&quot;: System.out.println(&quot;此为大妈&quot;); break; default: System.out.println(&quot;就当是少女吧&quot;); &#125; &#125;&#125; 输出： 1此为大妈 到JDK1.7为止，long始终不可用于switch。 利用switch case穿透的小技巧123456789101112131415161718192021public class Test &#123; public static void main(String[] args) &#123; char c = (char)(&apos;a&apos; + (int)(26 * Math.random())); System.out.print(c + &quot;是&quot;); switch (c) &#123; case &apos;a&apos;: case &apos;e&apos;: case &apos;i&apos;: case &apos;o&apos;: case &apos;u&apos;: System.out.println(&quot;元音&quot;); break; case &apos;y&apos;: case &apos;w&apos;: System.out.println(&quot;半元音&quot;); break; default: System.out.println(&quot;辅音&quot;); &#125; &#125;&#125; Java有哪些数据类型？ 基本数据类型(primitive type) –&gt; 详见Java 基础-基本数据类型。 引用类型(reference type)。 枚举类型(enumeration type)。 行内注释可在行内只修饰一个变量： 1String /*其实是老婆婆*/bayun = &quot;17岁的美少女&quot;; Java中保留字Java之父James Gosling编写的《The Java Programming Language》一书的附录中给出了一个Java的关键字列表。其中包含的一些关键字，例如goto及const，直至今日也并没有真正被Java使用。有人将其称之为Java的保留字。 广义的讲，保留字这个词应有更广泛的含义：在系统类库中使用过的有特殊意义的单词或单词的组合都被视为保留字。 标识符(Identifier)必须以字母|下划线|美元符开头。其他部分可以是字母|下划线|美元符|数字的任意组合。标识符大小写敏感，长度无限。不可为Java的关键字(保留字)。 这里所说的字母，并不仅仅是指针对英语语系的ASCII编码而言。因为实际上Java采用Unicode字符集，因此汉字及其他非英语国家的文字也可出现在标识符中。 示例： 1234String 八云紫 = &quot;我今年17岁&quot;; // 正确String $ = &quot;想钱想疯了&quot;; // 正确int 1a = 5; // 错误，不能以数字开头int a# = 5; // 错误，只能包含字母|下划线|美元符|数字，不能包含#这种特殊字符 字符串连接符1System.out.println(4 + 5 + &quot;2&quot;); // 92 带标签的break和continueJava中goto是保留字，但却没有相关的跳转的功能。可通过带标签的break和continue实现goto的弱化版功能。不过正如不推荐使用goto那样，自然也不推荐使用带标签的break和continue。 1234567891011public class Test &#123; public static void main(String[] args) &#123; // 打印[101,150]所有质数 mark: for (int i = 101; i &lt;= 150; i++) &#123; for (int j = 2; j &lt;= Math.sqrt(i); j++) &#123; if (i % j == 0) continue mark; &#125; System.out.println(i); &#125; &#125;&#125; 包关系com.p1与com.p1.p2并没有从属关系，不过我们通常会从逻辑上认为后者从属于前者。 子类包含的父类中的this指向子类12345678910111213141516171819202122232425public class Test &#123; public static void main(String[] args) &#123; new Son().show(); &#125;&#125;class Parent &#123; public void m() &#123; System.out.println(&quot;parent m&quot;); &#125; public void show() &#123; this.m(); &#125;&#125;class Son extends Parent &#123; @Override public void m() &#123; System.out.println(&quot;son m&quot;); &#125;&#125; 输出： 1son m 做如下修改： 123456789101112131415161718192021222324252627282930public class Test &#123; public static void main(String[] args) &#123; new Son().show(); &#125;&#125;class Parent &#123; public void m() &#123; System.out.println(&quot;parent m&quot;); &#125; public void show() &#123; this.m(); &#125;&#125;class Son extends Parent &#123; @Override public void m() &#123; System.out.println(&quot;son m&quot;); &#125; @Override public void show() &#123; super.show(); &#125;&#125; 输出依然为： 1son m 可见，无论如何，子类包含的父类中的this总是指向子类。 方法链以StringBuilder为例： 12345678public class Test &#123; public static void main(String[] args) &#123; StringBuilder sb = new StringBuilder(); sb.append(&quot;八云紫&quot;).append(&quot;是老婆婆&quot;).append(true); System.out.println(sb.toString()); &#125;&#125; 运行后输出： 1八云紫是老婆婆true 这里 1sb.append(&quot;八云紫&quot;).append(&quot;是老婆婆&quot;).append(true); 就是一个方法链，其原理为StringBuilder的append方法都实现了类似的结构，我们来随便看一个StringBuilder的append方法的源码： 1234public StringBuilder append(String str) &#123; super.append(str); return this;&#125; 方法的最后返回了this引用，因此可以像一个链条一样在一行代码中一直点出append方法。]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java JDK7源码-java.util.Enumeration&lt;E&gt;]]></title>
    <url>%2F2017%2F09%2F05%2FJava%20JDK7%E6%BA%90%E7%A0%81-javautilEnumerationE%2F</url>
    <content type="text"><![CDATA[源码 1234package java.lang;public interface Cloneable &#123;&#125;]]></content>
      <categories>
        <category>Java JDK7源码</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java JDK7源码-java.util.Vector&lt;E&gt;]]></title>
    <url>%2F2017%2F09%2F05%2FJava%20JDK7%E6%BA%90%E7%A0%81-javautilVectorE%2F</url>
    <content type="text"><![CDATA[源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617package java.util;public class Vector&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; /** * vector用于存储元素的数组缓冲区 * vector的容量(capacity)为该数组的长度 * 其大小至少会满足能容纳vector的所有元素 * * 该数组中未存储元素的空间以null填充 */ protected Object[] elementData; /** * vector中实际存储元素的个数 * 因此数组elementData中索引在 * [0,elementCount-1] * 之间的元素为vector实际存储的元素 */ protected int elementCount; /** * 当vector容量不足时自动扩展的容量值 * 若capacityIncrement&lt;=0，则vector每次自动扩展时容量翻倍 */ protected int capacityIncrement; private static final long serialVersionUID = -2767605614048989439L; /** * @throws IllegalArgumentException initialCapacity&lt;0 */ public Vector(int initialCapacity, int capacityIncrement) &#123; super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); this.elementData = new Object[initialCapacity]; this.capacityIncrement = capacityIncrement; &#125; /** * @throws IllegalArgumentException initialCapacity&lt;0 */ public Vector(int initialCapacity) &#123; this(initialCapacity, 0); &#125; public Vector() &#123; this(10); &#125; /** * 以c为基础构造vector，vector中元素的顺序为c迭代器返回的顺序 * * @throws NullPointerException c==null */ public Vector(Collection&lt;? extends E&gt; c) &#123; // c.toArray()可能不返回Object[](见6260652) // 说明： // 因为c可以是任意的Collection实现 // 而Collection对toArray()的返回值仅仅是要求Object[] // 即实际的返回可以是任意Object的子类 elementData = c.toArray(); elementCount = elementData.length; if (elementData.getClass() != Object[].class) // 注1:Arrays.copyOf(r, i, newType) elementData = Arrays.copyOf(elementData, elementCount, Object[].class); &#125; /** * 将vector中的元素copy至anArray中 * vector中索引位置为k的元素会被copy至anArray的索引k处 * * @throws NullPointerException anArray==null * @throws IndexOutOfBoundsException anArray.length&lt;vector.size() * @throws ArrayStoreException vector中至少有一个元素因类型不符无法被存入anArray */ public synchronized void copyInto(Object[] anArray) &#123; // 注2:System.arraycopy(r, 0, a, 0, i) System.arraycopy(elementData, 0, anArray, 0, elementCount); &#125; /** * 裁剪vector的容量为list当前的实际长度 * 应用可以使用本方法达到vector的存储空间占用最小化 */ public synchronized void trimToSize() &#123; // 注3:modCount modCount++; int oldCapacity = elementData.length; if (elementCount &lt; oldCapacity) &#123; // 注4:Arrays.copyOf(r, i) elementData = Arrays.copyOf(elementData, elementCount); &#125; &#125; /** * 保证vector的容量足以容纳最少minCapacity个元素 * 如果有必要(即vector的容量不足以容纳最少minCapacity个元素) * 则增大vector的容量 * * 若vector的当前容量不足以容纳minCapacity个元素 * 则替换vector的内部数据数组elementData为一个更大的数组： * if (capacityIncrement&lt;=0) 新数组的容量较之老数组翻倍 * if (capacityIncrement&gt;0) 新数组的容量为老数组的容量加上capacityIncrement * 若如此扩展后的新数组容量仍无法容纳minCapacity个元素，则新数组的长度将被设置为minCapacity */ public synchronized void ensureCapacity(int minCapacity) &#123; if (minCapacity &gt; 0) &#123; // 注3:modCount modCount++; ensureCapacityHelper(minCapacity); &#125; &#125; /** * 本方法不是线程安全的 * 本类中线程安全的方法可以在内部调用本方法以确保vector的容量满足需求 * 同时不会导致额外的并发开销 */ private void ensureCapacityHelper(int minCapacity) &#123; if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; /** * 数组可申请的最大容量 * 某些JVM会在数组中保存一些头信息 * 试图申请一个大容量的数组可能会导致OutOfMemoryError： * 即需要的数组容量超出JVM的限制 */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; private void grow(int minCapacity) &#123; int oldCapacity = elementData.length; int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // 注4:Arrays.copyOf(r, i) elementData = Arrays.copyOf(elementData, newCapacity); &#125; private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; /** * 设置vector的有效长度 * 若newSize大于当前有效长度，则确保vector能容纳newSize个元素(不一定需要扩容) * 若newSize小于当前有效长度，所有索引大于等于newSize的元素都被置为null * * @throws ArrayIndexOutOfBoundsException newSize&lt;0 */ public synchronized void setSize(int newSize) &#123; // 注3:modCount modCount++; if (newSize &gt; elementCount) &#123; ensureCapacityHelper(newSize); &#125; else &#123; for (int i = newSize ; i &lt; elementCount ; i++) &#123; elementData[i] = null; &#125; &#125; elementCount = newSize; &#125; /** * 返回vector的容量 * 即为vector内部存储数据的数组的长度 * 不是vector的有效长度 */ public synchronized int capacity() &#123; return elementData.length; &#125; /** * 重写父类:java.util.AbstractList&lt;E&gt; * 实现接口:java.util.List&lt;E&gt; * * 返回vector的有效长度 */ public synchronized int size() &#123; return elementCount; &#125; /** * 重写父类:java.util.AbstractList&lt;E&gt; * 实现接口:java.util.List&lt;E&gt; * * 若vector的有效长度为0则返回true，反之返回false */ public synchronized boolean isEmpty() &#123; return elementCount == 0; &#125; public Enumeration&lt;E&gt; elements() &#123; return new Enumeration&lt;E&gt;() &#123; int count = 0; public boolean hasMoreElements() &#123; return count &lt; elementCount; &#125; public E nextElement() &#123; synchronized (Vector.this) &#123; if (count &lt; elementCount) &#123; return elementData(count++); &#125; &#125; throw new NoSuchElementException(&quot;Vector Enumeration&quot;); &#125; &#125;; &#125; public boolean contains(Object o) &#123; return indexOf(o, 0) &gt;= 0; &#125; public int indexOf(Object o) &#123; return indexOf(o, 0); &#125; public synchronized int indexOf(Object o, int index) &#123; if (o == null) &#123; for (int i = index ; i &lt; elementCount ; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = index ; i &lt; elementCount ; i++) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; public synchronized int lastIndexOf(Object o) &#123; return lastIndexOf(o, elementCount-1); &#125; public synchronized int lastIndexOf(Object o, int index) &#123; if (index &gt;= elementCount) throw new IndexOutOfBoundsException(index + &quot; &gt;= &quot;+ elementCount); if (o == null) &#123; for (int i = index; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = index; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; public synchronized E elementAt(int index) &#123; if (index &gt;= elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + &quot; &gt;= &quot; + elementCount); &#125; return elementData(index); &#125; public synchronized E firstElement() &#123; if (elementCount == 0) &#123; throw new NoSuchElementException(); &#125; return elementData(0); &#125; public synchronized E lastElement() &#123; if (elementCount == 0) &#123; throw new NoSuchElementException(); &#125; return elementData(elementCount - 1); &#125; public synchronized void setElementAt(E obj, int index) &#123; if (index &gt;= elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + &quot; &gt;= &quot; + elementCount); &#125; elementData[index] = obj; &#125; public synchronized void removeElementAt(int index) &#123; modCount++; if (index &gt;= elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + &quot; &gt;= &quot; + elementCount); &#125; else if (index &lt; 0) &#123; throw new ArrayIndexOutOfBoundsException(index); &#125; int j = elementCount - index - 1; if (j &gt; 0) &#123; System.arraycopy(elementData, index + 1, elementData, index, j); &#125; elementCount--; elementData[elementCount] = null; &#125; public synchronized void insertElementAt(E obj, int index) &#123; modCount++; if (index &gt; elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + &quot; &gt; &quot; + elementCount); &#125; ensureCapacityHelper(elementCount + 1); System.arraycopy(elementData, index, elementData, index + 1, elementCount - index); elementData[index] = obj; elementCount++; &#125; public synchronized void addElement(E obj) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = obj; &#125; public synchronized boolean removeElement(Object obj) &#123; modCount++; int i = indexOf(obj); if (i &gt;= 0) &#123; removeElementAt(i); return true; &#125; return false; &#125; public synchronized void removeAllElements() &#123; modCount++; for (int i = 0; i &lt; elementCount; i++) elementData[i] = null; elementCount = 0; &#125; public synchronized Object clone() &#123; try &#123; @SuppressWarnings(&quot;unchecked&quot;) Vector&lt;E&gt; v = (Vector&lt;E&gt;) super.clone(); v.elementData = Arrays.copyOf(elementData, elementCount); v.modCount = 0; return v; &#125; catch (CloneNotSupportedException e) &#123; throw new InternalError(); &#125; &#125; public synchronized Object[] toArray() &#123; return Arrays.copyOf(elementData, elementCount); &#125; @SuppressWarnings(&quot;unchecked&quot;) public synchronized &lt;T&gt; T[] toArray(T[] a) &#123; if (a.length &lt; elementCount) return (T[]) Arrays.copyOf(elementData, elementCount, a.getClass()); System.arraycopy(elementData, 0, a, 0, elementCount); if (a.length &gt; elementCount) a[elementCount] = null; return a; &#125; @SuppressWarnings(&quot;unchecked&quot;) E elementData(int index) &#123; return (E) elementData[index]; &#125; public synchronized E get(int index) &#123; if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); return elementData(index); &#125; public synchronized E set(int index, E element) &#123; if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); E oldValue = elementData(index); elementData[index] = element; return oldValue; &#125; public synchronized boolean add(E e) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true; &#125; public boolean remove(Object o) &#123; return removeElement(o); &#125; public void add(int index, E element) &#123; insertElementAt(element, index); &#125; public synchronized E remove(int index) &#123; modCount++; if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); E oldValue = elementData(index); int numMoved = elementCount - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--elementCount] = null; return oldValue; &#125; public void clear() &#123; removeAllElements(); &#125; public synchronized boolean containsAll(Collection&lt;?&gt; c) &#123; return super.containsAll(c); &#125; public synchronized boolean addAll(Collection&lt;? extends E&gt; c) &#123; modCount++; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityHelper(elementCount + numNew); System.arraycopy(a, 0, elementData, elementCount, numNew); elementCount += numNew; return numNew != 0; &#125; public synchronized boolean removeAll(Collection&lt;?&gt; c) &#123; return super.removeAll(c); &#125; public synchronized boolean retainAll(Collection&lt;?&gt; c) &#123; return super.retainAll(c); &#125; public synchronized boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; modCount++; if (index &lt; 0 || index &gt; elementCount) throw new ArrayIndexOutOfBoundsException(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityHelper(elementCount + numNew); int numMoved = elementCount - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); elementCount += numNew; return numNew != 0; &#125; public synchronized boolean equals(Object o) &#123; return super.equals(o); &#125; public synchronized int hashCode() &#123; return super.hashCode(); &#125; public synchronized String toString() &#123; return super.toString(); &#125; public synchronized List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; return Collections.synchronizedList(super.subList(fromIndex, toIndex), this); &#125; protected synchronized void removeRange(int fromIndex, int toIndex) &#123; modCount++; int numMoved = elementCount - toIndex; System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); int newElementCount = elementCount - (toIndex-fromIndex); while (elementCount != newElementCount) elementData[--elementCount] = null; &#125; private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException &#123; final java.io.ObjectOutputStream.PutField fields = s.putFields(); final Object[] data; synchronized (this) &#123; fields.put(&quot;capacityIncrement&quot;, capacityIncrement); fields.put(&quot;elementCount&quot;, elementCount); data = elementData.clone(); &#125; fields.put(&quot;elementData&quot;, data); s.writeFields(); &#125; public synchronized ListIterator&lt;E&gt; listIterator(int index) &#123; if (index &lt; 0 || index &gt; elementCount) throw new IndexOutOfBoundsException(&quot;Index: &quot;+index); return new ListItr(index); &#125; public synchronized ListIterator&lt;E&gt; listIterator() &#123; return new ListItr(0); &#125; public synchronized Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; private class Itr implements Iterator&lt;E&gt; &#123; int cursor; int lastRet = -1; int expectedModCount = modCount; public boolean hasNext() &#123; return cursor != elementCount; &#125; public E next() &#123; synchronized (Vector.this) &#123; checkForComodification(); int i = cursor; if (i &gt;= elementCount) throw new NoSuchElementException(); cursor = i + 1; return elementData(lastRet = i); &#125; &#125; public void remove() &#123; if (lastRet == -1) throw new IllegalStateException(); synchronized (Vector.this) &#123; checkForComodification(); Vector.this.remove(lastRet); expectedModCount = modCount; &#125; cursor = lastRet; lastRet = -1; &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; final class ListItr extends Itr implements ListIterator&lt;E&gt; &#123; ListItr(int index) &#123; super(); cursor = index; &#125; public boolean hasPrevious() &#123; return cursor != 0; &#125; public int nextIndex() &#123; return cursor; &#125; public int previousIndex() &#123; return cursor - 1; &#125; public E previous() &#123; synchronized (Vector.this) &#123; checkForComodification(); int i = cursor - 1; if (i &lt; 0) throw new NoSuchElementException(); cursor = i; return elementData(lastRet = i); &#125; &#125; public void set(E e) &#123; if (lastRet == -1) throw new IllegalStateException(); synchronized (Vector.this) &#123; checkForComodification(); Vector.this.set(lastRet, e); &#125; &#125; public void add(E e) &#123; int i = cursor; synchronized (Vector.this) &#123; checkForComodification(); Vector.this.add(i, e); expectedModCount = modCount; &#125; cursor = i + 1; lastRet = -1; &#125; &#125;&#125; 已整理层级关系本类直接继承的类 java.util.AbstractList&lt;E&gt; 本类直接实现的接口 java.util.List&lt;E&gt; java.util.RandomAccess java.lang.Cloneable java.io.Serializable 综述Vector实现了一个可增长的数组对象。像数组一样，Vector可使用索引进行随机访问。但是Vector在创建后，其长度可随着添加或移除元素而增长或收缩。 vector试图通过维护capacity及capacityIncrement以达到存储管理的最优化。capacity总是至少和vector的长度一样大；capacity通常都会比vector的长度大一些，因为随着元素的添加vector是以capacityIncrement为基数成块增长。为减少空间重分配的次数，应用可以在添加大量元素前增大vector的capacity至一个合理的值。 vector返回的iterator： 12iterator() : iteratorlistIterator(int) : listIterator 遵循fail-fast原则：在iterator创建后，若vector因非该iterator的原因，即不是该iterator的以下方法： 12ListIterator#remove() removeListIterator#add(Object) add 而发生了结构性变化，该iterator会抛出ConcurrentModificationException。因此，面对并发性修改，iterator放弃的快速而彻底，并不会去仔细考察该并发性修改是否真的会对自身即将进行的操作造成不利影响。vector的elements()返回的Enumeration对象不遵循fail-fast原则。 注意iterator遵循的fail-fast原则并不能从根本上解决并发问题，它仅仅只是尽力而为，若要避免并发问题，还需结构本身提供线程安全保护。因此因fail-fast原则抛出的ConcurrentModificationException仅应被用于检测bug，而非以其为依据进行并发保护。 在JDK1.2版本中，Vector被重写，重写后的Vector实现了List接口，因此其成为了Java集合框架中的一员。和新的集合实现类不同，Vector是线程安全的。若应用不需要线程安全的实现，推荐使用ArrayList替代本类。 注1:Arrays.copyOf(r, i, newType)1Arrays.copyOf(U[] r, int i, Class&lt;? extends T[]&gt; newType) 以r为基础返回一个长度为i的数组，返回数组的类型为newType。 若i&lt;r.length则r发生截断。实际返回的数组为r中索引为[0,i-1]的元素。 若i==r.length，则返回的数组与r相等。 若i&gt;r.length，返回的数组中索引为[0, r.length-1]的元素为r中对应位置的元素，索引为[r.length, i-1]的元素以null填充。 无论如何，返回的数组都是新生成的，与r不存在引用关系。返回的数组中的元素是r中元素的浅拷贝。 注2:System.arraycopy(r, 0, a, 0, i)参数含义依次为： r: 待复制的源数组。 0: 源数组中开始复制的索引。 a: 复制目标数组。 0: 目标数组中接收元素的起始索引。 i: 复制的元素个数。 目标数组中其他位置的元素不受影响。 注3:modCountmodCount字段继承自超类AbstractList： list发生结构性变化的次数。结构性变化是指改变list的长度，或是其他会使迭代器结果混乱的变化。 本字段将被iterator()返回的iterator及listIterator()返回的listIterator使用。若本字段发生了 iterator/listIterator 所没有预期到的变化，则在调用 iterator/listIterator 的next()，remove()，previous()，set(E e)，add(E e)出现fail-fast时抛出ConcurrentModificationException。 在迭代过程中，若检测到并发性变化，则直接判定为失败并抛出异常(fail-fast)，而不会去进一步检测所发生的并发性变化是否真的会对迭代造成影响(non-deterministic)。 子类可自行选择是否使用本字段。若子类决定继承本类的fail-fast判定，则只需要在会引发结构性变化的方法中增加本字段的值。本类中已实现的引发结构性变化的方法有add(int index, E element)及remove(int index)。调用一次add(int index, E element)或remove(int index)只需将本字段自增1，表示发生了一次结构性变化，否则 iterator/listIterator 会抛出错误的ConcurrentModificationException。 若子类不想遵循fail-fast，忽略本字段即可。 注4:Arrays.copyOf(r, i)以r为基础返回一个长度为i的数组。 若i&lt;r.length则r发生截断。实际返回的数组为r中索引为[0,i-1]的元素。 若i==r.length，则返回的数组与r相等。 若i&gt;r.length，返回的数组中索引为[0, r.length-1]的元素为r中对应位置的元素，索引为[r.length, i-1]的元素以null填充。 无论如何，返回的数组都是新生成的，与r不存在引用关系。返回的数组中的元素是r中元素的浅拷贝。]]></content>
      <categories>
        <category>Java JDK7源码</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
        <tag>Collection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[传智 springmvc+mybatis day1-9.原始dao开发方式]]></title>
    <url>%2F2017%2F08%2F13%2F%E4%BC%A0%E6%99%BAspringmvcmybatisday1-9%E5%8E%9F%E5%A7%8Bdao%E5%BC%80%E5%8F%91%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[原始DAO的开发方式程序员需要写DAO接口及DAO的接口实现。 项目路径： 仓库：chuanzhi_springmvc_mybatis 项目：day1_7 项目架构： pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com&lt;/groupId&gt; &lt;artifactId&gt;day1_7&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;maven.compiler.encoding&gt;UTF-8&lt;/maven.compiler.encoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.43&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;asm&lt;/groupId&gt; &lt;artifactId&gt;asm&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.javassist&lt;/groupId&gt; &lt;artifactId&gt;javassist&lt;/artifactId&gt; &lt;version&gt;3.21.0-GA&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.35&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; log4j.properties 123456log4j.rootLogger=DEBUG,baselog4j.appender.base=org.apache.log4j.DailyRollingFileAppenderlog4j.appender.base.layout=org.apache.log4j.PatternLayoutlog4j.appender.base.layout.conversionPattern=%d&#123;yyyy-MM-dd HH\:mm\:ss&#125; %c\:%L [%-4p] - %m%nlog4j.appender.base.File=/day1_7.log mybatis/SqlMapConfig.xml 12345678910111213141516171819&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot; /&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;&quot; /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;mybatis/sqlmap/user.xml&quot; /&gt; &lt;/mappers&gt;&lt;/configuration&gt; mybatis/sqlmap/user.xml 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.day1_7.user.pojo.UserPojo&quot;&gt; &lt;select id=&quot;selectById&quot; parameterType=&quot;int&quot; resultType=&quot;com.day1_7.user.pojo.UserPojo&quot;&gt; select * from user where id= #&#123;id&#125; &lt;/select&gt; &lt;select id=&quot;selectByName&quot; parameterType=&quot;String&quot; resultType=&quot;com.day1_7.user.pojo.UserPojo&quot;&gt; select * from user where name like &apos;$&#123;value&#125;%&apos; &lt;/select&gt; &lt;insert id=&quot;insert&quot; parameterType=&quot;com.day1_7.user.pojo.UserPojo&quot;&gt; &lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;int&quot;&gt; select last_insert_id() &lt;/selectKey&gt; insert into user(name,create_time) values(#&#123;name&#125;,#&#123;create_time&#125;) &lt;/insert&gt;&lt;/mapper&gt; UserPojo.java 12345678910111213141516171819202122232425262728293031323334353637package com.day1_7.user.pojo;import java.util.Date;public class UserPojo &#123; private Integer id; private String name; private Date create_time; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Date getCreate_time() &#123; return create_time; &#125; public void setCreate_time(Date create_time) &#123; this.create_time = create_time; &#125;&#125; com.day1_7.user.dao.UserDao.java 1234567891011121314package com.day1_7.user.dao;import java.util.List;import com.day1_7.user.pojo.UserPojo;public interface UserDao &#123; public UserPojo selectById(int id) throws Exception; public List&lt;UserPojo&gt; selectByName(String name) throws Exception; public void insert(UserPojo userPojo) throws Exception;&#125; 通常DAO接口都会抛出异常，以便于service层处理。 com.day1_7.user.dao.UserDaoImpl.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.day1_7.user.dao;import java.util.List;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import com.day1_7.user.pojo.UserPojo;public class UserDaoImpl implements UserDao &#123; private SqlSessionFactory sqlSessionFactory; public UserDaoImpl(SqlSessionFactory sqlSessionFactory) &#123; this.sqlSessionFactory = sqlSessionFactory; &#125; @Override public UserPojo selectById(int id) &#123; SqlSession sqlSession = null; UserPojo userPojo = null; try &#123; sqlSession = this.sqlSessionFactory.openSession(); userPojo = sqlSession.selectOne(&quot;com.day1_7.user.pojo.UserPojo.selectById&quot;, id); &#125; finally &#123; if (null != sqlSession) sqlSession.close(); &#125; return userPojo; &#125; @Override public List&lt;UserPojo&gt; selectByName(String name) &#123; SqlSession sqlSession = null; List&lt;UserPojo&gt; userPojoList = null; try &#123; sqlSession = this.sqlSessionFactory.openSession(); userPojoList = sqlSession.selectList(&quot;com.day1_7.user.pojo.UserPojo.selectByName&quot;, name); &#125; finally &#123; if (null != sqlSession) sqlSession.close(); &#125; return userPojoList; &#125; @Override public void insert(UserPojo userPojo) &#123; SqlSession sqlSession = null; try &#123; sqlSession = this.sqlSessionFactory.openSession(); sqlSession.insert(&quot;com.day1_7.user.pojo.UserPojo.insert&quot;, userPojo); sqlSession.commit(); &#125; finally &#123; if (null != sqlSession) sqlSession.close(); &#125; &#125;&#125; SqlSessionFactory是单例的，因此应以某种方式注入。本demo以构造函数注入。 com.UserDaoImplTest.java 12345678910111213141516171819202122232425package com;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Before;import org.junit.Test;import com.alibaba.fastjson.JSON;import com.day1_7.user.dao.UserDaoImpl;public class UserDaoImplTest &#123; private SqlSessionFactory sqlSessionFactory; @Before public void setUp() throws Exception &#123; this.sqlSessionFactory = new SqlSessionFactoryBuilder().build(Resources.getResourceAsStream(&quot;mybatis/SqlMapConfig.xml&quot;)); &#125; @Test public void testSelectById() &#123; System.out.println(JSON.toJSONString(new UserDaoImpl(this.sqlSessionFactory).selectById(1))); &#125;&#125; 运行该测试类： 1&#123;&quot;create_time&quot;:1496411217000,&quot;id&quot;:1,&quot;name&quot;:&quot;博丽灵梦&quot;&#125; 打印的dubug日志信息如下： 12345678910111213142017-08-13 15:17:26 org.apache.ibatis.logging.LogFactory:135 [DEBUG] - Logging initialized using &apos;class org.apache.ibatis.logging.slf4j.Slf4jImpl&apos; adapter.2017-08-13 15:17:26 org.apache.ibatis.datasource.pooled.PooledDataSource:316 [DEBUG] - PooledDataSource forcefully closed/removed all connections.2017-08-13 15:17:26 org.apache.ibatis.datasource.pooled.PooledDataSource:316 [DEBUG] - PooledDataSource forcefully closed/removed all connections.2017-08-13 15:17:26 org.apache.ibatis.datasource.pooled.PooledDataSource:316 [DEBUG] - PooledDataSource forcefully closed/removed all connections.2017-08-13 15:17:26 org.apache.ibatis.datasource.pooled.PooledDataSource:316 [DEBUG] - PooledDataSource forcefully closed/removed all connections.2017-08-13 15:17:26 org.apache.ibatis.transaction.jdbc.JdbcTransaction:136 [DEBUG] - Opening JDBC Connection2017-08-13 15:17:26 org.apache.ibatis.datasource.pooled.PooledDataSource:387 [DEBUG] - Created connection 1430361668.2017-08-13 15:17:26 org.apache.ibatis.transaction.jdbc.JdbcTransaction:100 [DEBUG] - Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@55419644]2017-08-13 15:17:26 com.day1_7.user.pojo.UserPojo.selectById:159 [DEBUG] - ==&gt; Preparing: select * from user where id= ? 2017-08-13 15:17:26 com.day1_7.user.pojo.UserPojo.selectById:159 [DEBUG] - ==&gt; Parameters: 1(Integer)2017-08-13 15:17:26 com.day1_7.user.pojo.UserPojo.selectById:159 [DEBUG] - &lt;== Total: 12017-08-13 15:17:26 org.apache.ibatis.transaction.jdbc.JdbcTransaction:122 [DEBUG] - Resetting autocommit to true on JDBC Connection [com.mysql.jdbc.JDBC4Connection@55419644]2017-08-13 15:17:26 org.apache.ibatis.transaction.jdbc.JdbcTransaction:90 [DEBUG] - Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@55419644]2017-08-13 15:17:26 org.apache.ibatis.datasource.pooled.PooledDataSource:344 [DEBUG] - Returned connection 1430361668 to pool.]]></content>
      <categories>
        <category>传智 springmvc+mybatis day1</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdbc</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[传智 springmvc+mybatis day1-10.mapper代理开发方式]]></title>
    <url>%2F2017%2F08%2F13%2F%E4%BC%A0%E6%99%BAspringmvcmybatisday1-10mapper%E4%BB%A3%E7%90%86%E5%BC%80%E5%8F%91%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[原始DAO开发方式的不足 DAO的实现类中存在重复的代码，整个代码的模板是重复的： 创建session 调用对应session方法 关闭session DAO的实现类中存在硬编码，调用sqlsession方法时传入的statement的namespace+id为硬编码： 1userPojo = sqlSession.selectOne(&quot;com.day1_7.user.pojo.UserPojo.selectById&quot;, id); mapper开发规范要想让Mybatis自动创建DAO接口实现类的代理对象，必须遵循一些规则： 为了要让Mybatis知道DAO接口对应的是哪个mapper.xml，mapper.xml的namespace必须指定为对应DAO接口的全路径名。因此Mybatis提出了mapper接口的概念，在使用Mybatis开发时，mapper接口与DAO接口的概念等价。 mapper接口的命名方式通常为 表名+Mapper.java。 mapper配置文件的命名方式通常为 表名+Mapper.xml(与其对应的mapper接口同名)。 mapper.xml中statement的id是mapper接口中对应的方法名。 mapper.xml中statement的parameterType和mapper接口对应方法输入的参数类型一致。 mapper.xml中statement的resultType和mapper接口对应方法的返回值类型一致。 项目项目路径： 仓库：chuanzhi_springmvc_mybatis 项目：day1_8 项目架构： pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com&lt;/groupId&gt; &lt;artifactId&gt;day1_8&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;maven.compiler.encoding&gt;UTF-8&lt;/maven.compiler.encoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.43&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;asm&lt;/groupId&gt; &lt;artifactId&gt;asm&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.javassist&lt;/groupId&gt; &lt;artifactId&gt;javassist&lt;/artifactId&gt; &lt;version&gt;3.21.0-GA&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.35&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; log4j.properties 123456log4j.rootLogger=DEBUG,baselog4j.appender.base=org.apache.log4j.DailyRollingFileAppenderlog4j.appender.base.layout=org.apache.log4j.PatternLayoutlog4j.appender.base.layout.conversionPattern=%d&#123;yyyy-MM-dd HH\:mm\:ss&#125; %c\:%L [%-4p] - %m%nlog4j.appender.base.File=/day1_8.log mybatis/SqlMapConfig.xml 12345678910111213141516171819&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot; /&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;&quot; /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;mybatis/mapper/UserMapper.xml&quot; /&gt; &lt;/mappers&gt;&lt;/configuration&gt; mybatis/mapper/UserMapper.xml 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.day1_8.user.mapper.UserMapper&quot;&gt; &lt;select id=&quot;selectById&quot; parameterType=&quot;int&quot; resultType=&quot;com.day1_8.user.pojo.UserPojo&quot;&gt; select * from user where id= #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; com.day1_8.user.pojo.UserPojo.java 123456789101112131415161718192021222324252627282930313233343536package com.day1_8.user.pojo;import java.util.Date;public class UserPojo &#123; private Integer id; private String name; private Date create_time; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Date getCreate_time() &#123; return create_time; &#125; public void setCreate_time(Date create_time) &#123; this.create_time = create_time; &#125;&#125; com.day1_8.user.mapper.UserMapper.java 12345678package com.day1_8.user.mapper;import com.day1_8.user.pojo.UserPojo;public interface UserMapper &#123; public UserPojo selectById(int id) throws Exception;&#125; com.UserMapperTest.java 12345678910111213141516171819202122232425262728package com;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Before;import org.junit.Test;import com.alibaba.fastjson.JSON;import com.day1_8.user.mapper.UserMapper;public class UserMapperTest &#123; private SqlSessionFactory sqlSessionFactory; @Before public void setUp() throws Exception &#123; this.sqlSessionFactory = new SqlSessionFactoryBuilder().build(Resources.getResourceAsStream(&quot;mybatis/SqlMapConfig.xml&quot;)); &#125; @Test public void testSelectById() throws Exception &#123; SqlSession sqlSession = this.sqlSessionFactory.openSession(); System.out.println(JSON.toJSONString(sqlSession.getMapper(UserMapper.class).selectById(1))); sqlSession.close(); &#125;&#125; 屏幕打印结果： 1&#123;&quot;create_time&quot;:1496411217000,&quot;id&quot;:1,&quot;name&quot;:&quot;博丽灵梦&quot;&#125; 日志信息： 12345678910111213142017-09-02 11:23:49 org.apache.ibatis.logging.LogFactory:135 [DEBUG] - Logging initialized using &apos;class org.apache.ibatis.logging.slf4j.Slf4jImpl&apos; adapter.2017-09-02 11:23:49 org.apache.ibatis.datasource.pooled.PooledDataSource:316 [DEBUG] - PooledDataSource forcefully closed/removed all connections.2017-09-02 11:23:49 org.apache.ibatis.datasource.pooled.PooledDataSource:316 [DEBUG] - PooledDataSource forcefully closed/removed all connections.2017-09-02 11:23:49 org.apache.ibatis.datasource.pooled.PooledDataSource:316 [DEBUG] - PooledDataSource forcefully closed/removed all connections.2017-09-02 11:23:49 org.apache.ibatis.datasource.pooled.PooledDataSource:316 [DEBUG] - PooledDataSource forcefully closed/removed all connections.2017-09-02 11:23:49 org.apache.ibatis.transaction.jdbc.JdbcTransaction:136 [DEBUG] - Opening JDBC Connection2017-09-02 11:23:49 org.apache.ibatis.datasource.pooled.PooledDataSource:387 [DEBUG] - Created connection 491919031.2017-09-02 11:23:49 org.apache.ibatis.transaction.jdbc.JdbcTransaction:100 [DEBUG] - Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@1d5216b7]2017-09-02 11:23:49 com.day1_8.user.mapper.UserMapper.selectById:159 [DEBUG] - ==&gt; Preparing: select * from user where id= ? 2017-09-02 11:23:49 com.day1_8.user.mapper.UserMapper.selectById:159 [DEBUG] - ==&gt; Parameters: 1(Integer)2017-09-02 11:23:49 com.day1_8.user.mapper.UserMapper.selectById:159 [DEBUG] - &lt;== Total: 12017-09-02 11:23:49 org.apache.ibatis.transaction.jdbc.JdbcTransaction:122 [DEBUG] - Resetting autocommit to true on JDBC Connection [com.mysql.jdbc.JDBC4Connection@1d5216b7]2017-09-02 11:23:49 org.apache.ibatis.transaction.jdbc.JdbcTransaction:90 [DEBUG] - Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@1d5216b7]2017-09-02 11:23:49 org.apache.ibatis.datasource.pooled.PooledDataSource:344 [DEBUG] - Returned connection 491919031 to pool.]]></content>
      <categories>
        <category>传智 springmvc+mybatis day1</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdbc</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 并发-synchronized]]></title>
    <url>%2F2017%2F07%2F13%2FJava%20%E5%B9%B6%E5%8F%91-synchronized%2F</url>
    <content type="text"><![CDATA[在synchronized标记范围内的同步块同时只能被一个线程进入并执行操作，所有其他等待进入该同步块的线程将被阻塞，直到该同步块中的线程退出。 synchronized的含义为同步。在表现上，synchronized实现了监视器机制。 被阻塞的是尝试进入synchronized同步块的线程，如果说线程被阻塞相当于在前行的路上被一道门挡住了，则synchronized所修饰的对象(称为监视器对象)则相当于加于这道门上的监视器。在这里被当做监视器的对象仅仅相当于一个记号，所有对象都可被用作监视器，而被作为监视器对对象而言也没什么影响，受影响的仅仅是被阻塞了的线程。 synchronized相当于在线程前进的路上设置了两道门。进第一道门时需要获得监视器对象的认可，同一时间点最多只能有一个线程可以得到这个认可。若线程获得认可进入第一道门后，则可继续前行直至第二道门，第二道门没有监视器，其只相当于一个线程的退出标记，当线程离开第二道门后第一道门上的监视器对象将收回对该线程的认可，并可将该认可再次发给其他线程(当然只要刚离开第二道门的线程愿意，它也可以马上再次申请该认可)。 本质上，synchronized只能修饰对象，synchronized有如下具体的使用方式： 修饰实例方法。实际是修饰该实例方法所属的对象。 1public synchronized void m() &#123;&#125; 修饰静态方法。实际是修饰该静态方法所属类的类对象(即Class对象)。 1public static synchronized void m() &#123;&#125; 实例/静态 方法中的同步块。此时synchronized会显示指明监视器对象。 1synchronized(o) &#123;&#125; 如果一个线程在等待监视器对象的认可，那么等待的结果只有两种：要么获得认可结束等待；要么无限期的等下去。换句话说，等待监视器对象认可是没有中断机制的。 synchronized同步块中的变量具有可见性。且并发线程执行到synchronized同步块时相当于变回了串行执行，因此synchronized天然具有有序性。由此synchronized可实现volatile的所有功能，只是付出的代价要大一些。 通信：wait()/wait(long timeout)，notify()/notifyAll()。这几个方法都出自Object类： 123456789public final void wait() throws InterruptedException &#123; wait(0);&#125;public final native void wait(long timeout) throws InterruptedException;public final native void notify();public final native void notifyAll(); wait()内部实际上就是调用wait(long timeout)，0表示无限期等待： 因此本质上二者的实现机制是一致的，wait()表示无限等待，只要没有接到唤醒信号就会一直等下去。wait(long timeout)除了会在接到唤醒信号时结束等待之外，也会在设置的限定时间到期后自动结束等待。除此之外二者没有其他差异。为了论述方便，下文仅以wait()来代指 wait()/wait(long timeout) 。 关于wait()，notify()和notifyAll()与Java线程状态转换的关系，详见Java 并发-线程状态转换。 为了进行线程间的通信，可采用”自定义通信对象+忙等待查询”的方式，详见Java 并发-线程通信。 忙等待的缺陷：从JVM的角度来看，JVM并不知道进行忙等待的线程是在做无法产生有效结果的等待操作，在它看来，该线程依然在正常的运行着并在切实执行用户程序。此时该线程并没有让出它已获得的所有资源。用户程序人为的让该线程在等待时适当的进行睡眠可以在一定程度上缓解这个问题，但是睡眠频度及睡眠时间的长短很难根据系统当前情况调整为一个最优值。 因此，Java提供了一个内建机制以从根本上解决这个问题，将用户程序从复杂的通信问题中解放出来。 java.lang.Object类定义了三个实例方法：wait()，notify()和notifyAll()来实现这个等待机制。注意该机制必须配合synchronized关键字使用，即这3个实例方法必须存在于synchronized标记范围内的同步块中，且该synchronized所监视的监视器对象即为这3个实例方法所属的对象(若不是，可通过编译，运行时抛出运行时异常IllegalMonitorStateException)。换句话说，要想使用某监视器对象的通信机制，必须要先获得该监视器对象的认可。因为同一时间点最多只能有一个线程可以得到这个认可，所以在同一时间点，对于某特定监视器对象而言，最多只有一个线程能调用这3个方法中的任意一个。 wait()：让出监视器对象的认可及CPU。因为唯有这样其他线程才有机会获得这个认可从而调用notify()或notifyAll()正常结束该线程的等待状态。该方法会throws受检查异常：InterruptedException。 notify()：随机唤醒监视器对象等待池中的一个线程。 notifyAll()：唤醒监视器对象等待池中的所有线程。 因为监视器对象的认可只有一个，因此notify()及notifyAll()只负责通知被唤醒的线程：你被唤醒了，可以不用等了。至于被唤醒的线程能否获得监视器对象的认可。这两个方法就不管了。具体来说，需要关注的问题有两个： 和wait()不同，线程调用notify()或notifyAll()相当于只发出了一个通知，notify()或notifyAll()对其而言只是一个普通的方法，调用完成后线程不会让出任何资源，并且会继续向下执行。因为不让出任何资源，自然也不会让出其已获得的监视器对象的认可。因此不是调用notify()或notifyAll()后被唤醒线程立刻就能获得监视器对象的认可了，起码也要等调用线程让出该认可后才有可能。而只有重新获得了监视器对象的认可，被阻塞的线程才能够从等锁池中解放出来从而继续向下执行。 基于同样的原理，notifyAll()虽然唤醒了所有线程，但是哪个线程能先得到监视器对象的认可，则要靠真本事去竞争了。不过这也只是先后问题，除非死锁或饿死，所有被唤醒的线程总有机会执行完成。 该通信机制有一个问题：notify()及notifyAll()是非常不负责任的方法，它们只是姑且通知一下，如果在通知的时候监视器对象的等待池中并没有在等待的线程。那么没有也就没有了，本次通知相当于作废。因此如果程序流程不当，导致notify()或notifyAll()调用在了其对应的wait()之前，这就会导致wait()永远无法再次接到唤醒信号了。 如下所示，该程序运行后无法结束。 12345678910111213141516171819202122232425262728public class Test &#123; public static void main(String[] args) &#123; Runnable wait = new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(1000L); // 设置情境：保证notify信号先发出 synchronized (Test.class) &#123; Test.class.wait(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; Runnable notify = new Runnable() &#123; @Override public void run() &#123; synchronized (Test.class) &#123; Test.class.notify(); &#125; &#125; &#125;; new Thread(wait).start(); new Thread(notify).start(); &#125;&#125; 为解决该问题，可配合自定义通信对象一起使用： 1234567891011121314151617181920212223242526272829303132333435363738public class Test &#123; private static boolean NOTIFY_FLAG = false; private static final synchronized void setNOTIFY_FLAG(boolean nOTIFY_FLAG) &#123; NOTIFY_FLAG = nOTIFY_FLAG; &#125; public static void main(String[] args) &#123; Runnable wait = new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(1000L); // 设置情境：保证notify信号先发出 if (!Test.NOTIFY_FLAG) &#123; synchronized (Test.class) &#123; Test.class.wait(); &#125; &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Test.setNOTIFY_FLAG(false); // 保证一个notify只为一个wait所用 &#125; &#125;; Runnable notify = new Runnable() &#123; @Override public void run() &#123; synchronized (Test.class) &#123; Test.setNOTIFY_FLAG(true); Test.class.notify(); &#125; &#125; &#125;; new Thread(wait).start(); new Thread(notify).start(); &#125;&#125; 改造后，程序可执行完成。 JVM中synchronized的实现方式synchronized可以支持方法级的同步及方法内部一段指令序列的同步，在底层是通过管程(Monitor)来支持的。 方法级的同步是隐式的，即无需通过字节码指令来控制，它实现在方法调用和返回操作之中。JVM可通过判断class文件-&gt;方法表集合-&gt;方法表-&gt;access_flags中标记同步的标志ACC_SYNCHRONIZED是否为1来判断该方法是否是同步方法。若被设置为同步方法，执行线程需要先成功持有管程(即上文中的监视器许可)，然后才能执行方法，最后当执行完成(无论是正常完成还是非正常完成，即若一个同步方法在执行期间抛出了异常，且该方法无法处理这个异常，则执行线程将在该异常被抛出到同步方法之外时自动释放其所持有的管程)，都会释放管程。在其释放管程之前，其他任何线程都无法再取得这个管程。 而对于方法内部一段指令序列的同步，JVM提供了monitorenter及monitorexit指令标记同步区域。因此欲正确实现synchronized对方法内部一段指令序列的同步需javac编译器(将源码中被synchronized关键字修饰的代码块替换为对应的被monitorenter及monitorexit标记的字节码指令区域)及解释器(正确读取并执行monitorenter及monitorexit指令)二者共同支持。 例如有如下代码： 12345678public class Test &#123; public void m(Object o) &#123; synchronized (o) &#123; System.out.println(&quot;in synchronized...&quot;); &#125; &#125;&#125; 使用javap反编译其class文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164Classfile /E:/Test.class Last modified 2017-11-22; size 531 bytes MD5 checksum e7d825a53a74620971ce4799ed6aad4a Compiled from &quot;Test.java&quot;public class Test SourceFile: &quot;Test.java&quot; minor version: 0 major version: 51 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #6.#19 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = Fieldref #20.#21 // java/lang/System.out:Ljava/io/PrintStream; #3 = String #22 // in synchronized... #4 = Methodref #23.#24 // java/io/PrintStream.println:(Ljava/lang/String;)V #5 = Class #25 // Test #6 = Class #26 // java/lang/Object #7 = Utf8 &lt;init&gt; #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 m #12 = Utf8 (Ljava/lang/Object;)V #13 = Utf8 StackMapTable #14 = Class #25 // Test #15 = Class #26 // java/lang/Object #16 = Class #27 // java/lang/Throwable #17 = Utf8 SourceFile #18 = Utf8 Test.java #19 = NameAndType #7:#8 // &quot;&lt;init&gt;&quot;:()V #20 = Class #28 // java/lang/System #21 = NameAndType #29:#30 // out:Ljava/io/PrintStream; #22 = Utf8 in synchronized... #23 = Class #31 // java/io/PrintStream #24 = NameAndType #32:#33 // println:(Ljava/lang/String;)V #25 = Utf8 Test #26 = Utf8 java/lang/Object #27 = Utf8 java/lang/Throwable #28 = Utf8 java/lang/System #29 = Utf8 out #30 = Utf8 Ljava/io/PrintStream; #31 = Utf8 java/io/PrintStream #32 = Utf8 println #33 = Utf8 (Ljava/lang/String;)V&#123; public Test(); flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 1: 0 public void m(java.lang.Object); flags: ACC_PUBLIC Code: stack=2, locals=4, args_size=2 // 操作数栈最大深度为2 // 局部变量表长度为4Slot，即支持的索引为[0,3] // 方法传入参数为2：this,java.lang.Object(后文记为o) // 初始时： // 局部变量表：this,o,无,无 // 操作数栈(自栈底至栈顶)：无,无 0: aload_1 // 将局部变量表1号Slot中的引用类型压入操作数栈 // 本指令完成后： // 局部变量表：this,o,无,无 // 操作数栈(自栈底至栈顶)：o,无 1: dup // 弹出操作数栈栈顶数值，复制该值并将原值及复制值压入操作数栈 // 该复制值后文记为o_c // 本指令完成后： // 局部变量表：this,o,无,无 // 操作数栈(自栈底至栈顶)：o,o_c 2: astore_2 // 将栈顶引用类型弹出并存入局部变量表2号索引处 // 本指令完成后： // 局部变量表：this,o,o_c,无 // 操作数栈(自栈底至栈顶)：o,无 3: monitorenter // 弹出并获得操作数栈栈顶对象的管程，用于被synchronized关键字修饰的同步块 // 本指令完成后： // 局部变量表：this,o,o_c,无 // 操作数栈(自栈底至栈顶)：无,无 4: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; // 获取指定类的指定类变量，并将其值压入操作数栈。该指令的操作码之后会紧跟一个u2的操作数说明具体需要的是哪个类变量，该参数指向常量池集合中的一个CONSTANT_UTF8_info类型的索引项，也就是该字段的字段符号引用 // 本指令取得的类变量后文将记为out // 本指令完成后： // 局部变量表：this,o,o_c,无 // 操作数栈(自栈底至栈顶)：out,无 7: ldc #3 // String in synchronized... // 将int,float或String型常量值从常量池中推送至操作数栈栈顶。该指令的操作码之后会紧跟一个u2的操作数作为具体的值，该参数指向常量池集合中的一个对应类型的索引项 // 本指令对应的字符串后文中记为s // 本指令完成后： // 局部变量表：this,o,o_c,无 // 操作数栈(自栈底至栈顶)：out,s 9: invokevirtual #4 // Method java/io/PrintStream.println:(Ljava/lang/String;)V // 调用实例方法。会根据对象的实际类型进行动态单分派(虚方法分派) // 弹出操作数栈中的out及s，out作为被调用方法的对象，s为方法所需的参数 // 本指令完成后： // 局部变量表：this,o,o_c,无 // 操作数栈(自栈底至栈顶)：无,无 12: aload_2 // 将局部变量表2号Slot中的引用类型压入操作数栈 // 本指令完成后： // 局部变量表：this,o,o_c,无 // 操作数栈(自栈底至栈顶)：o_c,无 13: monitorexit // 弹出并释放操作数栈栈顶对象的管程，用于被synchronized关键字修饰的同步块 // 之所以用o_c而非o是为防止o被改变 // 本指令完成后： // 局部变量表：this,o,o_c,无 // 操作数栈(自栈底至栈顶)：无,无 14: goto 22 // 无条件跳转至指令22 17: astore_3 // 将栈顶引用类型弹出并存入局部变量表3号索引处 // [4,13]发生异常后会跳转至本指令，不妨设12结束后发生异常。则操作数栈栈顶会被压入抛出的异常e // 本指令完成后： // 局部变量表：this,o,o_c,e // 操作数栈(自栈底至栈顶)：o_c,无 18: aload_2 // 将局部变量表2号Slot中的引用类型压入操作数栈 // 本指令完成后： // 局部变量表：this,o,o_c,e // 操作数栈(自栈底至栈顶)：o_c,o_c 19: monitorexit // 弹出并释放操作数栈栈顶对象的管程，用于被synchronized关键字修饰的同步块 // 之所以用o_c而非o是为防止o被改变 // 本指令完成后： // 局部变量表：this,o,o_c,e // 操作数栈(自栈底至栈顶)：o_c,无 20: aload_3 // 将局部变量表3号Slot中的引用类型压入操作数栈 // 本指令完成后： // 局部变量表：this,o,o_c,e // 操作数栈(自栈底至栈顶)：o_c,e 21: athrow // 弹出操作数栈栈顶的异常并将其抛出 22: return // 从当前方法返回void，本方法结束 Exception table: from to target type 4 14 17 any 17 20 17 any LineNumberTable: line 4: 0 line 5: 4 line 6: 12 line 7: 22 StackMapTable: number_of_entries = 2 frame_type = 255 /* full_frame */ offset_delta = 17 locals = [ class Test, class java/lang/Object, class java/lang/Object ] stack = [ class java/lang/Throwable ] frame_type = 250 /* chop */ offset_delta = 4&#125; 由上述反编译文件可证实，无论方法是否正常退出，只要执行了monitorenter(3)，就会执行对应的monitorexit(13,19，各可能的分支上都会冗余存储一份)。 一个隐蔽的错误加锁的示例现有如下程序： 123456789101112131415161718192021222324public class Test implements Runnable &#123; private static Integer I = 0; @Override public void run() &#123; for (int j = 0; j &lt; 1000_0000; j++) &#123; synchronized (Test.I) &#123; I++; &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; Test r = new Test(); Thread t1 = new Thread(r); Thread t2 = new Thread(r); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(Test.I); &#125;&#125; 该程序实现了一个简单的计算器，乍看之下没有任何问题，预期运行结果为2000_0000。然而实际的运行结果为： 115429002 这比预期的结果小了很多，那么问题出在哪里呢？ 在Java 并发-Thread类中，我们得出了这样一个结论：以Thread类的实例为监视器对象可能会引起未知的并发错误。可见监视器对象的错误选择是引起并发错误的一个重要原因，那么本例的错误是否也是由监视器对象I的选择错误引起的呢？ 正是这样！I的类型为Integer: 1public final class Integer extends Number implements Comparable&lt;Integer&gt; 这是一个被final修饰的不可变的类。也就是说一旦Integer的实例被创建，比如我们将其赋值为1，那么它终其一生就只能是1，不能变成其他值。而我们在程序中为什么又可以使用诸如I++来改变I的值呢？这其实是Java的一个小戏法：改变I的值相当于新建了一个Integer实例。 更具体的说，I++其实是这样实现的： 1I = Integer.valueOf(I.intValue() + 1); 然后我们再来看valueOf()这个方法的源码： 123456public static Integer valueOf(int i) &#123; assert IntegerCache.high &gt;= 127; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; 这样原因就明确了：监视器对象I所指向的实例相当于始终处于变化中，自然无法保证同步。由此看来，尽量不要选择不可变对象为监视器才好。 修改本例： 1234567891011121314151617181920212223242526package com.test;public class Test implements Runnable &#123; private static Integer I = 0; @Override public void run() &#123; for (int j = 0; j &lt; 1000_0000; j++) &#123; synchronized (Test.class) &#123; I++; &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; Test r = new Test(); Thread t1 = new Thread(r); Thread t2 = new Thread(r); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(Test.I); &#125;&#125; 输出： 120000000 符合预期，没有发生并发问题。]]></content>
      <categories>
        <category>Java 并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>synchronized</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 并发-线程通信]]></title>
    <url>%2F2017%2F07%2F13%2FJava%20%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[自定义通信对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Test &#123; private static final Signal SIGNAL = new Signal(); /** * 写入线程：只写入一次。 * 读取线程：直到有数据前等待，只读取一次。 */ public static void main(String[] args) &#123; Runnable write = new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(2000L); // 模拟写入耗时 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;写入数据完成&quot;); Test.SIGNAL.setHaveData(true); &#125; &#125;; Runnable read = new Runnable() &#123; @Override public void run() &#123; while (!Test.SIGNAL.haveData) &#123; // 忙等待 try &#123; System.out.println(&quot;数据未准备好&quot;); Thread.sleep(1000L); // 防止空转次数过多 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(&quot;数据已准备好&quot;); &#125; &#125;; new Thread(write).start(); new Thread(read).start(); &#125;&#125;final class Signal &#123; boolean haveData = false; synchronized void setHaveData(boolean haveData) &#123; this.haveData = haveData; &#125;&#125; 输出： 1234数据未准备好数据未准备好写入数据完成数据已准备好 wait(),notify()和notifyAll()详见Java 并发-synchronized。]]></content>
      <categories>
        <category>Java 并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 并发-线程状态转换]]></title>
    <url>%2F2017%2F07%2F12%2FJava%20%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[进程与线程进程(Process)是具有一定独立功能的程序在某个数据集合上的一次运行活动，是操作系统进行资源分配和调度的基本单位。 线程可以看作是轻量级的进程，是CPU调度和分派,比进程更小的能独立运行的基本单位。 进程在执行时通常拥有独立的内存单元，而线程之间可以共享内存。 简单来说，可以认为进程是线程的容器。举一个生活中的小例子：一家3口生活在他们的屋子里。在这里屋子就可以看作是进程。而在其中生活的一家3口就是线程。屋子为一家3口提供了电视，厨房，厕所等人类生活所需要的资源。因为有些资源是有限的，所以有时会产生冲突，例如电视只有一个，当孩子想看动画片时父亲就看不了体育比赛了。当然一个健康的家庭更多的时候还是在体现着协作(总冲突这个家也算是完了)，例如妈妈在厨房做饭，爸爸在书房工作，孩子在客厅玩耍，这样才能保证这个家庭平稳的生活下去。 Java线程状态转换 图中的6个状态定义在Thread类的State枚举中： 12345678public enum State &#123; NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED;&#125; Java语言定义了6种线程状态： 新建(NEW)：创建但尚未运行。即已调用new生成了线程对象，但是尚未调用start()启动。 可运行(RUNNABLE)：RUNNABLE状态的线程一定已获得了除CPU以外运行所需的所有资源，依是否正获得着CPU又可细分为两类：就绪(READY)及运行(RUNNING)(分别对应操作系统线程状态中的READY及RUNNING)。READY表明目前没有正在占用CPU，但是线程已经准备好了，正所谓万事俱备，只欠CPU，只要CPU为其分配了执行时间立即就可转为RUNNING状态运行。RUNNING表明线程正在占用着CPU。 无限期等待(WAITING)：该状态下的线程会让出CPU，已占用的锁或监视器对象的认可。 限期等待(TIMED_WAITING)：该状态下的线程会让出CPU，已占用的锁或监视器对象的认可。 阻塞(BLOCKED)：无限期等待(WAITING)及限期等待(TIMED_WAITING)代表了线程的意志，即线程本身想停下来等待，也就是所谓的”不想做”。而阻塞(BLOCKED)代表了JVM的意志，属于强制力，无论线程作何打算，JVM目前已没有足够的资源让线程运行下去，也就是所谓的”做不到”。 结束(TERMINATED)：线程已终止。 任意时间点一个线程有且仅有其中的一种状态。不同状态间的转换条件为： 新建(NEW) –&gt; 可运行(RUNNABLE):start() 就绪(READY) –&gt; 运行(RUNNING):CPU调度为线程分配CPU时间。 运行(RUNNING) –&gt; 就绪(READY):CPU调度剥夺线程已得到的CPU，或线程主动调用yield()让出CPU。 可运行(RUNNABLE) –&gt; 结束(TERMINATED):run()执行结束。 可运行(RUNNABLE) –&gt; 阻塞(BLOCKED):申请资源(例如锁，监视器对象的认可，i/o流)而不得。 阻塞(BLOCKED) –&gt; 可运行(RUNNABLE):之前申请不到的资源申请到了。 可运行(RUNNABLE) –&gt; 限期等待(TIMED_WAITING): Thread.sleep()。 有TimeOut参数的Object.wait()。 有TimeOut参数的Thread.join()。 LockSupport.parkNanos()。 LockSupport.parkUntil()。 限期等待(TIMED_WAITING) –&gt; 可运行(RUNNABLE):接到唤醒信号，或设定的限期到来时自动转换。如果需要，在苏醒后成功获得所需的锁或监视器对象的认可。 限期等待(TIMED_WAITING) –&gt; 阻塞(BLOCKED):接到唤醒信号，或设定的限期到来时自动转换。在苏醒后未成功获得所需的锁或监视器对象的认可。 可运行(RUNNABLE) –&gt; 无限期等待(WAITING): 没有TimeOut参数的Object.wait()。 没有TimeOut参数的Thread.join()。 LockSupport.park()。 无限期等待(WAITING) –&gt; 可运行(RUNNABLE):接到唤醒信号。如果需要，在苏醒后成功获得所需的锁或监视器对象的认可。 无限期等待(WAITING) –&gt; 阻塞(BLOCKED):接到唤醒信号。在苏醒后未成功获得所需的锁或监视器对象的认可。 sleep(long millis)1public static native void sleep(long millis) throws InterruptedException; sleep(long millis)会抛出受检查异常InterruptedException，会让出已占有的CPU时间，会让给哪个线程与线程的优先级无关。 sleep(long millis)和锁及监视器对象的许可无关。 处于可运行(RUNNABLE)状态的线程调用sleep(long millis)后进入限期等待(TIMED_WAITING)状态。sleep(long millis)期限到来后恢复为可运行(RUNNABLE)状态。 wait()/wait(long timeout)wait()内部实际上就是调用wait(long timeout)，0表示无限期等待： 12345public final void wait() throws InterruptedException &#123; wait(0);&#125;public final native void wait(long timeout) throws InterruptedException; wait()/wait(long timeout) 会抛出受检查异常InterruptedException，会让出已占有的CPU时间。 wait()/wait(long timeout) 必须配合synchronized关键字使用，并会放弃已得到的监视器对象的许可。 处于可运行(RUNNABLE)状态的线程调用wait()后进入无限期等待(WAITING)状态。被唤醒后将重新尝试获取监视器对象的认可，获取成功则恢复为可运行(RUNNABLE)状态，获取失败则进入阻塞(BLOCKED)状态。 处于可运行(RUNNABLE)状态的线程调用wait(long timeout)后进入限期等待(TIMED_WAITING)状态。被唤醒或限期到来后将重新尝试获取监视器对象的认可，获取成功则恢复为可运行(RUNNABLE)状态，获取失败则进入阻塞(BLOCKED)状态。 yield()1public static native void yield(); yield()只会将CPU让给相同优先级或更高优先级的线程。 处于运行(RUNNING)状态的线程调用yield()后进入就绪(READY)状态。 等锁池与等待池等锁池及等待池均属于对象。等锁池(lock pool)是指等待synchronized及Lock的线程所处的队列。等待池(wait pool)是指调用 wait()/wait(long timeout) 后线程所处的队列。]]></content>
      <categories>
        <category>Java 并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 并发-Java内存模型]]></title>
    <url>%2F2017%2F07%2F12%2FJava%20%E5%B9%B6%E5%8F%91-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[若CPU是多核架构的，本文中的1个CPU指CPU的一个核。 硬件内存架构现代计算机硬件架构的简单图示： 绝大多数CPU都有一个缓存层，有些CPU还有多层缓存。 CPU操作数据时的数据流向：主存-&gt;缓存-&gt;寄存器-&gt;CPU读取并处理-&gt;寄存器-&gt;缓存–&gt;主存。 主存缓存的数据：为提高执行频率，不会每有一次CPU对数据的操作就进行一次同步，而是会在某个时间点一次性同步一批。每次同步也不会刷新所有缓存区域，而是以cache lines为基本单位一次同步缓存区域的一部分。 Java内存模型硬件内存架构没有栈和堆的区分。随着与CPU当前执行指令的亲密度的降序排列栈和堆中的信息可能出现在硬件架构中的所有位置：寄存器-&gt;缓存-&gt;主存。 一个CPU同时只能处理一个Java线程。 为建立JVM与硬件架构之间的联系，产生了Java内存模型JMM(Java Memory Model)。JMM的关键技术点都是围绕着多线程的原子性(Atomicity)，可见性(Visibility)及有序性(Ordering)建立的。 原子性(Atomicity) 原子性的操作是指那些最基本的，不可再分的操作，即便是在并发环境中，也不会产生模糊的值。例如两个线程各占用一个CPU同时给一个int型的变量赋值。线程1欲赋值为1，线程2欲赋值为2。那么结果上这个变量的值要么是1，要么是2，而绝不会产生某个其他的中间值。 举一个反例，在32位的JVM上，长度为64位的long型数据的读和写都不是原子操作(仅仅是32位的JVM是这样，64位的JVM对long型的操作也是原子的)。可以理解为都是先操作其前32位，再操作其后32位。每次操作32位的这个操作是原子的，但是两次这样的原子操作所拼接成的64位的long型数据的操作就不是原子的了。这就会带来一系列的并发问题。 具体来说，不妨设有一个long型的变量l，其前32位的值为i1，后32位的值为i2。则有l=i1+i2(此处的+是拼接)。再假设有写入线程1及写入线程2对l做并发修改。若某修改顺序为：线程1修改i1 –&gt; 线程2修改i1 –&gt; 线程2修改i2 –&gt; 线程1修改i2。这样得到的结果l中的i1部分是被线程2修改的，i2部分是被线程1修改的，产生了既不是线程1也不是线程2所期望的一个脏值。 可见性(Visibility) 可见性问题主要包含如下两种： 自身的修改能否及时被他人所见：CPU经由其缓存对数据做出的修改只要没有同步回主存就无法被其他CPU所见。 能否及时看到他人的修改：缓存只要没有从主存中同步那么CPU就拿不到主存当前的最新值。 解决策略：Java中的volatile关键字可以保证所有被其修饰的变量： 修改后总可及时同步回主存。 读取时总可读取到主存中的最新值。 竞争条件(race conditions)：即便保证了可见性，当多个CPU同时操作某数据时，依然会产生并发问题： 缓存1读取最新的o，缓存2读取最新的o：此时没有问题。 缓存1处理o，缓存2处理o：此时o的值在缓存1，缓存2，主存中已有差异。 即便是可以及时同步回主存，也是指CPU对o的操作告一段落后，因此这个同步的操作总是能分出先后，后同步回主存的值会把先同步回主存的值覆盖掉。 解决策略：Java synchronized同步，详见Java 并发-synchronized。 有序性(Ordering) 为了提高执行效率，保证流水线尽量满载(即尽量少的中断流水线)，有时候可能会进行指令重排(注意仅仅是可能，何时重排，怎样重排，都是应用程序不可控的)。重排后可以保证在线程内部不会因重排而导致结果有变化，但是对于并发环境下其他线程的观测结果重排则不做保证。例如： 123456789101112131415public class Test &#123; private int a; private boolean flag; public void write() &#123; this.a = 1; this.flag = true; &#125; public void read() &#123; if (this.flag) System.out.println(this.a); &#125;&#125; 现让线程1调用write()方法，先执行。线程2调用read()方法，稍晚执行。理论上结果要么是1(read()方法执行时write()方法已执行完成)，要么无输出(read()方法执行时write()方法还未执行到this.flag = true)。但是如果发生了指令重排且指令重排的结果将write()方法改变为如下所示： 1234public void write() &#123; this.flag = true; this.a = 1;&#125; 对于调用write()方法的线程1而言，这样排列对结果没有任何影响。但是对线程2而言，flag先于a被设置会导致输出的结果可能为0。 解决策略：volatile可阻止被其修饰的变量的上下文中发生指令重排。 指令重排遵循Happen-Before规则，具体来说： 程序顺序原则：一个线程的内部要保证语义的串行性。 volatile规则：volatile变量的写先发生于读，这保证了volatile变量的可见性。 锁规则：解锁(unlock)必然发生在随后的加锁(lock)前。 传递性：A先于B，B先于C，那么A必然先于C。 线程的start()方法先于它的每一个动作。 线程的所有操作先于线程的终结(thread.join())。 线程的中断(interrupt())先于被中断线程的代码。 对象的构造函数先于其finalize()。 Java内存模型中的变量位置方法的局部变量存放在栈上。对象存放在堆上： 属于方法的局部变量：标记变量的空间位于栈上其所属方法的栈帧中。 属于对象的非静态成员变量：标记变量的空间位于堆上其所属的对象中。 属于类的静态成员变量：标记变量的空间位于堆上其所属的类定义对象(即该类的Class对象。该对象的信息来源于方法区)中。 对于 属于方法的局部变量/属于对象的非静态成员变量/属于类的静态成员变量 ，均有： 若为基本数据类型，标记变量的空间中的值即为其本体。 若为非基本数据类型，标记变量的空间中的值为本体的引用，本体为堆上的对象。]]></content>
      <categories>
        <category>Java 并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 算法题-排序]]></title>
    <url>%2F2017%2F07%2F10%2FJava%20%E7%AE%97%E6%B3%95%E9%A2%98-%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[交换排序 冒泡排序123456789101112131415161718public class BubbleSort &#123; public static void bubbleSort(int[] a) &#123; if (null == a) throw new NullPointerException(&quot;a is null&quot;); for (int i = 0; i &lt; a.length - 1; i++) &#123; for (int j = 0; j &lt; a.length - 1 - i; j++) &#123; if (a[j] &gt; a[j + 1]) swap(a, j, j + 1); &#125; &#125; &#125; private static void swap(int[] a, int i, int j) &#123; int temp = a[i]; a[i] = a[j]; a[j] = temp; &#125;&#125; 第1层：确定每次冒泡的边界，索引依次为a.length - 1, a.length - 2, …, 1。不妨将这个边界设为r。一共需进行a.length - 1次。每一次大轮的排序都会确保边界位置填入正确的值。 第2层：在每个边界内部，通过不断的依序两两交换将索引[0,r]中的最大值沉底入索引r。 例如： 12索引： 0 1 2 3 4数值： 5 4 3 2 1 第1层，确定每次冒泡的边界，索引依次为4, 3, 2, 1。一共需进行4次。 第2层： 第1次结束：4, 3, 2, 1, 5。 第2次结束：3, 2, 1, 4, 5。 第3次结束：2, 1, 3, 4, 5。 第4次结束：1, 2, 3, 4, 5。 在代码中： i的取值范围为[0,a.length-2]。代表冒泡需要进行的次数，其作用仅仅是为了计数：共需进行a.length - 1次冒泡。 a.length - 1 - i的取值范围为[a.length - 1, 1]。代表每次冒泡时的边界r。 快速排序12345678910111213141516171819202122232425262728293031323334public class QuickSort &#123; public static void quickSort(int[] a) &#123; if (null == a) throw new NullPointerException(&quot;a is null&quot;); quickSort(a, 0, a.length - 1); &#125; private static void quickSort(int[] a, int low, int high) &#123; if (low &gt;= high) return; int keyIndex = partition(a, low, high); quickSort(a, low, keyIndex - 1); quickSort(a, keyIndex + 1, high); &#125; private static int partition(int[] a, int low, int high) &#123; // left的使命是扫描出比轴大的元素 // right的使命是扫描出比轴小的元素 int left = low, right = high; int keyValue = a[low]; while (left &lt; right) &#123; while (right &gt; left &amp;&amp; a[right] &gt;= keyValue) right--; while (left &lt; right &amp;&amp; a[left] &lt;= keyValue) left++; if (left &lt; right) &#123; int temp = a[left]; a[left] = a[right]; a[right] = temp; &#125; &#125; a[low] = a[left]; // 此时必有left == right a[left] = keyValue; // 轴元素放到了其该在的位置 return left; &#125;&#125; 在选定最左侧low为轴的前提下，若欲升序排列则应right指针先向左动，若欲降序排列则应left指针先向右动。其原因在于while结束后将进行哨兵(即left与right交汇的那个位置)与low的交换，若欲升序排列，则必须保证哨兵要不大于keyValue才行，而欲保证这一点，则只能在每次循环的内部，均先移动right，反之同理。 插入排序直接插入排序12345678910111213141516public class DirectInsertSort &#123; public static void directInsertSort(int[] a) &#123; if (null == a) throw new NullPointerException(&quot;a is null&quot;); for (int keyIndex = 1; keyIndex &lt; a.length; keyIndex++) &#123; int keyValue = a[keyIndex]; int preIndex = keyIndex - 1; while (preIndex &gt;= 0 &amp;&amp; a[preIndex] &gt; keyValue) &#123; a[preIndex + 1] = a[preIndex]; preIndex--; &#125; a[preIndex + 1] = keyValue; &#125; &#125;&#125; 希尔排序1234567891011121314151617181920212223public class ShellSort &#123; public static void shellSort(int[] a) &#123; if (null == a) throw new NullPointerException(&quot;a is null&quot;); int base = 3; // base &gt; 1 int gap = 1; // 必须保证最后一轮排序的步长=1 while (gap &lt; a.length / base) gap = base * gap + 1; while (gap &gt; 0) &#123; for (int keyIndex = gap; keyIndex &lt; a.length; keyIndex++) &#123; int keyValue = a[keyIndex]; int preIndex = keyIndex - gap; while (preIndex &gt;= 0 &amp;&amp; a[preIndex] &gt; keyValue) &#123; a[preIndex + gap] = a[preIndex]; preIndex -= gap; &#125; a[preIndex + gap] = keyValue; &#125; gap /= base; &#125; &#125;&#125; 选择排序简单选择排序1234567891011121314151617181920public class SimpleChooseSort &#123; public static void simpleChooseSort(int[] a) &#123; if (null == a) throw new NullPointerException(&quot;a is null&quot;); for (int i = 0; i &lt; a.length - 1; i++) &#123; int minIndex = i; for (int j = i + 1; j &lt; a.length; j++) &#123; if (a[j] &lt; a[minIndex]) minIndex = j; &#125; if (minIndex != i) swap(a, i, minIndex); &#125; &#125; private static void swap(int[] a, int i, int j) &#123; int temp = a[i]; a[i] = a[j]; a[j] = temp; &#125;&#125; 堆排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class HeapSort &#123; public static void heapSort(int[] a) &#123; if (null == a) throw new NullPointerException(&quot;a is null&quot;); for (int i = getPI(a.length - 1); i &gt;= 0; i--) createMaxHeap(a, a.length, i); for (int i = a.length - 1; i &gt; 0; i--) &#123; swap(a, 0, i); createMaxHeap(a, i, 0); &#125; &#125; /** * 创建大根堆 * @param a * @param mri 创建大根堆的元素范围：i &lt; mri * @param ri 需创建大根堆的根 */ private static void createMaxHeap(int[] a, int mri, int ri) &#123; int lci = getLCI(ri); int rci = getRCI(ri); int li = ri; if (lci &lt; mri &amp;&amp; a[lci] &gt; a[li]) li = lci; if (rci &lt; mri &amp;&amp; a[rci] &gt; a[li]) li = rci; if (li != ri) &#123; swap(a, ri, li); createMaxHeap(a, mri, li); &#125; &#125; private static void swap(int[] a, int i, int j) &#123; int temp = a[i]; a[i] = a[j]; a[j] = temp; &#125; private static int getPI(int i) &#123; return (i - 1) / 2; &#125; private static int getLCI(int i) &#123; return 2 * i + 1; &#125; private static int getRCI(int i) &#123; return 2 * i + 2; &#125;&#125; 归并排序12345678910111213141516171819202122public class MergeSort &#123; public static void mergeSort(int[] a) &#123; if (null == a) throw new NullPointerException(&quot;a is null&quot;); mergeSort(a, new int[a.length], 0, a.length - 1); &#125; private static void mergeSort(int[] a, int[] temp, int begin, int end) &#123; if (begin &gt;= end) return; int mid = begin + (end - begin) / 2; int b1 = begin, e1 = mid; int b2 = mid + 1, e2 = end; mergeSort(a, temp, b1, e1); // 保证左面一半有序 mergeSort(a, temp, b2, e2); // 保证右面一半有序 int i = begin; while (b1 &lt;= e1 &amp;&amp; b2 &lt;= e2) temp[i++] = a[b1] &lt;= a[b2] ? a[b1++] : a[b2++]; while (b1 &lt;= e1) temp[i++] = a[b1++]; while (b2 &lt;= e2) temp[i++] = a[b2++]; for (i = begin; i &lt;= end; i++) a[i] = temp[i]; &#125;&#125;]]></content>
      <categories>
        <category>Java 算法题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java JDK7源码-java.util.ArrayList&lt;E&gt;]]></title>
    <url>%2F2017%2F07%2F06%2FJava%20JDK7%E6%BA%90%E7%A0%81-javautilArrayListE%2F</url>
    <content type="text"><![CDATA[源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235package java.util;public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; private static final long serialVersionUID = 8683452581122892189L; /** * 底层数组默认的初始化容量 */ private static final int DEFAULT_CAPACITY = 10; /** * 供本类空实例使用的空数组 */ private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; /** * 用于存储arrayList中的元素的数组 * arrayList的容量即为本数组的长度 * * 使用 * new ArrayList&lt;&gt;()声明的arrayList其内部均有： * elementData == EMPTY_ELEMENTDATA * 在插入第一个元素时elementData会被扩展为DEFAULT_CAPACITY */ private transient Object[] elementData; /** * arrayList的长度 * 注意，本字段不是arrayList的容量，而是arrayList包含的元素个数 */ private int size; /** * 以initialCapacity为初始化容量构建一个空arrayList * * @throws IllegalArgumentException：initialCapacity &lt; 0。 */ public ArrayList(int initialCapacity) &#123; super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); this.elementData = new Object[initialCapacity]; &#125; /** * 以默认容量10构造一个空arrayList * 刚构造完成时数组依然是EMPTY_ELEMENTDATA，即空数组。 * 需要第一个元素插入进来后才会自动扩展为长度为10的数组 */ public ArrayList() &#123; super(); this.elementData = EMPTY_ELEMENTDATA; &#125; public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); size = elementData.length; // c.toArray()可能不返回Object[](见6260652) // 说明： // 因为c可以是任意的Collection实现 // 而Collection对toArray()的返回值仅仅是要求Object[] // 即实际的返回可以是任意Object的子类 if (elementData.getClass() != Object[].class) // 注1:Arrays.copyOf(r, i, newType) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; /** * 裁剪arrayList的容量为arrayList当前的实际长度 * 可以使用本方法达到arrayList的存储空间占用最小化 */ public void trimToSize() &#123; // 注2:modCount modCount++; if (size &lt; elementData.length) &#123; // 注3：Arrays.copyOf(r, i) elementData = Arrays.copyOf(elementData, size); &#125; &#125; /** * 公开出去的API方法 * 调用本方法时并不知道当前容量是否能满足minCapacity的需求 * 本方法会确保当前容量能满足minCapacity的需求(即如果不够用的话则需要扩容) */ public void ensureCapacity(int minCapacity) &#123; int minExpand = (elementData != EMPTY_ELEMENTDATA) ? 0 : DEFAULT_CAPACITY; if (minCapacity &gt; minExpand) &#123; ensureExplicitCapacity(minCapacity); &#125; &#125; /** * 供ArrayList类内部调用 * 调用本方法时并不知道当前容量是否能满足minCapacity的需求 * 本方法会确保当前容量能满足minCapacity的需求(即如果不够用的话则需要扩容) */ private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity); &#125; /** * 调用本方法时并不知道当前容量是否能满足minCapacity的需求 * 本方法会确保当前容量能满足minCapacity的需求(即如果不够用的话则需要扩容) */ private void ensureExplicitCapacity(int minCapacity) &#123; // 注2:modCount modCount++; // 内存溢出保护代码 if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; /** * 数组能申请的最大长度 * 某些JVM会在数组中存储一些头信息 * 试图申请过大长度的数组可能会导致OutOfMemoryError： * 所需数组长度超过JVM限制 */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; /** * 本方法被调用说明当前数组的容量确实是不够minCapacity的需求用了 * 扩充数组容量以满足其至少能容纳minCapacity个元素 */ private void grow(int minCapacity) &#123; int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // 注3：Arrays.copyOf(r, i) elementData = Arrays.copyOf(elementData, newCapacity); &#125; private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; /** * 重写父类:java.util.AbstractList&lt;E&gt; * 实现接口:java.util.List&lt;E&gt; * * 返回arrayList的元素个数 */ public int size() &#123; return size; &#125; /** * 重写父类:java.util.AbstractList&lt;E&gt; * 实现接口:java.util.List&lt;E&gt; * * 若arrayList不包含元素则返回true */ public boolean isEmpty() &#123; return size == 0; &#125; /** * 重写父类:java.util.AbstractList&lt;E&gt; * 实现接口:java.util.List&lt;E&gt; * * 若arrayList包含o则返回true * 更一般的来说，当且仅当arrayList至少包含一个满足如下条件的元素e时返回true： * (o==null ? e==null : o.equals(e)) */ public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0; &#125; /** * 重写父类:java.util.AbstractList&lt;E&gt; * 实现接口:java.util.List&lt;E&gt; * * 返回o在arrayList中第一次出现时的索引 * 若arrayList中不包含o则返回-1 * * 更一般的来说，返回满足如下条件的i的最小值： * (o==null ? get(i)==null : o.equals(get(i))) * 若无法找到满足条件的i则返回-1 */ public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; /** * 重写父类:java.util.AbstractList&lt;E&gt; * 实现接口:java.util.List&lt;E&gt; * * 返回o在arrayList中最后一次出现时的索引 * 若arrayList中不包含o则返回-1 * * 更一般的来说，返回满足如下条件的i的最大值： * (o==null ? get(i)==null : o.equals(get(i))) * 若无法找到满足条件的i则返回-1 */ public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; /** * 重写父类:java.util.AbstractList&lt;E&gt; * * 返回arrayList的一个浅拷贝(其所包含的元素本身并未被复制) */ public Object clone() &#123; try &#123; @SuppressWarnings(&quot;unchecked&quot;) ArrayList&lt;E&gt; v = (ArrayList&lt;E&gt;) super.clone(); // 注3：Arrays.copyOf(r, i) v.elementData = Arrays.copyOf(elementData, size); // # 注2:modCount v.modCount = 0; return v; &#125; catch (CloneNotSupportedException e) &#123; // 因ArrayList是可克隆的，因此该错误不会发生 throw new InternalError(); &#125; &#125; /** * 重写父类:java.util.AbstractList&lt;E&gt; * 实现接口:java.util.List&lt;E&gt; * * 本方法是连接数组与集合的桥梁 * 返回一个包含arrayList所有元素并有arrayList有相同顺序的数组 * * 返回的数组是&quot;安全的&quot; * 其与arrayList之间不存在引用关系(换句话说，本方法必须声明一个新的数组) * 因此调用者可以自由的修改返回的数组 */ public Object[] toArray() &#123; // 注3：Arrays.copyOf(r, i) return Arrays.copyOf(elementData, size); &#125; /** * 重写父类:java.util.AbstractList&lt;E&gt; * 实现接口:java.util.List&lt;E&gt; * * 查询操作。 * 本方法是连接集合与数组之间的桥梁。 * * 返回包含列表所有元素的数组。该数组的顺序与列表的固有顺序相同。返回数组的类型即为a的类型。 * 具体规则的伪代码为： * if (a.length &lt; list.size()) * 不修改a，而是以a的类型新建长度为list.size()的数组并填入列表中的值，随后返回这个新生成的数组。 * else if (a.length == list.size() * 将返回的结果直接填入a后返回a(若a中已有值，则a中的原值会被覆盖)。 * else * 数组索引在[0, list.size() -1]的元素会被列表对应位置的元素覆盖。 * 数组索引 == list.size()的元素会被置为null * 数组中后续元素(如果有的话)不变。 * * 若列表不允许包含空元素，则本方法此时可用来计算列表的长度：返回的数组第一次出现null的索引即为列表的长度。 * * 返回的数组与列表之间不存在引用关系(即使列表的底层就是基于数组实现的)，数组中的元素是列表中元素的浅拷贝。 * * 小例子： * String[] y = x.toArray(new String[0]); * x是一个元素类型为String的列表，则上述语句会将x中的元素依序复制一份浅拷贝到数组y。 * * 关于本方法与前文介绍的toArray()方法，需明确： * list.toArray() * list.toArray(new Object[s]) * 当s &lt; list.size()时，上述两行代码的效果等价。 * * 本方法与前文介绍的toArray()方法很相似，可对比学习。 * * @throws ArrayStoreException a的类型列表不支持。 * @throws NullPointerException null==a。 */ @SuppressWarnings(&quot;unchecked&quot;) public &lt;T&gt; T[] toArray(T[] a) &#123; if (a.length &lt; size) // # 注1:Arrays.copyOf(r, i, newType) return (T[]) Arrays.copyOf(elementData, size, a.getClass()); // # 注4:System.arraycopy(r, 0, a, 0, i) System.arraycopy(elementData, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a; &#125; /** * 位置访问操作 */ @SuppressWarnings(&quot;unchecked&quot;) E elementData(int index) &#123; return (E) elementData[index]; &#125; /** * 重写父类:java.util.AbstractList&lt;E&gt; * 实现接口:java.util.List&lt;E&gt; * * 位置访问操作 * 返回arrayList中索引位置为index的元素 * * @throws IndexOutOfBoundsException 索引越界(index &lt; 0 || index &gt;= size) */ public E get(int index) &#123; rangeCheck(index); return elementData(index); &#125; /** * 重写父类:java.util.AbstractList&lt;E&gt; * 实现接口:java.util.List&lt;E&gt; * * 以element替换arrayList中索引为index的元素。方法返回被替换的元素 * * @throws IndexOutOfBoundsException 索引越界(index &lt; 0 || index &gt;= size) */ public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue; &#125; /** * 重写父类:java.util.AbstractList&lt;E&gt; * 实现接口:java.util.List&lt;E&gt; * * 将e添加至arrayList末尾 */ public boolean add(E e) &#123; // 该方法内部会增加modCount ensureCapacityInternal(size + 1); elementData[size++] = e; return true; &#125; /** * 重写父类:java.util.AbstractList&lt;E&gt; * 实现接口:java.util.List&lt;E&gt; * * 将element插入arrayList的index下标处 * 原来处于index下标及以后的元素均向后移动一个位置 * * @throws IndexOutOfBoundsException 索引越界(index &lt; 0 || index &gt; size) */ public void add(int index, E element) &#123; rangeCheckForAdd(index); // 该方法内部会增加modCount ensureCapacityInternal(size + 1); // # 注4:System.arraycopy(r, 0, a, 0, i) System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125; /** * 重写父类:java.util.AbstractList&lt;E&gt; * 实现接口:java.util.List&lt;E&gt; * * 移除arrayList中索引值为index的元素 * 后续元素左移一个位置 * 返回被移除的元素 * * @throws IndexOutOfBoundsException 索引越界(index &lt; 0 || index &gt;= size) */ public E remove(int index) &#123; rangeCheck(index); // # 注2:modCount modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) // # 注4:System.arraycopy(r, 0, a, 0, i) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // 便于GC回收 return oldValue; &#125; /** * 重写父类:java.util.AbstractList&lt;E&gt; * 实现接口:java.util.List&lt;E&gt; * * 移除o在arrayList中第一次出现的位置的元素 * 如果arrayList中不包含o则arrayList将不会被本方法改变 * * 更一般的来说，移除如下元素： * o==null ? get(i)==null : o.equals(get(i)) * 其中为i满足相等条件的最小索引值 * * 若本方法改变了arrayList则返回true，反之返回false */ public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; private void fastRemove(int index) &#123; // # 注2:modCount modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) // # 注4:System.arraycopy(r, 0, a, 0, i) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // 便于GC回收 &#125; /** * 重写父类:java.util.AbstractList&lt;E&gt; * 实现接口:java.util.List&lt;E&gt; * * 移除arrayList中的所有元素 * 调用本方法后arrayList将变为空arrayList */ public void clear() &#123; // # 注2:modCount modCount++; // 之所以不直接将elementData置为空 // 是为了保持容积不变，同时便于GC回收 for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0; &#125; /** * 重写父类:java.util.AbstractList&lt;E&gt; * 实现接口:java.util.List&lt;E&gt; * * 将c中所有元素插入arrayList的末尾，插入顺序为c的迭代器取出的顺序 * * 本方法并未定义如下事件发生时的解决策略： * 在将c中的元素添加至arrayList的过程中c发生变化 * 这也意味着如下事件的解决策略同样未定义： * 将一个非空arrayList添加至自身 * * 若arrayList因本方法发生变化则返回true，反之返回false * * @throws NullPointerException c==null */ public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // 增加modCount // # 注4:System.arraycopy(r, 0, a, 0, i) System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; &#125; /** * 重写父类:java.util.AbstractList&lt;E&gt; * 实现接口:java.util.List&lt;E&gt; * * 将c中所有元素插入arrayList的指定位置(index) * 插入顺序为c的迭代器取出的顺序 * 原index位置及以后位置的元素顺次向后移动，空出装载c的位置 * * 若arrayList因本方法发生变化则返回true，反之返回false * * @throws IndexOutOfBoundsException 索引越界(index &lt; 0 || index &gt; size) * @throws NullPointerException c==null */ public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // 增加modCount int numMoved = size - index; if (numMoved &gt; 0) // # 注4:System.arraycopy(r, 0, a, 0, i) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0; &#125; /** * 重写父类:java.util.AbstractList&lt;E&gt; * * 从arrayList中移除索引为[fromIndex,toIndex)的元素 * 并将后续元素左移 * 本方法减少了arrayList (toIndex - fromIndex)个元素 * 若toIndex==fromIndex，本方法不产生实际效果 * * @throws IndexOutOfBoundsException 索引越界(fromIndex &lt; 0 || fromIndex &gt;= size() || toIndex &gt; size() || toIndex &lt; fromIndex) */ protected void removeRange(int fromIndex, int toIndex) &#123; modCount++; int numMoved = size - toIndex; // # 注4:System.arraycopy(r, 0, a, 0, i) System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); int newSize = size - (toIndex-fromIndex); // 便于GC回收 for (int i = newSize; i &lt; size; i++) &#123; elementData[i] = null; &#125; size = newSize; &#125; /** * 检查index是否在边界之内 * 若不在，则抛出一个适当的运行时异常 * * 本方法不会检查index&lt;0的情况： * 因为访问数组时索引&gt;=0是前提条件 * 若index&lt;0，则数组会自行抛出ArrayIndexOutOfBoundsException */ private void rangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; /** * add及addAll方法所使用的边界检查方法 */ private void rangeCheckForAdd(int index) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; /** * 构建一个IndexOutOfBoundsException的详细信息 * 在众多可能的错误处理代码中 * 这种&quot;溢出&quot;的处理代码在server及client JVM中均有最佳的性能 */ private String outOfBoundsMsg(int index) &#123; return &quot;Index: &quot;+index+&quot;, Size: &quot;+size; &#125; /** * 重写父类:java.util.AbstractList&lt;E&gt; * 实现接口:java.util.List&lt;E&gt; * * 从arrayList中移除所有与c的交集元素(求差集) * 若arrayList因本方法发生变化则返回true，反之返回false * * @throws ClassCastException arrayList中至少有一个元素的类型与c不相容 * @throws NullPointerException arrayList中至少有一个元素为null且c不允许null存在；或c==null */ public boolean removeAll(Collection&lt;?&gt; c) &#123; // # 注5:batchRemove(c, b) return batchRemove(c, false); &#125; /** * 重写父类:java.util.AbstractList&lt;E&gt; * 实现接口:java.util.List&lt;E&gt; * * 保留arrayList与c的交集元素 * 若arrayList因本方法发生变化则返回true，反之返回false * * @throws ClassCastException arrayList中至少有一个元素的类型与c不相容 * @throws NullPointerException arrayList中至少有一个元素为null且c不允许null存在；或c==null */ public boolean retainAll(Collection&lt;?&gt; c) &#123; // # 注5:batchRemove(c, b) return batchRemove(c, true); &#125; private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123; final Object[] elementData = this.elementData; int r = 0, w = 0; boolean modified = false; try &#123; for (; r &lt; size; r++) if (c.contains(elementData[r]) == complement) // complement == true：移除arrayList中与c不同的元素，retainAll调用。 // complement == false：移除arrayList中与c相同的元素，removeAll调用。 elementData[w++] = elementData[r]; &#125; finally &#123; // 在c.contains()抛出异常时兼容AbstractCollection的保护性行为 if (r != size) &#123; // 进入此if说明try中的for循环未完成，即c.contains()在循环过程中抛出了异常 // 此时从抛出异常的索引值r起的后续元素均不应再参与remove行为了，即索引在[r,size-1]之间的元素原样保留。 // # 注4:System.arraycopy(r, 0, a, 0, i) System.arraycopy(elementData, r, elementData, w, size - r); w += size - r; &#125; if (w != size) &#123; // 进入此if说明确实成功移除了元素。 // 则应标明已移除并修改size等属性。 for (int i = w; i &lt; size; i++) elementData[i] = null; modCount += size - w; size = w; modified = true; &#125; &#125; return modified; &#125; /** * 将arrayList的状态保存至流中(序列化时使用) * * 流中存储的信息为： * 1. arrayList本身的信息。 * 2. arrayList的长度。 * 3. arrayList中的元素按序排列。 * * @throws java.io.IOException */ private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; // # 注2:modCount int expectedModCount = modCount; s.defaultWriteObject(); // arrayList本身的信息 s.writeInt(size); // 长度 for (int i=0; i&lt;size; i++) &#123; // arrayList中的元素 s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; &#125; /** * 反序列化时从流中恢复arrayList * * @throws java.io.IOException * @throws ClassNotFoundException */ private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; elementData = EMPTY_ELEMENTDATA; s.defaultReadObject(); // arrayList本身的信息 s.readInt(); // 长度 if (size &gt; 0) &#123; // 类似于clone()，声明所需大小的数组 ensureCapacityInternal(size); Object[] a = elementData; for (int i=0; i&lt;size; i++) &#123; // 依次读入流中所有元素 a[i] = s.readObject(); &#125; &#125; &#125; /** * 重写父类:java.util.AbstractList&lt;E&gt; * 实现接口:java.util.List&lt;E&gt; * * 返回一个arrayList按固有顺序迭代的listIterator * 迭代开始时游标位于索引[index-1,index]之间 * * 即使用本方法得到listIterator后 * 若第一次调用的是listIterator.next()，返回的元素的索引是index； * 同理，若第一次调用的是listIterator.previous()，返回的是索引为index-1的元素 * * 返回的listIterator遵循fail-fast原则 * * @throws IndexOutOfBoundsException 索引越界(index &lt; 0 || index &gt; size) */ public ListIterator&lt;E&gt; listIterator(int index) &#123; if (index &lt; 0 || index &gt; size) throw new IndexOutOfBoundsException(&quot;Index: &quot;+index); return new ListItr(index); &#125; /** * 重写父类:java.util.AbstractList&lt;E&gt; * 实现接口:java.util.List&lt;E&gt; * * 返回一个arrayList按固有顺序迭代的listIterator * 返回的listIterator遵循fail-fast原则 */ public ListIterator&lt;E&gt; listIterator() &#123; return new ListItr(0); &#125; /** * 重写父类:java.util.AbstractList&lt;E&gt; * 实现接口:java.util.List&lt;E&gt; * * 返回一个arrayList按固有顺序迭代的iterator * 返回的iterator遵循fail-fast原则 */ public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; /** * Iterator在ArrayList的最优实现 */ private class Itr implements Iterator&lt;E&gt; &#123; /** * 游标位于元素[cursor-1,cursor]之间 */ int cursor; /** * 上一次操作的元素的索引 * 即调用next()或previous()后赋以对应的值 * 初始时或调用remove()或add(E e)后置为-1 */ int lastRet = -1; /** * iterator认为的arrayList发生的结构性变化的次数 * 初始时同步自其所属的arrayList */ int expectedModCount = modCount; /** * 实现接口:java.util.Iterator&lt;E&gt; */ public boolean hasNext() &#123; return cursor != size; &#125; /** * 实现接口:java.util.Iterator&lt;E&gt; */ @SuppressWarnings(&quot;unchecked&quot;) public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; /** * 实现接口:java.util.Iterator&lt;E&gt; */ public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; /** * ListIterator在arrayList的最优实现 */ private class ListItr extends Itr implements ListIterator&lt;E&gt; &#123; ListItr(int index) &#123; super(); cursor = index; &#125; /** * 实现接口:java.util.ListIterator&lt;E&gt; */ public boolean hasPrevious() &#123; return cursor != 0; &#125; /** * 实现接口:java.util.ListIterator&lt;E&gt; */ public int nextIndex() &#123; return cursor; &#125; /** * 实现接口:java.util.ListIterator&lt;E&gt; */ public int previousIndex() &#123; return cursor - 1; &#125; /** * 实现接口:java.util.ListIterator&lt;E&gt; */ @SuppressWarnings(&quot;unchecked&quot;) public E previous() &#123; checkForComodification(); int i = cursor - 1; if (i &lt; 0) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i; return (E) elementData[lastRet = i]; &#125; /** * 实现接口:java.util.ListIterator&lt;E&gt; */ public void set(E e) &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.set(lastRet, e); &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; /** * 实现接口:java.util.ListIterator&lt;E&gt; */ public void add(E e) &#123; checkForComodification(); try &#123; int i = cursor; ArrayList.this.add(i, e); cursor = i + 1; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; &#125; /** * 重写父类:java.util.AbstractList&lt;E&gt; * 实现接口:java.util.List&lt;E&gt; * * 返回arrayList的一部分，索引值区间： * [fromIndex,toIndex) * 特别的，若fromIndex==toIndex，则返回空arrayList(不是null) * * 返回的arrayList是原arrayList的一个视图 * 前者是后者的一部分，并未从后者中分离出去 * 因此作用在前者之上的修改会反映在后者上，反之亦然 * * 使用本方法的好处在于 * 当我们操作arrayList的一部分时 * 可以直接在这一部分内部操作(仿佛这就是一个新的arrayList) * 而无需被各种索引的边界分散过多的注意 * * 例如，如果想批量移除arrayList中的一部分，可按如下操作: * arrayList.subList(from, to).clear(); * * 同理，所有本类的方法及所有 * java.util.Collections类 * 提供的静态方法均支持subList取得的视图作为一个独立的arrayList调用 * 例如: * arrayList2 = arrayList.subList(1, 2); * arrayList2.get(0); * 此时取得的元素即为arrayList.get(1) * * 若在生成视图后原arrayList发生了结构性的变化(例如长度发生了变化) * 则已生成的视图将被重置为未定义的状态 * * @throws IndexOutOfBoundsException 索引越界(fromIndex &lt; 0 || toIndex &gt; size) * @throws IllegalArgumentException fromIndex &gt; toIndex */ public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; subListRangeCheck(fromIndex, toIndex, size); return new SubList(this, 0, fromIndex, toIndex); &#125; static void subListRangeCheck(int fromIndex, int toIndex, int size) &#123; if (fromIndex &lt; 0) throw new IndexOutOfBoundsException(&quot;fromIndex = &quot; + fromIndex); if (toIndex &gt; size) throw new IndexOutOfBoundsException(&quot;toIndex = &quot; + toIndex); if (fromIndex &gt; toIndex) throw new IllegalArgumentException(&quot;fromIndex(&quot; + fromIndex + &quot;) &gt; toIndex(&quot; + toIndex + &quot;)&quot;); &#125; private class SubList extends AbstractList&lt;E&gt; implements RandomAccess &#123; /** * 本视图的父亲list * 注意: * parent代表的是近亲父亲，也就是说依然可能是个视图，而非始祖 * * 例如始祖list生成了视图sublist1 * sublist1生成了视图sublist2 * sublist1的parent为list * sublist2的parent为sublist1 */ private final AbstractList&lt;E&gt; parent; /** * 本视图相对于父亲list的位移量 * * 例如有始祖list * list使用subList(f, t)得到了subList1 * 则subList1的parent为list，parentOffset=f */ private final int parentOffset; /** * 本视图相对于始祖的位移量 */ private final int offset; /** * 本视图长度 */ int size; /** * @param parent AbstractList&lt;E&gt;, 父亲list * @param offset int, 父亲list相对于始祖的位移 * @param fromIndex int, 本视图相对于父亲list的位移 * @param toIndex int, 本视图相对于父亲list的位移结束量。实际本视图包含的元素为父亲list中的[fromIndex,toIndex) */ SubList(AbstractList&lt;E&gt; parent, int offset, int fromIndex, int toIndex) &#123; this.parent = parent; this.parentOffset = fromIndex; this.offset = offset + fromIndex; this.size = toIndex - fromIndex; this.modCount = ArrayList.this.modCount; &#125; /** * 重写父类:java.util.AbstractList&lt;E&gt; */ public E set(int index, E e) &#123; rangeCheck(index); checkForComodification(); E oldValue = ArrayList.this.elementData(offset + index); ArrayList.this.elementData[offset + index] = e; return oldValue; &#125; /** * 重写父类:java.util.AbstractList&lt;E&gt; */ public E get(int index) &#123; rangeCheck(index); checkForComodification(); return ArrayList.this.elementData(offset + index); &#125; public int size() &#123; checkForComodification(); return this.size; &#125; /** * 重写父类:java.util.AbstractList&lt;E&gt; * * 本方法之所以使用了parent的add方法而非始祖的add方法 * 是因为本方法使始祖list发生了结构性变化 * 这种变化必须通知到本视图的所有前辈 */ public void add(int index, E e) &#123; rangeCheckForAdd(index); checkForComodification(); parent.add(parentOffset + index, e); this.modCount = parent.modCount; this.size++; &#125; /** * 重写父类:java.util.AbstractList&lt;E&gt; * * 本方法之所以使用了parent的remove方法而非始祖的remove方法 * 是因为本方法使始祖list发生了结构性变化 * 这种变化必须通知到本视图的所有前辈 */ public E remove(int index) &#123; rangeCheck(index); checkForComodification(); E result = parent.remove(parentOffset + index); this.modCount = parent.modCount; this.size--; return result; &#125; /** * 重写父类:java.util.AbstractList&lt;E&gt; * * 本方法之所以使用了parent的removeRange方法而非始祖的removeRange方法 * 是因为本方法使始祖list发生了结构性变化 * 这种变化必须通知到本视图的所有前辈 */ protected void removeRange(int fromIndex, int toIndex) &#123; checkForComodification(); parent.removeRange(parentOffset + fromIndex, parentOffset + toIndex); this.modCount = parent.modCount; this.size -= toIndex - fromIndex; &#125; /** * 重写父类:java.util.AbstractList&lt;E&gt; */ public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(this.size, c); &#125; /** * 重写父类:java.util.AbstractList&lt;E&gt; * * 本方法之所以使用了parent的addAll方法而非始祖的addAll方法 * 是因为本方法使始祖list发生了结构性变化 * 这种变化必须通知到本视图的所有前辈 */ public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); int cSize = c.size(); if (cSize==0) return false; checkForComodification(); parent.addAll(parentOffset + index, c); this.modCount = parent.modCount; this.size += cSize; return true; &#125; /** * 重写父类:java.util.AbstractList&lt;E&gt; */ public Iterator&lt;E&gt; iterator() &#123; // 本类并未重写listIterator()方法 // 因此这里调用的是父类AbstractList的listIterator()方法 // 父类AbstractList的listIterator()方法实际调用的是listIterator(0) // 而本类重写了listIterator(i) // 故最终实际调用的是本类的listIterator(i) return listIterator(); &#125; /** * 重写父类:java.util.AbstractList&lt;E&gt; * * 入参index是相对本视图内部的索引值 */ public ListIterator&lt;E&gt; listIterator(final int index) &#123; checkForComodification(); rangeCheckForAdd(index); final int offset = this.offset; return new ListIterator&lt;E&gt;() &#123; int cursor = index; int lastRet = -1; int expectedModCount = ArrayList.this.modCount; public boolean hasNext() &#123; return cursor != SubList.this.size; &#125; @SuppressWarnings(&quot;unchecked&quot;) public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= SubList.this.size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (offset + i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[offset + (lastRet = i)]; &#125; public boolean hasPrevious() &#123; return cursor != 0; &#125; @SuppressWarnings(&quot;unchecked&quot;) public E previous() &#123; checkForComodification(); int i = cursor - 1; if (i &lt; 0) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (offset + i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i; return (E) elementData[offset + (lastRet = i)]; &#125; public int nextIndex() &#123; return cursor; &#125; public int previousIndex() &#123; return cursor - 1; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; SubList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = ArrayList.this.modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; public void set(E e) &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.set(offset + lastRet, e); &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; public void add(E e) &#123; checkForComodification(); try &#123; int i = cursor; SubList.this.add(i, e); cursor = i + 1; lastRet = -1; expectedModCount = ArrayList.this.modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; final void checkForComodification() &#123; if (expectedModCount != ArrayList.this.modCount) throw new ConcurrentModificationException(); &#125; &#125;; &#125; /** * 重写父类:java.util.AbstractList&lt;E&gt; */ public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; subListRangeCheck(fromIndex, toIndex, size); return new SubList(this, offset, fromIndex, toIndex); &#125; private void rangeCheck(int index) &#123; if (index &lt; 0 || index &gt;= this.size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; private void rangeCheckForAdd(int index) &#123; if (index &lt; 0 || index &gt; this.size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; private String outOfBoundsMsg(int index) &#123; return &quot;Index: &quot;+index+&quot;, Size: &quot;+this.size; &#125; private void checkForComodification() &#123; if (ArrayList.this.modCount != this.modCount) throw new ConcurrentModificationException(); &#125; &#125;&#125; 已整理层级关系本类直接继承的类 java.util.AbstractList&lt;E&gt; 本类直接实现的接口 java.util.List&lt;E&gt; java.util.RandomAccess java.lang.Cloneable java.io.Serializable 综述本类是Java集合框架中的一员，底层基于数组实现了List接口。 本类实现了List接口所有可选的操作，允许包含null在内的所有元素。除了实现List接口外，本类还提供调整本类内部用于存储arrayList的数组的长度的方法。 除了Vector不具备序列化能力及本类不具备线程安全的能力外，粗略的讲，可以认为本类与Vector等价。 size()，isEmpty()，get(int index)，set(int index, E element)，iterator()，listIterator()时间复杂度为O(1)。add(E e)的时间复杂度为常数恒定分摊时间(添加一个元素为O(1)，若需扩容则需大于O(1)的时间)，即：添加n个元素需要O(n)的时间。所有其他的操作花费线性阶的时间(粗略的讲)。总体来说，时间复杂度较之LinkedList要低。 capacity 每一个本类的实例都有一个容量，容量是指被用于存储arrayList中的元素的数组的长度。它的长度总是至少等于arrayList的长度。随着元素被插入arrayList，该数组的长度会自动增长。只要满足添加一个元素的时间复杂度为常数恒定分摊时间即可，对于扩容策略的细节并未有强制规定。 使用时，可以在向list中添加大量元素前使用ensureCapacity(int minCapacity)对arrayList进行扩容。这样可以减少重新分配增量空间的次数。 synchronized 注意，本实现是线程不安全的。如果复数个线程同时访问一个arrayList实例，并且至少一个线程对arrayList做出了结构性修改(结构性操作是指任何添加或删除一个或一个以上元素的操作，或者更确切的说，改变了内部数组的大小。仅仅只是设置一个元素的值不是结构性变化)，则必须要在调用外部保证线程安全。通常来说，这种线程安全性需要容器本身来确保(例如Vector)，不过，如果实在是需要在并发环境下使用线程不安全的list，例如本类，则可用 1Collections.synchronizedList(List&lt;T&gt; list) 封装。即： 1List list = Collections.synchronizedList(new ArrayList(...)); 该操作最好在声明arrayList时即进行，以避免意外情况下会有线程不安全的访问请求arrayList。 fail-fast 本类iterator()及listIterator()返回的迭代器采用快速失败模式：在迭代器创建后，若arrayList在任何时候以任何方式发生了结构性变化，除非原因是因为迭代器本身触发(具体来说：ListIterator.remove()及ListIterator.add(E e))，否则迭代器会抛出ConcurrentModificationException。因此，在面对并发性修改时，迭代器会简单明了的失败，而非依据实际的改变情况，在未来采取不确定的行为。 事实上，fail-fast模式并不能完全根除线程不安全的并发修改。它只是尽力而为：若实在力有不逮则迭代器会抛出ConcurrentModificationException。因此在程序中完全依靠fail-fast避免线程安全问题是错误的：fail-fast模式应该只被用于检测bug。 注1:Arrays.copyOf(r, i, newType)1Arrays.copyOf(U[] r, int i, Class&lt;? extends T[]&gt; newType) 以r为基础返回一个长度为i的数组，返回数组的类型为newType。 若i&lt;r.length则r发生截断。实际返回的数组为r中索引为[0,i-1]的元素。 若i==r.length，则返回的数组与r相等。 若i&gt;r.length，返回的数组中索引为[0, r.length-1]的元素为r中对应位置的元素，索引为[r.length, i-1]的元素以null填充。 无论如何，返回的数组都是新生成的，与r不存在引用关系。返回的数组中的元素是r中元素的浅拷贝。 注2:modCountmodCount字段继承自超类AbstractList： list发生结构性变化的次数。结构性变化是指改变list的长度，或是其他会使迭代器结果混乱的变化。 本字段将被iterator()返回的iterator及listIterator()返回的listIterator使用。若本字段发生了 iterator/listIterator 所没有预期到的变化，则在调用 iterator/listIterator 的next()，remove()，previous()，set(E e)，add(E e)出现fail-fast时抛出ConcurrentModificationException。 在迭代过程中，若检测到并发性变化，则直接判定为失败并抛出异常(fail-fast)，而不会去进一步检测所发生的并发性变化是否真的会对迭代造成影响(non-deterministic)。 子类可自行选择是否使用本字段。若子类决定继承本类的fail-fast判定，则只需要在会引发结构性变化的方法中增加本字段的值。本类中已实现的引发结构性变化的方法有add(int index, E element)及remove(int index)。调用一次add(int index, E element)或remove(int index)只需将本字段自增1，表示发生了一次结构性变化，否则 iterator/listIterator 会抛出错误的ConcurrentModificationException。 若子类不想遵循fail-fast，忽略本字段即可。 注3:Arrays.copyOf(r, i)以r为基础返回一个长度为i的数组。 若i&lt;r.length则r发生截断。实际返回的数组为r中索引为[0,i-1]的元素。 若i==r.length，则返回的数组与r相等。 若i&gt;r.length，返回的数组中索引为[0, r.length-1]的元素为r中对应位置的元素，索引为[r.length, i-1]的元素以null填充。 无论如何，返回的数组都是新生成的，与r不存在引用关系。返回的数组中的元素是r中元素的浅拷贝。 注4:System.arraycopy(r, 0, a, 0, i)参数含义依次为： r: 待复制的源数组。 0: 源数组中开始复制的索引。 a: 复制目标数组。 0: 目标数组中接收元素的起始索引。 i: 复制的元素个数。 目标数组中其他位置的元素不受影响。 注5:batchRemove(c, b)第二个参数的类型为boolean，其含义为： true：移除arrayList中与c不同的元素。 false：移除arrayList中与c相同的元素。]]></content>
      <categories>
        <category>Java JDK7源码</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
        <tag>Collection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java JDK7源码-java.io.Serializable]]></title>
    <url>%2F2017%2F07%2F04%2FJava%20JDK7%E6%BA%90%E7%A0%81-javaioSerializable%2F</url>
    <content type="text"><![CDATA[源码 1234package java.io;public interface Serializable &#123;&#125; 已整理层级关系直接实现本接口的类 java.util.ArrayList&lt;E&gt; 综述实现本接口的类具备可序列化的能力。未实现本接口的类则不能进行序列化及反序列化。所有可序列化的类的子类都自动具备序列化的能力而无需在类定义中声明。本接口中没有任何方法或字段，它只是一个标志，标识实现本接口的类具备可序列化的能力。 为使非序列化的类具备序列化的能力，通常的做法为声明一个具备序列化能力的子类，子类必须承担起保存及恢复子类的public，protected，以及(如果可访问的话)封装字段的状态的责任。子类只在如下条件下才能承担起该责任：该子类的超类中有一个可访问的无参构造函数用以帮助子类初始化自身的状态，若不满足该条件则可通过编译，但在运行时会抛出异常。 在反序列化的过程中，非序列化类的字段将被该类的public或protected的无参构造函数初始化。该无参构造函数必须要能够被已实现序列化的子类访问。已实现序列化的子类的字段将从流中恢复。 在传输图结构时，可能会遇到不支持本接口的情况。此时会抛出NotSerializableException并定位到未序列化的类。 writeObject,readObject,readObjectNoData在序列化及反序列化时需要进行特殊操作的类必须实现如下特定的方法： 123456private void writeObject(java.io.ObjectOutputStream out) throws IOExceptionprivate void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException;private void readObjectNoData() throws ObjectStreamException; writeObject负责写特定的类的对象的状态以便于对应的readObject可以恢复它。默认情况下是通过调用out.defaultWriteObject()保存对象的状态。本方法不需要关心其所属超类或子类的状态。状态会以独立字段的形式被本方法或out.defaultWriteObject()存入ObjectOutputStream。默认写入的内容为调用对象的toString()的返回值。测试如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;public class STest &#123; private static final String PATH_F = &quot;D://data.f&quot;; private static void writeByFOS(Data data, String path) throws Exception &#123; ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(path)); objectOutputStream.writeObject(data); objectOutputStream.close(); &#125; private static Data readByFIS(String path) throws Exception &#123; ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(path)); Data result = (Data)objectInputStream.readObject(); objectInputStream.close(); return result; &#125; public static void main(String args[]) throws Exception &#123; STest.writeByFOS(new Data(0, &quot;灵梦&quot;), STest.PATH_F); System.out.println(STest.readByFIS(STest.PATH_F)); &#125;&#125;class Data implements Serializable &#123; private static final long serialVersionUID = 615562960517507579L; private int id; private String value; public Data(int id, String value) &#123; this.id = id; this.value = value; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getValue() &#123; return value; &#125; public void setValue(String value) &#123; this.value = value; &#125; @Override public String toString() &#123; return &quot;Data [id=&quot; + (id + 1) + &quot;, value=&quot; + value + value + &quot;]&quot;; &#125;&#125; 输出结果： 1Data [id=1, value=灵梦灵梦] readObject方法负责从流中读取数据并恢复类字段。本方法可以调用in.defaultReadObject()以采用默认的机制恢复对象的non-static及non-transient字段。defaultReadObject()将流中存储的对象的字段存入当前对象的对应位置。本方法处理类需要加字段的情况。本方法不需要关心其所属超类或子类的状态。状态会以独立字段的形式被writeObject方法或out.defaultWriteObject()存入ObjectOutputStream。 writeObject及readObject示例如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;public class STest &#123; private static final String PATH_F = &quot;D://data.f&quot;; private static void writeByFOS(Data data, String path) throws Exception &#123; ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(path)); objectOutputStream.writeObject(data); objectOutputStream.close(); &#125; private static Data readByFIS(String path) throws Exception &#123; ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(path)); Data result = (Data)objectInputStream.readObject(); objectInputStream.close(); return result; &#125; public static void main(String args[]) throws Exception &#123; STest.writeByFOS(new Data(0, &quot;灵梦&quot;), STest.PATH_F); System.out.println(STest.readByFIS(STest.PATH_F)); &#125;&#125;class Data implements Serializable &#123; private static final long serialVersionUID = 615562960517507579L; private int id; private String value; public Data(int id, String value) &#123; this.id = id; this.value = value; &#125; private void writeObject(ObjectOutputStream out) throws IOException &#123; out.defaultWriteObject(); &#125; private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException &#123; in.defaultReadObject(); &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getValue() &#123; return value; &#125; public void setValue(String value) &#123; this.value = value; &#125; @Override public String toString() &#123; return &quot;Data [id=&quot; + id + &quot;, value=&quot; + value + &quot;]&quot;; &#125;&#125; 此时内部均仍采用默认机制。结果如下： 1Data [id=0, value=灵梦] 若将writeObject方法体置为空，则抛出异常： 12345678910111213141516Exception in thread &quot;main&quot; java.io.EOFException at java.io.ObjectInputStream$BlockDataInputStream.readFully(ObjectInputStream.java:2744) at java.io.ObjectInputStream.defaultReadFields(ObjectInputStream.java:1979) at java.io.ObjectInputStream.defaultReadObject(ObjectInputStream.java:500) at stest.Data.readObject(STest.java:51) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:606) at java.io.ObjectStreamClass.invokeReadObject(ObjectStreamClass.java:1017) at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:1893) at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1798) at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1350) at java.io.ObjectInputStream.readObject(ObjectInputStream.java:370) at stest.STest.readByFIS(STest.java:22) at stest.STest.main(STest.java:29) 若将readObject置为空，则抛出异常： 1234567891011Exception in thread &quot;main&quot; java.io.StreamCorruptedException: invalid type code: 00 at java.io.ObjectInputStream$BlockDataInputStream.readBlockHeader(ObjectInputStream.java:2508) at java.io.ObjectInputStream$BlockDataInputStream.refill(ObjectInputStream.java:2543) at java.io.ObjectInputStream$BlockDataInputStream.skipBlockData(ObjectInputStream.java:2445) at java.io.ObjectInputStream.skipCustomData(ObjectInputStream.java:1941) at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:1918) at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1798) at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1350) at java.io.ObjectInputStream.readObject(ObjectInputStream.java:370) at stest.STest.readByFIS(STest.java:22) at stest.STest.main(STest.java:29) Serializable对象反序列化时，由于序列化与反序列化提供的class版本不同，序列化的class的super class不同于反序列化时的class的super class；或待接收的流受到了干扰；或者收到有敌意的流；或接收不完整；都会对初始化对象字段值时造成影响。如果发生以上情况时，没有定义readObjectNoData方法时，类的字段就会初始化成它们的默认值。当出现上面的情况时，readObjectNoData会取代readObject的调用。 writeReplace,readResolve当实现序列化的类需指定一个替代类时，在写入流时需实现以下方法： 1ANY-ACCESS-MODIFIER Object writeReplace() throws ObjectStreamException; 若序列化的类未实现writeReplace方法则会调用writeObject方法写入流。若序列化的类实现了writeReplace方法则会用writeReplace方法替代writeObject方法写入流，测试用例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.ObjectStreamException;import java.io.Serializable;public class STest &#123; private static final String PATH_F = &quot;D://data.f&quot;; private static void writeByFOS(Data data, String path) throws Exception &#123; ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(path)); objectOutputStream.writeObject(data); objectOutputStream.close(); &#125; private static Data readByFIS(String path) throws Exception &#123; ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(path)); Data result = (Data)objectInputStream.readObject(); objectInputStream.close(); return result; &#125; public static void main(String args[]) throws Exception &#123; STest.writeByFOS(new Data(0, &quot;灵梦&quot;), STest.PATH_F); System.out.println(STest.readByFIS(STest.PATH_F)); &#125;&#125;class Data implements Serializable &#123; private static final long serialVersionUID = 615562960517507579L; private int id; private String value; public Data(int id, String value) &#123; this.id = id; this.value = value; &#125; public Object writeReplace() throws ObjectStreamException &#123; return new Data(1, this.value + this.value); &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getValue() &#123; return value; &#125; public void setValue(String value) &#123; this.value = value; &#125; @Override public String toString() &#123; return &quot;Data [id=&quot; + id + &quot;, value=&quot; + value + &quot;]&quot;; &#125;&#125; 输出结果为： 1Data [id=1, value=灵梦灵梦] 1ANY-ACCESS-MODIFIER Object readResolve() throws ObjectStreamException; 同理，当反序列化时，要将一个对象从流中读出来，我们如果想将读出来的对象用另一个对象实例替换，则需实现readResolve方法。测试用例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.ObjectStreamException;import java.io.Serializable;public class STest &#123; private static final String PATH_F = &quot;D://data.f&quot;; private static void writeByFOS(Data data, String path) throws Exception &#123; ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(path)); objectOutputStream.writeObject(data); objectOutputStream.close(); &#125; private static Data readByFIS(String path) throws Exception &#123; ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(path)); Data result = (Data)objectInputStream.readObject(); objectInputStream.close(); return result; &#125; public static void main(String args[]) throws Exception &#123; STest.writeByFOS(new Data(0, &quot;灵梦&quot;), STest.PATH_F); System.out.println(STest.readByFIS(STest.PATH_F)); &#125;&#125;class Data implements Serializable &#123; private static final long serialVersionUID = 615562960517507579L; private int id; private String value; public Data(int id, String value) &#123; this.id = id; this.value = value; &#125; public Object readResolve() throws ObjectStreamException &#123; return new Data(1, this.value + this.value); &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getValue() &#123; return value; &#125; public void setValue(String value) &#123; this.value = value; &#125; @Override public String toString() &#123; return &quot;Data [id=&quot; + id + &quot;, value=&quot; + value + &quot;]&quot;; &#125;&#125; 输出结果为： 1Data [id=1, value=灵梦灵梦] serialVersionUID序列化运行时会将每一个实现序列化的类与一个版本号关联起来，称为serialVersionUID。该版本号被用于比对发送方及接受方所用的类是否是同一个版本。若接收方与发送方版本号不一致，则会抛出InvalidClassException。 实现序列化的类可指定serialVersionUID的值： 1ANY-ACCESS-MODIFIER static final long serialVersionUID = xxxL; 若实现序列化的类未明确指定serialVersionUID，则序列化会在运行时依据待序列化类的各个方面计算一个默认的serialVersionUID值。然而Java强烈推荐每一个可序列化的类都明确指定自己的serialVersionUID，因为默认serialVersionUID的计算结果对类的编译结果异常敏感，因此若发送方及接收方的编译器有所差异则可能会在反序列化时抛出InvalidClassException。因此，为保证有一个无关Java编译实现的常量serialVersionUID值，序列化的类必须明确指定serialVersionUID。同时也强烈建议如果可能的话将serialVersionUID的访问权限设为private，因为serialVersionUID仅仅对其所属的类本身有用，换句话说，serialVersionUID并不是一个需继承的字段。数组类无法声明一个特定的serialVersionUID，所以它们总是使用默认的计算值，但是数组类并不需要与serialVersionUID建立起匹配关系。 测试代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;import java.util.ArrayList;import java.util.List;public class STest &#123; private static final String PATH_F = &quot;D://data.f&quot;; private static void writeByFOS(List&lt;Data&gt; list, String path) throws Exception &#123; ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(path)); objectOutputStream.writeObject(&quot;使用FOS:&quot;); objectOutputStream.writeObject(list); objectOutputStream.close(); &#125; @SuppressWarnings(&quot;unchecked&quot;) private static List&lt;Data&gt; readByFIS(String path) throws Exception &#123; ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(path)); System.out.println((String)objectInputStream.readObject()); List&lt;Data&gt; result = (ArrayList&lt;Data&gt;)objectInputStream.readObject(); objectInputStream.close(); return result; &#125; private static ByteArrayOutputStream writeByBAOS(List&lt;Data&gt; list) throws Exception &#123; ByteArrayOutputStream result = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(result); objectOutputStream.writeObject(&quot;使用BAOS:&quot;); objectOutputStream.writeObject(list); objectOutputStream.flush(); return result; &#125; @SuppressWarnings(&quot;unchecked&quot;) private static List&lt;Data&gt; readByBAIS(ByteArrayOutputStream baos) throws Exception &#123; ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray())); System.out.println((String)objectInputStream.readObject()); List&lt;Data&gt; result = (ArrayList&lt;Data&gt;)objectInputStream.readObject(); objectInputStream.close(); return result; &#125; public static void main(String args[]) throws Exception &#123; List&lt;Data&gt; list = new ArrayList&lt;Data&gt;(); list.add(new Data(0, &quot;灵梦&quot;)); list.add(new Data(1, &quot;v2&quot;)); list.add(new Data(2, &quot;v3&quot;)); list.add(new Data(3, &quot;v4&quot;)); STest.writeByFOS(list, STest.PATH_F); System.out.println(STest.readByFIS(STest.PATH_F)); ByteArrayOutputStream baos = STest.writeByBAOS(list); System.out.println(STest.readByBAIS(baos)); &#125;&#125;class Data implements Serializable &#123; private static final long serialVersionUID = 615562960517507579L; private int id; private String value; public Data(int id, String value) &#123; this.id = id; this.value = value; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getValue() &#123; return value; &#125; public void setValue(String value) &#123; this.value = value; &#125; @Override public String toString() &#123; return &quot;Data [id=&quot; + id + &quot;, value=&quot; + value + &quot;]&quot;; &#125;&#125; 测试结果 1234使用FOS:[Data [id=0, value=灵梦], Data [id=1, value=v2], Data [id=2, value=v3], Data [id=3, value=v4]]使用BAOS:[Data [id=0, value=灵梦], Data [id=1, value=v2], Data [id=2, value=v3], Data [id=3, value=v4]] 备注 若Data类不实现Serializable接口，则可通过编译，但运行时会报如下异常： 123456789101112131415Exception in thread &quot;main&quot; java.io.NotSerializableException: stest.Data at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1183) at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:347) at java.util.ArrayList.writeObject(ArrayList.java:742) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:606) at java.io.ObjectStreamClass.invokeWriteObject(ObjectStreamClass.java:988) at java.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:1495) at java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:1431) at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1177) at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:347) at stest.STest.writeByFOS(STest.java:19) at stest.STest.main(STest.java:57)]]></content>
      <categories>
        <category>Java JDK7源码</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java JDK7源码-java.lang.Cloneable]]></title>
    <url>%2F2017%2F07%2F04%2FJava%20JDK7%E6%BA%90%E7%A0%81-javalangCloneable%2F</url>
    <content type="text"><![CDATA[源码 1234package java.lang;public interface Cloneable &#123;&#125; 已整理层级关系直接实现本接口的类 java.util.ArrayList&lt;E&gt; 综述一个类如果想进行克隆操作则必须实现本接口(若未实现本接口又强行调用clone()，则可通过编译，但是运行时会抛出CloneNotSupportedException)。 通常来说，实现本接口的类需要重写Object的clone()方法。Object.clone()为protected方法，重写后的方法为public方法。当然，也可以选择不重写，但此时clone()仅有protected权限。 默认o.clone()方法采用浅拷贝，会将o copy一份并赋予新的引用。o中的成员变量若为基本数据类型，无论是浅拷贝还是深拷贝，都会进行原值克隆。毕竟他们都不是对象，不是存储在堆中。注意：基本数据类型并不包括他们对应的包装类。但是若o中的成员变量是一个对象，则浅拷贝不会拷贝该对象，即新拷贝出的o的克隆体中的对象仍为原对象。而深拷贝则会有N层拷贝的概念，即控制实际拷贝到第几层级。 注意本接口未包含clone()。因此仅仅是继承本接口是无法拷贝对象的。即使clone()被反射调用，也无法保证它会成功。]]></content>
      <categories>
        <category>Java JDK7源码</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[传智 springmvc+mybatis day1-8.sqlSession使用范围]]></title>
    <url>%2F2017%2F07%2F02%2F%E4%BC%A0%E6%99%BAspringmvcmybatisday1-8sqlSession%E4%BD%BF%E7%94%A8%E8%8C%83%E5%9B%B4%2F</url>
    <content type="text"><![CDATA[SqlMapConfig.xml总结Mybatis全局配置文件，只有一个。名称不固定。其中主要包含以下两项： 配置数据源(引入Spring后数据源将由Spring管理) 管理mapper.xml，mapper.xml中配置核心的SQL语句 mapper.xml总结以statement为单位进行配置(把一个SQL称为一个statement，之所以这么说，是因为Mybatis最后会把SQL封装为mapper的statement对象)。statement中配置SQL语句，输入参数类型parameterType(完成输入映射)，输出结果类型resultType(完成输出映射)。 除parameterType外，还提供parameterMap配置输入参数类型(已过时，不推荐使用)。 除resultType外，还提供resultMap配置输出结果类型(未过时，仍推荐使用)完成复杂数据类型映射(例如一对多映射，多对多映射)。 selectOneSqlSession.selectOne(String statement, Object parameter)不能用于查询多条记录，会抛出异常。 Mybatis开发DAOMybatis开发DAO(Data Access Object，数据存取对象)的两种方式： 原始：DAO接口及DAO实现均需程序员自己编写。 mapper代理：程序员只需要写DAO接口。DAO实现由Mybatis自动生成代理对象。这么做不会降低程序的灵活性，因为：本身DAO在三层架构中就是一个通用的接口(service不是通用接口)。 sqlSession的使用范围一段sqlSession的创建代码如下： 12SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(Resources.getResourceAsStream(&quot;mybatis/SqlMapConfig.xml&quot;));SqlSession sqlSession = sqlSessionFactory.openSession(); 因此创建关系为： 1SqlSessionFactoryBuilder - SqlSessionFactory - SqlSession SqlSessionFactoryBuilder 以工具类的方式使用(因SqlSessionFactory是单例的，因此创建完一次SqlSessionFactory后，即无需再管SqlSessionFactoryBuilder)，用于创建SqlSessionFactory。 SqlSessionFactory 正常开发时，以单例方式管理SqlSessionFactory。整个系统运行过程中SqlSessionFactory只有一个实例。与Spring整合后，由Spring以单例的方式管理SqlSessionFactory。 SqlSession SqlSession是一个面向用户(即程序员)的接口。程序员调用SqlSession的接口方法操作数据库。它在Mybatis架构中的层级为： 1public interface SqlSession extends Closeable 有两个实现类： 1public class DefaultSqlSession implements SqlSession 1public class SqlSessionManager implements SqlSessionFactory, SqlSession 其中DefaultSqlSession为默认的实现类，在该类中，有一个成员变量为： 1private Executor executor; 即为： 1public interface Executor 该接口即为数据库操作的执行器接口。SqlSession内部调用Excutor操作数据库。Excutor接口有两个实现： 默认执行器，即： 1public abstract class BaseExecutor implements Executor 缓存执行器，即： 1public class CachingExecutor implements Executor 以默认执行器的某个子类(批量操作执行器)为例： 1public class BatchExecutor extends BaseExecutor BatchExecutor有如下成员变量： 1private String currentSql; // 封装SQL语句 1private MappedStatement currentStatement; // 用于封装SQL的对象。其中有statement中定义的所有内容。 MappedStatement类成员变量举例： 1234567891011121314151617181920212223private String resource;private Configuration configuration;private String id;private Integer fetchSize;private Integer timeout;private StatementType statementType;private ResultSetType resultSetType;private SqlSource sqlSource;private Cache cache;private ParameterMap parameterMap;private List&lt;ResultMap&gt; resultMaps;private boolean flushCacheRequired;private boolean useCache;private boolean resultOrdered;private SqlCommandType sqlCommandType;private KeyGenerator keyGenerator;private String[] keyProperties;private String[] keyColumns;private boolean hasNestedResultMaps;private String databaseId;private Log statementLog;private LanguageDriver lang;private String[] resultSets; SqlSession是线程不安全的:在多线程环境下，SqlSession不能使用单例，因为SqlSession中的Executor的成员变量中有currentSql这样的数据字段，换句话说，SqlSession是线程不安全的。因此SqlSession的最佳应用范围在方法体内，即在方法体内定义局部变量来使用SqlSession。]]></content>
      <categories>
        <category>传智 springmvc+mybatis day1</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdbc</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[传智 springmvc+mybatis day1-7.mybatis和hibernate的适用场景]]></title>
    <url>%2F2017%2F07%2F02%2F%E4%BC%A0%E6%99%BAspringmvcmybatisday1-7mybatis%E5%92%8Chibernate%E7%9A%84%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%2F</url>
    <content type="text"><![CDATA[Mybatis与Hibernate的区别区别主要用于项目技术选型。进行技术选型时，主要考虑以下两点： 降低开发成本 提高系统稳定性 Mybatis 入门简单。程序容易上手开发，节省开发成本。 需要程序员自己编写SQL语句，是一个不完全的ORM框架(Object Relational Mapping，对象关系映射)，易于进行SQL的修改及优化。 适合开发需求变更频繁的项目。例如：互联网电商网站等互联网项目(讲究敏捷开发，高效)。 Hibernate 入门门槛较高。难以写出性能较高的程序(需要用到缓存技术，而且这些缓存技术已过时，现在讲究的是分布式缓存)。 无需写SQL语句，提倡面向对象，采用完全的标准ORM框架，无法优化SQL语句。若想优化SQL语句，则必须使用Hibernate写原生态SQL的方法，此时Hibernate的优势将不复存在，换句话说，此时已没有使用Hibernate的必要，可直接使用JDBC。 适合开发需求变更不大，对象数据模型稳定，中小型的项目。例如：企业OA(办公自动化，Office Automation)。]]></content>
      <categories>
        <category>传智 springmvc+mybatis day1</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdbc</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java JDK7源码-java.util.AbstractQueue&lt;E&gt;]]></title>
    <url>%2F2017%2F06%2F30%2FJava%20JDK7%E6%BA%90%E7%A0%81-javautilAbstractQueueE%2F</url>
    <content type="text"><![CDATA[源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117package java.util;public abstract class AbstractQueue&lt;E&gt; extends AbstractCollection&lt;E&gt; implements Queue&lt;E&gt; &#123; protected AbstractQueue() &#123; &#125; /** * 重写父类:java.util.AbstractCollection&lt;E&gt; * 实现接口:java.util.Queue&lt;E&gt; * * 在不超出容量限制的前提下 * 将e插入到queue中并返回true * 若已超出容量限制无法插入 * 则抛出IllegalStateException * * 本方法通过调用offer(E e)实现。 * 若offer(E e)返回true则本方法返回true * 若offer(E e)返回false则本方法抛出IllegalStateException。 * * @throws IllegalStateException 因容量限制e此时无法被插入queue。 * @throws ClassCastException e因其所属的类禁止被插入queue。 * @throws NullPointerException e==null且queue禁止包含空元素。 * @throws IllegalArgumentException e因其某些属性禁止被插入queue。 */ public boolean add(E e) &#123; if (offer(e)) return true; else throw new IllegalStateException(&quot;Queue full&quot;); &#125; /** * 实现接口:java.util.Queue&lt;E&gt; * * 检索，移除并返回queue的头元素。 * * 本方法与poll()的区别仅仅在于： * 若queue为空队列，poll()返回null，本方法抛出异常。 * 因此，除非queue为空，否则本方法返回poll()的结果。 * * @throws NoSuchElementException queue为空。 */ public E remove() &#123; E x = poll(); if (x != null) return x; else throw new NoSuchElementException(); &#125; /** * 实现接口:java.util.Queue&lt;E&gt; * * 检索并返回但不移除queue的头元素。 * * 本方法与peek()的区别仅仅在于： * 若queue为空队列，peek()返回null，本方法抛出异常。 * 因此，除非queue为空，否则本方法返回peek()的结果。 * * @throws NoSuchElementException queue为空。 */ public E element() &#123; E x = peek(); if (x != null) return x; else throw new NoSuchElementException(); &#125; /** * 重写父类:java.util.AbstractCollection&lt;E&gt; * * 移除queue中的所有元素。 * 调用本方法后，queue将为空队列。 * * 本方法重复调用poll()直到其返回null为止。 */ public void clear() &#123; while (poll() != null) ; &#125; /** * 重写父类:java.util.AbstractCollection&lt;E&gt; * * 将c中所有元素加入queue。 * 若c为queue自身则抛出IllegalArgumentException。 * 更一般的说，本方法并未定义如下行为的解决策略：c在本方法操作过程中发生变化。 * * 本方法迭代c同时将迭代得到的每个元素插入queue。 * * 在插入某个元素(特别的，这个某个元素也包含null)时若因相关异常导致插入失败 * 结果只有部分元素能成功插入queue，此时会抛出运行时异常。 * * queue因本方法发生改变则返回true。 * * @throws ClassCastException c中任意一个元素因为其所属的类禁止被插入queue。 * @throws NullPointerException c中任意一个元素为null且queue禁止包含空元素；或c==null。 * @throws IllegalArgumentException c中任意一个元素因其某些属性禁止被插入queue；或c是queue自身。 * @throws IllegalStateException 因插入限制，此时并非c中所有元素都能被插入queue。 */ public boolean addAll(Collection&lt;? extends E&gt; c) &#123; if (c == null) throw new NullPointerException(); if (c == this) throw new IllegalArgumentException(); boolean modified = false; for (E e : c) if (add(e)) modified = true; return modified; &#125;&#125; 已整理层级关系本类直接继承的类 java.util.AbstractCollection&lt;E&gt; 本类直接实现的接口 java.util.Queue&lt;E&gt; 综述本类是Java集合框架中的一员。E为AbstractQueue所包含的元素类型。 本类提供Queue接口的基本实现。若基本实现要求不得包含空元素，本类方法会对此作出调整。add(E e)，remove()，element()分别基于offer(E e)，poll()，peek()。不同的是当操作失败时前者抛出异常，后者会返回失败标志(false或null)。 若要以最小化的方式实现本类，程序员必须实现Queue.offer(E e)(禁止插入空元素)，Queue.peek()，Queue.poll()，Collection.size()，Collection.iterator()。若实现类无法满足Queue的规范，则应考虑使用AbstractCollection或其其他子类。 未整理层级关系直接继承本类的类 java.util.concurrent.ArrayBlockingQueue&lt;E&gt; java.util.concurrent.LinkedBlockingDeque&lt;E&gt; java.util.concurrent.ConcurrentLinkedQueue&lt;E&gt; java.util.concurrent.DelayQueue&lt;E extends Delayed&gt; java.util.PriorityQueue&lt;E&gt;]]></content>
      <categories>
        <category>Java JDK7源码</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
        <tag>Collection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java JDK7源码-java.util.AbstractSet&lt;E&gt;]]></title>
    <url>%2F2017%2F06%2F28%2FJava%20JDK7%E6%BA%90%E7%A0%81-javautilAbstractSetE%2F</url>
    <content type="text"><![CDATA[源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129package java.util;public abstract class AbstractSet&lt;E&gt; extends AbstractCollection&lt;E&gt; implements Set&lt;E&gt; &#123; protected AbstractSet() &#123; &#125; /** * 重写父类:java.util.AbstractCollection&lt;E&gt; * 实现接口:java.util.Set&lt;E&gt; * * 比较o与set的相等性。 * 满足如下条件返回true： * o同样是一个Set * o与set长度相同 * o中的每个元素都在set中存在 * 只要满足这些条件，即便是Set接口的不同实现之间也可判定为相等 * * 本方法首先检查o是否是set本身，如果是则返回true。 * 然后检查o是否是一个Set及长度是否与set相同，如果有一个为否则返回false。 * 如果均为true，则返回containsAll((Collection) o)的结果。 */ public boolean equals(Object o) &#123; if (o == this) return true; if (!(o instanceof Set)) return false; Collection c = (Collection) o; if (c.size() != size()) return false; try &#123; return containsAll(c); &#125; catch (ClassCastException unused) &#123; return false; &#125; catch (NullPointerException unused) &#123; return false; &#125; &#125; /** * 重写父类:java.util.AbstractCollection&lt;E&gt; * 实现接口:java.util.Set&lt;E&gt; * * 返回set的hash code值。 * * 一个set的hash code值为其组成元素的hash code值之和 * 等于null的元素的hash code值被定义为0 * 这样可以保证对于任意两个set，s1及s2 * 只要有s1.equals(s2)，即有s1.hashCode()==s2.hashCode() * 满足Java规范对于hashCode()及equals(Object obj)返回关系的要求 * * 本方法迭代set * 调用set中每个元素的hashCode() * 求和作为本方法的结果返回 */ public int hashCode() &#123; int h = 0; Iterator&lt;E&gt; i = iterator(); while (i.hasNext()) &#123; E obj = i.next(); if (obj != null) h += obj.hashCode(); &#125; return h; &#125; /** * 重写父类:java.util.AbstractCollection&lt;E&gt; * 实现接口:java.util.Set&lt;E&gt; * * 本方法可选 * 移除set中所有被c所包含的元素 * 若c同样是一个Set，本操作实际为求差集 * * 本方法通过调用set及c的size()确定哪一个的长度更小: * * 若set长度更小，则迭代set * 检查迭代出的元素是否被c所包含 * 若包含，则调用迭代器的remove()将其从set中移除。 * * 若c的长度更小，则迭代c * 调用set的remove(Object o)从set中移除所有被迭代器返回的元素。 * * 注意，若set返回的iterator未实现remove() * 则会抛出UnsupportedOperationException。 * * 若set因本方法发生了改变则返回true，反之返回false。 * * 本方法所重写的AbstractCollection类下的方法为： * public boolean removeAll(Collection&lt;?&gt; c) &#123; * boolean modified = false; * Iterator&lt;?&gt; it = iterator(); * while (it.hasNext()) &#123; * if (c.contains(it.next())) &#123; * it.remove(); * modified = true; * &#125; * &#125; * return modified; * &#125; * 因为Set不允许包含重复元素 * 本方法重写后增加了基于长度的判断以提高算法性能。 * * @throws UnsupportedOperationException 集合不支持本方法。 * @throws ClassCastException 集合中至少有一个元素的类型与c不相容。 * @throws NullPointerException c==null或 * 集合中至少有一个元素为null且c不允许空元素存在。 */ public boolean removeAll(Collection&lt;?&gt; c) &#123; boolean modified = false; if (size() &gt; c.size()) &#123; for (Iterator&lt;?&gt; i = c.iterator(); i.hasNext(); ) // 因Set不允许包含重复元素 // 故调用1次remove后即可保证set中不再包含被移除的元素 modified |= remove(i.next()); &#125; else &#123; for (Iterator&lt;?&gt; i = iterator(); i.hasNext(); ) &#123; if (c.contains(i.next())) &#123; i.remove(); modified = true; &#125; &#125; &#125; return modified; &#125;&#125; 已整理层级关系本类直接继承的类 java.util.AbstractCollection&lt;E&gt; 本类直接实现的接口 java.util.Set&lt;E&gt; 综述本类是Java集合框架中的一员。提供了Set接口的最小化实现。E表示被Set所持有的元素类型。 在遵循Set接口的额外约束(例如不允许存在重复元素)的前提下，继承本类实现Set与继承AbstractCollection实现Collection所需做的工作是相同的。 未整理层级关系直接继承本类的类 java.util.HashSet]]></content>
      <categories>
        <category>Java JDK7源码</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
        <tag>Collection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java JDK7源码-java.util.RandomAccess]]></title>
    <url>%2F2017%2F06%2F22%2FJava%20JDK7%E6%BA%90%E7%A0%81-javautilRandomAccess%2F</url>
    <content type="text"><![CDATA[源码 1234package java.util;public interface RandomAccess &#123;&#125; 综述本接口是Java集合框架中的一员，是被List所使用的标记接口，实现该接口表明List支持快速(通常是指常数时间)随机访问。 本接口的主要目的为在随机或顺序访问list时允许通用算法修改其行为以提供更好的性能。 当把基于随机访问list(例如ArrayList)的最佳算法用于顺序访问list(例如LinkedList)时，算法在用时上会呈平方阶增长。因此在设计list访问的通用算法时，最好先看一下传入的list是否实现了本接口，若未实现本接口，则说明传入list天然不支持随机访问，在设计算法时必须特殊考虑以保证访问的性能在可接受的范围内。 随机访问与顺序访问的界限通常是模糊的。例如，一些List在长度巨大时的访问时间复杂度接近于线性阶，但是在实际使用中，长度一般时的时间复杂度为常数阶。这样的List通常也会实现本接口。 一般来说，当某个list执行循环1的效率高于循环2时，即认为应该实现本接口。 循环1： 12for (int i=0, n=list.size(); i &lt; n; i++) list.get(i); 循环2： 12for (Iterator i=list.iterator(); i.hasNext(); ) i.next(); 换句话说，在欲迭代一个list之前，最好先判断其是否已实现了本接口。然后采取不同的调用方法： 12345678910if (list instance of RandomAccess) &#123; for (int i = 0; i &lt; list.size(); i++)&#123; // TODO &#125;&#125; else &#123; Iterator iterator = list.iterator(); while (iterator.hasNext()) &#123; // TODO &#125;&#125; 以下类是对性能的测试： 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.ArrayList;import java.util.Iterator;import java.util.LinkedList;import java.util.List;import org.junit.Test;public class TestRandomAccess &#123; private final static int LIST_SIZE = 1000; private final static int TEST_COUNT = 1000; @Test public void testRandomAccess() &#123; List&lt;Integer&gt; arraylist = new ArrayList&lt;Integer&gt;(); for (int i = 0; i &lt; TestRandomAccess.LIST_SIZE; i++) arraylist.add(i); List&lt;Integer&gt; linkedList = new LinkedList&lt;Integer&gt;(); for (int i = 0; i &lt; TestRandomAccess.LIST_SIZE; i++) linkedList.add(i); System.out.println(&quot;size=&quot; + TestRandomAccess.LIST_SIZE + &quot;,test count=&quot; + TestRandomAccess.TEST_COUNT + &quot;\n&quot;); System.out.println(&quot;ArrayList for time=&quot; + this.forTime(arraylist)); System.out.println(&quot;ArrayList iterator time=&quot; + this.iteratorTime(arraylist)); System.out.println(&quot;LinkedList for time=&quot; + this.forTime(linkedList)); System.out.println(&quot;LinkedList iterator time=&quot; + this.iteratorTime(linkedList)); &#125; private long forTime(List&lt;Integer&gt; list) &#123; long beginTime = System.currentTimeMillis(); for (int count = 0; count &lt; TestRandomAccess.TEST_COUNT; count++) &#123; for (int i = 0; i &lt; list.size(); i++) list.get(i); &#125; return System.currentTimeMillis() - beginTime; &#125; private long iteratorTime(List&lt;Integer&gt; list) &#123; long beginTime = System.currentTimeMillis(); for (int count = 0; count &lt; TestRandomAccess.TEST_COUNT; count++) &#123; Iterator&lt;Integer&gt; iterator = list.iterator(); while (iterator.hasNext()) iterator.next(); &#125; return System.currentTimeMillis() - beginTime; &#125;&#125; 运行结果为： 123456size=1000,test count=1000ArrayList for time=7ArrayList iterator time=12LinkedList for time=466LinkedList iterator time=15]]></content>
      <categories>
        <category>Java JDK7源码</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
        <tag>Collection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java JDK7源码-java.util.AbstractList&lt;E&gt;]]></title>
    <url>%2F2017%2F06%2F19%2FJava%20JDK7%E6%BA%90%E7%A0%81-javautilAbstractListE%2F</url>
    <content type="text"><![CDATA[源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046package java.util;public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt; &#123; protected AbstractList() &#123; &#125; /** * 重写父类:java.util.AbstractCollection&lt;E&gt; * 实现接口:java.util.List&lt;E&gt; * * 本方法可选 * 将特定元素添加至list结尾。 * * 支持本方法的list可能会对可添加至list的元素有所限制。 * 具体来说，某些实现拒绝添加空元素；某些实现会限制可添加元素的类型。 * 程序员在继承本类时需在实现类中明确指明这些限制。 * * 本方法通过调用add(int index, E element)以实现自身功能。 * 因add(int index, E element)默认抛出UnsupportedOperationException * 因此除非实现类重写了add(int index, E element) * 否则调用本方法时会抛出UnsupportedOperationException。 * * @throws UnsupportedOperationException list不支持本方法。 * @throws ClassCastException e因为其所属的类禁止被插入list。 * @throws NullPointerException e==null且list禁止包含空元素。 * @throws IllegalArgumentException e因其某些属性禁止被插入list。 */ public boolean add(E e) &#123; add(size(), e); return true; &#125; /** * 实现接口:java.util.List&lt;E&gt; * * 返回list中索引位置为index的元素。 * * @throws IndexOutOfBoundsException 索引越界(index &lt; 0 || index &gt;= size)。 */ abstract public E get(int index); /** * 实现接口:java.util.List&lt;E&gt; * * 本方法可选，实现类可依自身情况决定是否真的需要实现。 * 用element替换list索引值为index的元素。方法返回被替换的元素。 * 本方法总是抛出UnsupportedOperationException。 * * @throws UnsupportedOperationException list不支持本方法。 * @throws ClassCastException element因为其所属的类禁止被插入list。 * @throws NullPointerException element==null且list禁止包含空元素。 * @throws IllegalArgumentException element因其某些属性禁止被插入list。 * @throws IndexOutOfBoundsException 索引越界(index &lt; 0 || index &gt;= size)。 */ public E set(int index, E element) &#123; throw new UnsupportedOperationException(); &#125; /** * 实现接口:java.util.List&lt;E&gt; * * 本方法可选，实现类可依自身情况决定是否真的需要实现。 * 将element插入list的index下标处。原来处于index下标及以后的元素均向后移动一个位置。 * * list.add(&quot;1&quot;); * list.add(list.size(), &quot;1&quot;); * 二者等效。 * * 本方法总是抛出UnsupportedOperationException。 * * @throws UnsupportedOperationException list不支持本方法。 * @throws ClassCastException element因为其所属的类禁止被插入list。 * @throws NullPointerException element==null且list禁止包含空元素。 * @throws IllegalArgumentException element因其某些属性禁止被插入list。 * @throws IndexOutOfBoundsException 索引越界(index &lt; 0 || index &gt; size)。 */ public void add(int index, E element) &#123; throw new UnsupportedOperationException(); &#125; /** * 实现接口:java.util.List&lt;E&gt; * * 本方法可选，实现类可依自身情况决定是否真的需要实现。 * 移除list中索引值为index的元素。后续元素左移一个位置。返回被移除的元素。 * * 本方法总是抛出UnsupportedOperationException。 * * @throws UnsupportedOperationException list不支持本方法。 * @throws IndexOutOfBoundsException 索引越界(index &lt; 0 || index &gt;= size)。 */ public E remove(int index) &#123; throw new UnsupportedOperationException(); &#125; /** * 实现接口:java.util.List&lt;E&gt; * * 搜索操作 * 返回o在list中第一次出现的索引。 * 若list不包含o则返回-1。 * * 更一般的来说，返回满足如下条件索引值最小的元素的索引： * (o==null ? get(i)==null : o.equals(get(i)))。 * 若不存在这样的元素则返回-1。 * * 本方法首先使用listIterator()获得一个list iterator。 * 随后，向后迭代list直到找到o或迭代结束。 * * @throws ClassCastException o所属的类与list不相容(依实现可选)。 * @throws NullPointerException o==null且list禁止包含空元素。 */ public int indexOf(Object o) &#123; ListIterator&lt;E&gt; it = listIterator(); if (o==null) &#123; while (it.hasNext()) if (it.next()==null) return it.previousIndex(); &#125; else &#123; while (it.hasNext()) if (o.equals(it.next())) return it.previousIndex(); &#125; return -1; &#125; /** * 实现接口:java.util.List&lt;E&gt; * * 搜索操作 * 返回o在list中最后一次出现的索引。 * 若list不包含o则返回-1。 * * 更一般的来说，返回满足如下条件索引值最大的元素的索引： * (o==null ? get(i)==null : o.equals(get(i)))。 * 若不存在这样的元素则返回-1。 * * 本方法首先使用listIterator(final int index)获得一个指向 * [list.size()-1,list.size()] * 的list iterator。 * 随后，向前迭代list直到找到o或迭代结束。 * * @throws ClassCastException o所属的类与list不相容(依实现可选)。 * @throws NullPointerException o==null且list禁止包含空元素。 */ public int lastIndexOf(Object o) &#123; ListIterator&lt;E&gt; it = listIterator(size()); if (o==null) &#123; while (it.hasPrevious()) if (it.previous()==null) return it.nextIndex(); &#125; else &#123; while (it.hasPrevious()) if (o.equals(it.previous())) return it.nextIndex(); &#125; return -1; &#125; /** * 重写父类:java.util.AbstractCollection&lt;E&gt; * 实现接口:java.util.List&lt;E&gt; * * 批量操作 * 本方法可选，实现类可依自身情况决定是否真的需要实现。 * * 移除list中的所有元素,调用本方法后list将为空。 * 本方法通过调用removeRange(int fromIndex, int toIndex)以实现自身功能。 * 因此除非重写removeRange(int fromIndex, int toIndex)或remove(int index) * 否则本方法将抛出UnsupportedOperationException，调用链条如下： * * clear() -&gt; * removeRange(int fromIndex, int toIndex) -&gt; * listIterator.remove() -&gt; * remove(int index) * * remove(int index)默认抛出UnsupportedOperationException。 */ public void clear() &#123; // removeRange(int fromIndex, int toIndex)说明: // 移除索引在[fromIndex,toIndex)范围内的元素 removeRange(0, size()); &#125; /** * 实现接口:java.util.List&lt;E&gt; * * 本方法可选，实现类可依自身情况决定是否真的需要实现。 * * 将c中所有元素插入list的指定位置(index)，插入顺序为c的迭代器取出的顺序。 * 原index位置及以后位置的元素顺次向后移动，空出装载c的位置。 * * 本方法并未定义如下事件发生时的解决策略： * 在将c中的元素添加至list的过程中c发生变化 * 这也意味着如下事件的解决策略同样未定义：将一个非空list添加至自身。 * * 若list因本方法发生变化则返回true，反之返回false。 * * list.addAll(set); * list.addAll(list.size(), set); * 二者等价。 * * 本方法首先得到c的迭代器 * 而后遍历c，将遍历得到的c中的元素插入list的索引index处 * 具体方法为使用add(int index, E element) * 因为add(int index, E element)默认抛出UnsupportedOperationException * 因此如果要实现本方法的功能，则必须重写add(int index, E element)。 * * 基于效率考虑，许多实现会重写本方法。 * * @throws UnsupportedOperationException list不支持本方法。 * @throws ClassCastException c中任意一个元素因为其所属的类禁止被插入list。 * @throws NullPointerException c中任意一个元素为null且list禁止包含空元素；或c==null。 * @throws IllegalArgumentException c中任意一个元素因其某些属性禁止被插入list。 * @throws IndexOutOfBoundsException 索引越界(index &lt; 0 || index &gt; size)。 */ public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; // 注1:rangeCheckForAdd(int index) rangeCheckForAdd(index); boolean modified = false; for (E e : c) &#123; add(index++, e); modified = true; &#125; return modified; &#125; /** * 重写父类:java.util.AbstractCollection&lt;E&gt; * 实现接口:java.util.List&lt;E&gt; * * 返回一个基于list的有序迭代器。 * 本方法返回的迭代器是Iterator接口的一个简单实现 * 基于本类的size()，get(int index)，remove(int index)。 * * 返回的iterator的iterator.remove()需调用remove(int index) * 而remove(int index)默认抛出UnsupportedOperationException * 因此除非重写remove(int index)，否则在调用iterator.remove()时会抛出UnsupportedOperationException。 * * 基于protected字段modCount(list发生结构性变化的次数)的值 * 本方法返回的iterator可能会抛出运行时异常(发生结构性变化的次数超过iterator的预期，即发生结构性变化不是由该iterator导致的)。 */ public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; /** * 实现接口:java.util.List&lt;E&gt; * * 返回一个list按固有顺序迭代的listIterator。 */ public ListIterator&lt;E&gt; listIterator() &#123; return listIterator(0); &#125; /** * 实现接口:java.util.List&lt;E&gt; * * 返回一个list按固有顺序迭代的listIterator * 迭代开始时游标位于索引[index-1,index]之间。 * * 使用本方法得到listIterator后 * 若第一次调用的是listIterator.next()，返回的元素的索引是index * 同理，若第一次调用的是listIterator.previous()，返回的是索引为index-1的元素。 * * @throws IndexOutOfBoundsException 索引越界(index &lt; 0 || index &gt; size)。 */ public ListIterator&lt;E&gt; listIterator(final int index) &#123; // 注1:rangeCheckForAdd(int index) rangeCheckForAdd(index); return new ListItr(index); &#125; private class Itr implements Iterator&lt;E&gt; &#123; /** * 当前游标指向的位置的后一个元素的索引。 * 默认游标位于第一个元素之前。因此默认值为0 */ int cursor = 0; /** * 记录最近一次调用next()或previous()返回的元素的索引。 * 若该元素被remove()移除则本值被重置为-1。 * 初始时本值为-1。 */ int lastRet = -1; /** * 本字段记录了iterator认为的abstractList应有的结构性变化次数。 * 初始时，本字段等于创建iterator那个时间点的modCount(modCount中记录的是list总的结构性变化次数)。 * 此后凡是经由iterator导致的list的结构性变化 * iterator均会同步修改expectedModCount及modCount，以保证二者始终相等。 * 因此一旦iterator检测到了expectedModCount != modCount * 则证明list因为本iterator以外的原因发生了结构性变化 * 进而可认为list存在同步性问题。 */ int expectedModCount = modCount; /** * 实现接口:java.util.Iterator&lt;E&gt; * * 在迭代过程中，若集合还有元素则返回true。 * 换句话说，返回ture说明仍然可以通过next()方法取到元素 * 若在本方法返回false时继续调用next()方法，则next()方法会抛出异常。 */ public boolean hasNext() &#123; return cursor != size(); &#125; /** * 实现接口:java.util.Iterator&lt;E&gt; * 返回iterator游标所指向的元素，同时游标后移一位 * 注2:checkForComodification() * * @throws NoSuchElementException iterator游标所指的位置已无元素。 */ public E next() &#123; checkForComodification(); try &#123; int i = cursor; E next = get(i); lastRet = i; cursor = i + 1; return next; &#125; catch (IndexOutOfBoundsException e) &#123; checkForComodification(); throw new NoSuchElementException(); &#125; &#125; /** * 实现接口:java.util.Iterator&lt;E&gt; * * 移除当前游标所指元素的前一个元素。 * 即上一次调用next()所返回的元素。 * 因此，调用本方法之前必须调用一次next()。 * 调用一次next()后多次调用本方法是不允许的。本方法必须与next()一一配对。 * * 本方法没有定义应对以下事件的对策： * 在迭代过程中，被迭代集合因本方法以外的原因发生了改变。 * * 注2:checkForComodification() * 注3:Itr.remove()测试 * * @throws UnsupportedOperationException iterator不支持本方法。 * @throws IllegalStateException 在调用本方法前没有调用与之配对的next()(包含调用一次next()后多次调用本方法的情况)。 */ public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; AbstractList.this.remove(lastRet); // 本类Itr中只有hasNext()及next()，因此只会向后迭代 // 如果仅考虑本类的话，是不需要这个if判断的 // 因为必有lastRet &lt; cursor，直接全部调用cursor--; // 然后若考虑到后文出现的，本类的子类ListItr的话，其内部有向前移动的hasPrevious()及previous() // 在向前移动的情况下，cursor &lt; lastRet，此时remove()后无需做任何操作 // 实在是精妙的操作，这样ListItr就无需重写本方法了 if (lastRet &lt; cursor) cursor--; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException e) &#123; throw new ConcurrentModificationException(); &#125; &#125; /** * 注2:checkForComodification() */ final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; private class ListItr extends Itr implements ListIterator&lt;E&gt; &#123; ListItr(int index) &#123; cursor = index; &#125; /** * 实现接口:java.util.ListIterator&lt;E&gt; * * 当向前遍历还有元素时返回true。 * 换句话说，返回ture说明仍然可以通过previous()取到元素 * 若在本方法返回false时继续调用previous()，则previous()会抛出异常。 */ public boolean hasPrevious() &#123; return cursor != 0; &#125; /** * 实现接口:java.util.ListIterator&lt;E&gt; * * 返回listIterator当前游标前一个元素，同时游标前移一位。 * 在迭代list的过程中本方法可能会被反复调用，或者与next()交替被调用。以此控制向前或向后迭代。 * * 以下语句均会返回当前游标的后一个元素： * listIterator.next(); * listIterator.previous(); * * 以下语句均会返回当前游标的前一个元素： * listIterator.previous(); * listIterator.next(); * * 注2:checkForComodification() * * @throws NoSuchElementException 游标所指的位置之前已无元素。 */ public E previous() &#123; checkForComodification(); try &#123; int i = cursor - 1; E previous = get(i); lastRet = cursor = i; return previous; &#125; catch (IndexOutOfBoundsException e) &#123; checkForComodification(); throw new NoSuchElementException(); &#125; &#125; /** * 实现接口:java.util.ListIterator&lt;E&gt; * * 返回listIterator当前游标后一个元素的索引。 * 本操作不会移动游标。 * 即本方法会返回下次调用next()时返回的元素的索引。 * 特别的，当游标位于list末尾时，调用本方法不会抛出异常，而是会返回list的长度。 */ public int nextIndex() &#123; return cursor; &#125; /** * 实现接口:java.util.ListIterator&lt;E&gt; * * 返回listIterator当前游标前一个元素的索引。 * 本操作不会移动游标。 * 即本方法会返回下次调用previous()时返回的元素的索引。 * 特别的，当游标位于list最左边时，调用本方法不会抛出异常，而是会返回-1。 */ public int previousIndex() &#123; return cursor-1; &#125; /** * 实现接口:java.util.ListIterator&lt;E&gt; * * 用e覆盖上一次由next()或previous()返回的元素的位置的元素。 * 本方法在调用前必须调用一次next()或previous()，否则不知道该覆盖哪个位置的元素。 * 且在本方法与最后一次next()或previous()之间不能调用add(E e)或remove()。 * * 本方法不会修改lastRet，因此自然也不会影响add(E e)或remove() * 但由于add(E e)或remove()均会修改lastRet为-1，因此这两个方法会影响本方法 * * 注2:checkForComodification() * * @throws UnsupportedOperationException listIterator不支持本方法。 * @throws ClassCastException e因为其所属的类禁止被插入list。 * @throws IllegalArgumentException e因其某些属性禁止被插入list。 * @throws IllegalStateException 本方法在调用前没有调用next()或previous()，或在本方法与最后一次next()或previous()之间调用add(E e)或remove()。 */ public void set(E e) &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; AbstractList.this.set(lastRet, e); expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; /** * 实现接口:java.util.ListIterator&lt;E&gt; * * 将e插入当前游标所在位置。若list为空，则e将成为list的第一个元素。 * * e插入后，当前游标位于e之后的位置。 * 因此插入后第一次如果调用的是next()将返回插入前游标所指的下一个元素 * 第一次如果调用的是previous()将返回e。 * * 调用该方法后，若调用nextIndex()或previousIndex()，和未调用该方法之前相比值均会增加1。 * * 注2:checkForComodification() * * @throws UnsupportedOperationException listIterator不支持本方法。 * @throws ClassCastException e因为其所属的类禁止被插入list。 * @throws IllegalArgumentException e因其某些属性禁止被插入list。 */ public void add(E e) &#123; checkForComodification(); try &#123; int i = cursor; AbstractList.this.add(i, e); lastRet = -1; cursor = i + 1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; &#125; /** * 实现接口:java.util.List&lt;E&gt; * * 视图 * * 返回list的一部分，索引值区间：[fromIndex,toIndex)。 * 特别的，若fromIndex==toIndex，则返回空list(不是null)。 * * 返回的列表是原list的一个视图，前者是后者的一部分，并未从后者中分离出去。 * 因此作用在前者之上的修改会反映在后者上，反之亦然。 * * 使用本方法的好处在于： * 当我们操作list的一部分时，可以直接在这一部分内部操作(仿佛这就是一个新的list)， * 而无需被各种索引的边界分散过多的注意。 * * 例如，如果想批量移除list中的一部分，可按如下操作： * list.subList(fromIndex, toIndex).clear(); * * 同理，所有本接口的方法及所有java.util.Collections类提供的静态方法 * 均支持本方法返回的视图作为一个独立的list调用。例如： * list2 = list.subList(1, 2); * list2.get(0); * 此时取得的元素即为list.get(1)。 * * 若在生成视图后原list发生了结构性的变化(例如长度发生了变化) * 则已生成的视图将被重置为未定义的状态。 * * 返回的视图在其私有域中存储了： * 1.相对于原list的偏移量 * 2.存储的视图的长度(该长度在视图生命周期中可变) * 3.存储原list的modCount(即原list发生结构性变化的次数) * * 视图有两个变种： * 若原list实现了java.util.RandomAccess接口，则返回的视图将基于RandomAccessSubList构造 * 反之，返回的视图将基于SubList构造。 * * 在SubList及RandomAccessSubList中： * * 在越界检查及偏移量调整后，视图的： * set(int index, E element) * get(int index) * add(int index, E element) * remove(int index) * addAll(int index, Collection&lt;? extends E&gt; c) * removeRange(int fromIndex, int toIndex) * 均基于原list计算。 * addAll(Collection&lt;? extends E&gt; c)是通过addAll(size, c)实现的。 * * listIterator(final int index)返回一个封装的对象 * 该对象基于原list的listIterator，并附加视图的偏移量。 * * iterator()是通过调用listIterator()实现的。 * * size()是通过调用视图的size字段实现的。 * * 所有方法都会检查原list当前的modCount值(原list发生结构性变化的次数)是否与视图的预期相等。 * 若不相等则抛出ConcurrentModificationException。 * * @throws IndexOutOfBoundsException 索引越界(fromIndex &lt; 0 || toIndex &gt; size)。 * @throws IllegalArgumentException fromIndex &gt; toIndex。 */ public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; return (this instanceof RandomAccess ? new RandomAccessSubList&lt;&gt;(this, fromIndex, toIndex) : new SubList&lt;&gt;(this, fromIndex, toIndex)); &#125; /** * 重写祖先类:java.lang.Object * 实现接口:java.util.List&lt;E&gt; * * 比较与哈希 * 比较o与list是否相等。 * * 当且仅当: * o同样是一个列表 * o与list长度相同 * o与list所有对应位置的元素均相等 * 时，认为o与list相等 * * 关于&quot;o与list所有对应位置的元素均相等&quot;，具体来说： * 若设e1为o中的某个元素，e2为list中对应相同位置的元素 * 若有 * e1==null ? e2==null : e1.equals(e2) * 则有e1与e2相等。 * 换句话说，两个list相等的条件为：在相同的位置包含相同的元素。 * * 本方法首先检查o是否是list本身，如果是则返回true。 * 若不是则检查o是否是一个list，若不是则返回false。 * 如果是则同时迭代o及list，比较对应位置的元素。 * 若任意某个比较结果返回false，返回false。 * 若其中一个迭代器先于另一个迭代结束(即o与list长度不同)，返回false。 * 若迭代正常结束，则返回true。 */ public boolean equals(Object o) &#123; if (o == this) return true; if (!(o instanceof List)) return false; ListIterator&lt;E&gt; e1 = listIterator(); ListIterator e2 = ((List) o).listIterator(); while (e1.hasNext() &amp;&amp; e2.hasNext()) &#123; E o1 = e1.next(); Object o2 = e2.next(); if (!(o1==null ? o2==null : o1.equals(o2))) return false; &#125; return !(e1.hasNext() || e2.hasNext()); &#125; /** * 重写祖先类:java.lang.Object * 实现接口:java.util.List&lt;E&gt; * * 比较与哈希 * * 返回list的hash code值。 * 计算方式如下： * int hashCode = 1; * for (E e : abstractList) * hashCode = 31 * hashCode + (e == null ? 0 : e.hashCode()); * * 这种计算方式可以保证: * 任意list1.equals(list2) * 有 * list1.hashCode()==list2.hashCode()。 */ public int hashCode() &#123; int hashCode = 1; for (E e : this) hashCode = 31*hashCode + (e==null ? 0 : e.hashCode()); return hashCode; &#125; /** * 移除list索引区间为[fromIndex,toIndex)的全部元素。 * 并将后续元素左移补位。 * 本方法减少了list中(toIndex - fromIndex)个元素。 * 若有toIndex==fromIndex，则本方法实际并未对list产生影响。 * * 本方法会被list及其视图的clear()调用。 * 重写本方法可大幅提高clear()的性能。 * * 本方法首先得到一个listIterator * 并将初始游标定位于[fromIndex-1,fromIndex]。 * 随后反复调用listIterator.next()及listIterator.remove() * 直到指定范围内的元素全部被移除。 * * 注意： * 若listIterator.remove()需要线性阶时间 * 则本方法需要平方阶时间。 */ protected void removeRange(int fromIndex, int toIndex) &#123; ListIterator&lt;E&gt; it = listIterator(fromIndex); for (int i=0, n=toIndex-fromIndex; i&lt;n; i++) &#123; it.next(); it.remove(); &#125; &#125; /** * list发生结构性变化的次数。 * 结构性变化是指改变list的长度，或是其他会使迭代器结果混乱的变化。 * * 本字段将被iterator()返回的iterator及listIterator()返回的listIterator使用。 * 若本字段发生了 iterator/listIterator 所没有预期到的变化 * 则在调用 iterator/listIterator 的: * next() * remove() * previous() * set(E e) * add(E e) * 出现fail-fast时抛出ConcurrentModificationException。 * * 在迭代过程中，若检测到并发性变化 * 则直接判定为失败并抛出异常(fail-fast) * 而不会去进一步检测所发生的并发性变化是否真的会对迭代造成影响(non-deterministic)。 * * 子类可自行选择是否使用本字段。 * 若子类决定继承本类的fail-fast判定 * 则只需要在会引发结构性变化的方法中增加本字段的值。 * 本类中已实现的引发结构性变化的方法有: * add(int index, E element) * remove(int index) * * 调用一次add(int index, E element)或remove(int index) * 只需将本字段自增1，表示发生了一次结构性变化 * 否则 iterator/listIterator 会抛出错误的ConcurrentModificationException。 * * 若子类不想遵循fail-fast，忽略本字段即可。 */ protected transient int modCount = 0; /** * 注1:rangeCheckForAdd(int index) */ private void rangeCheckForAdd(int index) &#123; if (index &lt; 0 || index &gt; size()) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; private String outOfBoundsMsg(int index) &#123; return &quot;Index: &quot;+index+&quot;, Size: &quot;+size(); &#125;&#125;class SubList&lt;E&gt; extends AbstractList&lt;E&gt; &#123; /** * 原list */ private final AbstractList&lt;E&gt; l; /** * 生成视图时的偏移量 * 即原list.subList(int fromIndex, int toIndex)中的fromIndex。 */ private final int offset; /** * 视图包含元素数 * 初始时为原list.subList(int fromIndex, int toIndex)中的toIndex-fromIndex。 */ private int size; SubList(AbstractList&lt;E&gt; list, int fromIndex, int toIndex) &#123; if (fromIndex &lt; 0) throw new IndexOutOfBoundsException(&quot;fromIndex = &quot; + fromIndex); if (toIndex &gt; list.size()) throw new IndexOutOfBoundsException(&quot;toIndex = &quot; + toIndex); if (fromIndex &gt; toIndex) throw new IllegalArgumentException(&quot;fromIndex(&quot; + fromIndex + &quot;) &gt; toIndex(&quot; + toIndex + &quot;)&quot;); l = list; offset = fromIndex; size = toIndex - fromIndex; this.modCount = l.modCount; &#125; /** * 重写父类:java.util.AbstractList&lt;E&gt; * * 用element替换视图索引值(视图内部的相对值)为index的元素。 * 方法返回被替换的元素。 * * @throws UnsupportedOperationException list不支持本方法。 * @throws ClassCastException element因为其所属的类禁止被插入list。 * @throws NullPointerException element==null且list禁止包含空元素。 * @throws IllegalArgumentException element因其某些属性禁止被插入list。 * @throws IndexOutOfBoundsException 索引越界(index &lt; 0 || index &gt;= size)。 */ public E set(int index, E element) &#123; // 注4:rangeCheck(index) rangeCheck(index); // 注2:checkForComodification() checkForComodification(); return l.set(index+offset, element); &#125; /** * 重写父类:java.util.AbstractList&lt;E&gt; * * 返回视图中索引(视图内部的相对值)位置为index的元素。 * * @throws IndexOutOfBoundsException 索引越界(index &lt; 0 || index &gt;= size)。 */ public E get(int index) &#123; // 注4:rangeCheck(index) rangeCheck(index); // 注2:checkForComodification() checkForComodification(); return l.get(index+offset); &#125; /** * 重写父类:java.util.AbstractList&lt;E&gt; */ public int size() &#123; // 注2:checkForComodification() checkForComodification(); return size; &#125; /** * 重写父类:java.util.AbstractList&lt;E&gt; * * 将element插入视图的index(视图内部的相对值)下标处。原来处于index下标及以后的元素均向后移动一个位置。 * * 视图.add(&quot;1&quot;); * 视图.add(视图.size(), &quot;1&quot;); * 二者等效。 * * @throws UnsupportedOperationException list不支持本方法。 * @throws ClassCastException element因为其所属的类禁止被插入list。 * @throws NullPointerException element==null且list禁止包含空元素。 * @throws IllegalArgumentException element因其某些属性禁止被插入list。 * @throws IndexOutOfBoundsException 索引越界(index &lt; 0 || index &gt; size)。 */ public void add(int index, E element) &#123; // 注1:rangeCheckForAdd(int index) rangeCheckForAdd(index); // 注2:checkForComodification() checkForComodification(); l.add(index+offset, element); this.modCount = l.modCount; size++; &#125; /** * 重写父类:java.util.AbstractList&lt;E&gt; * * 移除视图中索引值为index(视图内部的相对值)的元素。后续元素左移一个位置。返回被移除的元素。 * * @throws UnsupportedOperationException list不支持本方法。 * @throws IndexOutOfBoundsException 索引越界(index &lt; 0 || index &gt;= size)。 */ public E remove(int index) &#123; // 注4:rangeCheck(index) rangeCheck(index); // 注2:checkForComodification() checkForComodification(); E result = l.remove(index+offset); this.modCount = l.modCount; size--; return result; &#125; /** * 重写父类:java.util.AbstractList&lt;E&gt; * * 后文注释讨论的list均是指视图，其中的index均是视图中的相对值 * * 移除list索引区间为[fromIndex,toIndex)的全部元素。 * 并将后续元素左移补位。 * 本方法减少了list中(toIndex - fromIndex)个元素。 * 若有toIndex==fromIndex，则本方法实际并未对list产生影响。 */ protected void removeRange(int fromIndex, int toIndex) &#123; // 注2:checkForComodification() checkForComodification(); l.removeRange(fromIndex+offset, toIndex+offset); this.modCount = l.modCount; size -= (toIndex-fromIndex); &#125; /** * 重写父类:java.util.AbstractList&lt;E&gt; */ public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(size, c); &#125; /** * 重写父类:java.util.AbstractList&lt;E&gt; * * 后文注释讨论的list均是指视图，其中的index均是视图中的相对值 * * 将c中所有元素插入list的指定位置(index)，插入顺序为c的迭代器取出的顺序。 * 原index位置及以后位置的元素顺次向后移动，空出装载c的位置。 * * 本方法并未定义如下事件发生时的解决策略： * 在将c中的元素添加至list的过程中c发生变化 * 这也意味着如下事件的解决策略同样未定义：将一个非空list添加至自身。 * * 若list因本方法发生变化则返回true，反之返回false。 * * list.addAll(set); * list.addAll(list.size(), set); * 二者等价。 * * @throws UnsupportedOperationException list不支持本方法。 * @throws ClassCastException c中任意一个元素因为其所属的类禁止被插入list。 * @throws NullPointerException c中任意一个元素为null且list禁止包含空元素；或c==null。 * @throws IllegalArgumentException c中任意一个元素因其某些属性禁止被插入list。 * @throws IndexOutOfBoundsException 索引越界(index &lt; 0 || index &gt; size)。 */ public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; // 注1:rangeCheckForAdd(int index) rangeCheckForAdd(index); int cSize = c.size(); if (cSize==0) return false; // 注2:checkForComodification() checkForComodification(); l.addAll(offset+index, c); this.modCount = l.modCount; size += cSize; return true; &#125; /** * 重写父类:java.util.AbstractList&lt;E&gt; * * 方法的调用链为： * SubList.iterator() -&gt; * AbstractList.listIterator() -&gt; * SubList.listIterator(final int index) * * 若调用SubList.listIterator() * 因SubList未重写该方法，因此依然是调用AbstractList.listIterator() * * 因此，对于SubList * iterator()及listIterator()其实是一回事 * 最终都是调用SubList.listIterator(final int index) */ public Iterator&lt;E&gt; iterator() &#123; return listIterator(); &#125; /** * 重写父类:java.util.AbstractList&lt;E&gt; * * 后文注释讨论的list均是指视图，其中的index均是视图中的相对值 * * 返回一个list按固有顺序迭代的listIterator * 迭代开始时游标位于索引[index-1,index]之间。 * * 使用本方法得到listIterator后 * 若第一次调用的是listIterator.next()，返回的元素的索引是index * 同理，若第一次调用的是listIterator.previous()，返回的是索引为index-1的元素。 * * @throws IndexOutOfBoundsException 索引越界(index &lt; 0 || index &gt; size)。 */ public ListIterator&lt;E&gt; listIterator(final int index) &#123; // 注2:checkForComodification() checkForComodification(); // 注1:rangeCheckForAdd(int index) rangeCheckForAdd(index); return new ListIterator&lt;E&gt;() &#123; private final ListIterator&lt;E&gt; i = l.listIterator(index+offset); public boolean hasNext() &#123; return nextIndex() &lt; size; &#125; public E next() &#123; if (hasNext()) return i.next(); else throw new NoSuchElementException(); &#125; public boolean hasPrevious() &#123; return previousIndex() &gt;= 0; &#125; public E previous() &#123; if (hasPrevious()) return i.previous(); else throw new NoSuchElementException(); &#125; public int nextIndex() &#123; return i.nextIndex() - offset; &#125; public int previousIndex() &#123; return i.previousIndex() - offset; &#125; public void remove() &#123; i.remove(); SubList.this.modCount = l.modCount; size--; &#125; public void set(E e) &#123; i.set(e); &#125; public void add(E e) &#123; i.add(e); SubList.this.modCount = l.modCount; size++; &#125; &#125;; &#125; /** * 重写父类:java.util.AbstractList&lt;E&gt; * * 即视图的视图。 * 此时视图被看作是原list * 但无论如何，最终操作的始终都是最原始的那个list。 * 一切视图都是对偏移量逻辑的封装 */ public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; return new SubList&lt;&gt;(this, fromIndex, toIndex); &#125; /** * 注4:rangeCheck(index) */ private void rangeCheck(int index) &#123; if (index &lt; 0 || index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; /** * 注1:rangeCheckForAdd(int index) */ private void rangeCheckForAdd(int index) &#123; if (index &lt; 0 || index &gt; size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; private String outOfBoundsMsg(int index) &#123; return &quot;Index: &quot;+index+&quot;, Size: &quot;+size; &#125; /** * 注2:checkForComodification() */ private void checkForComodification() &#123; if (this.modCount != l.modCount) throw new ConcurrentModificationException(); &#125;&#125;class RandomAccessSubList&lt;E&gt; extends SubList&lt;E&gt; implements RandomAccess &#123; RandomAccessSubList(AbstractList&lt;E&gt; list, int fromIndex, int toIndex) &#123; super(list, fromIndex, toIndex); &#125; /** * 重写父类:java.util.SubList&lt;E&gt; */ public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; return new RandomAccessSubList&lt;&gt;(this, fromIndex, toIndex); &#125;&#125; 已整理层级关系本类直接继承的类 java.util.AbstractCollection&lt;E&gt; 本类直接实现的接口 java.util.List&lt;E&gt; 直接继承本类的类 java.util.ArrayList&lt;E&gt; java.util.Vector&lt;E&gt; 综述本类是Java集合框架中的一员，提供了基于支持随机访问的存储结构(形如数组)的List接口的基本实现。 若需实现顺序存储的List(形如链表)，则比起本类，更推荐继承本类的子类，更特化的AbstractSequentialList。 若需实现一个不需改变的List，程序员只需继承本类，并实现get(int index)及size()。 例如，本类某不可变的实现如下(为了填入数据，至少还需要初始化数据的代码，这里放到了构造函数中)： 1234567891011121314151617181920import java.util.AbstractList;public class UnmoCol&lt;E&gt; extends AbstractList&lt;E&gt; &#123; private E[] array; public UnmoCol(E[] array) &#123; this.array = array; &#125; @Override public E get(int index) &#123; return this.array[index]; &#125; @Override public int size() &#123; return this.array.length; &#125;&#125; 调用demo如下： 12345678910111213import java.util.AbstractList;import java.util.Iterator;public class Main &#123; public static void main(String[] args) &#123; AbstractList&lt;String&gt; unmoCol = new UnmoCol&lt;String&gt;(new String[]&#123;&quot;reimu&quot;, &quot;wang&quot;&#125;); System.out.println(unmoCol.size()); for (String s : unmoCol) System.out.println(s); Iterator&lt;String&gt; iterator = unmoCol.iterator(); while (iterator.hasNext()) System.out.println(iterator.next()); &#125;&#125; 执行本demo输出如下： 123452reimuwangreimuwang 若需实现一个可变的List，程序员必须额外重写set(int index, E element)，否则会抛出UnsupportedOperationException。若需要List长度可变，程序员必须额外重写add(int index, E element)及remove(int index)。 例如，某个实现如下： 1234567891011121314151617181920212223242526272829303132333435import java.util.AbstractList;import java.util.ArrayList;import java.util.List;public class Mocol&lt;E&gt; extends AbstractList&lt;E&gt; &#123; private List&lt;E&gt; list = new ArrayList&lt;E&gt;(); @Override public E get(int index) &#123; return this.list.get(index); &#125; @Override public int size() &#123; return this.list.size(); &#125; @Override public void add(int index, E element) &#123; this.list.add(index, element); this.modCount++; // 发生结构性变化的次数+1 &#125; @Override public E remove(int index) &#123; this.modCount++; // 发生结构性变化的次数+1 return this.list.remove(index); &#125; @Override public E set(int index, E element) &#123; return this.list.set(index, element); &#125;&#125; 调用demo如下： 12345678910111213141516import java.util.AbstractList;public class Main &#123; public static void main(String[] args) &#123; AbstractList&lt;String&gt; mocol = new Mocol&lt;String&gt;(); mocol.add(&quot;wang&quot;); mocol.add(0, &quot;reimu&quot;); for (String str : mocol) System.out.println(str); System.out.println(mocol.size()); mocol.remove(0); for (String str : mocol) System.out.println(str); mocol.set(0, &quot;change&quot;); for (String str : mocol) System.out.println(str); &#125;&#125; 执行本demo输出如下： 12345reimuwang2wangchange Java集合框架规范建议程序员在继承本类时实现两个构造函数：void(无参数)构造函数；接收一个collection的构造函数。 与其他的Collection接口的抽象实现类不同，程序员在继承本类时不需要提供iterator的实现。本类已实现了iterator及list iterator。 在此之上，程序员需实现或重写那些用于”随机访问”的方法： 1234get(int index) // 默认abstractset(int index, E element) // 默认抛出UnsupportedOperationExceptionadd(int index, E element) // 默认抛出UnsupportedOperationExceptionremove(int index) // 默认抛出UnsupportedOperationException 本类所有的非抽象方法都会在文档中有详细的实现描述。这些方法均可被重写。 注1:rangeCheckForAdd(int index)若(index &lt; 0 || index &gt; size())则抛出IndexOutOfBoundsException。 注2:checkForComodification()对于迭代器而言，若modCount != expectedModCount，则认为list存在同步性问题，抛出ConcurrentModificationException。 对于视图而言，若this.modCount != l.modCount，则认为list存在同步性问题，抛出ConcurrentModificationException。 注3:Itr.remove()测试123456789101112131415161718192021222324252627282930import java.util.AbstractList;import java.util.ArrayList;import java.util.List;public class AbstractListTest&lt;E&gt; extends AbstractList&lt;E&gt; &#123; private List&lt;E&gt; list = new ArrayList&lt;E&gt;(); @Override public E get(int index) &#123; return this.list.get(index); &#125; @Override public int size() &#123; return this.list.size(); &#125; @Override public void add(int index, E element) &#123; this.list.add(index, element); this.modCount++; &#125; @Override public E remove(int index) &#123; this.modCount++; return this.list.remove(index); &#125;&#125; 调用： 123456789101112131415161718package com.collectiontest.main;import java.util.AbstractList;import java.util.Iterator;public class Main &#123; public static void main(String[] args) &#123; AbstractList&lt;String&gt; abstractListTest = new AbstractListTest&lt;String&gt;(); abstractListTest.add(&quot;reimu&quot;); abstractListTest.add(&quot;wang&quot;); Iterator&lt;String&gt; iterator1 = abstractListTest.iterator(); Iterator&lt;String&gt; iterator2 = abstractListTest.iterator(); System.out.println(iterator1.next()); iterator1.remove(); System.out.println(iterator2.next()); &#125;&#125; 结果： 12345reimuException in thread &quot;main&quot; java.util.ConcurrentModificationException at java.util.AbstractList$Itr.checkForComodification(AbstractList.java:386) at java.util.AbstractList$Itr.next(AbstractList.java:355) at com.collectiontest.main.Main.main(Main.java:16) 注4:rangeCheck(index)若index &lt; 0 || index &gt;= size则抛出IndexOutOfBoundsException。 未整理层级关系直接继承本类的类 java.util.AbstractSequentialList&lt;E&gt;]]></content>
      <categories>
        <category>Java JDK7源码</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
        <tag>Collection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java JDK7源码-java.util.AbstractCollection&lt;E&gt;]]></title>
    <url>%2F2017%2F06%2F19%2FJava%20JDK7%E6%BA%90%E7%A0%81-javautilAbstractCollectionE%2F</url>
    <content type="text"><![CDATA[源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440package java.util;public abstract class AbstractCollection&lt;E&gt; implements Collection&lt;E&gt; &#123; protected AbstractCollection() &#123; &#125; /** * 实现接口:java.util.Collection&lt;E&gt; * * 查询操作。 * 返回一个集合的迭代器，该迭代器默认从头开始迭代。 */ public abstract Iterator&lt;E&gt; iterator(); /** * 实现接口:java.util.Collection&lt;E&gt; * * 查询操作。 * 返回集合包含的元素个数。 * 若集合包含的元素个数大于Integer.MAX_VALUE，则返回Integer.MAX_VALUE。 */ public abstract int size(); /** * 实现接口:java.util.Collection&lt;E&gt; * * 查询操作。 * 若集合不包含元素则返回true。反之返回false。 */ public boolean isEmpty() &#123; return size() == 0; &#125; /** * 实现接口:java.util.Collection&lt;E&gt; * * 查询操作。 * 若集合包含o则返回true，反之返回false。 * 更具体的说，当且仅当集合包含至少一个元素e，满足(o==null ? e==null : o.equals(e))时，返回true，反之返回false。 * 本方法会用迭代器迭代集合中的每个元素，检查每个元素是否与o相等。 * * 本方法与后文介绍的containsAll(Collection&lt;?&gt; c)方法很相似，可对比学习。 * * @throws ClassCastException o的类型与集合不相容。 * @throws NullPointerException o==null且集合不允许空元素存在。 */ public boolean contains(Object o) &#123; Iterator&lt;E&gt; it = iterator(); if (o==null) &#123; while (it.hasNext()) if (it.next()==null) return true; &#125; else &#123; while (it.hasNext()) if (o.equals(it.next())) return true; &#125; return false; &#125; /** * 实现接口:java.util.Collection&lt;E&gt; * * 查询操作。 * 本方法是连接集合与数组之间的桥梁。 * * 返回一个包含集合所有元素的数组，该数组由集合的迭代器遍历而得，数组中元素的顺序与迭代器遍历而得的顺序相同。 * 返回的数组的长度等于迭代器遍历而得的元素的个数。 * 在本方法的开始会调用一次size()得到集合的长度 * 通常情况下这与迭代器遍历而得的元素个数相同。 * 但是集合在迭代过程中发生结构性变化时，最终返回的数组的长度以迭代器实际取出的元素个数为准，这个长度可能会与之前调用的size()方法时得到的结果不同。 * * 本方法等价于： * List&lt;E&gt; list = new ArrayList&lt;E&gt;(size()); * for (E e : this) list.add(e); * return list.toArray(); * * 返回的数组与集合之间不存在引用关系(即使集合是基于数组的)，数组中的元素是集合中的元素的浅拷贝。 * * 本方法与后文介绍的toArray(T[] a)方法很相似，可对比学习。 */ public Object[] toArray() &#123; Object[] r = new Object[size()]; Iterator&lt;E&gt; it = iterator(); for (int i = 0; i &lt; r.length; i++) &#123; if (! it.hasNext()) // 迭代器得到的元素少于预期，发生截断 // 注1：Arrays.copyOf(r, i) return Arrays.copyOf(r, i); r[i] = it.next(); &#125; // 若it.hasNext()==true说明迭代器得到的元素多于预期：即集合在迭代过程中长度增加 // 注2：finishToArray(r, it) return it.hasNext() ? finishToArray(r, it) : r; &#125; /** * 实现接口:java.util.Collection&lt;E&gt; * * 查询操作。 * 本方法是连接集合与数组之间的桥梁。 * * 返回包含集合所有元素的数组。返回数组的类型即为a的类型。顺序为迭代器的迭代顺序。 * 具体规则的伪代码为： * if (a.length &lt; collection.size()) * 不修改a，而是以a的类型新建长度为collection.size()的数组并填入集合中的值，随后返回这个新生成的数组。 * else if (a.length == collection.size() * 将返回的结果直接填入a后返回a(若a中已有值，则a中的原值会被覆盖)。 * else * 数组索引在[0, collection.size() -1]的元素会被集合对应位置的元素覆盖。 * 数组索引 == collection.size()的元素会被置为null * 数组中后续元素(如果有的话)不变。 * * 若集合不允许包含空元素，则本方法此时可用来计算集合的长度：返回的数组第一次出现null的索引即为集合的长度。 * * 返回的数组与集合之间不存在引用关系(即使集合的底层就是基于数组实现的)，数组中的元素是集合中元素的浅拷贝。 * * 小例子： * String[] y = x.toArray(new String[0]); * x是一个元素类型为String的集合，则上述语句会将x中的元素依序复制一份浅拷贝到数组y。 * * 关于本方法与前文介绍的toArray()方法，需明确： * collection.toArray() * collection.toArray(new Object[s]) * 当s &lt; collection.size()时，上述两行代码的效果等价。 * * 返回数组的有效长度(数组中属于集合中的元素的长度)等于迭代器遍历而得的元素的个数。 * 本方法开始时会调用一次size()得到集合的长度，通常情况下这与迭代器遍历而得的元素个数相同。 * 但当集合在迭代过程中发生结构性变化时，最终返回的数组的有效长度以迭代器实际取出的元素个数为准。 * 这个长度可能会与之前调用size()时得到的结果不同。 * * 注4：toArray(T[] a)的调用示例 * * 本方法与前文介绍的toArray()方法很相似，可对比学习。 * * @throws ArrayStoreException a的类型collection不支持。 * @throws NullPointerException null==a。 */ public &lt;T&gt; T[] toArray(T[] a) &#123; int size = size(); // 以a中元素的类型为基础，根据反射新声明一个长度为size的数组 T[] r = a.length &gt;= size ? a : (T[])java.lang.reflect.Array .newInstance(a.getClass().getComponentType(), size); Iterator&lt;E&gt; it = iterator(); for (int i = 0; i &lt; r.length; i++) &#123; if (! it.hasNext()) &#123; // 迭代器得到元素少于预期，可能原因有2: // 1.迭代过程中集合的元素减少。 // 2.a.length&gt;size if (a == r) &#123; // a.length&gt;=size，此时操作r与操作a等效。 r[i] = null; // 后续else都是在处理a.length&lt;size的情况。 // 此时r与a是两个完全不同的数组。 &#125; else if (a.length &lt; i) &#123; // 此时少于预期的原因无论是1或2，集合依然无法放入a中。 // 注1：Arrays.copyOf(r, i) // 截取r并返回截取后的数组 return Arrays.copyOf(r, i); &#125; else &#123; // 此时虽然最初有a.length&lt;size，但是因为原因1，a又能装下集合了。 // 因此仍然选择将集合存入a。 // 注3：System.arraycopy(r, 0, a, 0, i) // 调用此方法时有：r.length=size&gt;a.length&gt;=i // 因此前有值时操作的均为r，故将r中的数据复制索引[0,i-1]至a。 System.arraycopy(r, 0, a, 0, i); if (a.length &gt; i) &#123; // a.length==i的情况不需要置null。 a[i] = null; &#125; &#125; return a; &#125; r[i] = (T)it.next(); &#125; // 迭代器得到元素多于预期。 // 可能的原因为：迭代过程中集合的元素增加。 // 注2：finishToArray(r, it) return it.hasNext() ? finishToArray(r, it) : r; &#125; /** * 通常情况下，允许创建的最大数组长度 * * 某些JVM会在数组中存储同步关键词 * 因此在声明容量较大的数组时应注意避免OutOfMemoryError * -8是一个相对安全的经验之谈，具体是否出错还要看实际的JVM实现 */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; /** * 在调用toArray(T[] a)或toArray()时 * 若迭代器返回的元素个数多于预期，则会调用本方法返回新数组，对原数组进行扩容 * 并将迭代器中多于预期的元素填入新数组 */ private static &lt;T&gt; T[] finishToArray(T[] r, Iterator&lt;?&gt; it) &#123; int i = r.length; while (it.hasNext()) &#123; int cap = r.length; if (i == cap) &#123; // 本if中是一次扩容操作： // 当前待插入索引i==r.length时需扩容。 // 若本句越界，则不会进入后面的if条件，会在调用Arrays.copyOf(r, newCap);时抛出异常。 int newCap = cap + (cap &gt;&gt; 1) + 1; // 满足进入本if的条件很苛刻： // newCap &gt; MAX_ARRAY_SIZE &amp;&amp; newCap &lt; Integer.MAX_VALUE。只有7个值。 // 进入本if说明当前的newCap OutOfMemoryError的风险较高。 if (newCap - MAX_ARRAY_SIZE &gt; 0) // 使用cap重新计算一个相对安全的newCap // hugeCapacity(cap + 1):见紧随本方法之后的下一个方法 // cap + 1为此时能允许的最小长度，因为cap已经不够用了 newCap = hugeCapacity(cap + 1); // 执行扩容操作。扩容后r已指向了一个全新的数组 r = Arrays.copyOf(r, newCap); // 注1 &#125; r[i++] = (T)it.next(); &#125; // 若扩容后的数组过大则将多余位置截断 return (i == r.length) ? r : Arrays.copyOf(r, i); &#125; /** * 当数组规模极大时才需要调用本方法。 * minCapacity为调用方能接受的最小扩容后的数组长度。 * * 本方法判断minCapacity的值系统是否可接受 * 若能接受则基于minCapacity返回一个合理的扩容后的长度，若不能接受则抛出OutOfMemoryError。 */ private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // minCapacity本来为一个极大的数，此处minCapacity&lt;0说明其已越界。 throw new OutOfMemoryError (&quot;Required array size too large&quot;); // 如果可能尽量将大小的上限控制为MAX_ARRAY_SIZE。 // 如果调用方能接受的容量范围在(MAX_ARRAY_SIZE,Integer.MAX_VALUE]， // 此时虽然OutOfMemoryError的风险较大，但系统仍会返回Integer.MAX_VALUE。 return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; /** * 实现接口:java.util.Collection&lt;E&gt; * * 修改操作 * 本方法始终抛出UnsupportedOperationException * * @throws UnsupportedOperationException 集合不支持本方法。 * @throws ClassCastException e因其类型禁止被插入集合。 * @throws NullPointerException e==null且集合禁止包含null。 * @throws IllegalArgumentException e因其某些属性禁止被插入集合。 * @throws IllegalStateException 因插入限制，此时e不能被插入集合。 */ public boolean add(E e) &#123; throw new UnsupportedOperationException(); &#125; /** * 实现接口:java.util.Collection&lt;E&gt; * * 修改操作。 * 若本方法改变了集合则返回true，反之返回false。 * * 使用集合的迭代器遍历集合 * 并用iterator.remove()移除集合符合条件的元素e： * (o==null ? e==null : o.equals(e))。 * 若有多个e符合条件，则本方法只会移除iterator遍历得到的第一个。 * * 若集合包含o且其迭代器未实现remove()，则抛出UnsupportedOperationException。 * * 本方法与后文介绍的removeAll(Collection&lt;?&gt; c)方法很相似，可对比学习。 * * @throws UnsupportedOperationException 集合不支持本方法。 * @throws ClassCastException o的类型与集合不相容。 * @throws NullPointerException o==null且集合不允许空元素存在。 */ public boolean remove(Object o) &#123; Iterator&lt;E&gt; it = iterator(); if (o==null) &#123; while (it.hasNext()) &#123; if (it.next()==null) &#123; it.remove(); return true; &#125; &#125; &#125; else &#123; while (it.hasNext()) &#123; if (o.equals(it.next())) &#123; it.remove(); return true; &#125; &#125; &#125; return false; &#125; /** * 实现接口:java.util.Collection&lt;E&gt; * * 批量查询操作。 * 若集合包含c中所有元素则返回true，反之返回false。 * * 本方法与前文介绍的contains(Object o)方法很相似，可对比学习。 * * @throws ClassCastException c中至少有一个元素的类型与集合不相容。 * @throws NullPointerException c==null或 * c中至少有一个元素为null且集合不允许空元素存在。 */ public boolean containsAll(Collection&lt;?&gt; c) &#123; for (Object e : c) if (!contains(e)) return false; return true; &#125; /** * 实现接口:java.util.Collection&lt;E&gt; * * 批量修改操作 * 将c中所有元素插入集合。 * 若集合因本方法发生变化则返回true，反之返回false。 * * 本方法未定义如下事件发生时的解决策略：在将c中的元素添加至集合的过程中c发生变化。 * 这也意味着如下事件的解决策略同样未定义：将一个非空集合添加至自身。 * * 在c!=null的前提下，若未重写add(E e)，则本方法将抛出UnsupportedOperationException。 * * 本方法与前文介绍的add(E e)方法很相似，可对比学习。 * * @throws UnsupportedOperationException 集合不支持本方法。 * @throws ClassCastException c中任意一个元素因其类型禁止被插入集合。 * @throws NullPointerException c==null或 * c中至少有一个元素为null且集合不允许空元素存在。 * @throws IllegalArgumentException c中任意一个元素因其某些属性禁止被插入集合。 * @throws IllegalStateException 因插入限制，此时并非c中所有元素都能被插入集合。 */ public boolean addAll(Collection&lt;? extends E&gt; c) &#123; boolean modified = false; for (E e : c) if (add(e)) modified = true; return modified; &#125; /** * 实现接口:java.util.Collection&lt;E&gt; * * 批量修改操作 * 从集合中移除所有与c的交集元素(求差集)。 * 若集合因本方法发生变化则返回true，反之返回false。 * * 若迭代器未实现remove()且集合至少有一个元素在c中则抛出UnsupportedOperationException。 * * 本方法与前文介绍的remove(Object o)方法很相似，可对比学习。 * 本方法与后文介绍的retainAll(Collection&lt;?&gt; c)方法正相反，可对比学习。 * * @throws UnsupportedOperationException 集合不支持本方法。 * @throws ClassCastException c中至少有一个元素的类型与集合不相容。 * @throws NullPointerException c==null或 * 集合中至少有一个元素为null且c不允许空元素存在。 */ public boolean removeAll(Collection&lt;?&gt; c) &#123; boolean modified = false; Iterator&lt;?&gt; it = iterator(); while (it.hasNext()) &#123; if (c.contains(it.next())) &#123; it.remove(); modified = true; &#125; &#125; return modified; &#125; /** * 实现接口:java.util.Collection&lt;E&gt; * * 批量修改操作 * 保留集合中与c的交集元素。 * 若集合因本方法发生变化则返回true，反之返回false。 * * 若迭代器未实现remove()且集合至少有一个元素不在c中则抛出UnsupportedOperationException。 * * 本方法与前文介绍的removeAll(Collection&lt;?&gt; c)方法正相反，可对比学习。 * * @throws UnsupportedOperationException 集合不支持本方法。 * @throws ClassCastException c中至少有一个元素的类型与集合不相容。 * @throws NullPointerException c==null或 * 集合中至少有一个元素为null且c不允许空元素存在。 */ public boolean retainAll(Collection&lt;?&gt; c) &#123; boolean modified = false; Iterator&lt;E&gt; it = iterator(); while (it.hasNext()) &#123; if (!c.contains(it.next())) &#123; it.remove(); modified = true; &#125; &#125; return modified; &#125; /** * 实现接口:java.util.Collection&lt;E&gt; * * 批量修改操作 * 清空集合。 * * 若迭代器未实现remove()且集合非空则抛出UnsupportedOperationException。 * * @throws UnsupportedOperationException 集合不支持本方法。 */ public void clear() &#123; Iterator&lt;E&gt; it = iterator(); while (it.hasNext()) &#123; it.next(); it.remove(); &#125; &#125; /** * 字符串变换 * 返回集合的字符串表述： * [e1, e2, e3] * 其中e1,e2,e3为集合按其迭代器顺序排列的元素。 * * 注5 toString()调用示例 */ public String toString() &#123; Iterator&lt;E&gt; it = iterator(); if (! it.hasNext()) return &quot;[]&quot;; StringBuilder sb = new StringBuilder(); sb.append(&apos;[&apos;); for (;;) &#123; E e = it.next(); // 防止自包含时无限递归 sb.append(e == this ? &quot;(this Collection)&quot; : e); if (! it.hasNext()) return sb.append(&apos;]&apos;).toString(); sb.append(&apos;,&apos;).append(&apos; &apos;); &#125; &#125;&#125; 已整理层级关系本类直接实现的接口 java.util.Collection&lt;E&gt; 直接继承本类的类 java.util.AbstractList&lt;E&gt; java.util.AbstractSet&lt;E&gt; java.util.AbstractQueue&lt;E&gt; 综述本类是Java集合框架中的一员，提供了Collection接口的基本实现。 如果要实现一个不需要改变的集合，程序员仅仅需要继承本类然后提供iterator()(iterator()返回的iterator必须实现hasNext()及next())及size()的实现。 例如，某个不可变的实现如下(为了填入数据，至少还需要初始化数据的代码，笔者将其放到了构造函数中)： 12345678910111213141516171819202122232425import java.util.AbstractCollection;import java.util.Collection;import java.util.HashMap;import java.util.Iterator;import java.util.Map;public class UnmoCol&lt;E&gt; extends AbstractCollection&lt;E&gt; &#123; private Map&lt;E, Object&gt; map = new HashMap&lt;E, Object&gt;(); public UnmoCol(Collection&lt;E&gt; c) &#123; Iterator&lt;E&gt; cIterator = c.iterator(); while (cIterator.hasNext()) this.map.put(cIterator.next(), new Object()); &#125; @Override public Iterator&lt;E&gt; iterator() &#123; return this.map.keySet().iterator(); &#125; @Override public int size() &#123; return this.map.size(); &#125;&#125; 调用demo如下： 1234567891011121314151617import java.util.Collection;import java.util.HashSet;import java.util.Iterator;import java.util.Set;public class Main &#123; public static void main(String[] args) &#123; Set&lt;String&gt; set = new HashSet&lt;String&gt;(); set.add(&quot;reimu&quot;); set.add(&quot;wang&quot;); Collection&lt;String&gt; collection = new UnmoCol&lt;String&gt;(set); System.out.println(collection.size()); Iterator&lt;String&gt; iterator = collection.iterator(); while (iterator.hasNext()) System.out.println(iterator.next()); &#125;&#125; 执行后输出如下： 1232reimuwang 如果要实现一个可变的集合，程序员必须重写本类的add(E e)方法(否则会抛出UnsupportedOperationException)。然后iterator()返回的iterator必须实现hasNext(),next(),remove()。 例如，某个实现如下： 123456789101112131415161718192021222324import java.util.AbstractCollection;import java.util.HashMap;import java.util.Iterator;import java.util.Map;public class Mocol&lt;E&gt; extends AbstractCollection&lt;E&gt; &#123; private Map&lt;E, Object&gt; map = new HashMap&lt;E, Object&gt;(); @Override public Iterator&lt;E&gt; iterator() &#123; return this.map.keySet().iterator(); &#125; @Override public int size() &#123; return this.map.size(); &#125; @Override public boolean add(E e) &#123; return this.map.put(e, new Object()) == null; &#125;&#125; 调用demo如下： 1234567891011121314import java.util.Collection;import java.util.Iterator;public class Main &#123; public static void main(String[] args) &#123; Collection&lt;String&gt; collection = new Mocol&lt;String&gt;(); collection.add(&quot;reimu&quot;); collection.add(&quot;wang&quot;); System.out.println(collection.size()); Iterator&lt;String&gt; iterator = collection.iterator(); while (iterator.hasNext()) System.out.println(iterator.next()); &#125;&#125; 执行本demo输出如下： 1232reimuwang Java语言规范建议程序员在继承本类时实现两个构造函数：void(无参)构造函数。接收一个collection的构造函数。 综上所述，现写本类的测试继承类如下： 1234567891011121314151617181920212223242526272829303132import java.util.AbstractCollection;import java.util.Collection;import java.util.HashMap;import java.util.Iterator;public class AbstractCollectionTest&lt;E&gt; extends AbstractCollection&lt;E&gt; &#123; private HashMap&lt;E, Object&gt; map = new HashMap&lt;E, Object&gt;(); public AbstractCollectionTest() &#123; &#125; public AbstractCollectionTest(Collection&lt;E&gt; c) &#123; Iterator&lt;E&gt; cIterator = c.iterator(); while (cIterator.hasNext()) this.map.put(cIterator.next(), new Object()); &#125; @Override public Iterator&lt;E&gt; iterator() &#123; return this.map.keySet().iterator(); &#125; @Override public int size() &#123; return this.map.size(); &#125; @Override public boolean add(E e) &#123; return map.put(e, new Object()) == null; &#125;&#125; 注1：Arrays.copyOf(r, i)以r为基础返回一个长度为i的数组。 若i&lt;r.length则r发生截断。实际返回的数组为r中索引为[0,i-1]的元素。 若i==r.length，则返回的数组与r相等。 若i&gt;r.length，返回的数组中索引为[0, r.length-1]的元素为r中对应位置的元素，索引为[r.length, i-1]的元素以null填充。 无论如何，返回的数组都是新生成的，与r不存在引用关系。返回的数组中的元素是r中元素的浅拷贝。 注2：finishToArray(r, it)finishToArray(r, it)会以r为基础声明一个长度足够的新数组r2，并将it中超出预期仍未取完的元素添加至r2，而后返回r2。 注3：System.arraycopy(r, 0, a, 0, i)参数含义依次为： r: 待复制的源数组。 0: 源数组中开始复制的索引。 a: 复制目标数组。 0: 目标数组中接收元素的起始索引。 i: 复制的元素个数。 注4：toArray(T[] a)的调用示例示例1： 12345678910111213141516import java.util.Collection;import java.util.HashSet;import java.util.Set;public class Main &#123; public static void main(String[] args) &#123; Set&lt;String&gt; set = new HashSet&lt;String&gt;(); set.add(&quot;reimu&quot;); set.add(&quot;wang&quot;); Collection&lt;String&gt; collection = new UnmoCol&lt;String&gt;(set); String[] a = &#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;&#125;; String[] a1 = collection.toArray(a); for (String e : a1) System.out.println(e); &#125;&#125; 输出结果： 1234reimuwangnull4 示例2 123456789101112131415161718package com.collectiontest.main;import java.util.Collection;import java.util.HashSet;import java.util.Set;public class Main &#123; public static void main(String[] args) &#123; Set&lt;String&gt; set = new HashSet&lt;String&gt;(); set.add(&quot;reimu&quot;); set.add(&quot;wang&quot;); Collection&lt;String&gt; collection = new UnmoCol&lt;String&gt;(set); String[] a = &#123;&#125;; String[] a1 = collection.toArray(a); for (String e : a1) System.out.println(e); &#125;&#125; 输出结果：12reimuwang 注5 toString()调用示例自包含测试 12345678910import java.util.Collection;public class Main &#123; public static void main(String[] args) &#123; Collection&lt;Collection&gt; collection = new AbstractCollectionTest&lt;Collection&gt;(); collection.add(collection); System.out.println(collection); &#125;&#125; 输出： 1[(this Collection)] 非自包含情况测试 1234567891011121314import java.util.Collection;import java.util.HashSet;import java.util.Set;public class Main &#123; public static void main(String[] args) &#123; Set&lt;String&gt; set = new HashSet&lt;String&gt;(); set.add(&quot;reimu&quot;); set.add(&quot;wang&quot;); Collection&lt;String&gt; collection = new AbstractCollectionTest&lt;String&gt;(set); System.out.println(collection); &#125;&#125; 输出： 1[reimu, wang] 未整理层级关系本类直接继承的类 java.lang.Object 直接继承本类的类 java.util.ArrayDeque&lt;E&gt; java.util.concurrent.ConcurrentLinkedDeque&lt;E&gt; 直接继承本类的内部类 静态成员内部类java.lang.ProcessEnvironment.CheckedValues 实例成员内部类java.util.HashMap&lt;K,V&gt;.Values 实例成员内部类java.util.IdentityHashMap&lt;K,V&gt;.Values 实例成员内部类java.util.WeakHashMap&lt;K,V&gt;.Values 实例成员内部类java.util.TreeMap&lt;K,V&gt;.Values 实例成员内部类java.util.Hashtable&lt;K,V&gt;.ValueCollection 实例成员内部类java.util.EnumMap&lt;K extends Enum&lt;K&gt;, V&gt;.Values 实例成员内部类java.util.concurrent.ConcurrentHashMap&lt;K, V&gt;.Values 实例成员内部类java.util.concurrent.ConcurrentSkipListMap&lt;K,V&gt;.Values&lt;E&gt;]]></content>
      <categories>
        <category>Java JDK7源码</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
        <tag>Collection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java JDK7源码-java.util.Queue&lt;E&gt;]]></title>
    <url>%2F2017%2F06%2F16%2FJava%20JDK7%E6%BA%90%E7%A0%81-javautilQueueE%2F</url>
    <content type="text"><![CDATA[源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package java.util;public interface Queue&lt;E&gt; extends Collection&lt;E&gt; &#123; /** * 继承父接口:java.util.Collection&lt;E&gt; * * 在不超过队列容量限制的情况下，将e插入到队列中(具体的插入位置依队列的优先规则而定)。 * 若插入成功则返回true。若因容量不足而插入失败则抛出IllegalStateException。 * * 本方法与后文介绍的offer(E e)方法很相似，可对比学习。 * * @throws IllegalStateException 因容量限制e此时无法被插入队列。 * @throws ClassCastException e因其类型禁止被插入队列。 * @throws NullPointerException e==null且队列禁止包含null。 * @throws IllegalArgumentException e因其某些属性禁止被插入队列。 */ boolean add(E e); /** * 在不超过队列容量限制的情况下，将e插入到队列中(具体的插入位置依队列的优先规则而定)。 * 若插入成功则返回true。若因容量不足而插入失败则返回false。 * * 当队列有容量限制时，本方法通常优于add(E e)。 * 因为对于有容量限制的队列而言，因容量已满无法插入元素是正常情况，不需要抛出异常。 * * 本方法与前文介绍的add(E e)方法很相似，可对比学习。 * * @throws ClassCastException e因其类型禁止被插入队列。 * @throws NullPointerException e==null且队列禁止包含null。 * @throws IllegalArgumentException e因其某些属性禁止被插入队列。 */ boolean offer(E e); /** * 本方法与父接口Collection中的remove(Object o)方法是重载关系，不是重写关系，注意不要混淆。 * * 返回并移除队列的头元素(头元素依队列的优先规则计算而得)。 * * 本方法与poll()方法的差异只体现在队列为空时：本方法抛出异常，poll()方法返回null。 * * 本方法与后文介绍的poll()方法很相似，可对比学习。 * * @throws NoSuchElementException 队列为空 */ E remove(); /** * 返回并移除队列的头元素(头元素依队列的优先规则计算而得)。 * * 本方法与remove()方法的差异只体现在队列为空时：本方法返回null，remove()方法抛出异常。 * * 本方法与前文介绍的remove()方法很相似，可对比学习。 */ E poll(); /** * 返回但不移除队列的头元素(头元素依队列的优先规则计算而得)。 * * 本方法与peek()方法的差异只体现在队列为空时：本方法抛出异常，peek()方法返回null。 * * 本方法与后文介绍的peek()方法很相似，可对比学习。 * * @throws NoSuchElementException 队列为空 */ E element(); /** * 返回但不移除队列的头元素(头元素依队列的优先规则计算而得)。 * * 本方法与element()方法的差异只体现在队列为空时：本方法返回null，element()方法抛出异常。 * * 本方法与前文介绍的element()方法很相似，可对比学习。 */ E peek();&#125; 已整理层级关系直接父接口 java.util.Collection&lt;E&gt; 直接实现本接口的类 java.util.AbstractQueue&lt;E&gt; 综述本接口是Java集合框架中的一员。Queue&lt;E&gt;中的E表示Queue中元素的类型。 在数据结构中，队列是一种按照设定好的优先规则进行排序的集合，移除时只能移除头部元素。这是广义上队列的定义。 狭义的队列，也是我们通常所说的队列，优先规则为入队的时间先后：入队越早，优先级越高。此时上文中的广义定义退化为FIFO(first-in-first-out)。 而广义的队列中的优先规则则可以是任意规则，比如我们甚至可以将狭义的优先规则颠倒过来：优先规则的依据依然是时间，只不过入队越晚，优先级越高。此时队列实现的就是LIFO(last-in-first-out)，也就是栈的功能了。所以从广义的角度上讲，栈其实是广义队列的一种。 Java中的Queue接口约束的是广义的队列。不过除非特殊声明，我们通常提到Java中的Queue接口时，指得依然是狭义上的队列，并且除非真的有必要，也没必要去实现广义上的队列，徒增程序的复杂性。 正因为Queue接口将优先规则交由实现类自行规定，因此实现类应在其文档中将自身采用的优先规则写明，以免其使用者产生误解。 与Collection接口相比，Queue接口提供了额外的插入，取出，校验操作。在操作失败时每个方法的返回值可能为以下两种返回形式之一： 抛出一个异常。 返回一个表示失败的值(依操作不同为null或false)。 其中抛出异常的那一组方法继承自父接口Collection(或沿用Collection接口的思路)，而返回特殊值的那一组是Queue接口额外添加的。 这是由Java的异常机制所致的。以添加元素为例，对于普通的集合而言，集合不足以容纳新元素是一种异常情况。而对于队列而言，因队列已满无法插入却属于正常情况(例如元素因无法插入固定容量的队列而需阻塞时)。为了解决这个矛盾，只能在遵循父接口的插入规范的基础上(毕竟抛出异常才是通常情况，不能因为队列这个特例改变Collection这一级别的设定)，重新定义符合自身逻辑规范的方法。 上图中还有一个需要注意的点就是poll()方法及peek()方法在队列为空时返回的都是null。这就意味着若这两个方法返回了null，我们是无法确定到底是队列为空了还是返回的元素就是null。因此虽然Queue接口未做强制规范，其实现类往往也会禁止队列包含空元素。 这6个方法就是全部显式声明在Queue接口中的方法了，其他方法均默认继承父接口Collection。这也从另一个侧面说明了这6个方法之于Queue接口的特殊性。 Java中的队列大多被用于并发环境下的阻塞队列。不过Queue接口中并未做并发规范，该规范均被定义在了Queue接口的直接子接口BlockingQueue中。 在equals(Object o)方法及hashCode()方法的设计上，Queue接口并未强制要求其实现类必须重写(因为优先规则实际上就是一种比较，没必要再做特别规范引起程序员的注意了)，默认情况下将调用公共父类Object中的equals(Object o)方法及hashCode()方法。 未整理层级关系直接子接口 java.util.Deque&lt;E&gt; java.util.concurrent.BlockingQueue&lt;E&gt; java.util.concurrent.ConcurrentLinkedQueue&lt;E&gt; 直接实现本接口的内部类 静态成员内部类java.util.Collections.AsLIFOQueue&lt;E&gt;]]></content>
      <categories>
        <category>Java JDK7源码</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
        <tag>Collection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java JDK7源码-java.util.Set&lt;E&gt;]]></title>
    <url>%2F2017%2F06%2F13%2FJava%20JDK7%E6%BA%90%E7%A0%81-javautilSetE%2F</url>
    <content type="text"><![CDATA[源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241package java.util;public interface Set&lt;E&gt; extends Collection&lt;E&gt; &#123; /** * 继承父接口:java.util.Collection&lt;E&gt; * * 查询操作。 * 返回set包含的元素个数(即set的势)。 * 若set包含的元素个数大于Integer.MAX_VALUE，则返回Integer.MAX_VALUE。 */ int size(); /** * 继承父接口:java.util.Collection&lt;E&gt; * * 查询操作。 * 若set不包含元素则返回true，反之返回false。 */ boolean isEmpty(); /** * 继承父接口:java.util.Collection&lt;E&gt; * * 查询操作。 * 若set包含o则返回true。 * 更具体的说，当且仅当set包含至少一个元素e，满足(o==null ? e==null : o.equals(e))，返回true * * 本方法与后文介绍的containsAll(Collection&lt;?&gt; c)方法很相似，可对比学习。 * * @throws ClassCastException o的类型与set不相容。 * @throws NullPointerException o==null且set不允许空元素存在。 */ boolean contains(Object o); /** * 继承父接口:java.util.Collection&lt;E&gt; * * 查询操作。 * 返回一个set的迭代器，该迭代器默认从头开始迭代。 * 通常情况下该迭代器不保证数据有序。 */ Iterator&lt;E&gt; iterator(); /** * 继承父接口:java.util.Collection&lt;E&gt; * * 查询操作。 * 本方法是连接集合与数组之间的桥梁。 * 返回包含set所有元素的数组。若set是有序的(即迭代器返回的结果有序)，则返回的数组必须有同样的顺序。 * 返回的数组与set之间不存在引用关系(即使set的底层就是基于数组实现的)，数组中的元素是set中元素的浅拷贝。 * * 本方法与后文介绍的toArray(T[] a)方法很相似，可对比学习。 */ Object[] toArray(); /** * 继承父接口:java.util.Collection&lt;E&gt; * * 查询操作。 * 本方法是连接集合与数组之间的桥梁。 * * 返回包含set所有元素的数组。返回数组的类型即为a的类型。若set是有序的(即迭代器返回的结果有序)，则返回的数组必须有同样的顺序。 * 具体规则的伪代码为： * if (a.length &lt; set.size()) * 不修改a，而是以a的类型新建长度为set.size()的数组并填入set中的值，随后返回这个新生成的数组。 * else if (a.length == set.size() * 将返回的结果直接填入a后返回a(若a中已有值，则a中的原值会被覆盖)。 * else * 数组索引在[0, set.size() -1]的元素会被set对应位置的元素覆盖。 * 数组索引 == set.size()的元素会被置为null * 数组中后续元素(如果有的话)不变。 * * 若set不允许包含空元素，则本方法此时可用来计算set的长度：返回的数组第一次出现null的索引即为set的长度。 * * 返回的数组与set之间不存在引用关系(即使set的底层就是基于数组实现的)，数组中的元素是set中元素的浅拷贝。 * * 小例子： * String[] y = x.toArray(new String[0]); * x是一个元素类型为String的set，则上述语句会将x中的元素依序复制一份浅拷贝到数组y。 * * 关于本方法与前文介绍的toArray()方法，需明确： * set.toArray() * set.toArray(new Object[s]) * 当s &lt; set.size()时，上述两行代码的效果等价。 * * 本方法与前文介绍的toArray()方法很相似，可对比学习。 * * @throws ArrayStoreException a的类型set不支持。 * @throws NullPointerException null==a。 */ &lt;T&gt; T[] toArray(T[] a); /** * 继承父接口:java.util.Collection&lt;E&gt; * * 修改操作。 * 本方法属于破坏性方法，可选。 * * 若e在set中不存在则将e插入到set中。 * 更一般的说，若set不包含e2这种元素：(e==null ? e2==null : e.equals(e2))，则将e插入set。 * 若set已包含e，本方法不会改变set并返回false。本方法配合set的构造函数，可保证set永远不会包括重复元素。 * 以上的规定不意味着在满足不重复的前提下set必须接受所有元素，set可能会拒绝添加任意特定元素，包括null，并抛出一个异常。 * * 本方法与后文介绍的addAll(Collection&lt;? extends E&gt; c)方法很相似，可对比学习。 * * @throws UnsupportedOperationException set不支持本方法。 * @throws ClassCastException e因其类型禁止被插入set。 * @throws NullPointerException e==null且set禁止包含null。 * @throws IllegalArgumentException e因其某些属性禁止被插入set。 */ boolean add(E e); /** * 继承父接口:java.util.Collection&lt;E&gt; * * 修改操作。 * 本方法属于破坏性方法，可选。 * * 移除set中符合条件的元素e：(o==null ? e==null : o.equals(e))。 * 若本方法改变了set则返回true，反之返回false。 * 一旦调用本方法后，set将不会再包含与o相等的元素。 * * 本方法与后文介绍的removeAll(Collection&lt;?&gt; c)方法很相似，可对比学习。 * * @throws UnsupportedOperationException set不支持本方法。 * @throws ClassCastException o的类型与set不相容。 * @throws NullPointerException o==null且set不允许空元素存在。 */ boolean remove(Object o); /** * 继承父接口:java.util.Collection&lt;E&gt; * * 批量查询操作。 * * 若set包含c中所有元素则返回true，反之返回false。 * 特别的，若c同样为Set且为set的子集，则返回true。 * * 本方法与前文介绍的contains(Object o)方法很相似，可对比学习。 * * @throws ClassCastException c中至少有一个元素的类型与set不相容。 * @throws NullPointerException c==null或 * c中至少有一个元素为null且set不允许空元素存在。 */ boolean containsAll(Collection&lt;?&gt; c); /** * 继承父接口:java.util.Collection&lt;E&gt; * * 批量修改操作 * 本方法属于破坏性方法，可选。 * * 在保证set中不存在重复元素的前提下，将c中所有元素插入set。 * 特别的，若c同样为一个Set，本方法实际上是将set改造为了该set与c的并集。 * 未定义发生如下事件时的应对策略：在操作过程中c发生变化。 * 若set因本方法发生变化则返回true，反之返回false。 * * 本方法与前文介绍的add(E e)方法很相似，可对比学习。 * * @throws UnsupportedOperationException set不支持本方法。 * @throws ClassCastException c中任意一个元素因其类型禁止被插入set。 * @throws NullPointerException c==null或 * c中至少有一个元素为null且set不允许空元素存在。 * @throws IllegalArgumentException c中任意一个元素因其某些属性禁止被插入set。 */ boolean addAll(Collection&lt;? extends E&gt; c); /** * 继承父接口:java.util.Collection&lt;E&gt; * * 批量修改操作 * 本方法属于破坏性方法，可选。 * * 保留set中与c的交集元素。 * 若set因本方法发生变化则返回true，反之返回false。 * * 本方法与后文介绍的removeAll(Collection&lt;?&gt; c)方法正相反，可对比学习。 * * @throws UnsupportedOperationException set不支持本方法。 * @throws ClassCastException c中至少有一个元素的类型与set不相容。 * @throws NullPointerException c==null或 * set中至少有一个元素为null且c不允许空元素存在。 */ boolean retainAll(Collection&lt;?&gt; c); /** * 继承父接口:java.util.Collection&lt;E&gt; * * 批量修改操作 * 本方法属于破坏性方法，可选。 * * 从set中移除所有与c的交集元素(求差集)。 * 若set因本方法发生变化则返回true，反之返回false。 * * 本方法与前文介绍的remove(Object o)方法很相似，可对比学习。 * * @throws UnsupportedOperationException set不支持本方法。 * @throws ClassCastException c中至少有一个元素的类型与set不相容。 * @throws NullPointerException c==null或 * set中至少有一个元素为null且c不允许空元素存在。 */ boolean removeAll(Collection&lt;?&gt; c); /** * 继承父接口:java.util.Collection&lt;E&gt; * * 批量修改操作 * 本方法属于破坏性方法，可选。 * * 清空set。该方法执行完成后set将为空。 * * @throws UnsupportedOperationException set不支持本方法。 */ void clear(); /** * 继承父接口:java.util.Collection&lt;E&gt; * * 比较及哈希操作 * 比较o与set是否相等。 * * 如下情况判断为相等： * o为Set，o与set长度相同，set中有o中所有的元素(或者也可以反过来说，o中有set中所有的元素)。 * 只要满足该相等条件，Set接口的不同实现之间也可判断为相等。 */ boolean equals(Object o); /** * 继承父接口:java.util.Collection&lt;E&gt; * * 比较及哈希操作 * 返回set的hash code。 * * set的hash code被定义为set中所有元素的hash code的和。 * 空元素的hash code被定义为0。 * 若s1与s2为两个Set，这确保了s1.equals(s2)即有s1.hashCode()==s2.hashCode()。 * 满足了Java语言规范中两个对象equals(Object o)方法相等即要有hashCode()方法相等的规范。 */ int hashCode();&#125; 已整理层级关系直接父接口 java.util.Collection&lt;E&gt; 直接实现本接口的类 java.util.AbstractSet&lt;E&gt; 综述本接口是Java集合框架中的一员，是一种没有重复元素的集合，顾名思义，本接口定义的是数学中Set的概念。Set&lt;E&amp;gt中的E代表Set中元素的类型。 更具体的说，Set中的元素e1,e2不存在如下情况：e1.equals(e2)为true。因此Set中最多只能有一个元素为null。 较之父接口Collection，本接口并未添加新的方法。不过对于很多方法的含义都做了特化。为了便于写文档，因此均会在本接口中重复写一遍。 这些含义上的具体化大致集中于如下3部分： 构造函数：经由Set的构造函数构造出的Set必须不能包含重复元素。 add()方法 equals()方法及hashCode()方法 当以容易改变的对象(尤其是这种改变会影响到equals()方法的判定时)作为Set的元素时必须要提高警惕。因为一旦成功被放入Set，再修改元素值导致元素间的重复Set本身是无能为力的。因此Set禁止自包含。 不同Set的实现类往往还会附加不同的，更为具体的限制。例如，某些实现类禁止包含空元素，某些实现类会限制其所包含的元素的类型。 试图插入一个不合规的元素会抛出一个运行时异常，例如NullPointerException，ClassCastException。 试图查询一个不合规的元素可能会抛出一个异常，或者仅仅只是返回false。 未整理层级关系直接子接口 java.util.SortedSet&lt;E&gt; com.sun.corba.se.impl.orbutil.graph.Graph 直接实现本接口的类 java.util.HashSet&lt;E&gt; java.util.SortedSet&lt;E&gt; java.util.LinkedHashSet&lt;E&gt; 直接实现本接口的内部类 静态成员内部类java.util.Collections.CheckedSet&lt;E&gt; 静态成员内部类java.util.Collections.SetFromMap&lt;E&gt; 静态成员内部类java.util.Collections.SynchronizedSet&lt;E&gt; 静态成员内部类java.util.Collections.UnmodifiableSet&lt;E&gt; 静态成员内部类-静态成员内部类java.util.Collections.CheckedMap&lt;K, V&gt;.CheckedEntrySet&lt;K, V&gt;]]></content>
      <categories>
        <category>Java JDK7源码</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
        <tag>Collection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java JDK7源码-java.util.List&lt;E&gt;]]></title>
    <url>%2F2017%2F05%2F25%2FJava%20JDK7%E6%BA%90%E7%A0%81-javautilListE%2F</url>
    <content type="text"><![CDATA[源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434package java.util;public interface List&lt;E&gt; extends Collection&lt;E&gt; &#123; /** * 继承父接口:java.util.Collection&lt;E&gt; * * 查询操作。 * 返回列表包含的元素个数。 * 若列表包含的元素个数大于Integer.MAX_VALUE，则返回Integer.MAX_VALUE。 */ int size(); /** * 继承父接口:java.util.Collection&lt;E&gt; * * 查询操作。 * 若列表不包含元素则返回true，反之返回false。 */ boolean isEmpty(); /** * 继承父接口:java.util.Collection&lt;E&gt; * * 查询操作。 * 若列表包含o则返回true，反之返回false。 * 更具体的说，当且仅当列表包含至少一个元素e，满足(o==null ? e==null : o.equals(e))时，返回true。 * * 本方法与后文介绍的containsAll(Collection&lt;?&gt; c)方法很相似，可对比学习。 * * @throws ClassCastException o的类型与列表不相容。 * @throws NullPointerException o==null且列表不允许空元素存在。 */ boolean contains(Object o); /** * 继承父接口:java.util.Collection&lt;E&gt; * * 返回一个列表的迭代器，该迭代器默认从头开始迭代。 * 该迭代器遍历得到的元素有序(与列表的固有顺序相同)。 * * 后文介绍的listIterator()方法是本方法基于List接口的特化，可对比学习。 * 后文介绍的listIterator(int index)方法是本方法基于List接口的特化，可对比学习。 */ Iterator&lt;E&gt; iterator(); /** * 继承父接口:java.util.Collection&lt;E&gt; * * 查询操作。 * 本方法是连接集合与数组之间的桥梁。 * * 返回包含列表所有元素的数组。该数组的顺序与列表的固有顺序相同。 * 返回的数组与列表之间不存在引用关系(即使列表是基于数组的)，数组中的元素是列表中元素的浅拷贝。 * * 本方法与后文介绍的toArray(T[] a)方法很相似，可对比学习。 */ Object[] toArray(); /** * 继承父接口:java.util.Collection&lt;E&gt; * * 查询操作。 * 本方法是连接集合与数组之间的桥梁。 * * 返回包含列表所有元素的数组。该数组的顺序与列表的固有顺序相同。返回数组的类型即为a的类型。 * 具体规则的伪代码为： * if (a.length &lt; list.size()) * 不修改a，而是以a的类型新建长度为list.size()的数组并填入列表中的值，随后返回这个新生成的数组。 * else if (a.length == list.size() * 将返回的结果直接填入a后返回a(若a中已有值，则a中的原值会被覆盖)。 * else * 数组索引在[0, list.size() -1]的元素会被列表对应位置的元素覆盖。 * 数组索引 == list.size()的元素会被置为null * 数组中后续元素(如果有的话)不变。 * * 若列表不允许包含空元素，则本方法此时可用来计算列表的长度：返回的数组第一次出现null的索引即为列表的长度。 * * 返回的数组与列表之间不存在引用关系(即使列表的底层就是基于数组实现的)，数组中的元素是列表中元素的浅拷贝。 * * 小例子： * String[] y = x.toArray(new String[0]); * x是一个元素类型为String的列表，则上述语句会将x中的元素依序复制一份浅拷贝到数组y。 * * 关于本方法与前文介绍的toArray()方法，需明确： * list.toArray() * list.toArray(new Object[s]) * 当s &lt; list.size()时，上述两行代码的效果等价。 * * 本方法与前文介绍的toArray()方法很相似，可对比学习。 * * @throws ArrayStoreException a的类型列表不支持。 * @throws NullPointerException null==a。 */ &lt;T&gt; T[] toArray(T[] a); /** * 继承父接口:java.util.Collection&lt;E&gt; * * 修改操作。 * 本方法属于破坏性方法，可选。 * * 将e加入列表的末尾。 * 若列表因本方法而改变则返回true，反之则返回false。 * * 即便实现类支持本方法，它也可能会做某种限制(禁止插入null，限制可插入的元素类型等)。 * * 本方法与后文介绍的addAll(Collection&lt;? extends E&gt; c)方法很相似，可对比学习。 * 本方法与后文介绍的方法addAll(int index, Collection&lt;? extends E&gt; c)很相似，可对比学习。 * 本方法与后文介绍的方法add(int index, E element)很相似，可对比学习。 * * @throws UnsupportedOperationException 列表不支持本方法。 * @throws ClassCastException e因其类型禁止被插入列表。 * @throws NullPointerException e==null且列表禁止包含null。 * @throws IllegalArgumentException e因其某些属性禁止被插入列表。 */ boolean add(E e); /** * 继承父接口:java.util.Collection&lt;E&gt; * * 修改操作。 * 本方法属于破坏性方法，可选。 * * 移除o在列表中第一次出现的位置的元素。即： * o==null ? get(i)==null : o.equals(get(i)) * 其中为i满足相等条件的最小索引值。 * * 若本方法改变了列表则返回true，反之返回false。 * * 本方法与后文介绍的removeAll(Collection&lt;?&gt; c)方法很相似，可对比学习。 * 本方法与后文介绍的remove(int index)方法很相似，可对比学习。 * * @throws UnsupportedOperationException 列表不支持本方法。 * @throws ClassCastException o的类型与列表不相容。 * @throws NullPointerException o==null且列表不允许空元素存在。 */ boolean remove(Object o); /** * 继承父接口:java.util.Collection&lt;E&gt; * * 批量查询操作。 * 若列表包含c中所有元素则返回true，反之返回false。 * * 本方法与前文介绍的contains(Object o)方法很相似，可对比学习。 * * @throws ClassCastException c中至少有一个元素的类型与列表不相容。 * @throws NullPointerException c==null或 * c中至少有一个元素为null且列表不允许空元素存在。 */ boolean containsAll(Collection&lt;?&gt; c); /** * 继承父接口:java.util.Collection&lt;E&gt; * * 批量修改操作 * 本方法属于破坏性方法，可选。 * * 将c中所有元素插入列表末尾，插入顺序为c的迭代器取出的顺序。 * 若列表因本方法发生变化则返回true，反之返回false。 * * 本方法未定义如下事件发生时的解决策略：在将c中的元素添加至列表的过程中c发生变化。 * 这也意味着如下事件的解决策略同样未定义：将一个非空列表添加至自身。 * * 本方法与前文介绍的add(E e)方法很相似，可对比学习。 * 本方法与后文介绍的方法addAll(int index, Collection&lt;? extends E&gt; c)很相似，可对比学习。 * 本方法与后文介绍的方法add(int index, E element)很相似，可对比学习。 * * @throws UnsupportedOperationException 列表不支持本方法。 * @throws ClassCastException c中任意一个元素因其类型禁止被插入列表。 * @throws NullPointerException c==null或 * c中至少有一个元素为null且列表不允许空元素存在。 * @throws IllegalArgumentException c中任意一个元素因其某些属性禁止被插入列表。 */ boolean addAll(Collection&lt;? extends E&gt; c); /** * 批量修改操作 * 本方法属于破坏性方法，可选。 * * 将c中所有元素插入列表的指定位置(index)，插入顺序为c的迭代器取出的顺序。 * 原index位置及以后位置的元素顺次向后移动，空出装载c的空间。 * 若列表因本方法发生变化则返回true，反之返回false。 * * 本方法未定义如下事件发生时的解决策略：在将c中的元素添加至列表的过程中c发生变化。 * 这也意味着如下事件的解决策略同样未定义：将一个非空列表添加至自身。 * * list.addAll(collection); * list.addAll(list.size(), collection); * 二者等价。 * * 本方法与前文介绍的add(E e)方法很相似，可对比学习。 * 本方法与前文介绍的方法addAll(Collection&lt;? extends E&gt; c)很相似，可对比学习。 * 本方法与后文介绍的方法add(int index, E element)很相似，可对比学习。 * * @throws UnsupportedOperationException 列表不支持本方法。 * @throws ClassCastException c中任意一个元素因其类型禁止被插入列表。 * @throws NullPointerException c==null或 * c中至少有一个元素为null且列表不允许空元素存在。 * @throws IllegalArgumentException c中任意一个元素因其某些属性禁止被插入列表。 * @throws IndexOutOfBoundsException 索引越界(index &lt; 0 || index &gt; size)。 */ boolean addAll(int index, Collection&lt;? extends E&gt; c); /** * 继承父接口:java.util.Collection&lt;E&gt; * * 批量修改操作 * 本方法属于破坏性方法，可选。 * * 从列表中移除所有与c的交集元素(求差集)。 * 若列表因本方法发生变化则返回true，反之返回false。 * * 本方法与前文介绍的remove(Object o)方法很相似，可对比学习。 * 本方法与后文介绍的remove(int index)方法很相似，可对比学习。 * 本方法与后文介绍的retainAll(Collection&lt;?&gt; c)方法正相反，可对比学习。 * * @throws UnsupportedOperationException 列表不支持本方法。 * @throws ClassCastException c中至少有一个元素的类型与列表不相容。 * @throws NullPointerException c==null或 * 列表中至少有一个元素为null且c不允许空元素存在。 */ boolean removeAll(Collection&lt;?&gt; c); /** * 继承父接口:java.util.Collection&lt;E&gt; * * 批量修改操作 * 本方法属于破坏性方法，可选。 * * 保留列表中与c的交集元素。 * 若列表因本方法发生变化则返回true，反之返回false。 * * 本方法与前文介绍的removeAll(Collection&lt;?&gt; c)方法正相反，可对比学习。 * * @throws UnsupportedOperationException 列表不支持本方法。 * @throws ClassCastException c中至少有一个元素的类型与列表不相容。 * @throws NullPointerException c==null或 * 列表中至少有一个元素为null且c不允许空元素存在。 */ boolean retainAll(Collection&lt;?&gt; c); /** * 继承父接口:java.util.Collection&lt;E&gt; * * 批量修改操作 * 本方法属于破坏性方法，可选。 * * 清空列表。 * * @throws UnsupportedOperationException 列表不支持本方法。 */ void clear(); /** * 继承父接口:java.util.Collection&lt;E&gt; * * 比较及哈希操作。 * * 比较o与列表是否相等。当且仅当满足如下所有情况时返回true： * o为一个List。 * o与list长度相同。 * o与list所有对应位置上的元素相等(e1==null ? e2==null : e1.equals(e2))。 * * 换句话说，当两个列表在相同位置上的元素均相等，则认为二者相等。 * * 只要满足如上相等的定义，List接口的不同实现类也可被认定为相等。 * * 本方法与后文介绍的hashCode()方法成对出现，可对比学习。 */ boolean equals(Object o); /** * 继承父接口:java.util.Collection&lt;E&gt; * * 比较及哈希操作。 * * 返回列表的hash code值。其计算方式如下： * int hashCode = 1; * for (E e : list) * hashCode = 31 * hashCode + (e == null ? 0 : e.hashCode()); * * 这种计算方式可以保证任意list1.equals(list2)有list1.hashCode()==list2.hashCode()。 * * 本方法与前文介绍的equals(Object o)方法成对出现，可对比学习。 */ int hashCode(); /** * 精确定位访问操作 * * 返回列表中索引位置为index的元素。 * * @throws IndexOutOfBoundsException 索引越界(index &lt; 0 || index &gt;= size)。 */ E get(int index); /** * 精确定位修改操作 * 本方法属于破坏性方法，可选。 * * 用element替换列表索引值为index的元素。方法返回被替换的元素。 * * @throws UnsupportedOperationException 列表不支持本方法。 * @throws ClassCastException element的类型与列表不相容。 * @throws NullPointerException element==null且列表禁止包含空元素。 * @throws IllegalArgumentException element因其某些属性禁止被插入列表。 * @throws IndexOutOfBoundsException 索引越界(index &lt; 0 || index &gt;= size)。 */ E set(int index, E element); /** * 精确定位修改操作 * 本方法属于破坏性方法，可选。 * * 将element插入列表的index下标处。原来处于index下标及以后的元素均向后移动一个位置。 * * list.add(&quot;1&quot;); * list.add(list.size(), &quot;1&quot;); * 等效 * * 本方法与前文介绍的add(E e)方法很相似，可对比学习。 * 本方法与前文介绍的方法addAll(Collection&lt;? extends E&gt; c)很相似，可对比学习。 * 本方法与前文介绍的方法addAll(int index, Collection&lt;? extends E&gt; c)很相似，可对比学习。 * * @throws UnsupportedOperationException 列表不支持本方法。 * @throws ClassCastException element的类型与列表不相容。 * @throws NullPointerException element==null且列表禁止包含空元素。 * @throws IllegalArgumentException element因其某些属性禁止被插入列表。 * @throws IndexOutOfBoundsException 索引越界(index &lt; 0 || index &gt; size)。 */ void add(int index, E element); /** * 精确定位修改操作 * 本方法属于破坏性方法，可选。 * * 移除列表中索引值为index的元素。后续元素左移一个位置。返回被移除的元素。 * * 本方法与前文介绍的remove(Object o)方法很相似，可对比学习。 * 本方法与前文介绍的removeAll(Collection&lt;?&gt; c)方法很相似，可对比学习。 * * @throws UnsupportedOperationException 列表不支持本方法。 * @throws IndexOutOfBoundsException 索引越界(index &lt; 0 || index &gt;= size)。 */ E remove(int index); /** * 搜索操作 * * 返回o在列表中第一次出现的索引。 * 若列表不包含o则返回-1。 * 更具体的说，返回满足如下条件索引值最小的元素的索引： * (o==null ? get(i)==null : o.equals(get(i)))。 * 若不存在这样的元素则返回-1。 * * 本方法与后文介绍的lastIndexOf(Object o)方法正相反，可对比学习。 * * @throws ClassCastException o的类型与列表不相容。 * @throws NullPointerException o==null且列表禁止包含空元素。 */ int indexOf(Object o); /** * 搜索操作 * * 返回o在列表中最后一次出现的索引。 * 若列表不包含o则返回-1。 * 更具体的说，返回满足如下条件索引值最大的元素的索引： * (o==null ? get(i)==null : o.equals(get(i)))。 * 若不存在这样的元素则返回-1。 * * 本方法与前文介绍的indexOf(Object o)方法正相反，可对比学习。 * * @throws ClassCastException o的类型与列表不相容。 * @throws NullPointerException o==null且列表禁止包含空元素。 */ int lastIndexOf(Object o); /** * 列表迭代器 * * 返回一个列表按固有顺序从头开始迭代的列表迭代器。 * * 本方法是前文介绍的iterator()方法基于List接口的特化，可对比学习。 * 本方法与后文介绍的listIterator(int index)方法很相似，可对比学习。 */ ListIterator&lt;E&gt; listIterator(); /** * 列表迭代器 * * 返回一个列表按固有顺序迭代的列表迭代器。 * 迭代开始时游标位于索引[index-1,index]之间。 * 即使用本方法得到列表迭代器后，若第一次调用的是listIterator.next()，返回的元素的索引是index； * 同理，若第一次调用的是listIterator.previous()，返回的元素的索引为index-1。 * * 本方法是前文介绍的iterator()方法基于List接口的特化，可对比学习。 * 本方法与前文介绍的listIterator()方法很相似，可对比学习。 * * @throws IndexOutOfBoundsException 索引越界(index &lt; 0 || index &gt; size)。 */ ListIterator&lt;E&gt; listIterator(int index); /** * 视图 * * 返回列表的一部分，索引值区间：[fromIndex,toIndex)。 * 特别的，若fromIndex==toIndex，则返回空列表(不是null)。 * * 返回的列表是原列表的一个视图，前者是后者的一部分，并未从后者中分离出去。 * 因此作用在前者之上的修改会反映在后者上，反之亦然。 * * 使用本方法的好处在于： * 当我们操作列表的一部分时，可以直接在这一部分内部操作(仿佛这就是一个新的列表)， * 而无需被各种索引的边界分散过多的注意。 * * 例如，如果想批量移除列表中的一部分，可按如下操作： * list.subList(fromIndex, toIndex).clear(); * * 同理，所有本接口的方法及所有java.util.Collections类提供的静态方法 * 均支持本方法返回的视图作为一个独立的列表调用。例如： * list2 = list.subList(1, 2); * list2.get(0); * 此时取得的元素即为list.get(1)。 * * 若在生成视图后原列表发生了结构性的变化(例如长度发生了变化) * 则已生成的视图将被重置为未定义的状态。 * * @throws IndexOutOfBoundsException 索引越界(fromIndex &lt; 0 || toIndex &gt; size || fromIndex &gt; toIndex)。 */ List&lt;E&gt; subList(int fromIndex, int toIndex);&#125; 已整理层级关系直接父接口 java.util.Collection&lt;E&gt; 直接实现本接口的类 java.util.AbstractList&lt;E&gt; java.util.ArrayList&lt;E&gt; 综述本接口是Java集合框架中的一员。List(列表)又名Sequence(序列)。是一种有序的集合。 使用者能精确的知道列表中每个元素的位置，能通过元素在列表中的索引访问或搜索元素。和数组一样，列表的索引从0开始。 不同于Set，列表允许重复元素。更通俗的说，若设e1,e2为列表中的两个元素，则允许e1.equals(e2)。特别的，若列表中允许空元素，则其也允许复数个空元素。 本接口不支持如下这种列表：禁止重复，且在试图插入重复元素时抛出运行时异常。 较之父接口Collection，本接口在如下方法中规定了额外的规范： iterator() add(E e) remove(Object o) equals(Object o) hashCode() 为方便起见，父接口Collection中的其他方法本接口也会再写一遍。 较之父接口Collection，本接口增加了4个可基于索引访问元素的方法: get(int index) set(int index, E element) add(int index, E element) remove(int index) 对本接口的某些实现而言(例如LinkedList)，上述操作的时间复杂度与索引值正相关(链表为取到某个索引值的元素需在链式结构中逐个向后查找)。因此在不确定本接口的具体实现时，比起使用上述基于索引的访问元素的方法，更推荐使用迭代器。 较之父接口Collection，本接口新增了一个特殊的迭代器ListIterator，它是Iterator的子接口。 较之父接口Iterator，ListIterator增加了新的功能： 元素插入 元素替换 双向访问 较之父接口Collection，本接口新增了一个方法新建从头开始迭代的ListIterator，同时还新增了另一个新建从特定索引开始的ListIterator的方法。 较之父接口Collection，本接口新增了两个方法用于搜索特定的对象： indexOf(Object o) lastIndexOf(Object o) 从性能的角度考虑，这两个方法应谨慎使用。在很多实现中，这两个方法采用代价昂贵的顺序查找(linear search)。 较之父接口Collection，本接口提供了两个方法用于在任意位置高效的插入或删除复数个元素： addAll(int index, Collection&lt;? extends E&gt; c) removeAll(Collection&lt;?&gt; c) 当列表允许包含自身以作为自身的元素时，这种列表中的equals(Object o)方法及hashCode()方法往往难于定义。 本接口的某些实现会对它们所能包含的元素有所限制。 例如，一些实现禁止包含空元素，一些实现对其所能包含的元素的类型有限制。 试图插入一个不合规的元素会抛出一个运行时异常，例如NullPointerException，ClassCastException。 依具体实现不同试图查询一个不合规的元素可能会抛出一个异常，或者仅仅只是返回false。 未整理层级关系直接子接口 com.sun.org.apache.xerces.internal.xs.datatypes.ObjectList com.sun.org.apache.xerces.internal.xs.datatypes.ByteList com.sun.org.apache.xerces.internal.xs.ShortList com.sun.org.apache.xerces.internal.xs.StringList com.sun.org.apache.xerces.internal.xs.XSObjectList com.sun.org.apache.xerces.internal.xs.XSNamespaceItemList com.sun.corba.se.spi.ior.IOR com.sun.corba.se.spi.ior.IORTemplate com.sun.corba.se.spi.ior.IORTemplateList com.sun.corba.se.spi.ior.TaggedProfileTemplate org.w3c.dom.ls.LSInput.LSInputList 直接实现本接口的类 java.util.LinkedList&lt;E&gt; java.util.Vector&lt;E&gt; java.util.concurrent.CopyOnWriteArrayList&lt;E&gt; 直接实现本接口的内部类 静态成员内部类java.util.Collections.CheckedList&lt;E&gt; 静态成员内部类java.util.Collections.SynchronizedList&lt;E&gt; 静态成员内部类java.util.Collections.UnmodifiableList&lt;E&gt;]]></content>
      <categories>
        <category>Java JDK7源码</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
        <tag>Collection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java JDK7源码-java.util.ListIterator&lt;E&gt;]]></title>
    <url>%2F2017%2F05%2F25%2FJava%20JDK7%E6%BA%90%E7%A0%81-javautilListIteratorE%2F</url>
    <content type="text"><![CDATA[源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117package java.util;public interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt; &#123; /** * 查询操作 * 继承父接口:java.util.Iterator&lt;E&gt; * 当向后遍历还有元素时返回true。 * 换句话说，返回ture说明仍然可以通过next()取到元素。 * 若在本方法返回false时继续调用next()，则next()会抛出异常。 */ boolean hasNext(); /** * 查询操作 * 继承父接口:java.util.Iterator&lt;E&gt; * 返回listIterator当前游标后一个元素，同时游标后移一位。 * 在迭代list的过程中本方法可能会被反复调用，或者与previous()交替被调用。以此控制向前或向后迭代。 * * 连续执行的情况下，以下语句均会返回当前游标的后一个元素： * listIterator.next(); * listIterator.previous(); * * 连续执行的情况下，以下语句均会返回当前游标的前一个元素： * listIterator.previous(); * listIterator.next(); * * @throws NoSuchElementException 游标所指的位置之后已无元素。 */ E next(); /** * 查询操作 * 当向前遍历还有元素时返回true。 * 换句话说，返回ture说明仍然可以通过previous()取到元素。 * 若在本方法返回false时继续调用previous()，则previous()会抛出异常。 */ boolean hasPrevious(); /** * 查询操作 * 返回listIterator当前游标前一个元素，同时游标前移一位。 * 在迭代list的过程中本方法可能会被反复调用，或者与next()交替被调用。以此控制向前或向后迭代。 * * 连续执行的情况下，以下语句均会返回当前游标的后一个元素： * listIterator.next(); * listIterator.previous(); * * 连续执行的情况下，以下语句均会返回当前游标的前一个元素： * listIterator.previous(); * listIterator.next(); * * @throws NoSuchElementException 游标所指的位置之前已无元素。 */ E previous(); /** * 查询操作 * 返回listIterator当前游标后一个元素的索引。 * 本操作不会移动游标。即本方法会返回下次调用next()时返回的元素的索引。 * 特别的，当游标位于list末尾时，调用本方法不会抛出异常，而是会返回list的长度。 */ int nextIndex(); /** * 查询操作 * 返回listIterator当前游标前一个元素的索引。 * 本操作不会移动游标。即本方法会返回下次调用previous()时返回的元素的索引。 * 特别的，当游标位于list最左边时，调用本方法不会抛出异常，而是会返回-1。 */ int previousIndex(); /** * 改变操作 * 继承父接口:java.util.Iterator&lt;E&gt; * 本方法可选，实现类可依自身情况决定是否真的需要实现。 * * 移除上一次由next()或previous()返回的元素。 * 本方法必须与next()或previous()一一配对。且每个配对之间不能调用add(E e)。 * * @throws UnsupportedOperationException listIterator不支持本方法。 * @throws IllegalStateException：本方法未与next()或previous()一一配对，或配对之间调用了add(E e)。 */ void remove(); /** * 改变操作 * 本方法可选，实现类可依自身情况决定是否真的需要实现。 * * 用e覆盖上一次由next()或previous()返回的元素的位置的元素。 * 本方法在调用前必须调用一次next()或previous()，否则不知道该覆盖哪个位置的元素。 * 且在本方法与最后一次next()或previous()之间不能调用add(E e)或remove()。 * * @throws UnsupportedOperationException listIterator不支持本方法。 * @throws ClassCastException e因为其所属的类禁止被插入list。 * @throws IllegalArgumentException e因其某些属性禁止被插入list。 * @throws IllegalStateException 本方法在调用前没有调用next()或previous()，或在本方法与最后一次next()或previous()之间调用add(E e)或remove()。 */ void set(E e); /** * 改变操作 * 本方法可选，实现类可依自身情况决定是否真的需要实现。 * * 将e插入当前游标所在位置。 * 若list为空，则e将成为list的第一个元素。 * e插入后，当前游标位于e之后的位置。 * 因此插入后第一次如果调用的是next()将返回插入前游标所指的下一个元素；第一次如果调用的是previous()将返回e。 * * 调用该方法后，若调用nextIndex()或previousIndex()，和未调用该方法之前相比值均会增加1。 * * @throws UnsupportedOperationException listIterator不支持本方法。 * @throws ClassCastException e因为其所属的类禁止被插入list。 * @throws IllegalArgumentException e因其某些属性禁止被插入list。 */ void add(E e);&#125; 已整理层级关系直接父接口 java.util.Iterator&lt;E&gt; 综述本接口是Java集合框架中的一员。是专为List接口设计的迭代器。可以双向迭代并修改list，并可获得迭代器当前的游标位置。 与父接口Iterator不同的是，ListIterator没有当前元素的概念。它的游标位置在两个元素之间。当调用previous()时将返回紧邻游标之前的一个元素同时游标前移一位；当调用next()时将返回紧邻游标之后的一个元素同时游标后移一位。 若list的长度为n，则有n+1个位置可供放置游标。形如： 12 Element(0) Element(1) Element(2) ... Element(n-1)cursor positions: ^ ^ ^ ^ ^ 游标无法定义remove()及set(E e)。因为这两个方法操作的是元素本身而游标指向的是元素之间的位置。这两个方法必须与next()或previous()配对(remove()要求一一配对而set(E e)不需要)，其操作的元素即为配对方法返回的元素。]]></content>
      <categories>
        <category>Java JDK7源码</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
        <tag>Collection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java JDK7源码-java.util.Iterator&lt;E&gt;]]></title>
    <url>%2F2017%2F05%2F24%2FJava%20JDK7%E6%BA%90%E7%A0%81-javautilIteratorE%2F</url>
    <content type="text"><![CDATA[源码 1234567891011121314151617181920212223242526272829303132333435package java.util;import java.util.NoSuchElementException;public interface Iterator&lt;E&gt; &#123; /** * 若集合还有元素则返回true，反之返回false。 * 更清晰的表述为：若iterator游标当前所指向的位置还有元素则返回true，反之返回false。 * 若在本方法返回false时继续调用next()方法，则next()方法会抛出异常。 */ boolean hasNext(); /** * 返回iterator游标当前所指向的元素，随后游标后移一位。 * * @throws NoSuchElementException iterator游标当前所指向的位置已无元素 */ E next(); /** * 本方法可选，实现类可依自身情况决定是否真的需要实现。 * * 移除iterator游标当前所指元素的前一个元素。即上一次调用next()方法所返回的元素。 * 因此，调用本方法之前必须调用一次next()方法。 * 调用一次next()方法后多次调用本方法是不允许的。本方法必须与next()方法一一配对。 * * 这么设计是符合逻辑的，因为我们一般只有先用next()方法得到元素后，才能知道该元素是否需要被移除。 * 因此移除的是游标的前一个元素，而非当前游标正指向的这个我们不知道的元素。 * * @throws UnsupportedOperationException 实现类未实现本方法。 * @throws IllegalStateException 本方法未与next()方法一一配对。 */ void remove();&#125; 已整理层级关系直接子接口 java.util.ListIterator&lt;E&gt; 直接实现本接口的内部类 实例成员内部类java.util.AbstractList&lt;E&gt;.Itr 实例成员内部类java.util.ArrayList&lt;E&gt;.Itr 实例成员内部类java.util.Vector&lt;E&gt;.Itr 综述本接口是Java集合框架中的一员，用于迭代集合中的元素。Iterator&lt;E&gt;中的E代表该迭代器(iterator)返回的元素类型。 Enumeration接口诞生于JDK1.0，而Iterator接口诞生于JDK1.2，是替代Enumeration的改进版本：即二者实现的功能相同，因此在日常开发中更推荐使用Iterator。Iterator与Enumeration的不同之处可归纳为如下两点： 在迭代过程中，Iterator允许删除集合中的元素，而Enumeration则不能。 Iterator使用更为精简易读的方法名。 未整理层级关系直接子接口 javax.xml.stream.XMLEventReader com.sun.corba.se.pept.transport.ContactInfoListIterator 直接实现本接口的类 java.util.Scanner com.sun.org.apache.xerces.internal.util.XMLAttributesIteratorImpl 直接实现本接口的非public类 javax.imageio.spi.FilterIterator&lt;T&gt; javax.imageio.spi.PartialOrderIterator com.sun.imageio.plugins.jpeg.ImageTypeIterator 直接实现本接口的内部类 实例成员内部类java.util.LinkedList&lt;E&gt;.DescendingIterator 实例成员内部类java.util.PriorityQueue&lt;E&gt;.Itr 实例成员内部类java.util.ArrayDeque&lt;E&gt;.DeqIterator 实例成员内部类java.util.ArrayDeque&lt;E&gt;.DescendingIterator 实例成员内部类java.util.HashMap&lt;K, V&gt;.HashIterator&lt;E&gt; 实例成员内部类java.util.TreeMap&lt;K, V&gt;.PrivateEntryIterator&lt;T&gt; 实例成员内部类java.util.WeakHashMap&lt;K, V&gt;.HashIterator&lt;T&gt; 实例成员内部类java.util.IdentityHashMap&lt;K, V&gt;.IdentityHashMapIterator&lt;T&gt; 实例成员内部类java.util.LinkedHashMap&lt;K, V&gt;.LinkedHashIterator&lt;T&gt; 实例成员内部类java.util.Hashtable&lt;K, V&gt;.Enumerator&lt;T&gt; 实例成员内部类java.util.EnumMap&lt;K extends Enum&lt;K&gt;, V&gt;.EnumMapIterator&lt;T&gt; 实例成员内部类java.util.JumboEnumSet&lt;E extends Enum&lt;E&gt;&gt;.EnumSetIterator&lt;E extends Enum&lt;E&gt;&gt; 实例成员内部类java.util.RegularEnumSet&lt;E extends Enum&lt;E&gt;&gt;.EnumSetIterator&lt;E extends Enum&lt;E&gt;&gt; 实例成员内部类java.util.ServiceLoader&lt;S&gt;.LazyIterator 实例成员内部类java.util.concurrent.ArrayBlockingQueue&lt;E&gt;.Itr 实例成员内部类java.util.concurrent.ConcurrentLinkedQueue&lt;E&gt;.Itr 实例成员内部类java.util.concurrent.LinkedBlockingQueue&lt;E&gt;.Itr 实例成员内部类java.util.concurrent.LinkedTransferQueue&lt;E&gt;.Itr 实例成员内部类java.util.concurrent.PriorityBlockingQueue&lt;E&gt;.Itr 实例成员内部类java.util.concurrent.DelayQueue&lt;E extends Delayed&gt;.Itr 实例成员内部类java.util.concurrent.ConcurrentLinkedDeque&lt;E&gt;.AbstractItr 实例成员内部类java.util.concurrent.LinkedBlockingDeque&lt;E&gt;.AbstractItr 实例成员内部类java.util.concurrent.ConcurrentHashMap&lt;K, V&gt;.EntryIterator 实例成员内部类java.util.concurrent.ConcurrentHashMap&lt;K, V&gt;.KeyIterator 实例成员内部类java.util.concurrent.ConcurrentHashMap&lt;K, V&gt;.ValueIterator 实例成员内部类java.util.concurrent.ConcurrentSkipListMap&lt;K, V&gt;.Iter&lt;T&gt; 实例成员内部类javax.xml.soap.MimeHeaders.MatchingIterator 实例成员内部类javax.print.attribute.standard.PrinterStateReasons.PrinterStateReasonSetIterator 实例成员内部类com.sun.corba.se.impl.encoding.BufferManagerWriteCollect.BufferManagerWriteCollectIterator 实例成员内部类com.sun.org.apache.xerces.internal.util.NamespaceSupport.IteratorPrefixes 非public类-实例成员内部类javax.print.MimeType.ParameterMapEntrySetIterator 静态成员内部类java.util.Collections.EmptyIterator&lt;E&gt; 静态成员内部类java.beans.beancontext.BeanContextSupport.BCSIterator 静态成员内部类javax.imageio.ImageIO.ImageReaderIterator 静态成员内部类javax.imageio.ImageIO.ImageTranscoderIterator 静态成员内部类javax.imageio.ImageIO.ImageWriterIterator 静态成员内部类javax.xml.validation.SchemaFactoryFinder.SingleIterator 静态成员内部类javax.xml.xpath.XPathFactoryFinder.SingleIterator 静态成员内部类com.sun.org.apache.xml.internal.security.keys.storage.implementations.CertsInFilesystemDirectoryResolver.FilesystemIterator 静态成员内部类com.sun.org.apache.xml.internal.security.keys.storage.implementations.SingleCertificateResolver.InternalIterator 静态成员内部类com.sun.org.apache.xml.internal.security.keys.storage.implementations.KeyStoreResolver.KeyStoreIterator 静态成员内部类com.sun.org.apache.xml.internal.security.keys.keyresolver.KeyResolver.ResolverIterator 静态成员内部类com.sun.org.apache.xml.internal.security.keys.storage.StorageResolver.StorageResolverIterator 静态成员内部类-实例成员内部类java.util.TreeMap&lt;K, V&gt;.NavigableSubMap&lt;K, V&gt;.SubMapIterator&lt;T&gt; 静态成员内部类-实例成员内部类java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue.Itr 静态成员内部类-实例成员内部类java.util.concurrent.ConcurrentSkipListMap&lt;K, V&gt;.SubMap&lt;K, V&gt;.SubMapIter&lt;T&gt;]]></content>
      <categories>
        <category>Java JDK7源码</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
        <tag>Collection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java JDK7源码-java.lang.Iterable&lt;T&gt;]]></title>
    <url>%2F2017%2F05%2F23%2FJava%20JDK7%E6%BA%90%E7%A0%81-javalangIterableT%2F</url>
    <content type="text"><![CDATA[源码 123456789101112package java.lang;import java.util.Iterator;/** * Iterable&lt;T&gt;中的T代表Iterator返回的元素类型。 * 实现本接口的类可用语法糖foreach(即增强for循环)进行遍历，foreach实际是由Iterator实现的。 */public interface Iterable&lt;T&gt; &#123; Iterator&lt;T&gt; iterator();&#125; 已整理层级关系直接子接口 java.util.Collection&lt;E&gt; 未整理层级关系直接子接口 java.nio.file.DirectoryStream&lt;T&gt; java.nio.file.Path 直接实现本接口的类 java.util.ServiceLoader&lt;S&gt; java.sql.SQLException]]></content>
      <categories>
        <category>Java JDK7源码</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
        <tag>Collection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java JDK7源码-java.util.Collection&lt;E&gt;]]></title>
    <url>%2F2017%2F05%2F23%2FJava%20JDK7%E6%BA%90%E7%A0%81-javautilCollectionE%2F</url>
    <content type="text"><![CDATA[源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238package java.util;public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; &#123; /** * 查询操作。 * 返回集合包含的元素个数。 * 若集合包含的元素个数大于Integer.MAX_VALUE，则返回Integer.MAX_VALUE。 */ int size(); /** * 查询操作。 * 若集合不包含元素则返回true。反之返回false。 */ boolean isEmpty(); /** * 查询操作。 * 若集合包含o则返回true，反之返回false。 * 更具体的说，当且仅当集合包含至少一个元素e，满足(o==null ? e==null : o.equals(e))时，返回true，反之返回false。 * * 本方法与后文介绍的containsAll(Collection&lt;?&gt; c)方法很相似，可对比学习。 * * @throws ClassCastException o的类型与集合不相容。 * @throws NullPointerException o==null且集合不允许空元素存在。 */ boolean contains(Object o); /** * 继承父接口:java.lang.Iterable&lt;T&gt; * * 查询操作。 * 返回一个集合的迭代器，该迭代器默认从头开始迭代。 * 本接口不保证集合本身是否有序，即不保证迭代器是否有序，均交由子孙自行控制。 */ Iterator&lt;E&gt; iterator(); /** * 查询操作。 * 本方法是连接集合与数组之间的桥梁。 * 返回包含集合所有元素的数组。若集合是有序的(即迭代器返回的结果有序)，则返回的数组必须有同样的顺序。 * 返回的数组与集合之间不存在引用关系(即使集合的底层就是基于数组实现的)，数组中的元素是集合中元素的浅拷贝。 * * 本方法与后文介绍的toArray(T[] a)方法很相似，可对比学习。 */ Object[] toArray(); /** * 查询操作。 * 本方法是连接集合与数组之间的桥梁。 * * 返回包含集合所有元素的数组。返回数组的类型即为a的类型。若集合是有序的(即迭代器返回的结果有序)，则返回的数组必须有同样的顺序。 * 具体规则的伪代码为： * if (a.length &lt; collection.size()) * 不修改a，而是以a的类型新建长度为collection.size()的数组并填入集合中的值，随后返回这个新生成的数组。 * else if (a.length == collection.size() * 将返回的结果直接填入a后返回a(若a中已有值，则a中的原值会被覆盖)。 * else * 数组索引在[0, collection.size() -1]的元素会被集合对应位置的元素覆盖。 * 数组索引 == collection.size()的元素会被置为null * 数组中后续元素(如果有的话)不变。 * * 若集合不允许包含空元素，则本方法此时可用来计算集合的长度：返回的数组第一次出现null的索引即为集合的长度。 * * 返回的数组与集合之间不存在引用关系(即使集合的底层就是基于数组实现的)，数组中的元素是集合中元素的浅拷贝。 * * 小例子： * String[] y = x.toArray(new String[0]); * x是一个元素类型为String的集合，则上述语句会将x中的元素依序复制一份浅拷贝到数组y。 * * 关于本方法与前文介绍的toArray()方法，需明确： * collection.toArray() * collection.toArray(new Object[s]) * 当s &lt; collection.size()时，上述两行代码的效果等价。 * * 本方法与前文介绍的toArray()方法很相似，可对比学习。 * * @throws ArrayStoreException a的类型collection不支持。 * @throws NullPointerException null==a。 */ &lt;T&gt; T[] toArray(T[] a); /** * 修改操作。 * 本方法属于破坏性方法，可选。 * * 若实现类不支持本方法，则应抛出UnsupportedOperationException。本机制尤其用于保护那些元素为常量值的集合。 * * 若集合因本方法而改变则返回true，反之则返回false。 * 返回false的情况举例：集合不允许包含重复元素且e在集合中已存在。 * 因此对于那些不能包含重复元素的集合而言，该方法也可用于判断集合是否已包含e(不过需要注意，如果不包含e会被插入集合)。 * * 即便实现类支持本方法，它也可能会做某种限制(禁止插入null，限制可插入的元素类型等)。 * * 本方法与后文介绍的addAll(Collection&lt;? extends E&gt; c)方法很相似，可对比学习。 * * @throws UnsupportedOperationException 集合不支持本方法。 * @throws ClassCastException e因其类型禁止被插入集合。 * @throws NullPointerException e==null且集合禁止包含null。 * @throws IllegalArgumentException e因其某些属性禁止被插入集合。 * @throws IllegalStateException 因插入限制，此时e不能被插入集合。 */ boolean add(E e); /** * 修改操作。 * 本方法属于破坏性方法，可选。 * * 移除集合符合条件的元素e： * (o==null ? e==null : o.equals(e)) * 若有多个e符合条件，则本方法只会移除其中一个，具体移除哪一个依具体实现而定。 * * 若本方法改变了集合则返回true，反之返回false。 * * 本方法与后文介绍的removeAll(Collection&lt;?&gt; c)方法很相似，可对比学习。 * * @throws UnsupportedOperationException 集合不支持本方法。 * @throws ClassCastException o的类型与集合不相容。 * @throws NullPointerException o==null且集合不允许空元素存在。 */ boolean remove(Object o); /** * 批量查询操作。 * 若集合包含c中所有元素则返回true，反之返回false。 * * 本方法与前文介绍的contains(Object o)方法很相似，可对比学习。 * * @throws ClassCastException c中至少有一个元素的类型与集合不相容。 * @throws NullPointerException c==null或 * c中至少有一个元素为null且集合不允许空元素存在。 */ boolean containsAll(Collection&lt;?&gt; c); /** * 批量修改操作 * 本方法属于破坏性方法，可选。 * * 将c中所有元素插入集合。 * 若集合因本方法发生变化则返回true，反之返回false。 * * 本方法未定义如下事件发生时的解决策略：在将c中的元素添加至集合的过程中c发生变化。 * 这也意味着如下事件的解决策略同样未定义：将一个非空集合添加至自身。 * * 本方法与前文介绍的add(E e)方法很相似，可对比学习。 * * @throws UnsupportedOperationException 集合不支持本方法。 * @throws ClassCastException c中任意一个元素因其类型禁止被插入集合。 * @throws NullPointerException c==null或 * c中至少有一个元素为null且集合不允许空元素存在。 * @throws IllegalArgumentException c中任意一个元素因其某些属性禁止被插入集合。 * @throws IllegalStateException 因插入限制，此时并非c中所有元素都能被插入集合。 */ boolean addAll(Collection&lt;? extends E&gt; c); /** * 批量修改操作 * 本方法属于破坏性方法，可选。 * * 从集合中移除所有与c的交集元素(求差集)。 * 若集合因本方法发生变化则返回true，反之返回false。 * * 本方法与前文介绍的remove(Object o)方法很相似，可对比学习。 * 本方法与后文介绍的retainAll(Collection&lt;?&gt; c)方法正相反，可对比学习。 * * @throws UnsupportedOperationException 集合不支持本方法。 * @throws ClassCastException c中至少有一个元素的类型与集合不相容。 * @throws NullPointerException c==null或 * 集合中至少有一个元素为null且c不允许空元素存在。 */ boolean removeAll(Collection&lt;?&gt; c); /** * 批量修改操作 * 本方法属于破坏性方法，可选。 * * 保留集合中与c的交集元素。 * 若集合因本方法发生变化则返回true，反之返回false。 * * 本方法与前文介绍的removeAll(Collection&lt;?&gt; c)方法正相反，可对比学习。 * * @throws UnsupportedOperationException 集合不支持本方法。 * @throws ClassCastException c中至少有一个元素的类型与集合不相容。 * @throws NullPointerException c==null或 * 集合中至少有一个元素为null且c不允许空元素存在。 */ boolean retainAll(Collection&lt;?&gt; c); /** * 批量修改操作 * 本方法属于破坏性方法，可选。 * * 清空集合。 * * @throws UnsupportedOperationException 集合不支持本方法。 */ void clear(); /** * 比较及哈希操作。 * * 比较o与集合是否相等。若相等则返回true，反之返回false。 * 关于判等的逻辑，若实现类未显式重写本方法，本方法将默认调用公共父类Object类的equals(Object obj)方法，即基于集合的引用地址判断是否相等。 * * 事实上，因为实现类必然会是公共父类Object类的子类，因此纯从规范的角度来说，本接口没必要显式声明本方法。 * 之所以还是要显式声明，是为了强调本方法的重要性，提醒程序员在写本接口的实现类时重视并重写本方法。 * 后文介绍的hashCode()方法也是同理。 * * 一般来说，设计本方法时应遵循如下规范： * 自反性，即a.equals(a)应为true。 * 对称性，即若a.equals(b)为true，则应有b.equals(a)为true。 * 传递性，即若a.equals(b)为true，b.equals(c)为true，则应有a.equals(c)为true。 * * Java API提供的直接继承本接口的子接口有3个：Queue,List,Set。 * 其中List,Set均对本方法有要求，它们要求其实现类的本方法不是继承自公共父类Object类，而是根据其具体的特点，比较集合中元素的&quot;值&quot;是否相等。 * 因此，当程序员使用Queue接口，或者是自己直接实现本接口时，一定要考虑好本方法的设计。 * 因为通常情况下，我们比较两个集合的相等性时，都不希望比较的是集合的引用地址是否相等，因为这往往是毫无意义的。 * * Java集合框架在设计时规定了一个大前提：List只能与List相等，Set只能与Set相等。 * 因此，我们无法写出一个类同时实现Set及List接口：若这样的实现类可以存在，意味着有一种集合既是List又是Set，与上文介绍的大前提相悖。 * * 本方法与后文介绍的hashCode()方法成对出现，可对比学习。 */ boolean equals(Object o); /** * 比较及哈希操作。 * * 返回集合的hash code值。 * 若实现类未显式重写本方法，本方法将默认调用公共父类Object类的hashCode()方法。 * * 本方法与equals(Object o)方法成对出现，可对比学习。 * 换句话说，只要重写了equals(Object o)方法，就必须配对重写本方法。 * 具体来说，若c1.equals(c2)为true，则应有c1.hashCode()==c2.hashCode()。 */ int hashCode();&#125; 已整理层级关系直接父接口 java.lang.Iterable&lt;T&gt; 直接子接口 java.util.List&lt;E&gt; java.util.Set&lt;E&gt; java.util.Queue&lt;E&gt; 直接实现本接口的类 java.util.AbstractCollection&lt;E&gt; 综述本接口是Java集合框架中的一员。或者更具体的说，是Java集合框架层级中的根接口。Collection&lt;E&gt;中的E代表集合中元素的类型。 Java API不会提供本接口的直接实现类，而是会实现本接口的子接口(Set,List,Queue)。通常情况下，这些实现类都应提供两个”标准”的构造函数(当然，因为接口无法包含构造函数，因此这个规范并不具备强制力，不过Java API中所有实现了本接口的类都遵循这个规范，Java语言规范中也强烈推荐程序员自定义的本接口的实现类也遵循这一规范)： 无参构造函数，它会创建一个空的集合。 带有一个集合类型参数的构造函数，它会依传入参数创建一个新的集合(新集合可与传入参数的类型不同，例如可以传入List，最终构造出Set)。 本接口包含破坏性方法(即可能会改变所属集合的方法)。若某个具体的实现类不需要支持某个破坏性方法，则需要抛出UnsupportedOperationException。 这样做的目的是为了引起调用者的重视：改变集合属于危险操作(相对于只读方法而言)，但是当前实现类不支持这个方法，你是不是对本实现类有什么误解呢？ 不过需要注意的是，目的才是最重要的，而抛出UnsupportedOperationException只是手段。换句话说，这一约束即便在官方的推荐中也没有那么绝对。有时，即便某实现类不支持某破坏性方法，但只要该方法不产生真正的破坏性结果，那么也可以不抛出UnsupportedOperationException。例如：某不可变实现类不支持addAll(Collection&lt;? extends E&gt; c)方法，在null==c时，就可以选择不抛出UnsupportedOperationException。 某些本接口的实现类可能会对其所包含的元素有更具体的限制。例如，有些实现禁止插入空元素，有些实现则会限制元素类型。试图插入不合法元素时官方推荐抛出一个unchecked exception，通常为NullPointerException或ClassCastException。试图查询一个不合法元素时官方推荐抛出异常或返回false。 本接口不规定同步策略，交由子孙自行控制。 本接口中的方法在判等时多使用元素的equals()方法。因为这样比较出的才是元素在业务逻辑层面的相等性。以contains(Object o)为例： 1当且仅当该集合包含至少一个元素e，满足(o==null ? e==null : o.equals(e))时，返回true。 当然，这个描述只是一个整体上的指导思路。并不是说具体实现类在实现这个方法时，就一定要遍历集合，或者一定要调用元素的equals()方法。事实上，只要能实现功能，实现类可以灵活的进行优化。例如某些情况下，实现类也可用hashCode()方法替代equals()方法比较两元素的相等性。 未整理层级关系直接子接口 java.beans.beancontext.BeanContext 直接实现本接口的内部类 静态成员内部类java.util.Collections.CheckedCollection&lt;E&gt; 静态成员内部类java.util.Collections.SynchronizedCollection&lt;E&gt; 静态成员内部类java.util.Collections.UnmodifiableCollection&lt;E&gt;]]></content>
      <categories>
        <category>Java JDK7源码</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
        <tag>Collection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[传智 springmvc+mybatis day1-6.用户修改和删除]]></title>
    <url>%2F2017%2F05%2F22%2F%E4%BC%A0%E6%99%BAspringmvcmybatisday1-6%E7%94%A8%E6%88%B7%E4%BF%AE%E6%94%B9%E5%92%8C%E5%88%A0%E9%99%A4%2F</url>
    <content type="text"><![CDATA[项目路径： 仓库：chuanzhi_springmvc_mybatis 项目：day1_6 项目架构： pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com&lt;/groupId&gt; &lt;artifactId&gt;day1_6&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;maven.compiler.encoding&gt;UTF-8&lt;/maven.compiler.encoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.43&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;asm&lt;/groupId&gt; &lt;artifactId&gt;asm&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.javassist&lt;/groupId&gt; &lt;artifactId&gt;javassist&lt;/artifactId&gt; &lt;version&gt;3.21.0-GA&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.35&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; log4j.properties 123456log4j.rootLogger=DEBUG,baselog4j.appender.base=org.apache.log4j.DailyRollingFileAppenderlog4j.appender.base.layout=org.apache.log4j.PatternLayoutlog4j.appender.base.layout.conversionPattern=%d&#123;yyyy-MM-dd HH\:mm\:ss&#125; %c\:%L [%-4p] - %m%nlog4j.appender.base.File=/day1_6.log mybatis/SqlMapConfig.xml 12345678910111213141516171819&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot; /&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;&quot; /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;mybatis/sqlmap/user.xml&quot; /&gt; &lt;/mappers&gt;&lt;/configuration&gt; mybatis/sqlmap/user.xml 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.day1_6.user.pojo.UserPojo&quot;&gt; &lt;delete id=&quot;delete&quot; parameterType=&quot;int&quot;&gt; delete from user where id=#&#123;id&#125; &lt;/delete&gt; &lt;update id=&quot;update&quot; parameterType=&quot;com.day1_6.user.pojo.UserPojo&quot;&gt; update user set name=#&#123;name&#125;,create_time=#&#123;create_time&#125; where id=#&#123;id&#125; &lt;/update&gt;&lt;/mapper&gt; com.day1_6.user.pojo.UserPojo.java 12345678910111213141516171819202122232425262728293031323334353637package com.day1_6.user.pojo;import java.util.Date;public class UserPojo &#123; private Integer id; private String name; private Date create_time; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Date getCreate_time() &#123; return create_time; &#125; public void setCreate_time(Date create_time) &#123; this.create_time = create_time; &#125;&#125; com.Delete.java 12345678910111213141516171819202122232425262728293031package com;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Before;import org.junit.Test;public class Delete &#123; private SqlSessionFactory sqlSessionFactory; @Before public void init() throws Exception &#123; this.sqlSessionFactory = new SqlSessionFactoryBuilder().build(Resources.getResourceAsStream(&quot;mybatis/SqlMapConfig.xml&quot;)); &#125; @Test public void run() &#123; SqlSession sqlSession = sqlSessionFactory.openSession(); try &#123; System.out.println(sqlSession.delete(&quot;com.day1_6.user.pojo.UserPojo.delete&quot;, 8)); sqlSession.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; sqlSession.close(); &#125; &#125;&#125; 运行该测试类： 11 打印的dubug日志信息如下： 1234567891011121314152017-05-23 00:10:03 org.apache.ibatis.logging.LogFactory:135 [DEBUG] - Logging initialized using &apos;class org.apache.ibatis.logging.slf4j.Slf4jImpl&apos; adapter.2017-05-23 00:10:03 org.apache.ibatis.datasource.pooled.PooledDataSource:316 [DEBUG] - PooledDataSource forcefully closed/removed all connections.2017-05-23 00:10:03 org.apache.ibatis.datasource.pooled.PooledDataSource:316 [DEBUG] - PooledDataSource forcefully closed/removed all connections.2017-05-23 00:10:03 org.apache.ibatis.datasource.pooled.PooledDataSource:316 [DEBUG] - PooledDataSource forcefully closed/removed all connections.2017-05-23 00:10:03 org.apache.ibatis.datasource.pooled.PooledDataSource:316 [DEBUG] - PooledDataSource forcefully closed/removed all connections.2017-05-23 00:10:03 org.apache.ibatis.transaction.jdbc.JdbcTransaction:136 [DEBUG] - Opening JDBC Connection2017-05-23 00:10:03 org.apache.ibatis.datasource.pooled.PooledDataSource:387 [DEBUG] - Created connection 165734423.2017-05-23 00:10:03 org.apache.ibatis.transaction.jdbc.JdbcTransaction:100 [DEBUG] - Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@9e0e817]2017-05-23 00:10:03 com.day1_6.user.pojo.UserPojo.delete:159 [DEBUG] - ==&gt; Preparing: DELETE FROM user WHERE id=? 2017-05-23 00:10:04 com.day1_6.user.pojo.UserPojo.delete:159 [DEBUG] - ==&gt; Parameters: 8(Integer)2017-05-23 00:10:04 com.day1_6.user.pojo.UserPojo.delete:159 [DEBUG] - &lt;== Updates: 12017-05-23 00:10:04 org.apache.ibatis.transaction.jdbc.JdbcTransaction:69 [DEBUG] - Committing JDBC Connection [com.mysql.jdbc.JDBC4Connection@9e0e817]2017-05-23 00:10:04 org.apache.ibatis.transaction.jdbc.JdbcTransaction:122 [DEBUG] - Resetting autocommit to true on JDBC Connection [com.mysql.jdbc.JDBC4Connection@9e0e817]2017-05-23 00:10:04 org.apache.ibatis.transaction.jdbc.JdbcTransaction:90 [DEBUG] - Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@9e0e817]2017-05-23 00:10:04 org.apache.ibatis.datasource.pooled.PooledDataSource:344 [DEBUG] - Returned connection 165734423 to pool. com.Update.java 123456789101112131415161718192021222324252627282930313233343536373839package com;import java.util.Date;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Before;import org.junit.Test;import com.day1_6.user.pojo.UserPojo;public class Update &#123; private SqlSessionFactory sqlSessionFactory; @Before public void init() throws Exception &#123; this.sqlSessionFactory = new SqlSessionFactoryBuilder().build(Resources.getResourceAsStream(&quot;mybatis/SqlMapConfig.xml&quot;)); &#125; @Test public void run() &#123; SqlSession sqlSession = sqlSessionFactory.openSession(); UserPojo userPojo = new UserPojo(); userPojo.setId(7); userPojo.setName(&quot;蓬莱山辉夜&quot;); userPojo.setCreate_time(new Date(System.currentTimeMillis())); try &#123; System.out.println(sqlSession.update(&quot;com.day1_6.user.pojo.UserPojo.update&quot;, userPojo)); sqlSession.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; sqlSession.close(); &#125; &#125;&#125; 1userPojo.setId(7); 若去掉本行，则不会进行更新。因为此时执行的SQL为： 1update user set name=&apos;蓬莱山辉夜&apos;,create_time=&apos;2017-05-23 00:14:43&apos; where id=null 1userPojo.setName(&quot;蓬莱山辉夜&quot;); 若去掉本行，则名字字段会更新为null，因为此时执行的SQL为： 1update user set name=null,create_time=&apos;2017-05-23 00:14:43&apos; where id=7 运行该测试类：11 打印的dubug日志信息如下： 1234567891011121314152017-05-23 00:14:42 org.apache.ibatis.logging.LogFactory:135 [DEBUG] - Logging initialized using &apos;class org.apache.ibatis.logging.slf4j.Slf4jImpl&apos; adapter.2017-05-23 00:14:42 org.apache.ibatis.datasource.pooled.PooledDataSource:316 [DEBUG] - PooledDataSource forcefully closed/removed all connections.2017-05-23 00:14:42 org.apache.ibatis.datasource.pooled.PooledDataSource:316 [DEBUG] - PooledDataSource forcefully closed/removed all connections.2017-05-23 00:14:42 org.apache.ibatis.datasource.pooled.PooledDataSource:316 [DEBUG] - PooledDataSource forcefully closed/removed all connections.2017-05-23 00:14:42 org.apache.ibatis.datasource.pooled.PooledDataSource:316 [DEBUG] - PooledDataSource forcefully closed/removed all connections.2017-05-23 00:14:42 org.apache.ibatis.transaction.jdbc.JdbcTransaction:136 [DEBUG] - Opening JDBC Connection2017-05-23 00:14:43 org.apache.ibatis.datasource.pooled.PooledDataSource:387 [DEBUG] - Created connection 1399451388.2017-05-23 00:14:43 org.apache.ibatis.transaction.jdbc.JdbcTransaction:100 [DEBUG] - Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@5369eefc]2017-05-23 00:14:43 com.day1_6.user.pojo.UserPojo.update:159 [DEBUG] - ==&gt; Preparing: UPDATE user set name=?,create_time=? WHERE id=? 2017-05-23 00:14:43 com.day1_6.user.pojo.UserPojo.update:159 [DEBUG] - ==&gt; Parameters: 蓬莱山辉夜(String), 2017-05-23 00:14:42.97(Timestamp), 7(Integer)2017-05-23 00:14:43 com.day1_6.user.pojo.UserPojo.update:159 [DEBUG] - &lt;== Updates: 12017-05-23 00:14:43 org.apache.ibatis.transaction.jdbc.JdbcTransaction:69 [DEBUG] - Committing JDBC Connection [com.mysql.jdbc.JDBC4Connection@5369eefc]2017-05-23 00:14:43 org.apache.ibatis.transaction.jdbc.JdbcTransaction:122 [DEBUG] - Resetting autocommit to true on JDBC Connection [com.mysql.jdbc.JDBC4Connection@5369eefc]2017-05-23 00:14:43 org.apache.ibatis.transaction.jdbc.JdbcTransaction:90 [DEBUG] - Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@5369eefc]2017-05-23 00:14:43 org.apache.ibatis.datasource.pooled.PooledDataSource:344 [DEBUG] - Returned connection 1399451388 to pool.]]></content>
      <categories>
        <category>传智 springmvc+mybatis day1</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdbc</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[传智 springmvc+mybatis day1-5.用户添加]]></title>
    <url>%2F2017%2F05%2F21%2F%E4%BC%A0%E6%99%BAspringmvcmybatisday1-5%E7%94%A8%E6%88%B7%E6%B7%BB%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[项目day1_4项目路径：chuanzhi_springmvc_mybatis 项目架构： pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com&lt;/groupId&gt; &lt;artifactId&gt;day1_4&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;maven.compiler.encoding&gt;UTF-8&lt;/maven.compiler.encoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.43&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;asm&lt;/groupId&gt; &lt;artifactId&gt;asm&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.javassist&lt;/groupId&gt; &lt;artifactId&gt;javassist&lt;/artifactId&gt; &lt;version&gt;3.21.0-GA&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.35&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; mybatis/SqlMapConfig.xml 12345678910111213141516171819&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot; /&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;&quot; /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;mybatis/sqlmap/user.xml&quot; /&gt; &lt;/mappers&gt;&lt;/configuration&gt; mybatis/sqlmap/user.xml 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.day1_4.user.pojo.UserPojo&quot;&gt; &lt;insert id=&quot;insert&quot; parameterType=&quot;com.day1_4.user.pojo.UserPojo&quot;&gt; &lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;int&quot;&gt; select last_insert_id() &lt;/selectKey&gt; insert into user(name,create_time) values(#&#123;name&#125;,#&#123;create_time&#125;) &lt;/insert&gt;&lt;/mapper&gt; 正常写SQL脚本时可在SQL的末尾加上分号以分割。Mybatis不支持SQl后加分号。 #{}接收pojo类型的parameterType时，会使用OGNL以对象导航图的方式解析pojo的属性值。 若传入parameterType中的pojo类型的属性不是简单类型，则可以一直.出所需参数值。例如parameterType传入的pojo类型为User，User中的sex属性同样为pojo类型。则若要取到sex中的real字段，则可用#{sex.real}。 使用${}同样可以实现上文#{}实现的对象导航图功能。 本例中，insert标签中的selectKey类似于habernate的主键返回功能。作用为得到新插入数据自增的主键值(得到主键只是selectKey的一个应用，selectKey并不仅仅可以得到主键)。 Mysql中的last_insert_id()函数可获得刚插入的自增主键值。 selectKey标签中的属性： keyProperty：将查得的key赋给的属性名。 order：返回时机。AFTER即为在本条SQL执行完成后得到所需key值。 resultType：selectKey标签中的SQL语句的返回值类型。 若所用数据库为Orical，因Orical没有自增主键查询函数，则需使用序列实现主键生成。 com.day1_4.user.pojo.UserPojo.java 12345678910111213141516171819202122232425262728293031323334353637package com.day1_4.user.pojo;import java.util.Date;public class UserPojo &#123; private Integer id; private String name; private Date create_time; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Date getCreate_time() &#123; return create_time; &#125; public void setCreate_time(Date create_time) &#123; this.create_time = create_time; &#125;&#125; log4j.properties 123456log4j.rootLogger=DEBUG,baselog4j.appender.base=org.apache.log4j.DailyRollingFileAppenderlog4j.appender.base.layout=org.apache.log4j.PatternLayoutlog4j.appender.base.layout.conversionPattern=%d&#123;yyyy-MM-dd HH\:mm\:ss&#125; %c\:%L [%-4p] - %m%nlog4j.appender.base.File=/day1_4.log com.Insert.java 该类测试Mybatis传入单条pojo类型，将其插入到数据库中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com;import java.util.Date;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Before;import org.junit.Test;import com.alibaba.fastjson.JSON;import com.day1_4.user.pojo.UserPojo;public class Insert &#123; private SqlSessionFactory sqlSessionFactory; @Before public void init() throws Exception &#123; this.sqlSessionFactory = new SqlSessionFactoryBuilder().build(Resources.getResourceAsStream(&quot;mybatis/SqlMapConfig.xml&quot;)); &#125; @Test public void run() &#123; SqlSession sqlSession = sqlSessionFactory.openSession(); UserPojo userPojo = new UserPojo(); userPojo.setName(&quot;八意永琳3&quot;); userPojo.setCreate_time(new Date(System.currentTimeMillis())); try &#123; // 该方法返回插入操作影响的记录数 sqlSession.insert(&quot;com.day1_4.user.pojo.UserPojo.insert&quot;, userPojo); sqlSession.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; sqlSession.close(); &#125; System.out.println(JSON.toJSONString(userPojo)); &#125;&#125;``` 未设置为自动提交，因此需要用sqlSession.commit()手动提交事务。与Sping整合后，会由Spring自动提交。---因配置文件中设置了selectKey，最后输出的pojo类型中已填入Mysql自增生成的主键值。---运行该测试类： {“create_time”:1495343658305,”id”:8,”name”:”八意永琳3”}12打印的dubug日志信息如下： 2017-05-21 13:14:18 org.apache.ibatis.logging.LogFactory:135 [DEBUG] - Logging initialized using ‘class org.apache.ibatis.logging.slf4j.Slf4jImpl’ adapter.2017-05-21 13:14:18 org.apache.ibatis.datasource.pooled.PooledDataSource:316 [DEBUG] - PooledDataSource forcefully closed/removed all connections.2017-05-21 13:14:18 org.apache.ibatis.datasource.pooled.PooledDataSource:316 [DEBUG] - PooledDataSource forcefully closed/removed all connections.2017-05-21 13:14:18 org.apache.ibatis.datasource.pooled.PooledDataSource:316 [DEBUG] - PooledDataSource forcefully closed/removed all connections.2017-05-21 13:14:18 org.apache.ibatis.datasource.pooled.PooledDataSource:316 [DEBUG] - PooledDataSource forcefully closed/removed all connections.2017-05-21 13:14:18 org.apache.ibatis.transaction.jdbc.JdbcTransaction:136 [DEBUG] - Opening JDBC Connection2017-05-21 13:14:18 org.apache.ibatis.datasource.pooled.PooledDataSource:387 [DEBUG] - Created connection 676188939.2017-05-21 13:14:18 org.apache.ibatis.transaction.jdbc.JdbcTransaction:100 [DEBUG] - Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@284dd30b]2017-05-21 13:14:18 com.day1_4.user.pojo.UserPojo.insert:159 [DEBUG] - ==&gt; Preparing: INSERT INTO user(name,create_time) VALUES(?,?)2017-05-21 13:14:18 com.day1_4.user.pojo.UserPojo.insert:159 [DEBUG] - ==&gt; Parameters: 八意永琳3(String), 2017-05-21 13:14:18.305(Timestamp)2017-05-21 13:14:18 com.day1_4.user.pojo.UserPojo.insert:159 [DEBUG] - &lt;== Updates: 12017-05-21 13:14:18 com.day1_4.user.pojo.UserPojo.insert!selectKey:159 [DEBUG] - ==&gt; Preparing: select LAST_INSERT_ID()2017-05-21 13:14:18 com.day1_4.user.pojo.UserPojo.insert!selectKey:159 [DEBUG] - ==&gt; Parameters:2017-05-21 13:14:18 com.day1_4.user.pojo.UserPojo.insert!selectKey:159 [DEBUG] - &lt;== Total: 12017-05-21 13:14:18 org.apache.ibatis.transaction.jdbc.JdbcTransaction:69 [DEBUG] - Committing JDBC Connection [com.mysql.jdbc.JDBC4Connection@284dd30b]2017-05-21 13:14:18 org.apache.ibatis.transaction.jdbc.JdbcTransaction:122 [DEBUG] - Resetting autocommit to true on JDBC Connection [com.mysql.jdbc.JDBC4Connection@284dd30b]2017-05-21 13:14:18 org.apache.ibatis.transaction.jdbc.JdbcTransaction:90 [DEBUG] - Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@284dd30b]2017-05-21 13:14:18 org.apache.ibatis.datasource.pooled.PooledDataSource:344 [DEBUG] - Returned connection 676188939 to pool.12345678910# 项目day1_5项目路径：chuanzhi_springmvc_mybatis项目架构：![1.jpg](/images/blog_pic/传智springmvcmybatisday1/5用户添加/1.jpg)**pom.xml** 4.0.0 com day1_5 0.0.1-SNAPSHOT jar &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;maven.compiler.encoding&gt;UTF-8&lt;/maven.compiler.encoding&gt; junit junit 4.12 test org.slf4j slf4j-log4j12 1.7.25 mysql mysql-connector-java 5.1.43 org.mybatis mybatis 3.4.4 asm asm 3.3.1 cglib cglib 3.2.5 org.javassist javassist 3.21.0-GA com.alibaba fastjson 1.2.35 12**mybatis/SqlMapConfig.xml** &lt;!DOCTYPE configuration PUBLIC “-//mybatis.org//DTD Config 3.0//EN” “http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; 12## mybatis/sqlmap/user.xml &lt;?xml version=”1.0” encoding=”UTF-8”?&gt;&lt;!DOCTYPE mapper PUBLIC “-//mybatis.org//DTD Mapper 3.0//EN” “http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; select uuid() insert into user2(id,name,create_time) values(#{id},#{name},#{create_time}) 1234567若Mysql表中主键未设置自增，则可用uuid函数生成主键。此时生成的时机应为本条语句执行之前。并将生成的主键作为参数插入数据库中。使用uuid函数的好处为可保证主键在数据库表合并时始终全局唯一。注意：Mysql uuid()生成的id长度为36位，因此用于接收的varchar字段长度至少要为36。**log4j.properties** log4j.rootLogger=DEBUG,base log4j.appender.base=org.apache.log4j.DailyRollingFileAppenderlog4j.appender.base.layout=org.apache.log4j.PatternLayoutlog4j.appender.base.layout.conversionPattern=%d{yyyy-MM-dd HH\:mm\:ss} %c\:%L [%-4p] - %m%nlog4j.appender.base.File=/day1_5.log12**com.day1_5.user.pojo.UserPojo.java** package com.day1_5.user.pojo; import java.util.Date; public class UserPojo { private String id; private String name; private Date create_time; public String getId() { return id; } public void setId(String id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Date getCreate_time() { return create_time; } public void setCreate_time(Date create_time) { this.create_time = create_time; } }12**com.Insert.java** package com; import java.util.Date; import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Before;import org.junit.Test; import com.alibaba.fastjson.JSON;import com.day1_5.user.pojo.UserPojo; public class Insert { private SqlSessionFactory sqlSessionFactory; @Before public void init() throws Exception { this.sqlSessionFactory = new SqlSessionFactoryBuilder().build(Resources.getResourceAsStream(&quot;mybatis/SqlMapConfig.xml&quot;)); } @Test public void run() { SqlSession sqlSession = sqlSessionFactory.openSession(); UserPojo userPojo = new UserPojo(); userPojo.setName(&quot;八意永琳&quot;); userPojo.setCreate_time(new Date(System.currentTimeMillis())); try { sqlSession.insert(&quot;com.day1_5.user.pojo.UserPojo.insert&quot;, userPojo); sqlSession.commit(); } catch (Exception e) { e.printStackTrace(); } finally { sqlSession.close(); } System.out.println(JSON.toJSONString(userPojo)); } }1234该类测试Mybatis传入单条pojo类型，将其插入到数据库中。被插入的表主键非自增。值由Mysql的uuid函数生成。运行该测试类： {“create_time”:1495344987204,”id”:”6f644312-3de7-11e7-910e-1002b501dff5”,”name”:”八意永琳”}12打印的dubug日志信息如下： 2017-05-21 13:44:34 org.apache.ibatis.logging.LogFactory:135 [DEBUG] - Logging initialized using ‘class org.apache.ibatis.logging.slf4j.Slf4jImpl’ adapter.2017-05-21 13:44:34 org.apache.ibatis.datasource.pooled.PooledDataSource:316 [DEBUG] - PooledDataSource forcefully closed/removed all connections.2017-05-21 13:44:34 org.apache.ibatis.datasource.pooled.PooledDataSource:316 [DEBUG] - PooledDataSource forcefully closed/removed all connections.2017-05-21 13:44:34 org.apache.ibatis.datasource.pooled.PooledDataSource:316 [DEBUG] - PooledDataSource forcefully closed/removed all connections.2017-05-21 13:44:34 org.apache.ibatis.datasource.pooled.PooledDataSource:316 [DEBUG] - PooledDataSource forcefully closed/removed all connections.2017-05-21 13:44:35 org.apache.ibatis.transaction.jdbc.JdbcTransaction:136 [DEBUG] - Opening JDBC Connection2017-05-21 13:44:35 org.apache.ibatis.datasource.pooled.PooledDataSource:387 [DEBUG] - Created connection 237017996.2017-05-21 13:44:35 org.apache.ibatis.transaction.jdbc.JdbcTransaction:100 [DEBUG] - Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@e209b8c]2017-05-21 13:44:35 com.day1_5.user.pojo.UserPojo.insert!selectKey:159 [DEBUG] - ==&gt; Preparing: select uuid()2017-05-21 13:44:35 com.day1_5.user.pojo.UserPojo.insert!selectKey:159 [DEBUG] - ==&gt; Parameters:2017-05-21 13:44:35 com.day1_5.user.pojo.UserPojo.insert!selectKey:159 [DEBUG] - &lt;== Total: 12017-05-21 13:44:35 com.day1_5.user.pojo.UserPojo.insert:159 [DEBUG] - ==&gt; Preparing: INSERT INTO user2(id,name,create_time) VALUES(?,?,?)2017-05-21 13:44:35 com.day1_5.user.pojo.UserPojo.insert:159 [DEBUG] - ==&gt; Parameters: 922d6848-3de8-11e7-910e-1002b501dff5(String), 八意永琳(String), 2017-05-21 13:44:35.058(Timestamp)2017-05-21 13:44:35 com.day1_5.user.pojo.UserPojo.insert:159 [DEBUG] - &lt;== Updates: 12017-05-21 13:44:35 org.apache.ibatis.transaction.jdbc.JdbcTransaction:69 [DEBUG] - Committing JDBC Connection [com.mysql.jdbc.JDBC4Connection@e209b8c]2017-05-21 13:44:35 org.apache.ibatis.transaction.jdbc.JdbcTransaction:122 [DEBUG] - Resetting autocommit to true on JDBC Connection [com.mysql.jdbc.JDBC4Connection@e209b8c]2017-05-21 13:44:35 org.apache.ibatis.transaction.jdbc.JdbcTransaction:90 [DEBUG] - Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@e209b8c]2017-05-21 13:44:35 org.apache.ibatis.datasource.pooled.PooledDataSource:344 [DEBUG] - Returned connection 237017996 to pool.`]]></content>
      <categories>
        <category>传智 springmvc+mybatis day1</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdbc</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[传智 springmvc+mybatis day1-4.入门程序-查询用户信息]]></title>
    <url>%2F2017%2F05%2F20%2F%E4%BC%A0%E6%99%BAspringmvcmybatisday1-4%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F%E6%9F%A5%E8%AF%A2%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[项目路径： 仓库：chuanzhi_springmvc_mybatis 项目：day1_3 项目架构： pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com&lt;/groupId&gt; &lt;artifactId&gt;day1_3&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;maven.compiler.encoding&gt;UTF-8&lt;/maven.compiler.encoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.43&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;asm&lt;/groupId&gt; &lt;artifactId&gt;asm&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.javassist&lt;/groupId&gt; &lt;artifactId&gt;javassist&lt;/artifactId&gt; &lt;version&gt;3.21.0-GA&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.35&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; fastjson的作用为处理Json字符串。 mybatis/SqlMapConfig.xml 12345678910111213141516171819&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot; /&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;&quot; /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;mybatis/sqlmap/user.xml&quot; /&gt; &lt;/mappers&gt;&lt;/configuration&gt; 通过SqlMapConfig.xml加载Mybatis运行环境。 在SqlMapConfig.xml中配置数据库连接池，与Spring整合后该连接池将由Spring管理。 configuration标签内部包含两个标签：environments及mappers。 environments标签即为Mybatis环境(与Spring整合后使用Spring管理Mybatis的数据源，environments标签废弃)。environments包含两个标签： transactionManager: Mybatis所使用的JDBC事务管理 dataSource: Mybatis所使用的连接池 mappers标签加载具体查询某张表时的信息。最初，ibatis命名规则为：表名.xml。Mybatis不会限定命名，但建议命名为：表名+mapper.xml。为体现知识循序渐进的规律，本项目中采用ibatis命名规范。 mybatis/sqlmap/user.xml 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.day1_3.user.pojo.UserPojo&quot;&gt; &lt;select id=&quot;selectById&quot; parameterType=&quot;int&quot; resultType=&quot;com.day1_3.user.pojo.UserPojo&quot;&gt; select * from user where id= #&#123;id&#125; &lt;/select&gt; &lt;select id=&quot;selectByName&quot; parameterType=&quot;String&quot; resultType=&quot;com.day1_3.user.pojo.UserPojo&quot;&gt; select * from user where name like &apos;$&#123;value&#125;%&apos; &lt;/select&gt;&lt;/mapper&gt; user.xml配置操作user表的相关信息。 mapper标签中的namespace属性为命名空间，其作用为分类管理SQL语句。对SQL语句进行隔离后可方便管理。 本项目中，namespace可随意命名，只要不重名，能起到隔离作用即可。 使用mapper开发DAO时，namespace还另有非常重要的特殊作用，此时namespace不可随意命名，有固定的命名规范。 namespace+id唯一标识(即不同namespace下的id可同名)一个statement(Mybatis以statement为基本单位管理SQL语句）。代码中出现的为select标签的id属性，其余update,insert,delete等标签中的id同理。 #{}表示一个占位符。如果#{}传入简单类型的参数，#{}中的值可随意命名。 #{}会自动进行Java类型向JDBC类型值的转换。例如传入一个字符串，实际执行时会自动在两边加单引号。再比如传入一个字符串类型的参数至数据库中的datetime类型，mysql会自动将其转换为日期类型(Oricle不支持该功能，传入时就必须传入日期类型)。 ${}表示SQL的拼接。 ${}类似于#{}，不同之处在于不会自动进行Java类型向JDBC类型值的转换，即实际执行时维持原值。 select标签中的parameterType属性为输入参数的类型。#{}或${}会接收parameterType参数的值。使用parameterType传入参数时，只能传入一个参数，且传入和接收的命名可不同。其余update,insert,delete等标签中的parameterType同理。 1parameterType=&quot;String&quot; 也可写为： 1parameterType=&quot;string&quot; 也可写为 1parameterType=&quot;java.lang.String&quot; select标签中的resultType属性为输出结果类型。无论查询结果返回的是一条或多条记录，resultType均指定单条记录映射的pojo或hashmap或Java简单类型等。若返回的是多条记录，Mybatis会自动将其封装为List。其余update,insert,delete等标签中的resultType同理。 com.day1_3.user.pojo.UserPojo.java 123456789101112131415161718192021222324package com.day1_3.user.pojo;public class UserPojo &#123; private Integer id; private String name; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; log4j.properties 123456log4j.rootLogger=DEBUG,baselog4j.appender.base=org.apache.log4j.DailyRollingFileAppenderlog4j.appender.base.layout=org.apache.log4j.PatternLayoutlog4j.appender.base.layout.conversionPattern=%d&#123;yyyy-MM-dd HH\:mm\:ss&#125; %c\:%L [%-4p] - %m%nlog4j.appender.base.File=/day1_3.log com.SelectById.java 1234567891011121314151617181920212223242526272829303132333435package com;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Before;import org.junit.Test;import com.alibaba.fastjson.JSON;import com.day1_3.user.pojo.UserPojo;public class SelectById &#123; private SqlSessionFactory sqlSessionFactory; @Before public void init() throws Exception &#123; this.sqlSessionFactory = new SqlSessionFactoryBuilder().build(Resources.getResourceAsStream(&quot;mybatis/SqlMapConfig.xml&quot;)); &#125; @Test public void run() &#123; SqlSession sqlSession = sqlSessionFactory.openSession(); UserPojo userPojo = null; try &#123; userPojo = sqlSession.selectOne(&quot;com.day1_3.user.pojo.UserPojo.selectById&quot;, 1); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; sqlSession.close(); &#125; System.out.println(JSON.toJSONString(userPojo)); &#125;&#125; 该类测试Mybatis传入简单类型，返回单条记录。 其中： 123userPojo = sqlSession.selectOne(&quot;com.day1_3.user.pojo.UserPojo.selectById&quot;, 1);SqlSession.selectOne(String statement, Object parameter)方法接收两个参数，返回单条记录结果(&lt;T&gt;类型，实际使用时会根据XML文件中的resultType返回具体类型)。 String statement：namespace+id唯一标识的statement Object parameter: 传入参数value值。 若执行insert,update,delete等操作，则还需sqlSession.commit()。 运行该测试类： 1&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;博丽灵梦&quot;&#125; 打印的dubug日志信息如下： 12345678910111213142017-05-20 15:15:25 org.apache.ibatis.logging.LogFactory:135 [DEBUG] - Logging initialized using &apos;class org.apache.ibatis.logging.slf4j.Slf4jImpl&apos; adapter.2017-05-20 15:15:25 org.apache.ibatis.datasource.pooled.PooledDataSource:316 [DEBUG] - PooledDataSource forcefully closed/removed all connections.2017-05-20 15:15:25 org.apache.ibatis.datasource.pooled.PooledDataSource:316 [DEBUG] - PooledDataSource forcefully closed/removed all connections.2017-05-20 15:15:25 org.apache.ibatis.datasource.pooled.PooledDataSource:316 [DEBUG] - PooledDataSource forcefully closed/removed all connections.2017-05-20 15:15:25 org.apache.ibatis.datasource.pooled.PooledDataSource:316 [DEBUG] - PooledDataSource forcefully closed/removed all connections.2017-05-20 15:15:25 org.apache.ibatis.transaction.jdbc.JdbcTransaction:136 [DEBUG] - Opening JDBC Connection2017-05-20 15:15:25 org.apache.ibatis.datasource.pooled.PooledDataSource:387 [DEBUG] - Created connection 1780092666.2017-05-20 15:15:25 org.apache.ibatis.transaction.jdbc.JdbcTransaction:100 [DEBUG] - Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@6a1a0efa]2017-05-20 15:15:25 com.day1_3.user.pojo.UserPojo.selectById:159 [DEBUG] - ==&gt; Preparing: SELECT * FROM user WHERE id= ? 2017-05-20 15:15:25 com.day1_3.user.pojo.UserPojo.selectById:159 [DEBUG] - ==&gt; Parameters: 1(Integer)2017-05-20 15:15:25 com.day1_3.user.pojo.UserPojo.selectById:159 [DEBUG] - &lt;== Total: 12017-05-20 15:15:25 org.apache.ibatis.transaction.jdbc.JdbcTransaction:122 [DEBUG] - Resetting autocommit to true on JDBC Connection [com.mysql.jdbc.JDBC4Connection@6a1a0efa]2017-05-20 15:15:25 org.apache.ibatis.transaction.jdbc.JdbcTransaction:90 [DEBUG] - Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@6a1a0efa]2017-05-20 15:15:25 org.apache.ibatis.datasource.pooled.PooledDataSource:344 [DEBUG] - Returned connection 1780092666 to pool. 其中 创建连接并设置自动提交方式为false： 1232017-05-20 15:15:25 org.apache.ibatis.transaction.jdbc.JdbcTransaction:136 [DEBUG] - Opening JDBC Connection2017-05-20 15:15:25 org.apache.ibatis.datasource.pooled.PooledDataSource:387 [DEBUG] - Created connection 1780092666.2017-05-20 15:15:25 org.apache.ibatis.transaction.jdbc.JdbcTransaction:100 [DEBUG] - Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@6a1a0efa] 设置statement。com.day1_3.user.pojo.UserPojo.selectById即为配置文件中配置的namespace+id唯一标识；?即为配置文件中#{}中的值： 122017-05-20 15:15:25 com.day1_3.user.pojo.UserPojo.selectById:159 [DEBUG] - ==&gt; Preparing: SELECT * FROM user WHERE id= ? 2017-05-20 15:15:25 com.day1_3.user.pojo.UserPojo.selectById:159 [DEBUG] - ==&gt; Parameters: 1(Integer) 查询到的结果数： 12017-05-20 15:15:25 com.day1_3.user.pojo.UserPojo.selectById:159 [DEBUG] - &lt;== Total: 1 com.SelectByName.java 12345678910111213141516171819202122232425262728293031323334353637package com;import java.util.List;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Before;import org.junit.Test;import com.alibaba.fastjson.JSON;import com.day1_3.user.pojo.UserPojo;public class SelectByName &#123; private SqlSessionFactory sqlSessionFactory; @Before public void init() throws Exception &#123; this.sqlSessionFactory = new SqlSessionFactoryBuilder().build(Resources.getResourceAsStream(&quot;mybatis/SqlMapConfig.xml&quot;)); &#125; @Test public void run() &#123; SqlSession sqlSession = sqlSessionFactory.openSession(); List&lt;UserPojo&gt; userPojoList = null; try &#123; userPojoList = sqlSession.selectList(&quot;com.day1_3.user.pojo.UserPojo.selectByName&quot;, &quot;八云&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; sqlSession.close(); &#125; System.out.println(JSON.toJSONString(userPojoList)); &#125;&#125; 该类测试Mybatis传入简单类型，返回多条记录。 其中： 1SqlSession.selectList(String statement, Object parameter)方法接收两个参数，返回多条记录结果(&lt;E&gt;类型，实际使用时会根据XML文件中的resultType返回具体类型)。 String statement：namespace+id唯一标识的statement Object parameter: 传入参数value值。 运行该测试类： 1[&#123;&quot;id&quot;:3,&quot;name&quot;:&quot;八云紫&quot;&#125;,&#123;&quot;id&quot;:4,&quot;name&quot;:&quot;八云蓝&quot;&#125;] 打印的dubug日志信息如下： 12345678910111213142017-05-20 16:00:15 org.apache.ibatis.logging.LogFactory:135 [DEBUG] - Logging initialized using &apos;class org.apache.ibatis.logging.slf4j.Slf4jImpl&apos; adapter.2017-05-20 16:00:15 org.apache.ibatis.datasource.pooled.PooledDataSource:316 [DEBUG] - PooledDataSource forcefully closed/removed all connections.2017-05-20 16:00:15 org.apache.ibatis.datasource.pooled.PooledDataSource:316 [DEBUG] - PooledDataSource forcefully closed/removed all connections.2017-05-20 16:00:15 org.apache.ibatis.datasource.pooled.PooledDataSource:316 [DEBUG] - PooledDataSource forcefully closed/removed all connections.2017-05-20 16:00:15 org.apache.ibatis.datasource.pooled.PooledDataSource:316 [DEBUG] - PooledDataSource forcefully closed/removed all connections.2017-05-20 16:00:15 org.apache.ibatis.transaction.jdbc.JdbcTransaction:136 [DEBUG] - Opening JDBC Connection2017-05-20 16:00:15 org.apache.ibatis.datasource.pooled.PooledDataSource:387 [DEBUG] - Created connection 161114647.2017-05-20 16:00:15 org.apache.ibatis.transaction.jdbc.JdbcTransaction:100 [DEBUG] - Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@99a6a17]2017-05-20 16:00:15 com.day1_3.user.pojo.UserPojo.selectByName:159 [DEBUG] - ==&gt; Preparing: SELECT * FROM user WHERE name LIKE &apos;八云%&apos; 2017-05-20 16:00:15 com.day1_3.user.pojo.UserPojo.selectByName:159 [DEBUG] - ==&gt; Parameters: 2017-05-20 16:00:15 com.day1_3.user.pojo.UserPojo.selectByName:159 [DEBUG] - &lt;== Total: 22017-05-20 16:00:15 org.apache.ibatis.transaction.jdbc.JdbcTransaction:122 [DEBUG] - Resetting autocommit to true on JDBC Connection [com.mysql.jdbc.JDBC4Connection@99a6a17]2017-05-20 16:00:15 org.apache.ibatis.transaction.jdbc.JdbcTransaction:90 [DEBUG] - Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@99a6a17]2017-05-20 16:00:15 org.apache.ibatis.datasource.pooled.PooledDataSource:344 [DEBUG] - Returned connection 161114647 to pool. 其中： 因为配置文件中使用${}，因此预编译的SQL中没有占位符。是直接拼接而成的语句。由此可见使用该方法虽可实现功能，但是预编译所带来的优势(防注入，效率高)将消失。 SQL注入简单举例: SQL模版如下： 1String sql = &quot;select * from user where name=&apos;&quot; + name + &quot;&apos;&quot;; 正常情况下，若传入name如下： 1String name = &quot;博丽灵梦&quot;; 则模版实际执行时的sql为： 1select * from user where name=&apos;博丽灵梦&apos; 若传入name变为： 1String name = &quot;博丽灵梦&apos; or &apos;1=1&quot;; 则模版实际执行时的SQL为： 1select * from user where name=&apos;博丽灵梦&apos; or &apos;1=1&apos; 会将表中所有数据均查询出来，形成SQL注入。]]></content>
      <categories>
        <category>传智 springmvc+mybatis day1</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdbc</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[传智 springmvc+mybatis day1-3.mybatis工程结构]]></title>
    <url>%2F2017%2F05%2F19%2F%E4%BC%A0%E6%99%BAspringmvcmybatisday1-3mybatis%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[mybatis3 jar包下载：Releases · mybatis/mybatis-3 项目路径： 仓库：chuanzhi_springmvc_mybatis 项目：day1_2 项目架构： pom.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com&lt;/groupId&gt; &lt;artifactId&gt;day1_2&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;maven.compiler.encoding&gt;UTF-8&lt;/maven.compiler.encoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.43&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;asm&lt;/groupId&gt; &lt;artifactId&gt;asm&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.javassist&lt;/groupId&gt; &lt;artifactId&gt;javassist&lt;/artifactId&gt; &lt;version&gt;3.21.0-GA&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; jar包引用依赖关系如下： 其中： slf4j-log4j12为slf4j与log4j之间的桥接包。 slf4j-log4j12隐式依赖了slf4j-api，即简单日志门面(Simple Logging Facade for Java)，slf4j不是具体的日志解决方案，它只服务于各种各样的日志系统。按照官方的说法，slf4j是一个用于日志系统的简单Facade，允许最终用户在部署其应用时使用其所希望的日志System。 slf4j-log4j12隐式依赖了log4j。log4j是Apache的一个开源项目，通过使用log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件，甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。 mybatis为Mybatis的核心jar包。 asm是一个Java字节码操纵框架，它能被用来动态生成类或者增强既有类的功能。asm可以直接产生二进制class文件，也可以在类被加载入JVM之前动态改变类行为。Java class被存储在严格格式定义的.class文件里，这些类文件拥有足够的元数据来解析类中的所有元素：类名称、方法、属性以及Java字节码指令。asm从类文件中读入信息后，能够改变类行为，分析类信息，甚至能够根据用户要求生成新类。 cglib是一个强大的，高性能，高质量的Code生成类库。它可以在运行期扩展Java类与实现Java接口。其底层是通过小而快的字节码处理框架asm来转换字节码并生成新的类。大部分功能实际上是asm所提供的，cglib只是封装了asm，简化了asm的操作，实现了在运行期动态生成新的class。 cglib隐式依赖了asm，注意这与本pom中单独引用的asm不是同一个jar包，cglib隐式依赖的为org.ow2.asm。 cglib隐式依赖了org.apache下的ant及ant-launcher，其作用为进行文件的压缩与解压缩。 javassist：我们常用到的动态特性主要是反射，在运行时查找对象属性、方法，修改作用域，通过方法名称调用方法等。在线的应用不会频繁使用反射，因为反射的性能开销较大。其实还有一种和反射一样强大的特性，但是开销却很低，它就是Javassit。Javassit其实就是一个二方包，提供了运行时操作Java字节码的方法。大家都知道，Java代码编译完会生成.class文件，就是一堆字节码。JVM(暂不考虑JIT)会解释执行这些字节码(转换为机器码并执行)，由于字节码的解释执行是在运行时进行的，那我们能否手工编写字节码，再由JVM执行呢？答案是肯定的，而Javassist就提供了一些方便的方法，让我们通过这些方法生成字节码。类似字节码操作方法还有asm。几种动态编程方法相比较，在性能上Javassist高于反射，但低于asm，因为Javassist增加了一层抽象。在实现成本上Javassist和反射都很低，而asm由于直接操作字节码，相比Javassist源码级别的api实现成本高很多。几个方法有自己的应用场景，比如Kryo使用的是asm，追求性能的最大化。而NBeanCopyUtil采用的是Javassist，在对象拷贝的性能上也已经明显高于其他的库，并保持高易用性。实际项目中推荐先用Javassist实现原型，若在性能测试中发现Javassist成为了性能瓶颈，再考虑使用其他字节码操作方法做优化。 com.day1_2.user.pojo.UserPojo.java 1234package com.day1_2.user.pojo;public class UserPojo &#123;&#125; 对应数据库表的实体类。 mybatis/SqlMapConfig.xml 12345&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;&lt;/configuration&gt; Mybatis全局配置文件，其作用为加载Mybatis运行环境。 mybatis/sqlmap/user.xml 1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper&gt;&lt;/mapper&gt; 最初，ibatis命名规则为：表名.xml。mybatis不会限定命名，但建议命名为：表名+mapper.xml。 为体现循序渐进的演变过程，本demo程序使用ibatis的命名规范。 log4j.properties 123456log4j.rootLogger=INFO,baselog4j.appender.base=org.apache.log4j.DailyRollingFileAppenderlog4j.appender.base.layout=org.apache.log4j.PatternLayoutlog4j.appender.base.layout.conversionPattern=%d&#123;yyyy-MM-dd HH\:mm\:ss&#125; %c\:%L [%-4p] - %m%nlog4j.appender.base.File=/day1_2.log]]></content>
      <categories>
        <category>传智 springmvc+mybatis day1</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdbc</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[传智 springmvc+mybatis day1-2.mybatis架构]]></title>
    <url>%2F2017%2F05%2F19%2F%E4%BC%A0%E6%99%BAspringmvcmybatisday1-2mybatis%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[Mybatis简介Mybatis因其较为灵活而流行。 Mybatis的前身是Apache的开源项目ibatis。2010年ibatis被apache software foundation迁移至google code，并改名为Mybatis，Mybatis是对ibatis的改进，目前Mybatis托管于github上。 Mybatis是一个持久层框架。使用Mybatis时，程序员只需要关注SQL本身而不需要关注使用JDBC时需进行的繁琐设置，Mybatis会将SQL很好的维护起来。 Mybatis通过XML或注解的方式将要执行的各种statement（statement、preparedStatemnt、CallableStatement）配置起来，并通过Java对象和statement中的SQL进行映射生成最终执行的SQL语句，最后由Mybatis框架执行SQL并将结果映射成Java对象并返回。 Mybatis架构 配置文件 Mybatis有一个全局配置文件，其作用为加载Mybatis运行环境(数据源，事务)。通常命名为sqlMapConfig.xml。实际使用时根据需要可改为其他名称。 除此之外，还有复数个mapper.xml文件，其中配置了SQL语句。 SqlSessionFactory 即会话工厂。其作用为创建SqlSession。 SqlSession SqlSession是面向用户的接口，接口中封装了数据库的操作方法-增删改查。其作用为操作数据库。 Excutor 即为数据库操作的执行器接口。SqlSession内部调用Excutor操作数据库。Excutor接口有两个实现： 默认执行器 缓存执行器 MappedStatement MappedStatement是Mybatis的底层封装对象。该对象封装了SQL语句。Excutor通过MappedStatement操作数据库。 MappedStatement接收输入映射传入的参数封装为对象，由Excutor调用该对象操作数据库。操作结束后通过输出映射生成结果对象。]]></content>
      <categories>
        <category>传智 springmvc+mybatis day1</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdbc</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[传智 springmvc+mybatis day1-1.原生态jdbc编程中的问题总结]]></title>
    <url>%2F2017%2F05%2F18%2F%E4%BC%A0%E6%99%BAspringmvcmybatisday1-1%E5%8E%9F%E7%94%9F%E6%80%81jdbc%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Java使用JDBC操作关系型数据库。Mybatis是对JDBC的封装 JDBC操作数据库的效率比框架高 JDBC demo程序项目路径： 仓库：chuanzhi_springmvc_mybatis 项目：day1_1 项目架构： pom.xml 123456789101112131415161718192021222324252627282930&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com&lt;/groupId&gt; &lt;artifactId&gt;day1_1&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;maven.compiler.encoding&gt;UTF-8&lt;/maven.compiler.encoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.43&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; jar包引用依赖关系如下： 其中，mysql-connector-java导入了mysql-jdbc驱动。junit为单元测试包。junit隐式依赖了hamcrest。hamcrest是一个断言工具包，junit的底层使用了hamcrest作为匹配工具。 com.day1_1.main.Main.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.day1_1.main;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;public class Main &#123; public static void main(String[] args) &#123; Connection connection = null; PreparedStatement preparedStatement = null; ResultSet resultSet = null; try &#123; Class.forName(&quot;com.mysql.jdbc.Driver&quot;); connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8&quot;, &quot;root&quot;, &quot;&quot;); preparedStatement = connection.prepareStatement(&quot;select * from user where name=?&quot;); preparedStatement.setString(1, &quot;博丽灵梦&quot;); resultSet = preparedStatement.executeQuery(); while (resultSet.next()) System.out.println(resultSet.getString(&quot;id&quot;) + &quot; &quot; + resultSet.getString(&quot;name&quot;)); &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (null != resultSet) &#123; try &#123; resultSet.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; if (null != preparedStatement) &#123; try &#123; preparedStatement.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; if (null != connection) &#123; try &#123; connection.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 该类在import时，有以下冲突，应导入接口： com.mysql.cj.jdbc.PreparedStatement(C) java.sql.PreparedStatement(I，导入) PreparedStatement是预编译的Statement。 Statement的作用：通过Statement进行数据库的操作。 为何使用PreparedStatement： 防止sql注入。 效率高，原因：当使用Statement时，数据库接收到SQL语句后会找寻最优执行途径即进行编译，编译的结果会记录到缓存中，下次再遇到相同的SQL则会直接读取缓存中已有的方案而跳过编译的步骤。但是在使用Statement时SQL1: 1select * from user where id=1 与SQL2: 1select * from user where id=2 是两条不同的SQL，因此即便数据库缓存中已有SQL1的处理结果，当其接到SQL2的请求时仍需重新编译，即便这两个SQL执行的最优途径实际上是相同的。PreparedStatement使用 1select * from user where id=? 规避了这个问题。 1Class.forName(&quot;com.mysql.jdbc.Driver&quot;); 该行代码作用为加载Mysql驱动。””中的字符串即为Mysql驱动包中驱动类的全路径。 使用原生JDBC时，若设计不当，则数据库的连接可能会频繁的创建和关闭，浪费数据库资源，影响效率。解决方案：使用数据库连接池。 1preparedStatement = connection.prepareStatement(&quot;select * from user where name=?&quot;); ?表示占位符。 1preparedStatement.setString(1, &quot;博丽灵梦&quot;); 设置占位符的下标应从1开始，这与多数编程习惯不符。]]></content>
      <categories>
        <category>传智 springmvc+mybatis day1</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdbc</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode Algorithms-9.Palindrome Number]]></title>
    <url>%2F2017%2F05%2F12%2FLeetcode%20Algorithms-9PalindromeNumber%2F</url>
    <content type="text"><![CDATA[问题地址Palindrome Number | LeetCode OJ 问题描述 解法思路 将原始数字翻转后与原始数字比较，若相等即为回文数。 原始数据除到个位数时即停止计算，此时翻转后的数字比原数少一位，因此必然不会越界。 注意 不使用额外空间是不可能的，题意应该是指空间复杂度应为O(1)。 负数不是回文数。 代码 1234567891011121314public class Solution &#123; public boolean isPalindrome(int x) &#123; if (x &lt; 0) return false; int originalReduce = x; int reverseIncrease = 0; int measure = 10; while (originalReduce &gt;= measure) &#123; reverseIncrease = reverseIncrease * measure + originalReduce % measure; originalReduce /= measure; &#125; return reverseIncrease == x / measure &amp;&amp; originalReduce == x % measure; &#125;&#125; 以上是leetcode中给出的官方解法，它从根本上避免了int型的越界。不过在我来看，如果用的语言是Java的话，即便越界了也没有什么。原始的x不可能是一个越界的数，如果它在翻转后越界了，说明它就不可能是一个回文数。因此我们可以不用考虑越界问题，这样写： 1234567891011121314class Solution &#123; public boolean isPalindrome(int x) &#123; if (x &lt; 0) return false; int result = 0; int base = x; int m = 10; while (x != 0) &#123; result = m * result + x % m; x /= m; &#125; return result == base; &#125;&#125; 事实上，这种写法确实也能通过leetcode的检查。]]></content>
      <categories>
        <category>Leetcode Algorithms</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Leetcode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux-Windows仿Linux命令界面ConEmu安装]]></title>
    <url>%2F2017%2F05%2F11%2FLinux-Windows%E4%BB%BFLinux%E5%91%BD%E4%BB%A4%E7%95%8C%E9%9D%A2ConEmu%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[本文安装方法面向系统： Windows7 64位 Windows10 64位 安装ConEmu软件下载地址 ConEmu官网下载：下载地址 Windows64位 安装包个人存档：下载地址 安装时，选择64位系统： 其余操作，除安装目录选择外，保持默认即可。 安装成功后初次启动时，需选择bash类型：选择git bash(该bash与原生linux shell最为接近)。 配置成功后的界面：]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Windows</tag>
        <tag>ConEmu</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode Algorithms-7.Reverse Integer]]></title>
    <url>%2F2017%2F05%2F08%2FLeetcode%20Algorithms-7ReverseInteger%2F</url>
    <content type="text"><![CDATA[问题地址Reverse Integer | LeetCode OJ 问题描述 解法1思路 使用long型避免溢出。 注意 Java中int型取值范围为[-2^31 ,2^31 -1]。 Java中a%b=a-(a/b)*b 代码 1234567891011121314public class Solution &#123; public int reverse(int x) &#123; int measure = 10; long result = 0; while(x != 0) &#123; result = measure * result + x % measure; if(result &lt; Integer.MIN_VALUE || result &gt; Integer.MAX_VALUE) return 0; x /= measure; &#125; return (int)result; &#125;&#125; 解法2思路 每次计算后将算得的结果还原回去，若与原值不等则越界。无需使用long型避免越界。 代码 代码路径： 1234567891011121314151617public class Solution &#123; public int reverse(int x) &#123; int result = 0; int m = 10; while (x &gt;= m || x &lt;= -1 * m) &#123; result = m * result + x % m; x /= m; &#125; int tempResult = m * result + x; if ((tempResult - x) / m != result) return 0; else result = tempResult; return result; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode Algorithms</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Leetcode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode Algorithms-1.Two Sum]]></title>
    <url>%2F2017%2F05%2F07%2FLeetcode%20Algorithms-1TwoSum%2F</url>
    <content type="text"><![CDATA[问题地址Two Sum | LeetCode OJ 问题描述 解法思路 使用哈希表存储已遍历过的数字。 代码 12345678910111213141516171819202122import java.util.HashMap;import java.util.Map;public class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; if (null == nums) throw new NullPointerException(&quot;nums is null&quot;); int[] result = new int[2]; Map&lt;Integer, Integer&gt; numberMap = new HashMap&lt;Integer, Integer&gt;(); for(int i = 0; i &lt; nums.length; i++) &#123; int assume = target - nums[i]; if(numberMap.containsKey(assume)) &#123; result[0] = numberMap.get(assume); result[1] = i; break; &#125; numberMap.put(nums[i], i); &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode Algorithms</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Leetcode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode Algorithms-566.Reshape the Matrix]]></title>
    <url>%2F2017%2F05%2F07%2FLeetcode%20Algorithms-566ReshapetheMatrix%2F</url>
    <content type="text"><![CDATA[问题地址Reshape the Matrix | LeetCode OJ 问题描述 总体思路将原始二维数组（不妨设为O）按行读取放入一维数组中(不妨设为T)，再将该一维数组按行填入结果二维数组中（不妨设为R）。 解法1思路 遍历O，通过T建立起O,R索引之间的联系。 代码 代码路径： 1234567891011121314151617181920public class Solution &#123; public int[][] matrixReshape(int[][] nums, int r, int c) &#123; if (null == nums) throw new NullPointerException(&quot;nums is null&quot;); if (r &lt; 0 || c &lt; 0) throw new IllegalArgumentException(&quot;r &lt; 0 || c &lt; 0&quot;); if(nums.length * nums[0].length != r * c) return nums; int[][] result = new int[r][c]; int line = 0; for(int i = 0; i &lt; nums.length; i++) &#123; for(int j = 0; j &lt; nums[0].length; j++) &#123; result[line / c][line % c] = nums[i][j]; line++; &#125; &#125; return result; &#125;&#125; 解法2思路 遍历O，不通过T，直接建立O,R索引之间的联系。 代码 12345678910111213141516171819202122232425public class Solution &#123; public int[][] matrixReshape(int[][] nums, int r, int c) &#123; if (null == nums) throw new NullPointerException(&quot;nums is null&quot;); if (r &lt; 0 || c &lt; 0) throw new IllegalArgumentException(&quot;r &lt; 0 || c &lt; 0&quot;); if(nums.length * nums[0].length != r * c) return nums; int[][] result = new int[r][c]; int tempRow = 0; int tempColumn = 0; for(int i = 0; i &lt; nums.length; i++) &#123; for(int j = 0; j &lt; nums[0].length; j++) &#123; result[tempRow][tempColumn]=nums[i][j]; tempColumn++; if(tempColumn == c) &#123; tempRow++; tempColumn = 0; &#125; &#125; &#125; return result; &#125;&#125; 解法3思路 遍历T，通过T建立起O,R索引之间的联系。 代码 12345678910111213141516public class Solution &#123; public int[][] matrixReshape(int[][] nums, int r, int c) &#123; if (null == nums) throw new NullPointerException(&quot;nums is null&quot;); if (r &lt; 0 || c &lt; 0) throw new IllegalArgumentException(&quot;r &lt; 0 || c &lt; 0&quot;); int expectTotalLength = r * c; if(nums.length * nums[0].length != expectTotalLength) return nums; int[][] result = new int[r][c]; for(int i = 0; i &lt; expectTotalLength; i++) result[i / c][i % c] = nums[i / nums[0].length][i % nums[0].length]; return result; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode Algorithms</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Leetcode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode Algorithms-461.Hamming Distance]]></title>
    <url>%2F2017%2F05%2F01%2FLeetcode%20Algorithms-461HammingDistance%2F</url>
    <content type="text"><![CDATA[问题地址Hamming Distance | LeetCode OJ 问题描述 解法1思路 使用语言自带方法输出抑或位个数。 代码 12345678public class Solution &#123; public int hammingDistance(int x, int y) &#123; if (x &lt; 0 || y &lt; 0) throw new IllegalArgumentException(&quot;x &lt; 0 || y &lt; 0&quot;); return Integer.bitCount(x ^ y); &#125;&#125; 解法2思路 自行实现输出抑或位个数。 代码 1234567891011121314public class Solution &#123; public int hammingDistance(int x, int y) &#123; if (x &lt; 0 || y &lt; 0) throw new IllegalArgumentException(&quot;x &lt; 0 || y &lt; 0&quot;); int xor = x ^ y; int result = 0; while(xor != 0) &#123; result += xor &amp; 1; xor &gt;&gt;= 1; &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode Algorithms</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Leetcode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode Algorithms-561.Array Partition 1]]></title>
    <url>%2F2017%2F04%2F26%2FLeetcode%20Algorithms-561ArrayPartition1%2F</url>
    <content type="text"><![CDATA[问题地址Array Partition I | LeetCode OJ 问题描述 解法1思路 排序后输出奇数项。 时间复杂度：取决于选用的排序算法的时间复杂度；除此之外的时间复杂度为O(n) 空间复杂度：取决于选用的排序算法的空间复杂度；除此之外的空间复杂度为O(1) 代码 12345678910111213141516import java.util.Arrays;public class Solution &#123; public int arrayPairSum(int[] nums) &#123; if (null == nums) throw new NullPointerException(&quot;nums is null&quot;); if (nums.length &lt; 2 || nums.length &gt; 20000) throw new IllegalArgumentException(&quot;nums &apos;s length &lt; 2 || &gt; 20000&quot;); int result = 0; Arrays.sort(nums); for(int i = 0; i &lt; nums.length; i = i + 2) result += nums[i]; return result; &#125;&#125; 解法2思路 题设中规定n为整数，且取值范围为[-10000, 10000]。则可声明一个长度为20001的数组，不妨设为hashArray，该数组作为散列表即可存储所有2n个整数。解决冲突的方法为自增1。即hashArray中元素的值代表其索引值在原2n个整数中出现的次数。hashArray中所有元素求和即为2n。 hashArray生成完成后，其实就完成了对原数组的排序。且时间复杂度为O(n)，空间复杂度O(n)。 遍历hashArray，设当前进行到的下标为i，则hashArray[i]按奇偶数及输出状态将情况分为以下4种： 输出 不输出 奇数 值：(i - 10000) * (hashArray[i] + 1) / 2下一个索引开始状态：不输出 值：(i - 10000) * (hashArray[i] / 2)下一个索引开始状态：输出 偶数 值：(i - 10000) * hashArray[i] / 2下一个索引开始状态：输出 值：(i - 10000) * hashArray[i] / 2下一个索引开始状态：不输出 其中 输出/不输出 是指：因只需输出有序数组中的奇数项，故某下标开始时会有一个输出或不输出的状态；结束时又会为下一个下标生成一个输出或不输出的状态。 奇数/偶数 是指：该下标中存储的值，即为下标值在原始数据中出现的次数。 原始数据 –&gt; hashArray 做了 [-10000, 10000] –&gt; [0, 20000] 的值映射，因此实际参与计算时应还原回原值。 代码 奇数-不输出时，(i - 10000) * (hashArray[i] / 2)中，(hashArray[i] / 2)的括号一定要有，保证整数下取整机制。 1234567891011121314151617181920212223242526public class Solution &#123; public int arrayPairSum(int[] nums) &#123; if (null == nums) throw new NullPointerException(&quot;nums is null&quot;); if (nums.length &lt; 2 || nums.length &gt; 20000) throw new IllegalArgumentException(&quot;nums &apos;s length &lt; 2 || &gt; 20000&quot;); int limit = 10000; int result = 0; int[] hashArray = new int[2 * limit + 1]; boolean ifAdd = true; for(int num : nums) hashArray[num + limit]++; for(int i = 0; i &lt; hashArray.length; i++) &#123; if(hashArray[i] % 2 == 0) &#123; result = result + (i - limit) * hashArray[i] / 2; &#125; else &#123; if(ifAdd) result = result + (i - limit) * (hashArray[i] + 1) / 2; else result = result + (i - limit) * (hashArray[i] / 2); ifAdd = !ifAdd; &#125; &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode Algorithms</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Leetcode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python-Windows下Python安装]]></title>
    <url>%2F2017%2F04%2F24%2FPython-Windows%E4%B8%8BPython%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[本文安装方法面向系统： Windows7 64位 Windows10 64位 安装Python软件下载地址 Python官网下载地址：下载地址。 Windows64位安装包个人存档：下载地址。 安装时，除安装目录选择外，其余设定保持默认即可。 不妨将安装目录设为： 1D:\work\python\python27 配置python环境变量在path变量中追加： 1D:\work\python\python27 打开cmd，输入： 1python -V 返回如下类似信息则安装成功： 安装Pip软件下载地址 Pip官网下载地址：下载地址。 Windows64位安装包个人存档：下载地址。 解压后打开cmd，进入解压目录，执行： 1python setup.py install 安装完成后安装包即可删除。 配置Pip环境变量在path变量中追加： 1D:\work\python\python27\Scripts 打开cmd，输入： 1pip list 返回如下类似信息则安装成功： 安装Pycharm软件下载地址 Windows64位安装包个人存档：下载地址。 安装时，除安装目录选择外，其余设定保持默认即可。 Pycharm注册首次启动Pycharm时会提示输入注册信息。 解压下载文件中的压缩包PyCharm4.0_KeyGen.zip，得到keygen.exe，执行该文件。将Application切换至PyCharm，得到User Name及License Key。填入对应位置。 Pycharm设置文件编码 1File --&gt; File Encoding 缩进 1File --&gt; Settings --&gt; Editor --&gt; Code Style --&gt; Python 字号 12File --&gt; Settings --&gt; Editor --&gt; Colors &amp; Fonts --&gt; FontFile --&gt; Settings --&gt; Editor --&gt; Colors &amp; Fonts --&gt; Console Font]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Pip</tag>
        <tag>Pycharm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven-Eclipse新建Maven标准应用]]></title>
    <url>%2F2017%2F04%2F23%2FMaven-Eclipse%E6%96%B0%E5%BB%BAMaven%E6%A0%87%E5%87%86%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Eclipse</tag>
        <tag>Java</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven-Maven安装]]></title>
    <url>%2F2017%2F04%2F23%2FMaven-Maven%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[本文安装方法面向系统： Windows7 64位 Windows10 64位 安装Maven软件下载地址 Maven官网下载地址：下载地址。 Windows64位安装包个人存档：下载地址。 解压即可，不妨将解压后的根目录路径设为： 1D:\work\java\apache-maven-3.5.0 配置环境变量新建变量： 12变量名: MAVEN_HOME变量值: D:\work\java\apache-maven-3.5.0 在path变量中追加： 1%MAVEN_HOME%\bin 打开cmd，输入： 1mvn -v 返回如下类似信息则安装成功： 修改本地仓库存储路径打开D:\work\java\apache-maven-3.5.0\conf\settings.xml，修改本地仓库路径(路径中不能有空格)： 1&lt;localRepository&gt;D:\work\java\maven-repository&lt;/localRepository&gt; 关联Maven与Eclipse打开Eclipse，在菜单项中依次选择： 1Window --&gt; Preferences --&gt; Maven --&gt; User Settings 设置如下: 在菜单项中依次选择： 1Window --&gt; Preferences --&gt; Maven --&gt; Installations 将Eclipse关联的Maven软件改为新下载的版本： 配置下载jar包源码打开D:\work\java\apache-maven-3.5.0\conf\settings.xml，添加： 12345678910111213&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;downloadSources&lt;/id&gt; &lt;properties&gt; &lt;downloadSources&gt;true&lt;/downloadSources&gt; &lt;downloadJavadocs&gt;true&lt;/downloadJavadocs&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;/profiles&gt; &lt;activeProfiles&gt; &lt;activeProfile&gt;downloadSources&lt;/activeProfile&gt; &lt;/activeProfiles&gt; 打开Eclipse，在菜单项中依次选择： 1Window --&gt; Preferences --&gt; Maven 配置如下： 指定Maven默认Java版本打开D:\work\java\apache-maven-3.5.0\conf\settings.xml，添加： 1234567891011121314&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;jdk-1.7&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.7&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.7&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt;&lt;/profiles&gt; 示例中使用的是JDK1.7。依实际需求可改成对应版本。]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Eclipse</tag>
        <tag>Java</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github-Github基本操作]]></title>
    <url>%2F2017%2F04%2F22%2FGithub-Github%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[创建新项目通过Github页面创建新项目，得到SSH clone地址(使用HTTP时每次提交均需输入账号密码，SSH不需要)。进入选定的仓库目录，clone远端代码： 1git clone git@github.com:ReimuWang/gitHubTest.git 日常操作流程触发时机：阶段性修改完成，需提交至远端(首次填充空仓库也可视为一次较大的改动而非创建)。 拉取最新的代码 1git pull 查看当前工作区的更改情况 1git status 根据status的指示，将工作区中修改的文件添加至缓存区 1git add 文件名 特别的，如下命令将添加所有变更文件 1git add * 将当前缓存区中的文件提交到本地HEAD中(该命令执行后还需输入一下本次提交的简介) 1git commit 将本地HEAD中的文件提交至远端master分支，可积攒多个commit后统一提交 1git push origin master]]></content>
      <categories>
        <category>Github</category>
      </categories>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github-Hexo主题Next使用总结]]></title>
    <url>%2F2017%2F04%2F17%2FGithub-Hexo%E4%B8%BB%E9%A2%98Next%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Next安装进入Hexo根目录，执行： 1git clone https://github.com/iissnan/hexo-theme-next themes/next/ 配置文件路径 Hexo配置文件路径：hexo/_config.yml Next配置文件路径：hexo/themes/next/_config.yml 启用Next修改Hexo配置文件： 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next Next主题设定通过Next配置文件，可配置3种主题： 1234# Schemes#scheme: Musescheme: Mist#scheme: Pisces 说明： 主题 描述 Muse 默认主题，大量留白 Mist 默认主题紧凑简洁版 Pisces 双栏紧凑简洁版，移动端无法滑动，不可用 文章中添加图片文章中用到的本地图片可存放于：hexo/themes/next/source/images/ 实际调用时的格式形如： 1![0.jpg](/images/0.jpg) 菜单Next的菜单如下图所示： 要实现上图中的界面，需在Next配置文件中设置： 12345678menu: home: / categories: /categories #about: /about archives: /archives tags: /tags #sitemap: /sitemap.xml #commonweal: /404.html Hexo将具体的文章称为post，存储在hexo/source/_posts/中，将菜单项称为page，以文件夹的形式存储在hexo/source/中。若Next配置文件中配置的某菜单项未在hexo/source/下创建文件夹，则将报错。以categories为例，进入Hexo根目录后执行： 1hexo new page &quot;categories&quot; 此时hexo/source/中将生成目录categories，打开该目录下的index.md文件，修改type字段： 1type: &quot;categories&quot; 若启用了评论插件，menu页面默认也会开启该功能，若要在某menu中取消该功能，以categories为例，在hexo/source/categories/index.md中添加： 1comments: false 侧边栏显示时机侧边栏如下图所示： 可在next配置文件中设置其展示时机： 12345678910sidebar: # Sidebar Display, available value: # - post expand on posts automatically. Default. # - always expand for all pages automatically # - hide expand only when click on the sidebar toggle icon. # - remove Totally remove sidebar including sidebar toggle. #display: post display: always #display: hide #display: remove display字段可选值及含义如下： 值 含义 post 在文章页面中（拥有目录列表时）显示 always 在所有页面中都显示 hide 在所有页面中都隐藏（可以手动展开） remove 完全移除 设置头像头像展现示例： 在Hexo配置文件中添加： 1avatar: /images/avatar.jpg 将头像文件avatar.jpg(380*380)放入路径：hexo/themes/next/source/images/ 设置logolog展示示例 修改Next配置文件： 1favicon: images/favicon.ico 将logo文件favicon.ico（32*32）存入hexo/themes/next/source/images/ 可使用favicon制作 - 在线工具制作logo。 添加404公益页面在Next配置文件中添加公益页面菜单。 1commonweal: /404.html 在hexo/source/中添加404.html文件： 1234567891011121314151617layout: falsetitle: &quot;404&quot;date: 2017-04-18 22:13:15---&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8;&quot;/&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt;&lt;meta name=&quot;robots&quot; content=&quot;all&quot; /&gt;&lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;/&gt;&lt;title&gt;公益404页面 // ReimuWang的博客&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.qq.com/404/search_children.js&quot; charset=&quot;utf-8&quot; homePageUrl=&quot;http://reimuwang.org/&quot; homePageName=&quot;ReimuWang的博客&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 添加网易云音乐展示示例 访问网易云音乐，找到欲添加的歌曲。点击 生成外链播放器。 配置如下图所示，完成后点击 复制代码。 在hexo/themes/next/layout/_macro/sidebar.swig中的div class=”sidebar-toggle”中新建div，添加刚才复制的代码，例如： 123&lt;div id=&quot;music163player&quot;&gt; &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 src=&quot;//music.163.com/outchain/player?type=2&amp;id=691506&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;&lt;/div&gt; 添加Fork me on GitHub展示示例 访问GitHub Ribbons，挑选某个样式： 将代码复制至hexo/themes/next/layout/_layout.swig文件的body标签中： 1&lt;a href=&quot;https://github.com/ReimuWang&quot;&gt;&lt;img style=&quot;position: absolute; top: 0; left: 0; border: 0;&quot; src=&quot;https://camo.githubusercontent.com/567c3a48d796e2fc06ea80409cc9dd82bf714434/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f6461726b626c75655f3132313632312e706e67&quot; alt=&quot;Fork me on GitHub&quot; data-canonical-src=&quot;https://s3.amazonaws.com/github/ribbons/forkme_left_darkblue_121621.png&quot;&gt;&lt;/a&gt; 其中 1href=&quot;https://github.com/ReimuWang&quot; 填写Github个人主页网址。 字数统计功能展示示例 进入Hexo根目录，执行： 1npm install hexo-wordcount --save 修改Next配置文件： 1234post_wordcount: item_text: true wordcount: true min2read: true Leancloud阅读次数统计展示示例 访问LeanCloud，注册后得到app_id及app_key： 添加class Counter。该class名称固定，不可命名为其他名称。 修改Next配置文件： 1234leancloud_visitors: enable: true app_id: xxx app_key: xxx]]></content>
      <categories>
        <category>Github</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github-Hexo使用总结]]></title>
    <url>%2F2017%2F04%2F16%2FGithub-Hexo%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Hexo的配置信息基本都位于其根目录下的_config.yml中。 日常操作进入Hexo根目录: 新建文章 1hexo new post &quot;xxx&quot; 或直接在_posts目录下新建.md文件。 清空缓存；生成文件；上传至服务器 1hexo clean;hexo d -g 本地调试 1hexo clean;hexo g;hexo server 主题主题相当于Hexo基本功能的定制与扩展。其中主题Next的使用参见Github-Hexo主题Next使用总结 站点信息打开Hexo根目录下的_config.yml。修改站点信息： 1234567# Sitetitle: ReimuWang&apos;s Blogsubtitle:description: Thou Shalt Commentauthor: 王艺凯language: zh-Hanstimezone: 说明 字段 含义 title 站点标题 subtitle 站点子标题（next中无效） description 站点简介 author 站点作者 language 站点语言，简体中文值为zh-Hans timezone 站点时区（next中无效） 分页修改Hexo根目录下的_config.yml： 1234# Pagination## Set per_page to 0 to disable paginationper_page: 1pagination_dir: page 头像修改Hexo根目录下的_config.yml： 1avatar: images/avatar.jpg 若使用Next主题则images目录为hexo/themes/next/source/images 绑定阿里万网域名在万网购买域名后，进入其管理控制台的云解析DNS目录，点击解析： 点击立即设置： 提示输入ip： ping Github博客首页： 1ping reimuwang.github.io 得到的返回值形如： 将红框中的ip填入上文提示输入ip的选框中。点击提交： 在Hexo根目录的source文件夹下新建文件CNAME，其中填入在万网中申请到的域名： 1reimuwang.org]]></content>
      <categories>
        <category>Github</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github-Hexo安装]]></title>
    <url>%2F2017%2F04%2F16%2FGithub-Hexo%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[本文安装方法面向系统：Windows7/10 64位。 安装Node.js软件下载地址 Node.js官网下载地址 Windows64位安装包个人存档 安装时，除安装目录外，其余设定保持默认即可。 验证 执行： 12node -vnpm -v 安装成功时的结果形如： 安装Hexo安装 新建Hexo安装目录并进入到该目录下，执行： 1npm install hexo-cli -g 安装时间可能会较长，期间可能无输出或输出warn信息，为正常情况。安装完成后输入如下语句验证： 1hexo -v 安装成功时输出形如： 初始化 进入到Hexo安装目录下，依次执行： 12hexo initnpm install 安装时间可能会较长，期间可能无输出或输出warn信息，为正常情况。]]></content>
      <categories>
        <category>Github</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github-Github添加SSH密钥]]></title>
    <url>%2F2017%2F04%2F12%2FGithub-Github%E6%B7%BB%E5%8A%A0SSH%E5%AF%86%E9%92%A5%2F</url>
    <content type="text"><![CDATA[本文方法面向系统：Windows7/10 64位。 SSH密钥分为私钥与公钥两部分:私钥存储在本地机器中，而公钥则上传到Github服务器的自身账号下。 本地机器端设置Git用户名 1git config --global user.name &quot;ReimuWang&quot; 设置Git邮箱 1git config --global email.name &quot;1505580759@qq.com&quot; 生成SSH密钥对 1ssh-keygen -t rsa -C &quot;1505580759@qq.com&quot; -C后的参数值为上文设置的Git邮箱。命令输入后会提示输入密码，无需密码的情况下，连按3个回车即可。 执行完成后进入~/.ssh，即可发现其下多了两个文件。其中id_rsa为私钥，id_rsa.pub为公钥。 将生成的私钥注册至本地机器的ssh-agent 注册前首先确保本地的ssh-agent可用。执行： 1eval &quot;$(ssh-agent -s)&quot; 如果返回值形如： 1Agent pid 5292 则ssh-agent即为可用。此时将刚才生成的私钥注册至本机的ssh-agent中： 1ssh-add ~/.ssh/id_rsa Github服务器端将公钥注册至Github的个人账户下 登陆Github，进入个人页。点击右上角的Settings： 点击左侧的SSH and GPG keys： 点击右侧的New SSH key： 将id_rsa.pub文件中的值粘贴至key选框中。然后点击Add SSH key： 验证执行： 1ssh -T git@github.com 如果结果返回形如： 1Hi ReimuWang! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 则证明配对成功。]]></content>
      <categories>
        <category>Github</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github-Git安装]]></title>
    <url>%2F2017%2F04%2F11%2FGithub-Git%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[本文安装方法面向系统：Windows7/10 64位。 安装git软件下载地址 Git官网下载地址 Windows 64位安装包个人存档 验证是否安装成功 1git --version 安装成功时返回版本信息： 安装TortoiseGit软件下载地址 TortoiseGit官网下载地址 Windows 64位安装包个人存档 先安装软件本体，再安装语言包。]]></content>
      <categories>
        <category>Github</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github-Github+Hexo搭建博客]]></title>
    <url>%2F2017%2F04%2F11%2FGithub-GithubHexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[本文安装方法面向系统：Windows7/10 64位。 Github环境搭建git安装 参见：Github-Git安装。 注册Github账号 登陆GitHub官网进行注册，直到回复确认邮件后才算是注册完成。 Github添加SSH密钥 参见：Github-Github添加SSH密钥。 创建存储博客应用的仓库 登入Github个人主页，点击下图右上角红框中的位置，创建一个新的仓库用于部署博客应用。 创建仓库时只需要填写Repository name，博客应用中该值固定为Gitgub账号名.github.io，以我为例，为： 1ReimuWang.github.io 填写完成后点击创建按钮： 创建后即可生成用于存储博客的仓库： Hexo环境搭建参见：Github-Hexo安装。 Github与Hexo建立关联安装Github-Hexo关联扩展 进入到Hexo安装目录下，执行： 1npm install hexo-deployer-git --save 修改Hexo配置文件 打开Hexo根目录下的_config.yml，修改deploy属性： 1234deploy: type: git repo: git@github.com:ReimuWang/ReimuWang.github.io.git branch: master 其中ReimuWang为Github账号名。 使用参见：Github-Hexo使用总结。]]></content>
      <categories>
        <category>Github</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github-Markdown语法]]></title>
    <url>%2F2017%2F04%2F10%2FGithub-Markdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[语法筛选规则：Github + Hexo + Next环境下测试通过并且展现效果良好。 标题代码 123456# 1级标题## 2级标题### 3级标题#### 4级标题##### 5级标题###### 6级标题 效果 引用代码 1234&gt; # 参考资料&gt;&gt; [ReimuWang的博客](http://reimuwang.org)&gt; [ReimuWang的Github主页](https://github.com/ReimuWang) 效果 强调代码 1234567*斜体***粗体*****粗斜体***~~删除线~~ 效果 斜体 粗体 粗斜体 删除线 无序列表代码 123- 元素- 元素- 元素 效果 元素 元素 元素 有序列表代码 1231. 元素12. 元素23. 元素3 效果 元素1 元素2 元素3 链接代码 1[ReimuWang的博客](http://reimuwang.org) 效果 ReimuWang的博客 图片代码 123![2.jpg](/images/blog_pic/Github/Markdown语法/2.jpg)![网络图片](http://5b0988e595225.cdn.sohucs.com/images/20170815/2b2b96ea6139429a9c2fcae53af5b8d3.jpeg) 效果 代码代码 效果 1print &quot;Hello, Reimu&quot; 水平分割线代码 1--- 效果 表格代码 效果 标题行1 标题行2 标题行3 左对齐 右对齐换行 居中 左对齐 右对齐 居中 缩略显示1&lt;!-- more --&gt;]]></content>
      <categories>
        <category>Github</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
