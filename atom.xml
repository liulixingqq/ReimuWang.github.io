<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ReimuWang&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-19T02:48:10.851Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>王艺凯</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode Algorithms-104.Maximum Depth of Binary Tree</title>
    <link href="http://yoursite.com/2018/09/19/Leetcode%20Algorithms-104Maximum%20Depth%20of%20Binary%20Tree/"/>
    <id>http://yoursite.com/2018/09/19/Leetcode Algorithms-104Maximum Depth of Binary Tree/</id>
    <published>2018-09-19T02:46:43.000Z</published>
    <updated>2018-09-19T02:48:10.851Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题地址"><a href="#问题地址" class="headerlink" title="问题地址"></a>问题地址</h1><p><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/description/" target="_blank" rel="noopener">Maximum Depth of Binary Tree - LeetCode</a></p><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p><img src="/images/blog_pic/Leetcode Algorithms/104Maximum Depth of Binary Tree/0.jpg" alt="0.jpg"></p><a id="more"></a><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public int maxDepth(TreeNode root) &#123;</span><br><span class="line">        return null == root ? 0 : Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题地址&quot;&gt;&lt;a href=&quot;#问题地址&quot; class=&quot;headerlink&quot; title=&quot;问题地址&quot;&gt;&lt;/a&gt;问题地址&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/maximum-depth-of-binary-tree/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Maximum Depth of Binary Tree - LeetCode&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/blog_pic/Leetcode Algorithms/104Maximum Depth of Binary Tree/0.jpg&quot; alt=&quot;0.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode Algorithms" scheme="http://yoursite.com/categories/Leetcode-Algorithms/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode Algorithms-101.Symmetric Tree</title>
    <link href="http://yoursite.com/2018/09/18/Leetcode%20Algorithms-101Symmetric%20Tree/"/>
    <id>http://yoursite.com/2018/09/18/Leetcode Algorithms-101Symmetric Tree/</id>
    <published>2018-09-18T09:21:43.000Z</published>
    <updated>2018-09-18T09:24:33.293Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题地址"><a href="#问题地址" class="headerlink" title="问题地址"></a>问题地址</h1><p><a href="https://leetcode.com/problems/symmetric-tree/description/" target="_blank" rel="noopener">Symmetric Tree - LeetCode</a></p><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p><img src="/images/blog_pic/Leetcode Algorithms/101Symmetric Tree/0.jpg" alt="0.jpg"></p><a id="more"></a><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public boolean isSymmetric(TreeNode root) &#123;</span><br><span class="line">        return root == null || isSymmetricHelp(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean isSymmetricHelp(TreeNode left, TreeNode right) &#123;</span><br><span class="line">        if(left == null || right == null) return left == right;</span><br><span class="line">        if(left.val != right.val) return false;</span><br><span class="line">        return isSymmetricHelp(left.left, right.right) &amp;&amp; isSymmetricHelp(left.right, right.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题地址&quot;&gt;&lt;a href=&quot;#问题地址&quot; class=&quot;headerlink&quot; title=&quot;问题地址&quot;&gt;&lt;/a&gt;问题地址&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/symmetric-tree/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Symmetric Tree - LeetCode&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/blog_pic/Leetcode Algorithms/101Symmetric Tree/0.jpg&quot; alt=&quot;0.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode Algorithms" scheme="http://yoursite.com/categories/Leetcode-Algorithms/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode Algorithms-100.Same Tree</title>
    <link href="http://yoursite.com/2018/09/18/Leetcode%20Algorithms-100Same%20Tree/"/>
    <id>http://yoursite.com/2018/09/18/Leetcode Algorithms-100Same Tree/</id>
    <published>2018-09-18T07:10:43.000Z</published>
    <updated>2018-09-18T07:13:09.234Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题地址"><a href="#问题地址" class="headerlink" title="问题地址"></a>问题地址</h1><p><a href="https://leetcode.com/problems/same-tree/description/" target="_blank" rel="noopener">Same Tree - LeetCode</a></p><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p><img src="/images/blog_pic/Leetcode Algorithms/100Same Tree/0.jpg" alt="0.jpg"></p><a id="more"></a><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public boolean isSameTree(TreeNode p, TreeNode q) &#123;</span><br><span class="line">        if (p == null &amp;&amp; q == null) return true;</span><br><span class="line">        if (p == null || q == null) return false;</span><br><span class="line">        if (p.val != q.val) return false;</span><br><span class="line">        return this.isSameTree(p.left, q.left) &amp;&amp; this.isSameTree(p.right, q.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题地址&quot;&gt;&lt;a href=&quot;#问题地址&quot; class=&quot;headerlink&quot; title=&quot;问题地址&quot;&gt;&lt;/a&gt;问题地址&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/same-tree/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Same Tree - LeetCode&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/blog_pic/Leetcode Algorithms/100Same Tree/0.jpg&quot; alt=&quot;0.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode Algorithms" scheme="http://yoursite.com/categories/Leetcode-Algorithms/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode Algorithms-88.Merge Sorted Array</title>
    <link href="http://yoursite.com/2018/09/18/Leetcode%20Algorithms-88Merge%20Sorted%20Array/"/>
    <id>http://yoursite.com/2018/09/18/Leetcode Algorithms-88Merge Sorted Array/</id>
    <published>2018-09-18T02:56:43.000Z</published>
    <updated>2018-09-18T03:04:26.245Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题地址"><a href="#问题地址" class="headerlink" title="问题地址"></a>问题地址</h1><p><a href="https://leetcode.com/problems/merge-sorted-array/description/" target="_blank" rel="noopener">Merge Sorted Array - LeetCode</a></p><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p><img src="/images/blog_pic/Leetcode Algorithms/88Merge Sorted Array/0.jpg" alt="0.jpg"></p><a id="more"></a><h1 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h1><p>正向迭代，此时需要顾虑nums1的长度变化情况，因此比较臃肿。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public void merge(int[] nums1, int m, int[] nums2, int n) &#123;</span><br><span class="line">        int i1 = 0;</span><br><span class="line">        int lengthI1 = m; </span><br><span class="line">        int orginI1 = 0;</span><br><span class="line">        int i2 = 0;</span><br><span class="line">        while (orginI1 &lt; m &amp;&amp; i2 &lt; n) &#123;</span><br><span class="line">            if (nums2[i2] &gt;= nums1[i1]) orginI1++;</span><br><span class="line">            else &#123;</span><br><span class="line">                this.insert(nums2[i2], nums1, lengthI1, i1);</span><br><span class="line">                lengthI1++;</span><br><span class="line">                i2++;</span><br><span class="line">            &#125;</span><br><span class="line">            i1++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (orginI1 == m)</span><br><span class="line">            for (int i = i2; i &lt; n; i++) nums1[i1++] = nums2[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void insert(int value, int[] nums, int length, int index) &#123;</span><br><span class="line">        for (int i = length; i &gt; index; i--) nums[i] = nums[i - 1];</span><br><span class="line">        nums[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h1><p>逆向迭代，看起来好多了。不过时间复杂度其实差不多。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public void merge(int[] nums1, int m, int[] nums2, int n) &#123;</span><br><span class="line">        int i1 = m - 1;</span><br><span class="line">        int i2 = n - 1;</span><br><span class="line">        int now = m + n - 1;</span><br><span class="line">        while (i1 &gt; -1 &amp;&amp; i2 &gt; -1)</span><br><span class="line">            nums1[now--] = (nums1[i1] &gt; nums2[i2]) ? nums1[i1--] : nums2[i2--];</span><br><span class="line">        while (i2 &gt; -1) nums1[now--] = nums2[i2--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题地址&quot;&gt;&lt;a href=&quot;#问题地址&quot; class=&quot;headerlink&quot; title=&quot;问题地址&quot;&gt;&lt;/a&gt;问题地址&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/merge-sorted-array/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Merge Sorted Array - LeetCode&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/blog_pic/Leetcode Algorithms/88Merge Sorted Array/0.jpg&quot; alt=&quot;0.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode Algorithms" scheme="http://yoursite.com/categories/Leetcode-Algorithms/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode Algorithms-83.Remove Duplicates from Sorted List</title>
    <link href="http://yoursite.com/2018/09/17/Leetcode%20Algorithms-83Remove%20Duplicates%20from%20Sorted%20List/"/>
    <id>http://yoursite.com/2018/09/17/Leetcode Algorithms-83Remove Duplicates from Sorted List/</id>
    <published>2018-09-17T11:11:43.000Z</published>
    <updated>2018-09-17T11:16:36.622Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题地址"><a href="#问题地址" class="headerlink" title="问题地址"></a>问题地址</h1><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/description/" target="_blank" rel="noopener">Remove Duplicates from Sorted List - LeetCode</a></p><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p><img src="/images/blog_pic/Leetcode Algorithms/83Remove Duplicates from Sorted List/0.jpg" alt="0.jpg"></p><a id="more"></a><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>非递归：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public ListNode deleteDuplicates(ListNode head) &#123;</span><br><span class="line">        if (null == head) return head;</span><br><span class="line">        ListNode tail = head;</span><br><span class="line">        ListNode now = head.next;</span><br><span class="line">        while (null != now) &#123;</span><br><span class="line">            if (tail.val != now.val) &#123;</span><br><span class="line">                tail.next = now;</span><br><span class="line">                tail = now;</span><br><span class="line">            &#125;</span><br><span class="line">            now = now.next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail.next = null;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(int x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public ListNode deleteDuplicates(ListNode head) &#123;</span><br><span class="line">        if(null == head || null == head.next) return head;</span><br><span class="line">        head.next = deleteDuplicates(head.next);</span><br><span class="line">        return head.val == head.next.val ? head.next : head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(int x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题地址&quot;&gt;&lt;a href=&quot;#问题地址&quot; class=&quot;headerlink&quot; title=&quot;问题地址&quot;&gt;&lt;/a&gt;问题地址&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/remove-duplicates-from-sorted-list/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Remove Duplicates from Sorted List - LeetCode&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/blog_pic/Leetcode Algorithms/83Remove Duplicates from Sorted List/0.jpg&quot; alt=&quot;0.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode Algorithms" scheme="http://yoursite.com/categories/Leetcode-Algorithms/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode Algorithms-70.Climbing Stairs</title>
    <link href="http://yoursite.com/2018/09/17/Leetcode%20Algorithms-70Climbing%20Stairs/"/>
    <id>http://yoursite.com/2018/09/17/Leetcode Algorithms-70Climbing Stairs/</id>
    <published>2018-09-17T10:37:43.000Z</published>
    <updated>2018-09-17T10:55:38.238Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题地址"><a href="#问题地址" class="headerlink" title="问题地址"></a>问题地址</h1><p><a href="https://leetcode.com/problems/climbing-stairs/description/" target="_blank" rel="noopener">Climbing Stairs - LeetCode</a></p><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p><img src="/images/blog_pic/Leetcode Algorithms/70Climbing Stairs/0.jpg" alt="0.jpg"></p><a id="more"></a><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>本题实际上就是一个斐波那契数列的变种，原始的斐波那契数列的定义为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">F(0)=0</span><br><span class="line">F(1)=1</span><br><span class="line">F(n)=F(n-1)+F(n-2) (n&gt;=2)</span><br></pre></td></tr></table></figure><p>即是一组这样的数:0,1,1,2,3,5,8…</p><p>本体并未改变斐波那契数列的根本特性(后一项是前两项的和)，只是拿掉了最初的两项，同时n也从1开始了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">F(1)=1</span><br><span class="line">F(2)=2</span><br><span class="line">F(n)=F(n-1)+F(n-2) (n&gt;=3)</span><br></pre></td></tr></table></figure><p>即是一组这样的数:1,2,3,5,8…</p><p>从最容易理解的角度来看，我们可以写出这样的递归代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public int climbStairs(int n) &#123;</span><br><span class="line">        return n &lt;= 2 ? n : climbStairs(n - 2) + climbStairs(n - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，这种解法的时间复杂度将达到恐怖的2^n。因为我们欲得到F(n)，则必须先得到F(n-1)及F(n-2)，依此类推。</p><p>因此，我们通常会采用如下时间复杂度为O(n)的解法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public int climbStairs(int n) &#123;</span><br><span class="line">        if (n &lt;= 2) return n;</span><br><span class="line">        int first = 1;</span><br><span class="line">        int second = 2;</span><br><span class="line">        int now = 0;</span><br><span class="line">        for (int i = 3; i &lt;= n; i++) &#123;</span><br><span class="line">            now = first + second;</span><br><span class="line">            first = second;</span><br><span class="line">            second = now;</span><br><span class="line">        &#125;</span><br><span class="line">        return now;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题地址&quot;&gt;&lt;a href=&quot;#问题地址&quot; class=&quot;headerlink&quot; title=&quot;问题地址&quot;&gt;&lt;/a&gt;问题地址&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/climbing-stairs/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Climbing Stairs - LeetCode&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/blog_pic/Leetcode Algorithms/70Climbing Stairs/0.jpg&quot; alt=&quot;0.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode Algorithms" scheme="http://yoursite.com/categories/Leetcode-Algorithms/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode Algorithms-69.Sqrt(x)</title>
    <link href="http://yoursite.com/2018/09/17/Leetcode%20Algorithms-69Sqrtx/"/>
    <id>http://yoursite.com/2018/09/17/Leetcode Algorithms-69Sqrtx/</id>
    <published>2018-09-17T10:02:43.000Z</published>
    <updated>2018-09-17T10:09:41.533Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题地址"><a href="#问题地址" class="headerlink" title="问题地址"></a>问题地址</h1><p><a href="https://leetcode.com/problems/sqrtx/description/" target="_blank" rel="noopener">Sqrt(x) - LeetCode</a></p><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p><img src="/images/blog_pic/Leetcode Algorithms/69Sqrtx/0.jpg" alt="0.jpg"></p><a id="more"></a><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public int mySqrt(int x) &#123;</span><br><span class="line">        if (x &lt;= 1) return x;</span><br><span class="line">        int begin = 0;</span><br><span class="line">        int end = x;</span><br><span class="line">        while (begin &lt;= end) &#123;</span><br><span class="line">            int mid = begin + (end - begin) / 2;</span><br><span class="line">            int now = x / mid;</span><br><span class="line">            if (now == mid) return mid;</span><br><span class="line">            else if (now &gt; mid) &#123;</span><br><span class="line">                if (mid + 1 &gt; x / (mid + 1)) return mid;</span><br><span class="line">                else begin = mid + 1;</span><br><span class="line">            &#125; else end = mid - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，出题人不希望我们直接使用Math.sqrt()。</p><p>本解法是二分查找的变种，需要注意的是解法中使用了形如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int now = x / mid;</span><br></pre></td></tr></table></figure><p>的代码，其实更符合逻辑的思路应该是正向相乘：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int now = mid * mid;</span><br></pre></td></tr></table></figure><p>不过，这样会有溢出的风险，因此还是应该用题中除法的形式。</p><p>另外，0是不能做除数的，因此一开始的边界判断也一定要做好。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题地址&quot;&gt;&lt;a href=&quot;#问题地址&quot; class=&quot;headerlink&quot; title=&quot;问题地址&quot;&gt;&lt;/a&gt;问题地址&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/sqrtx/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Sqrt(x) - LeetCode&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/blog_pic/Leetcode Algorithms/69Sqrtx/0.jpg&quot; alt=&quot;0.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode Algorithms" scheme="http://yoursite.com/categories/Leetcode-Algorithms/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode Algorithms-67.Add Binary</title>
    <link href="http://yoursite.com/2018/09/17/Leetcode%20Algorithms-67Add%20Binary/"/>
    <id>http://yoursite.com/2018/09/17/Leetcode Algorithms-67Add Binary/</id>
    <published>2018-09-17T08:59:43.000Z</published>
    <updated>2018-09-17T09:01:57.467Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题地址"><a href="#问题地址" class="headerlink" title="问题地址"></a>问题地址</h1><p><a href="https://leetcode.com/problems/add-binary/description/" target="_blank" rel="noopener">Add Binary - LeetCode</a></p><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p><img src="/images/blog_pic/Leetcode Algorithms/67Add Binary/0.jpg" alt="0.jpg"></p><a id="more"></a><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public String addBinary(String a, String b) &#123;</span><br><span class="line">        if (null == a || a.length() == 0) return b;</span><br><span class="line">        if (null == b || b.length() == 0) return a;</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        int ia = a.length() - 1;</span><br><span class="line">        int ib = b.length() - 1;</span><br><span class="line">        boolean mark = false;</span><br><span class="line">        while (ia &gt;= 0 || ib &gt;= 0) &#123;</span><br><span class="line">            char ta = ia &gt;= 0 ? a.charAt(ia) : &apos;0&apos;;</span><br><span class="line">            char tb = ib &gt;= 0 ? b.charAt(ib) : &apos;0&apos;;</span><br><span class="line">            if (ta == &apos;0&apos; &amp;&amp; tb == &apos;0&apos;) &#123;</span><br><span class="line">                if (mark) sb.append(&apos;1&apos;);</span><br><span class="line">                else sb.append(&apos;0&apos;);</span><br><span class="line">                mark = false;</span><br><span class="line">            &#125; else if (ta == &apos;1&apos; &amp;&amp; tb == &apos;1&apos;) &#123;</span><br><span class="line">                if (mark) sb.append(&apos;1&apos;);</span><br><span class="line">                else sb.append(&apos;0&apos;);</span><br><span class="line">                mark = true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (mark) sb.append(&apos;0&apos;);</span><br><span class="line">                else sb.append(&apos;1&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">            ia--;</span><br><span class="line">            ib--;</span><br><span class="line">        &#125;</span><br><span class="line">        if (mark) sb.append(&apos;1&apos;);</span><br><span class="line">        return sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题地址&quot;&gt;&lt;a href=&quot;#问题地址&quot; class=&quot;headerlink&quot; title=&quot;问题地址&quot;&gt;&lt;/a&gt;问题地址&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/add-binary/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Add Binary - LeetCode&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/blog_pic/Leetcode Algorithms/67Add Binary/0.jpg&quot; alt=&quot;0.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode Algorithms" scheme="http://yoursite.com/categories/Leetcode-Algorithms/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode Algorithms-66.Plus One</title>
    <link href="http://yoursite.com/2018/09/17/Leetcode%20Algorithms-66Plus%20One/"/>
    <id>http://yoursite.com/2018/09/17/Leetcode Algorithms-66Plus One/</id>
    <published>2018-09-17T08:24:43.000Z</published>
    <updated>2018-09-17T08:26:44.315Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题地址"><a href="#问题地址" class="headerlink" title="问题地址"></a>问题地址</h1><p><a href="https://leetcode.com/problems/plus-one/description/" target="_blank" rel="noopener">Plus One - LeetCode</a></p><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p><img src="/images/blog_pic/Leetcode Algorithms/66Plus One/0.jpg" alt="0.jpg"></p><a id="more"></a><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public int[] plusOne(int[] digits) &#123;</span><br><span class="line">        if (null == digits || digits.length == 0) return digits;</span><br><span class="line">        int now = digits.length - 1;</span><br><span class="line">        while (now &gt;= 0) &#123;</span><br><span class="line">            if (digits[now] != 9) &#123;</span><br><span class="line">                digits[now]++;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            digits[now--] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (now == -1) &#123;</span><br><span class="line">            int[] result = new int[digits.length + 1];</span><br><span class="line">            result[0] = 1;</span><br><span class="line">            for (int i = 0; i &lt; digits.length; i++) result[i + 1] = digits[i];</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        return digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题地址&quot;&gt;&lt;a href=&quot;#问题地址&quot; class=&quot;headerlink&quot; title=&quot;问题地址&quot;&gt;&lt;/a&gt;问题地址&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/plus-one/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Plus One - LeetCode&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/blog_pic/Leetcode Algorithms/66Plus One/0.jpg&quot; alt=&quot;0.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode Algorithms" scheme="http://yoursite.com/categories/Leetcode-Algorithms/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode Algorithms-58.Length of Last Word</title>
    <link href="http://yoursite.com/2018/09/17/Leetcode%20Algorithms-58Length%20of%20Last%20Word/"/>
    <id>http://yoursite.com/2018/09/17/Leetcode Algorithms-58Length of Last Word/</id>
    <published>2018-09-17T07:59:43.000Z</published>
    <updated>2018-09-17T08:01:27.439Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题地址"><a href="#问题地址" class="headerlink" title="问题地址"></a>问题地址</h1><p><a href="https://leetcode.com/problems/length-of-last-word/description/" target="_blank" rel="noopener">Length of Last Word - LeetCode</a></p><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p><img src="/images/blog_pic/Leetcode Algorithms/58Length of Last Word/0.jpg" alt="0.jpg"></p><a id="more"></a><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public int lengthOfLastWord(String s) &#123;</span><br><span class="line">        if (null == s || s.length() == 0) return 0;</span><br><span class="line">        String[] a = s.split(&quot; &quot;);</span><br><span class="line">        return a.length == 0 ? 0 : a[a.length - 1].length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题地址&quot;&gt;&lt;a href=&quot;#问题地址&quot; class=&quot;headerlink&quot; title=&quot;问题地址&quot;&gt;&lt;/a&gt;问题地址&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/length-of-last-word/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Length of Last Word - LeetCode&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/blog_pic/Leetcode Algorithms/58Length of Last Word/0.jpg&quot; alt=&quot;0.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode Algorithms" scheme="http://yoursite.com/categories/Leetcode-Algorithms/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode Algorithms-53.Maximum Subarray</title>
    <link href="http://yoursite.com/2018/09/17/Leetcode%20Algorithms-53Maximum%20Subarray/"/>
    <id>http://yoursite.com/2018/09/17/Leetcode Algorithms-53Maximum Subarray/</id>
    <published>2018-09-17T03:04:43.000Z</published>
    <updated>2018-09-17T07:47:59.079Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题地址"><a href="#问题地址" class="headerlink" title="问题地址"></a>问题地址</h1><p><a href="https://leetcode.com/problems/maximum-subarray/description/" target="_blank" rel="noopener">Maximum Subarray - LeetCode</a></p><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p><img src="/images/blog_pic/Leetcode Algorithms/53Maximum Subarray/0.jpg" alt="0.jpg"></p><a id="more"></a><h1 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h1><p>最为笨拙的暴力穷举解法，时间复杂度O(n2)。</p><p><strong>代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public int maxSubArray(int[] nums) &#123;</span><br><span class="line">        if (null == nums || nums.length == 0) return 0;</span><br><span class="line">        int result = nums[0];</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            int temp = 0;</span><br><span class="line">            for (int j = i; j &lt; nums.length; j++) &#123;</span><br><span class="line">                temp += nums[j];</span><br><span class="line">                if (temp &gt; result) result = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h1><p>这是一个时间复杂度为O(n)解法。</p><p>定义3个变量：</p><ul><li>max:当前已找到的最大和。遍历结束后返回的即是该值。</li><li>now:当前求和的起始元素。这个值并未在代码中显式定义，而是隐含在sum中。</li><li>sum:当前求得的和。</li></ul><p>我们不妨先将问题分为两类：全为负数的情况及并非全为负数的情况。</p><p>当数组中的元素全部为负数时，此时将元素相加毫无意义(因为只会越加越小)，此时问题将退化为筛选出数组中最大的元素。即每次循环均有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum=nums[i]</span><br></pre></td></tr></table></figure><p>然后和max比较以筛选出最大值。</p><p>当数组中的元素并非全为负数时，一旦某次加法进行后导致和变为了负数，说明此次加法操作肯定是不应该的：毕竟本情况下数组中是有非负数的，单拎出来最大值也不会是负数。此时就应更换起点，然后和历史上得到的最大值做比较。依次类推，最终返回最大值。</p><p><strong>代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public int maxSubArray(int[] nums) &#123;</span><br><span class="line">        if (null == nums || nums.length == 0) return 0;</span><br><span class="line">        int max = Integer.MIN_VALUE, sum = 0;</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum = sum &lt; 0 ? nums[i] : sum + nums[i];</span><br><span class="line">            if (sum &gt; max) max = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题地址&quot;&gt;&lt;a href=&quot;#问题地址&quot; class=&quot;headerlink&quot; title=&quot;问题地址&quot;&gt;&lt;/a&gt;问题地址&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/maximum-subarray/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Maximum Subarray - LeetCode&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/blog_pic/Leetcode Algorithms/53Maximum Subarray/0.jpg&quot; alt=&quot;0.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode Algorithms" scheme="http://yoursite.com/categories/Leetcode-Algorithms/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode Algorithms-38.Count and Say</title>
    <link href="http://yoursite.com/2018/09/14/Leetcode%20Algorithms-38Count%20and%20Say/"/>
    <id>http://yoursite.com/2018/09/14/Leetcode Algorithms-38Count and Say/</id>
    <published>2018-09-14T10:52:43.000Z</published>
    <updated>2018-09-14T10:54:31.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题地址"><a href="#问题地址" class="headerlink" title="问题地址"></a>问题地址</h1><p><a href="https://leetcode.com/problems/count-and-say/description/" target="_blank" rel="noopener">Count and Say - LeetCode</a></p><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p><img src="/images/blog_pic/Leetcode Algorithms/38Count and Say/0.jpg" alt="0.jpg"></p><a id="more"></a><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p><strong>代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public String countAndSay(int n) &#123;</span><br><span class="line">        if (n &lt; 1 || n &gt; 30) return null;</span><br><span class="line">        String str = &quot;1&quot;;</span><br><span class="line">        for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">            StringBuilder sb = new StringBuilder();</span><br><span class="line">            int mark = 0;</span><br><span class="line">            while (mark &lt; str.length()) &#123;</span><br><span class="line">                int count = numberCount(str, mark);</span><br><span class="line">                sb.append(count).append(str.charAt(mark));</span><br><span class="line">                mark += count;</span><br><span class="line">            &#125;</span><br><span class="line">            str = sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int numberCount(String str, int mark) &#123;</span><br><span class="line">        int count = 1;</span><br><span class="line">        while (mark &lt; str.length() - 1) &#123;</span><br><span class="line">            if (str.charAt(mark + 1) != str.charAt(mark)) break;</span><br><span class="line">            count++;</span><br><span class="line">            mark++;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题地址&quot;&gt;&lt;a href=&quot;#问题地址&quot; class=&quot;headerlink&quot; title=&quot;问题地址&quot;&gt;&lt;/a&gt;问题地址&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/count-and-say/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Count and Say - LeetCode&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/blog_pic/Leetcode Algorithms/38Count and Say/0.jpg&quot; alt=&quot;0.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode Algorithms" scheme="http://yoursite.com/categories/Leetcode-Algorithms/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode Algorithms-35.Search Insert Position</title>
    <link href="http://yoursite.com/2018/09/14/Leetcode%20Algorithms-35Search%20Insert%20Position/"/>
    <id>http://yoursite.com/2018/09/14/Leetcode Algorithms-35Search Insert Position/</id>
    <published>2018-09-14T09:52:43.000Z</published>
    <updated>2018-09-14T10:02:08.961Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题地址"><a href="#问题地址" class="headerlink" title="问题地址"></a>问题地址</h1><p><a href="https://leetcode.com/problems/search-insert-position/description/" target="_blank" rel="noopener">Search Insert Position - LeetCode</a></p><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p><img src="/images/blog_pic/Leetcode Algorithms/35Search Insert Position/0.jpg" alt="0.jpg"></p><a id="more"></a><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public int searchInsert(int[] nums, int target) &#123;</span><br><span class="line">        if (null == nums) return -1;</span><br><span class="line">        int low = 0;</span><br><span class="line">        int high = nums.length - 1;</span><br><span class="line">        while (low &lt;= high) &#123;</span><br><span class="line">            int mid = low + (high - low) / 2;</span><br><span class="line">            if (target == nums[mid]) return mid;</span><br><span class="line">            if (target &lt; nums[mid]) high = mid - 1;</span><br><span class="line">            else low = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本问题是二分查找的变种。当target在nums中时，和普通的二分查找一样返回mid即可。需要说明的是，当没有找到时，为何返回了low。</p><p>当无法找到时，最后一次查找必在相邻两个元素之间进行，即必有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">high=low+1</span><br><span class="line">mid=low+(high-low)/2=low</span><br></pre></td></tr></table></figure><p>本次若是找到，即得出mid=target，那是最好。此时直接返回mid即可。若是找不到，在target&lt;mid时应返回low，而target&gt;mid时应返回high。我们可以回看代码，第一种情况下比较后low没有改变；而第二种情况下比较后low=mid+1，即low=low+1，恰好等于需要的high了。因此在最后一次比较结束后，直接返回low即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题地址&quot;&gt;&lt;a href=&quot;#问题地址&quot; class=&quot;headerlink&quot; title=&quot;问题地址&quot;&gt;&lt;/a&gt;问题地址&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/search-insert-position/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Search Insert Position - LeetCode&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/blog_pic/Leetcode Algorithms/35Search Insert Position/0.jpg&quot; alt=&quot;0.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode Algorithms" scheme="http://yoursite.com/categories/Leetcode-Algorithms/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode Algorithms-28.Implement strStr()</title>
    <link href="http://yoursite.com/2018/09/14/Leetcode%20Algorithms-28Implement%20strStr/"/>
    <id>http://yoursite.com/2018/09/14/Leetcode Algorithms-28Implement strStr/</id>
    <published>2018-09-14T08:53:43.000Z</published>
    <updated>2018-09-14T09:00:29.693Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题地址"><a href="#问题地址" class="headerlink" title="问题地址"></a>问题地址</h1><p><a href="https://leetcode.com/problems/implement-strstr/description/" target="_blank" rel="noopener">Implement strStr() - LeetCode</a></p><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p><img src="/images/blog_pic/Leetcode Algorithms/28Implement strStr/0.jpg" alt="0.jpg"></p><a id="more"></a><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>显然，出题人希望我们能自行实现这个功能，而不是直接调用indexOf()或startsWith()。</p><p><strong>代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public int strStr(String haystack, String needle) &#123;</span><br><span class="line">        if (null == haystack) throw new NullPointerException(&quot;haystack is null&quot;);</span><br><span class="line">        if (null == needle) return -1;</span><br><span class="line">        int hl = haystack.length();</span><br><span class="line">        int nl = needle.length();</span><br><span class="line">        if (nl == 0) return 0;</span><br><span class="line">        if (nl &gt; hl) return -1;</span><br><span class="line">        for (int hStart = 0; hStart &lt;= hl - nl; hStart++) &#123;</span><br><span class="line">            String temp = haystack.substring(hStart, hStart + nl);</span><br><span class="line">            if (needle.equals(temp)) return hStart;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题地址&quot;&gt;&lt;a href=&quot;#问题地址&quot; class=&quot;headerlink&quot; title=&quot;问题地址&quot;&gt;&lt;/a&gt;问题地址&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/implement-strstr/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Implement strStr() - LeetCode&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/blog_pic/Leetcode Algorithms/28Implement strStr/0.jpg&quot; alt=&quot;0.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode Algorithms" scheme="http://yoursite.com/categories/Leetcode-Algorithms/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>Java 设计模式-23.Interpreter模式</title>
    <link href="http://yoursite.com/2018/09/10/Java%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-23Interpreter%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/09/10/Java 设计模式-23Interpreter模式/</id>
    <published>2018-09-10T06:45:49.000Z</published>
    <updated>2018-09-18T09:37:24.076Z</updated>
    
    <content type="html"><![CDATA[<p>在《图解设计模式》一书中，Interpreter模式被归入了第10部分<a href="">用类来表现</a>。在GoF原书中，Interpreter模式则被归入了<a href="">行为型设计模式</a>。</p><a id="more"></a><h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><p>现今主流的编程语言依然都属于第三代编程语言，这些语言的文法接近人类的自然语言，对程序员极其友好。然而实际执行程序的机器依然只能识别第一代编程语言(也就是一串1和0组成的流啦)，这就导致了，无论使用何种第三代编程语言，是Java也好，还是C++也罢，虽然具体的实现细节依语言不同而千差万别，但终归都需要进行一种操作：将程序员编写的高级语言代码翻译为机器能够识别的01码。</p><p>下面我们就以Java为例，来相对详细的说说这个过程。</p><p>和大多直接由高级语言翻译(编译执行与解释执行只是手段，其本质目的都还是翻译)为机器语言不同的是，Java将它内部的翻译过程又分为了两个阶段(当然，对外部使用者，也就是实际执行机器码的机器而言，这个过程是黑盒的)：首先会从程序员编写的，人类能够识别的Java语言翻译为.class文件(编译期)。而后再将.class文件翻译为机器能识别的机器码。</p><p>简单来说，程序员编写的Java语言遵循着一套语法(不妨标记为语法1)，机器识别机器码时遵循着另一套语法(语法3)。在此之外，Java又在其内部搞出了一个.class文件(语法2)。这样翻译链的顺序就变为了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语法1 --&gt; 语法2 --&gt; 语法3</span><br></pre></td></tr></table></figure><p>之所以要这么搞，是为了实现Java语言的语言无关性。详见<a href="/2017/10/16/Java 基础-技术体系/">Java 基础-技术体系</a>。</p><p>且不说翻译了几次，单说翻译行为本身，它的作用大致可归为以下两点：</p><ol><li>虽然翻译本身增加了额外的开销，却使得程序员得以用更加类似自然语言的语法编写程序，极大的降低了学习成本，同时提高了代码编写的便利性与可维护性。</li><li>完成了各级语言间的解耦。以语法1 –&gt; 语法2的过程为例。Java程序员只需要知道Java语言的语法，而它的翻译者(我们称其为编译器)在此基础上还需要知道.class文件的语法。这意味着，无论是语法1亦或是语法2发生了何种变化，只要另一种语法尚能实现相同的功能，那么对彼此而言，这种变化就是透明的：它会被翻译者消化掉。从这种意义上来讲，翻译者颇有些<a href="">2.Adapter模式</a>中的适配器的意思。</li></ol><p>将这种思想进一步扩展，得到的就是Interpreter模式。</p><p>主流的高级编程语言都是通用的，虽然各有擅长的点，但基本都能胜任绝大多数场景。而这种通用的另一面就是不够特化：高级语言语法的设计者当然不可能因为某个需求就修改语法。不过，高级语言的设计者虽然不能这么做，但需求的设计者却可以这样做：也就是说，我们为某个需求，或是某一类需求，定制一种”迷你语言”。如果我们将其称之为”语法0”的话，那么上文的翻译链就变为了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语法0 --&gt; 语法1 --&gt; 语法2 --&gt; 语法3</span><br></pre></td></tr></table></figure><p>如果想要这么做的话，我们当然也可以在语法0前面加上个”语法-1”，使得翻译链无限的向上堆叠上去，只不过这会让程序变得复杂，而这种复杂通常是没什么意义的，所以通常都不会这么做。</p><p>具体到这个应用场景，我们再来说下引入”语法0”的好处：</p><ol><li>较之高级语言，迷你语言的语法简单，且为需求高度定制。使得代码(此时程序员写的当然就是迷你语言的代码啦)的书写更为容易，目的性也更强。</li><li>在这个场景下，高级语言的语法一般不会发生变化，迷你语言的语法通常也不会发生变化。发生变化的基本只会是使用迷你语言编写的代码。</li></ol><p>如果要使用Interpreter模式编写程序的话，难点通常并不是在于编写迷你语言本身，而是在于编写”语法0 –&gt; 语法1”的翻译器。因为迷你语言完全是程序员根据需求生造出来的，只有他自己才知道语法，因此也只有他本身才能编写翻译器。这也是Interpreter模式被称为”解释器模式”的原因所在。通常翻译器我们都会用”语法1”，也就是作为基底的高级语言来开发。</p><h1 id="控制人物移动的迷你语言"><a href="#控制人物移动的迷你语言" class="headerlink" title="控制人物移动的迷你语言"></a>控制人物移动的迷你语言</h1><p>下面我们就针对”控制人物移动”这个需求来创建一门全新的迷你语言吧！</p><p>首先介绍下本文用于作为行走角色的妹子，来自东方Project的<a href="https://baike.baidu.com/item/%E4%BC%8A%E5%90%B9%E8%90%83%E9%A6%99/8771754?fr=aladdin" target="_blank" rel="noopener">伊吹萃香</a>：</p><p><img src="/images/blog_pic/Java 设计模式/23Interpreter模式/0.jpg" alt="0.jpg"></p><p>萃香好可爱啊~融化了。</p><p>这是用到的行走图素材，也是萌萌哒：</p><p><img src="/images/blog_pic/Java 设计模式/23Interpreter模式/1.png" alt="1.png"></p><p>按需求，我们可以向人物下达如下3种指令：</p><ul><li>前进1个长度单位(go)</li><li>右转(right)</li><li>左转(left)</li></ul><p>其中左转与右转是严格意义上的原地转向。在此之上，为了构成一个相对复杂的语言，我们引入了新的指令：</p><ul><li>重复(repeat)</li></ul><p>这可以让人物重复一定次数的指令集合。至此，我们已得到构成本文迷你语言的全部指令。</p><p>要想被称之为一门语言，光有指令(相当于自然语言中的单词)是不够的，我们还需要规定一个语法将它们组合起来。对于本文的迷你语言，我们先来看一段最简单的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">program</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>我们规定，这门迷你语言必须以program开头，后面跟随着指令集合(command list)。command list必须以end结尾。如果command list为空，那么就会出现上文中program后面直接跟着一个end的情况啦。显然，上述代码不会产生任何实际的效果。</p><p>程序可以采用换行，空格，tab等任何主流的分隔符，这意味上述代码我们也可以写成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">program end</span><br></pre></td></tr></table></figure><p>不过为了便于阅读，对于书写任意语言而言，适当的缩进都是很必要的。</p><p>然后我们再来看一段稍微复杂点的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">program</span><br><span class="line">  go go right</span><br><span class="line">  go go right</span><br><span class="line">  go go right</span><br><span class="line">  go go right</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>程序会按指令的书写顺序执行它们。执行这段指令，可以输出：</p><p><img src="/images/blog_pic/Java 设计模式/23Interpreter模式/2.jpg" alt="2.jpg"></p><p>该代码会让人物走一个正方形，而后回到初始的位置和朝向。为了在静态的图片中表现出代码的执行过程，我们绘制了人物移动的轨迹。</p><p>如果仔细看一下上述代码的话，会发现我们将：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go go right</span><br></pre></td></tr></table></figure><p>这个代码片段重复写了4遍。显然这是很low的行为。因此就需要repeat指令登场啦：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">program</span><br><span class="line">  repeat 4 go go right end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>repeat指令的语法规则为：首先是作为关键字的repeat，然后是表示循环次数的数字。最后是实际被循环的command list。执行该代码后输出与前图相同。</p><p>我们可以再来走一个更复杂的轨迹：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">program</span><br><span class="line">  repeat 1000</span><br><span class="line">    repeat 4</span><br><span class="line">      repeat 3 go right go left end</span><br><span class="line">      right</span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>这段代码会重复一个相对复杂的轨迹1000次，贴几张移动过程中的截图吧：</p><p><img src="/images/blog_pic/Java 设计模式/23Interpreter模式/3.jpg" alt="3.jpg"></p><p><img src="/images/blog_pic/Java 设计模式/23Interpreter模式/4.jpg" alt="4.jpg"></p><p><img src="/images/blog_pic/Java 设计模式/23Interpreter模式/5.jpg" alt="5.jpg"></p><p><img src="/images/blog_pic/Java 设计模式/23Interpreter模式/6.jpg" alt="6.jpg"></p><p><img src="/images/blog_pic/Java 设计模式/23Interpreter模式/7.jpg" alt="7.jpg"></p><h1 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h1><p>迷你语言的语法结构至此就算是结束了，该语言非常简单，简单到只有顺序和循环结构，连分支结构都没有。不过用来作说明已经是足够了。此外，上文我们是以自然语言在进行描述，也就是说给产品经理听的。而技术人员如果要将该语法落实到代码中，还需要用更为准确的数学语言来描述才可以。</p><p>本文采取的描述方法为EBNF(Extended Backus–Naur Form，即扩展的巴科斯-瑙尔范式)。顾名思义，它是对BNF(Backus-Naur Form，巴科斯范式)的扩展。我们先给出全部的语法描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;program&gt; ::= program &lt;command list&gt;</span><br><span class="line">&lt;command list&gt; ::= &lt;command&gt;* end</span><br><span class="line">&lt;command&gt; ::= &lt;repeat command&gt; | &lt;primitive command&gt;</span><br><span class="line">&lt;repeat command&gt; ::= repeat &lt;number&gt; &lt;command list&gt;</span><br><span class="line">&lt;primitive command&gt; ::= go | left | right</span><br></pre></td></tr></table></figure><p>较之自然语言，是不是简洁了许多呢(事实上，不仅仅是看起来简洁了，也更为精确了)？下面就来逐句分析一下吧！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;program&gt; ::= program &lt;command list&gt;</span><br></pre></td></tr></table></figure><p>首先是第一句，这个::=我们简单的理解为赋值就可以啦！该句用于描述&lt;program&gt;这个标签，或者更确切的说，是构成语法树的&lt;program&gt;结点。按照描述，&lt;program&gt;节点就是program关键字后跟上一个&lt;command list&gt;。</p><p>至此&lt;program&gt;算是描述完了，但是我们却无法真正能说完全了解它，program作为一个普通的字符串没什么可说的，不过这个&lt;command list&gt;是什么呢？这就好比表达式y=x+3，如果我们不知道x是什么，自然也不能知道y是什么。</p><p>不过不要急，第二句就是在描述&lt;command list&gt;啦：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;command list&gt; ::= &lt;command&gt;* end</span><br></pre></td></tr></table></figure><p>哦，原来&lt;command list&gt;是0到多个(描述范式中*所代表的含义，熟悉正则的朋友们应该会感到很亲切吧)&lt;command&gt;节点后再加上end关键字。那么这个&lt;command&gt;是什么呢：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;command&gt; ::= &lt;repeat command&gt; | &lt;primitive command&gt;</span><br></pre></td></tr></table></figure><p>范式告诉我们，&lt;command&gt;是一个&lt;repeat command&gt;结点或是一个&lt;primitive command&gt;结点。</p><p>而&lt;repeat command&gt;：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;repeat command&gt; ::= repeat &lt;number&gt; &lt;command list&gt;</span><br></pre></td></tr></table></figure><p>它是repeat关键字后跟随一个&lt;number&gt;结点，再跟随一个前文介绍过的&lt;command list&gt;结点。从而形成了递归结构。</p><p>最后是&lt;primitive command&gt;：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;primitive command&gt; ::= go | left | right</span><br></pre></td></tr></table></figure><p>它是go,left,right这3个关键字中的某一个。在编程领域，像&lt;primitive command&gt;这样描述它的信息中不包含其他结点的，或者更直观的说，我们可以仅仅通过描述语句本身就完全弄明白含义的结点，被称为终结符表达式(Terminal Expression)。与之相对的，像&lt;command list&gt;，&lt;command&gt;等需要进一步展开的结点则被称为非终结符表达式(Nonterminal Expression)。所谓递归，其实就是因非终结符表达式而起，最后收束于终结符表达式。</p><p>细心的朋友想必可以发现，我们还剩一个&lt;number&gt;结点没有描述。其实是应该写的，它应该是一个大于等于0的整数，是一个终结符表达式。只不过它的描述较为复杂，这里便省略了。</p><p>完成了语法的数学化描述后，下一步就是根据该描述将迷你语言的代码依据语法规则翻译为语法树，并存入宿主语言(本文使用Java)中，这一步被称为解析。而后再执行语法树中存储的语义，得到输出。这么说还是会有一些抽象，还是让我们赶紧来看具体的代码吧。</p><p>本程序中的所有代码将被统一置于design23包下，结构如下：</p><p><img src="/images/blog_pic/Java 设计模式/23Interpreter模式/8.jpg" alt="8.jpg"></p><p>迷你语言的示例程序使用前文介绍过的那个重复绘制1000次的复制图形。它被存储在名为code.txt的文件中。</p><p><strong>code.txt</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">program</span><br><span class="line">  repeat 1000</span><br><span class="line">    repeat 4</span><br><span class="line">      repeat 3 go right go left end</span><br><span class="line">      right</span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>然后我们介绍本文的重点，也就是model.parse包下的内容。这个包下的代码完成了前文说到的迷你语言的语法树的构建(即解析)以及执行。秉承Java语言”一切都是对象，对象就是一切”的思想，上文介绍的EBNF中的结点最终都被翻译为了类，这在后文的代码中将会有很明显的体现。</p><p><strong>Node类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package design23.model.parse;</span><br><span class="line"></span><br><span class="line">import design23.model.entity.GameMap;</span><br><span class="line"></span><br><span class="line">public abstract class Node &#123;</span><br><span class="line"></span><br><span class="line">    public abstract void parse(Context context) throws ParseException;</span><br><span class="line"></span><br><span class="line">    public abstract void exe(GameMap map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Node类是所有结点的抽象父类。按照需求，它约束自身的子类必须实现两个基本的功能：parse() –&gt; 解析 及 exe() –&gt; 执行。很显然，这两个方法的调用是有先后顺序的，即我们必须先完成解析，形成语法树，才能执行。</p><p>在解析方法parse()的方法定义中，我们抛出了自定义异常ParseException：</p><p><strong>ParseException类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package design23.model.parse;</span><br><span class="line"></span><br><span class="line">public class ParseException extends Exception &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">    ParseException(String msg) &#123;</span><br><span class="line">        super(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这只是一个很简单的异常类，就不多做赘述了。</p><p><strong>ProgramNode类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package design23.model.parse;</span><br><span class="line"></span><br><span class="line">import design23.model.entity.GameMap;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * &lt;program&gt; ::= program &lt;command list&gt;</span><br><span class="line"> */</span><br><span class="line">public class ProgramNode extends Node &#123;</span><br><span class="line"></span><br><span class="line">    private CommandListNode commandListNode;</span><br><span class="line"></span><br><span class="line">    private static final String PROGRAM_STR = &quot;program&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void parse(Context context) throws ParseException &#123;</span><br><span class="line">        context.skip(ProgramNode.PROGRAM_STR);</span><br><span class="line">        this.commandListNode = new CommandListNode();</span><br><span class="line">        this.commandListNode.parse(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;[&quot; + ProgramNode.PROGRAM_STR + &quot; &quot; + this.commandListNode + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void exe(GameMap map) &#123;</span><br><span class="line">        this.commandListNode.exe(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终于到EBNF中介绍的真正的结点了。很显然，ProgramNode对应&lt;program&gt;，这在类首的注释中也有所体现。我们会为每一个结点都加上类似的类首注释，以表明它代表的是EBNF中的哪个结点，因此后文在介绍其他结点时就不会再显式的点出这种对应关系了。</p><p>关于将EBNF翻译为实际的类，有一个很重要的点就是”不要做多余的事”。简单来说，在我们编写ProgramNode时，能参照的就仅仅只是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;program&gt; ::= program &lt;command list&gt;</span><br></pre></td></tr></table></figure><p>其他的一切都不需要知道。也不要耍小聪明做一些EBNF中没有的事，如果实在是想加新功能，也需要修改EBNF，而不是在翻译出的代码中自作主张。语法的设计在EBNF中已全部完成了，从EBNF到具体的代码仅仅只需要机械的翻译。</p><p>因此，这些结点的代码本身其实没什么好说的，后续结点的代码我们将快速的贴出。</p><p><strong>CommandListNode类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package design23.model.parse;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">import design23.model.entity.GameMap;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * &lt;command list&gt; ::= &lt;command&gt;* end</span><br><span class="line"> */</span><br><span class="line">public class CommandListNode extends Node &#123;</span><br><span class="line"></span><br><span class="line">    private List&lt;CommandNode&gt; commandList = new ArrayList&lt;CommandNode&gt;();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void parse(Context context) throws ParseException &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            String current = context.peek();</span><br><span class="line">            String endstr = &quot;end&quot;;</span><br><span class="line">            if (null == current) throw new ParseException(&quot;Missing &apos;&quot; + endstr + &quot;&apos;&quot;);</span><br><span class="line">            if (endstr.equals(current)) &#123;</span><br><span class="line">                context.skip(endstr);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            CommandNode commandNode = new CommandNode();</span><br><span class="line">            this.commandList.add(commandNode);</span><br><span class="line">            commandNode.parse(context);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return this.commandList.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void exe(GameMap map) &#123;</span><br><span class="line">        for (CommandNode commandNode : this.commandList)</span><br><span class="line">            commandNode.exe(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CommandNode类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package design23.model.parse;</span><br><span class="line"></span><br><span class="line">import design23.model.entity.GameMap;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * &lt;command&gt; ::= &lt;repeat command&gt; | &lt;primitive command&gt;</span><br><span class="line"> */</span><br><span class="line">public class CommandNode extends Node &#123;</span><br><span class="line"></span><br><span class="line">    private CommandNode commandNode;</span><br><span class="line"></span><br><span class="line">    protected static final String REPEAT_STR = &quot;repeat&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void parse(Context context) throws ParseException &#123;</span><br><span class="line">        this.commandNode = CommandNode.REPEAT_STR.equals(context.peek()) ?</span><br><span class="line">                           new RepeatCommandNode() :</span><br><span class="line">                           new PrimitiveCommandNode();</span><br><span class="line">        this.commandNode.parse(context);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return this.commandNode.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void exe(GameMap map) &#123;</span><br><span class="line">        this.commandNode.exe(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>RepeatCommandNode类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package design23.model.parse;</span><br><span class="line"></span><br><span class="line">import design23.model.entity.GameMap;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * &lt;repeat command&gt; ::= repeat &lt;number&gt; &lt;command list&gt;</span><br><span class="line"> */</span><br><span class="line">public class RepeatCommandNode extends CommandNode &#123;</span><br><span class="line"></span><br><span class="line">    private int number;</span><br><span class="line"></span><br><span class="line">    private CommandListNode commandListNode;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void parse(Context context) throws ParseException &#123;</span><br><span class="line">        context.skip(CommandNode.REPEAT_STR);</span><br><span class="line">        try &#123;</span><br><span class="line">            this.number = Integer.parseInt(context.peek());</span><br><span class="line">        &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">            throw new ParseException(&quot;fail to parse &quot; + CommandNode.REPEAT_STR + &quot; times.&quot; + e);</span><br><span class="line">        &#125;</span><br><span class="line">        context.next();</span><br><span class="line">        this.commandListNode = new CommandListNode();</span><br><span class="line">        this.commandListNode.parse(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;[&quot; + CommandNode.REPEAT_STR + &quot; &quot; + this.number + &quot; &quot; + this.commandListNode + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void exe(GameMap map) &#123;</span><br><span class="line">        for (int i = 0; i &lt; this.number; i++)</span><br><span class="line">            this.commandListNode.exe(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>PrimitiveCommandNode类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">package design23.model.parse;</span><br><span class="line"></span><br><span class="line">import design23.model.entity.GameMap;</span><br><span class="line">import design23.model.entity.Grid;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * &lt;primitive command&gt; ::= go | left | right</span><br><span class="line"> */</span><br><span class="line">public class PrimitiveCommandNode extends CommandNode &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public static final String GO = &quot;go&quot;;</span><br><span class="line"></span><br><span class="line">    public static final String LEFT = &quot;left&quot;;</span><br><span class="line"></span><br><span class="line">    public static final String RIGHT = &quot;right&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void parse(Context context) throws ParseException &#123;</span><br><span class="line">        this.name = context.peek();</span><br><span class="line">        context.skip(this.name);</span><br><span class="line">        if (!PrimitiveCommandNode.GO.equals(this.name) &amp;&amp;</span><br><span class="line">            !PrimitiveCommandNode.LEFT.equals(this.name) &amp;&amp;</span><br><span class="line">            !PrimitiveCommandNode.RIGHT.equals(this.name))</span><br><span class="line">            throw new ParseException(&quot;command &quot; + this.name + &quot; is undefined&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void exe(GameMap map) &#123;</span><br><span class="line">        int maxR = map.getGrids().length;</span><br><span class="line">        int maxC = map.getGrids()[0].length;</span><br><span class="line">        int focusR = map.getFocusR();</span><br><span class="line">        int focusC = map.getFocusC();</span><br><span class="line">        Grid focusGrid = map.getGrids()[focusR][focusC];</span><br><span class="line">        int direction = focusGrid.getDirection();</span><br><span class="line">        if (PrimitiveCommandNode.GO.equals(this.name)) &#123;</span><br><span class="line">            int newFocusR = focusR;</span><br><span class="line">            int newFocusC = focusC;</span><br><span class="line">            switch (direction) &#123;</span><br><span class="line">            case 0:</span><br><span class="line">                if (focusR + 1 == maxR) break;</span><br><span class="line">                newFocusR = focusR + 1;</span><br><span class="line">                break;</span><br><span class="line">            case 1:</span><br><span class="line">                if (focusC == 0) break;</span><br><span class="line">                newFocusC = focusC - 1;</span><br><span class="line">                break;</span><br><span class="line">            case 2:</span><br><span class="line">                if (focusC + 1 == maxC) break;</span><br><span class="line">                newFocusC = focusC + 1;</span><br><span class="line">                break;</span><br><span class="line">            case 3:</span><br><span class="line">                if (focusR == 0) break;</span><br><span class="line">                newFocusR = focusR - 1;</span><br><span class="line">            &#125;</span><br><span class="line">            // 模拟走路动作</span><br><span class="line">            for (int i = 0; i &lt; map.getStageCount(); i++) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(300);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                focusGrid.setStage((focusGrid.getStage() + 1) % map.getStageCount());</span><br><span class="line">                if (i == map.getStageCount() / 2) &#123;</span><br><span class="line">                    // 设置新的焦点格</span><br><span class="line">                    map.getGrids()[newFocusR][newFocusC].setDirection(direction);</span><br><span class="line">                    map.getGrids()[newFocusR][newFocusC].setStage(focusGrid.getStage());</span><br><span class="line">                    map.getGrids()[newFocusR][newFocusC].setTimes(map.getGrids()[newFocusR][newFocusC].getTimes() + 1);</span><br><span class="line">                    map.setFocusR(newFocusR);</span><br><span class="line">                    map.setFocusC(newFocusC);</span><br><span class="line">                    // 设置原来的焦点格</span><br><span class="line">                    focusGrid.setDirection(-1);</span><br><span class="line">                    focusGrid.setStage(-1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (PrimitiveCommandNode.LEFT.equals(this.name)) &#123;</span><br><span class="line">            switch (direction) &#123;</span><br><span class="line">            case 0:</span><br><span class="line">                focusGrid.setDirection(2);</span><br><span class="line">                break;</span><br><span class="line">            case 1:</span><br><span class="line">                focusGrid.setDirection(0);</span><br><span class="line">                break;</span><br><span class="line">            case 2:</span><br><span class="line">                focusGrid.setDirection(3);</span><br><span class="line">                break;</span><br><span class="line">            case 3:</span><br><span class="line">                focusGrid.setDirection(1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            switch (direction) &#123;</span><br><span class="line">            case 0:</span><br><span class="line">                focusGrid.setDirection(1);</span><br><span class="line">                break;</span><br><span class="line">            case 1:</span><br><span class="line">                focusGrid.setDirection(3);</span><br><span class="line">                break;</span><br><span class="line">            case 2:</span><br><span class="line">                focusGrid.setDirection(0);</span><br><span class="line">                break;</span><br><span class="line">            case 3:</span><br><span class="line">                focusGrid.setDirection(2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，所有的结点我们都介绍完了。不过，为了能让翻译器接收到源码，我们还写了Context类：</p><p><strong>Context类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package design23.model.parse;</span><br><span class="line"></span><br><span class="line">import java.util.StringTokenizer;</span><br><span class="line"></span><br><span class="line">public class Context &#123;</span><br><span class="line"></span><br><span class="line">    private StringTokenizer st;</span><br><span class="line"></span><br><span class="line">    private String current;</span><br><span class="line"></span><br><span class="line">    public Context(String text) &#123;</span><br><span class="line">        this.st = new StringTokenizer(text);</span><br><span class="line">        this.next();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String peek() &#123;</span><br><span class="line">        return this.current;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String next() &#123;</span><br><span class="line">        this.current = this.st.hasMoreTokens() ?</span><br><span class="line">                       this.st.nextToken() :</span><br><span class="line">                       null;</span><br><span class="line">        return this.current;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void skip(String token) throws ParseException &#123;</span><br><span class="line">        if (!token.equals(this.current))</span><br><span class="line">            throw new ParseException(&quot;need &quot; + token + &quot;, but &quot; + this.current + &quot; is found&quot;);</span><br><span class="line">        this.next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Context类的功能很简单，它将源码按分割符分割为一个个单词，然后作为解析器会逐个读取单词，而后根据单词生成新的结点，并将结点挂载到语法树合适的位置上。随着语法树的构建，Context中的文本信息会越来越少，直至读完。</p><p>至此，本文要介绍的核心功能就已经描述完了。后文要介绍的代码都只是为了得到一个可视化的结果。</p><p>首先来看model.entity包，这个包下存储了程序要展示的一些实体。一如前文中的截图看到的，我们希望游戏最终能实现RPG制作大师做出的游戏的效果。因此我们需要一张存储所有要素的游戏地图，该地图是由一个个”小格子”组成的。</p><p><strong>GameMap类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">package design23.model.entity;</span><br><span class="line"></span><br><span class="line">public class GameMap &#123;</span><br><span class="line"></span><br><span class="line">    private Grid[][] grids;</span><br><span class="line"></span><br><span class="line">    private int focusR;</span><br><span class="line"></span><br><span class="line">    private int focusC;</span><br><span class="line"></span><br><span class="line">    private int stageCount;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param row 地图上小格子的行数</span><br><span class="line">     * @param column 地图上小格子的列数</span><br><span class="line">     * @param stageCount 人物的行走状态</span><br><span class="line">     * @param focusR 初始时人物所在的小格子的行号</span><br><span class="line">     * @param focusC 初始时人物所在的小格子的列号</span><br><span class="line">     * @param initDirection 初始时人物的朝向 </span><br><span class="line">     */</span><br><span class="line">    public GameMap(int row, int column, int stageCount, int focusR, int focusC, int direction) &#123;</span><br><span class="line">        this.stageCount = stageCount;</span><br><span class="line">        this.grids = new Grid[row][column];</span><br><span class="line">        for (int r = 0; r &lt; row; r++)</span><br><span class="line">            for (int c = 0; c &lt; column; c++)</span><br><span class="line">                this.grids[r][c] = new Grid();</span><br><span class="line">        this.focusR = focusR;</span><br><span class="line">        this.focusC = focusC;</span><br><span class="line">        this.grids[this.focusR][this.focusC].setDirection(direction);</span><br><span class="line">        this.grids[this.focusR][this.focusC].setStage(1);</span><br><span class="line">        this.grids[this.focusR][this.focusC].setTimes(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Grid[][] getGrids() &#123;</span><br><span class="line">        return grids;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getFocusR() &#123;</span><br><span class="line">        return focusR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setFocusR(int focusR) &#123;</span><br><span class="line">        this.focusR = focusR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getFocusC() &#123;</span><br><span class="line">        return focusC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setFocusC(int focusC) &#123;</span><br><span class="line">        this.focusC = focusC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getStageCount() &#123;</span><br><span class="line">        return stageCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Grid类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package design23.model.entity;</span><br><span class="line"></span><br><span class="line">public class Grid &#123;</span><br><span class="line"></span><br><span class="line">    private int direction = -1;</span><br><span class="line"></span><br><span class="line">    private int stage = -1;</span><br><span class="line"></span><br><span class="line">    private int times;</span><br><span class="line"></span><br><span class="line">    public int getDirection() &#123;</span><br><span class="line">        return direction;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setDirection(int direction) &#123;</span><br><span class="line">        this.direction = direction;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getStage() &#123;</span><br><span class="line">        return stage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setStage(int stage) &#123;</span><br><span class="line">        this.stage = stage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getTimes() &#123;</span><br><span class="line">        return times;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTimes(int times) &#123;</span><br><span class="line">        this.times = times;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用了GameMap的构造函数后，我们便构建了这样的一张地图：</p><ul><li>row行column列</li><li>初始时人物所在的格子位置：grids[this.focusR][this.focusC]</li><li>只会有一个格子处于焦点状态。未处于焦点状态的格子的direction和stage均默认为-1。</li><li>Grid的times属性是指人物来到该格子上的次数，绘制轨迹用。</li></ul><p>这里需要简单介绍下direction与stage的含义。其中direction表示人物当前的朝向。而stage则表示行走状态，在人物从1个格子移动到另一个格子的过程中，我们一共会变化出3张图片，从而模拟出”人物移动的动作”。</p><p>这两个字段实际都是服务于图character.png：</p><p><img src="/images/blog_pic/Java 设计模式/23Interpreter模式/9.png" alt="9.png"></p><p>纵向来看，0-3分别代表下左右上四个朝向。而横向的0-2则代表三个行走状态：站立不动是中间的那张状态1。当人物从一个格子移动到另一个格子上时，发生的变化为：状态1 –&gt; 状态2 –&gt; 状态0 –&gt; 状态1。</p><p>然后我们提供了将parse包及entity包整合起来并对外(指得就是View啦)提供功能接口的Model类：</p><p><strong>Model类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">package design23.model;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line">import org.apache.commons.lang.StringUtils;</span><br><span class="line"></span><br><span class="line">import design23.model.entity.GameMap;</span><br><span class="line">import design23.model.parse.Context;</span><br><span class="line">import design23.model.parse.ParseException;</span><br><span class="line">import design23.model.parse.ProgramNode;</span><br><span class="line"></span><br><span class="line">public class Model &#123;</span><br><span class="line"></span><br><span class="line">    private GameMap map;</span><br><span class="line"></span><br><span class="line">    private ProgramNode root = new ProgramNode();</span><br><span class="line"></span><br><span class="line">    public void initMap(int row, int column, int stageCount, int focusR, int focusC, int direction) &#123;</span><br><span class="line">        this.map = new GameMap(row, column, stageCount, focusR, focusC, direction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void initInterpreter(String path) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            this.root.parse(new Context(this.loadCode(path)));</span><br><span class="line">        &#125; catch (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(this.root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void exe() &#123;</span><br><span class="line">        new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                Model.this.root.exe(Model.this.map);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public GameMap getMap() &#123;</span><br><span class="line">        return map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String loadCode(String path) &#123;</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        FileInputStream fi = null;</span><br><span class="line">        InputStreamReader ir = null;</span><br><span class="line">        BufferedReader br = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            fi = new FileInputStream(new File(path));</span><br><span class="line">            ir = new InputStreamReader(fi, &quot;UTF-8&quot;);</span><br><span class="line">            br = new BufferedReader(ir);</span><br><span class="line">            String lineTxt = null;</span><br><span class="line">            while (!StringUtils.isBlank((lineTxt = br.readLine())))</span><br><span class="line">                sb.append(lineTxt).append(&quot; &quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                br.close();</span><br><span class="line">                ir.close();</span><br><span class="line">                fi.close();</span><br><span class="line">            &#125; catch (Exception ef) &#123;</span><br><span class="line">                ef.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是作为GUI显示的View类，本文使用Java AWT：</p><p><strong>View类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">package design23.view;</span><br><span class="line"></span><br><span class="line">import java.awt.Color;</span><br><span class="line">import java.awt.Frame;</span><br><span class="line">import java.awt.Graphics;</span><br><span class="line">import java.awt.Image;</span><br><span class="line">import java.awt.event.WindowAdapter;</span><br><span class="line">import java.awt.event.WindowEvent;</span><br><span class="line">import java.awt.image.BufferedImage;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">import javax.imageio.ImageIO;</span><br><span class="line"></span><br><span class="line">import design23.model.Model;</span><br><span class="line">import design23.model.entity.Grid;</span><br><span class="line"></span><br><span class="line">public class View extends Frame &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">    private int gridSize = 32;</span><br><span class="line"></span><br><span class="line">    private int widebar = 31;</span><br><span class="line"></span><br><span class="line">    private int narrowbar = 6;</span><br><span class="line"></span><br><span class="line">    private Model model = new Model();</span><br><span class="line"></span><br><span class="line">    private BufferedImage img = this.loadImg(&quot;character.png&quot;);</span><br><span class="line"></span><br><span class="line">    public void launchFrame() &#123;</span><br><span class="line">        int gridRow = 7;</span><br><span class="line">        int gridColumn = 7;</span><br><span class="line">        this.model.initMap(gridRow, gridColumn, 3, 3, 0, 3);</span><br><span class="line">        this.model.initInterpreter(&quot;src/main/java/design23/code.txt&quot;);</span><br><span class="line">        super.setLocation(800, 300);</span><br><span class="line">        super.setSize(this.narrowbar + this.gridSize * gridColumn + this.narrowbar, this.widebar + this.gridSize * gridRow + this.narrowbar);</span><br><span class="line">        new Thread(this.new RepaintRunnable()).start();</span><br><span class="line">        super.addWindowListener(</span><br><span class="line">            new WindowAdapter() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void windowClosing(WindowEvent e) &#123;</span><br><span class="line">                    System.exit(0);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">        this.model.exe();</span><br><span class="line">        super.setVisible(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void paint(Graphics g) &#123;</span><br><span class="line">        Grid[][] grids = this.model.getMap().getGrids();</span><br><span class="line">        for (int r = 0; r &lt; grids.length; r++) &#123;</span><br><span class="line">            for (int c = 0; c &lt; grids[0].length; c++) &#123;</span><br><span class="line">                Grid grid = grids[r][c];</span><br><span class="line">                int dx1 = this.narrowbar + c * this.gridSize;</span><br><span class="line">                int dy1 = this.widebar + r * this.gridSize;</span><br><span class="line">                if (grid.getTimes() &gt; 0) &#123;</span><br><span class="line">                    Color tempColor = g.getColor();</span><br><span class="line">                    g.setColor(Color.GRAY);</span><br><span class="line">                    g.fillRect(dx1, dy1, this.gridSize, this.gridSize);</span><br><span class="line">                    g.setColor(tempColor);</span><br><span class="line">                &#125;</span><br><span class="line">                if (grid.getDirection() &gt;= 0) &#123;</span><br><span class="line">                    int direction = grid.getDirection();</span><br><span class="line">                    int stage = grid.getStage();</span><br><span class="line">                    g.drawImage(this.img,</span><br><span class="line">                                dx1,</span><br><span class="line">                                dy1,</span><br><span class="line">                                this.narrowbar + c * this.gridSize + this.gridSize,</span><br><span class="line">                                this.widebar + r * this.gridSize + this.gridSize,</span><br><span class="line">                                stage * this.gridSize,</span><br><span class="line">                                direction * this.gridSize,</span><br><span class="line">                                stage * this.gridSize + this.gridSize,</span><br><span class="line">                                direction * this.gridSize + this.gridSize,</span><br><span class="line">                                null);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private class RepaintRunnable implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    View.this.repaint();</span><br><span class="line">                    Thread.sleep(10);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void update(Graphics g) &#123;</span><br><span class="line">        Image bImage = super.createImage(this.getWidth(), this.getHeight());</span><br><span class="line">        Graphics bg = bImage.getGraphics();</span><br><span class="line">        this.paint(bg);</span><br><span class="line">        bg.dispose();</span><br><span class="line">        g.drawImage(bImage, 0, 0, this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private BufferedImage loadImg(String name) &#123;</span><br><span class="line">        BufferedImage bImage = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            bImage = ImageIO.read(View.class.getClassLoader().getResource(&quot;design23/&quot; + name));</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return bImage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在View的launchFrame()中，我们先调用model的initMap()初始化了地图，而后又调用model的initInterpreter()初始化了语法树。而后在需要的时候，也就是launchFrame()的最后，我们调用model的exe()方法来执行语法树。该方法会启一个新的线程，按设定的代码移动人物(其实就是改变地图中属性的值)。而View剩余要做的，就是不断的刷新并显示地图，将翻译器更新后的数据显示出来。</p><p>最后给出Main.java。执行该类后，即可得到结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package design23;</span><br><span class="line"></span><br><span class="line">import design23.view.View;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new View().launchFrame();        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，因为我们在Model初始化语法树时将语法树打印出来了。因此除了UI外，我们还会在控制台中得到这样的一句输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[program [[repeat 1000 [[repeat 4 [[repeat 3 [go, right, go, left]], right]]]]]]</span><br></pre></td></tr></table></figure><p>大家可以对照前文的EBNF加深理解。</p><h1 id="登场角色"><a href="#登场角色" class="headerlink" title="登场角色"></a>登场角色</h1><p>上面的示例程序介绍了Interpreter模式的Java实现，下面咱们试着跳出语言层面，抽象出Interpreter模式中登场的角色。</p><p><strong>AbstractExpression(抽象表达式)</strong></p><p>定义结点的基本约束。在示例程序中，由Node类扮演这个角色。</p><p><strong>TerminalExpression(终结符表达式)</strong></p><p>即EBNF中的终结符表达式，在示例程序中，由PrimitiveCommandNode类扮演这个角色。</p><p><strong>NonterminalExpression(非终结符表达式)</strong></p><p>即EBNF中的非终结符表达式，在示例程序中，由ProgramNode类，CommandListNode类，CommandNode类，RepeatCommandNode类联袂扮演这个角色。</p><p><strong>Context(上下文)</strong></p><p>在示例程序中，由Context类扮演这个角色。</p><h1 id="迷你语言可以有哪些？"><a href="#迷你语言可以有哪些？" class="headerlink" title="迷你语言可以有哪些？"></a>迷你语言可以有哪些？</h1><p>其实说白了，只要功能允许，也就是语言A中所表述的实体在语言B中实际存在，那么就可以使用Interpreter模式将语言A至于语言B之上。下面列出的是几种常用和热门的。</p><p><strong>批处理语言</strong></p><p>也就是所谓的第二代语言。这种语言基本就是单词的拼接，能表达的含义远没有第三代语言多。但是在某些本来就不需要那么多含义的场景下，使用批处理语言会使程序”更纯粹”，反而有利于开发和维护。本文示例程序中设计的迷你语言即属于批处理语言。</p><p><strong>正则</strong></p><p>大多数主流语言都支持对正则语法的解析。实现细节虽然千差万别，但核心思想基本不出本文藩篱。</p><p><strong>自然语言</strong></p><p>自然语言的语义识别和语法树的构建是人工智能的关键技术之一。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在《图解设计模式》一书中，Interpreter模式被归入了第10部分&lt;a href=&quot;&quot;&gt;用类来表现&lt;/a&gt;。在GoF原书中，Interpreter模式则被归入了&lt;a href=&quot;&quot;&gt;行为型设计模式&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Java 设计模式" scheme="http://yoursite.com/categories/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java 设计模式-22.Command模式</title>
    <link href="http://yoursite.com/2018/09/07/Java%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-22Command%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/09/07/Java 设计模式-22Command模式/</id>
    <published>2018-09-07T02:10:49.000Z</published>
    <updated>2018-09-07T11:12:19.765Z</updated>
    
    <content type="html"><![CDATA[<p>在《图解设计模式》一书中，Command模式被归入了第10部分<a href="">用类来表现</a>。在GoF原书中，Command模式则被归入了<a href="">行为型设计模式</a>。</p><a id="more"></a><h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><p>在<a href="">19.State模式</a>中，我们介绍了用类来描述状态。今天我们介绍另一个可以用类来描述的相对抽象的概念：命令。</p><p>宏观的说，一个类与其他类的关系可以归为两种：</p><ul><li>向其他类发出命令促使其他类发生变化。</li><li>接到来自其他类的指令自身发生变化。</li></ul><p>通常来说，系统只会记录变化的结果，而不会记录变化的过程。换句话说，当我们在某个时间点对系统进行查询时，通常只能查到系统在当前时间的静态状态，也就是因命令导致的结果，而无法查知变化的过程。虽然程序一般都会把这个过程记录在日志中，但从严格的意义上来讲，日志文件已经不属于系统本身了。</p><p>变化过程本身无法记录，但是如果我们将触发变化的命令作为对象记录下来呢？</p><p>假设我们要画一系列的点(这也是本文的示例程序，先简要描述下)，通常来说，我们会告诉绘图实例：在位置p1绘制一个半径为r1，颜色为c1的点！绘图实例就赶紧按要求画了一个点。我们再说：在位置p2绘制一个半径为r2，颜色为c2的点！绘图程序赶紧又画了一个。最终我们得到了绘制着两个点的画布。但是触发绘制这两个点的命令却丢失了：因为我们根本不曾记录。</p><p>如果我们将这两个命令记录下来，形成表示命令的实例：</p><ul><li>命令1：在位置p1绘制一个半径为r1，颜色为c1的点！</li><li>命令2：在位置p2绘制一个半径为r2，颜色为c2的点！</li></ul><p>这样我们便算是将一个抽象的变化存储为了相对具体的实体。一旦完成了存储，我们可做的事一下子就变多了：</p><ol><li>引入命令后，类A将从直接调用类B转化为制造一条命令，而后执行这条命令：这就使得类A与类B之间完成了解耦。</li><li>接上条，这种解耦并不仅仅是空间上的，同样还可以是时间上的，如果对命令结果的需求没那么迫切，类A完全可以只负责制造命令，而后就可以继续做自己的事了。这使得命令的执行变成了异步的。</li><li>继续接上条，一旦命令的执行变为异步，就意味着我们可以把待执行的命令存储起来，形成一个指令集。在需要的时候统一执行。</li><li><a href="">18.Memento模式</a>可以让我们进行存档与恢复。其做法就是把某个时间点的对象像拍照那样存储下来，而后在需要时再进行恢复；引入命令后，我们也可以做到类似的事，比如某实例最初处于初始状态，而后经过了命令1，2，3后变为了状态2。如果我们想要记录状态2，方法之一自然是使用<a href="">18.Memento模式</a>将状态2照下来。但我们同样也可以存储命令1，2，3。当我们需要状态2时，我们只需要再找一个处于初始状态的实例，而后再按顺序执行一遍命令1，2，3即可。</li><li>接上条，很显然，如果要使用命令集来制作存档的话，在恢复存档时通常要比拍快照更花时间。</li></ol><p>将这种”引入命令”的思想理论化后，得到的就是Command模式啦。有时，我们也会将命令称为事件(event)，它与”事件驱动编程”中的”事件”的含义是相同的。我们会在GUI编程中大量的用到事件：点击一次鼠标是一个事件，按下键盘上的一个按键是一个事件。而每个事件其实都可以视为一个指令，以促使系统发生相应的变化。</p><h1 id="示例程序需求分析"><a href="#示例程序需求分析" class="headerlink" title="示例程序需求分析"></a>示例程序需求分析</h1><p>下面我们就来设计一个应用了Command模式的小例子吧。这是一个使用Java Swing技术实现的画图小程序。启动时的初始面板为：</p><p><img src="/images/blog_pic/Java 设计模式/22Command模式/0.jpg" alt="0.jpg"></p><p>区域介绍：</p><p><img src="/images/blog_pic/Java 设计模式/22Command模式/1.jpg" alt="1.jpg"></p><p>默认画笔粗细为10(画笔形成的点的半径为10个像素)，默认颜色为黑色，在画布上按住鼠标左键拖动即可绘制图形。下图为使用初始参数绘制一条线：</p><p><img src="/images/blog_pic/Java 设计模式/22Command模式/2.jpg" alt="2.jpg"></p><p>然后我们调整画笔粗细为5，颜色为绿，在线的下面再画一个圈：</p><p><img src="/images/blog_pic/Java 设计模式/22Command模式/3.jpg" alt="3.jpg"></p><p>点击”清空”按钮后，画布会被清空。不过画笔颜色及粗细不会恢复为默认值。例如我们可以撤销部分绘制圆的操作：</p><p><img src="/images/blog_pic/Java 设计模式/22Command模式/4.jpg" alt="4.jpg"></p><p>点击”撤销”按钮可以让我们撤销一次操作，即取消绘制一个点。不过并不会撤销对画笔颜色及粗细的选择。</p><p>点击”保存”按钮可以将当前画布上的图形保存到文件中。此后可以通过点击”读取”按钮恢复此前保存的图形。</p><p>功能基本就是这么多，最后附上一幅我用这个程序画的一幢好丑好丑的房子，哈哈哈：</p><p><img src="/images/blog_pic/Java 设计模式/22Command模式/5.jpg" alt="5.jpg"></p><h1 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h1><p>本程序中的所有代码将被统一置于design22包下，结构如下：</p><p><img src="/images/blog_pic/Java 设计模式/22Command模式/6.jpg" alt="6.jpg"></p><p>下面将逐个贴出每个类的源码。</p><p>首先介绍command包里的类，顾名思义，这个包下自然全都是命令啦。</p><p><strong>Command接口</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package design22.command;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public interface Command &#123;</span><br><span class="line"></span><br><span class="line">    void execute();</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; strList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Command是最顶层的命令接口。内部只有两个方法。其中execute()表示执行命令。而strList()则会将命令转换为字符串以用于存档。之所以返回类型是List，是因为实际实现Command接口的命令有可能并非单独一条指令，而是一个指令集。</p><p><strong>MacroCommand类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">package design22.command;</span><br><span class="line"></span><br><span class="line">import java.awt.Color;</span><br><span class="line">import java.awt.Point;</span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.BufferedWriter;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.OutputStreamWriter;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">import org.apache.commons.lang.StringUtils;</span><br><span class="line"></span><br><span class="line">import com.alibaba.fastjson.JSONObject;</span><br><span class="line"></span><br><span class="line">import design22.view.MyCanvas;</span><br><span class="line"></span><br><span class="line">public class MacroCommand implements Command &#123;</span><br><span class="line"></span><br><span class="line">    private Stack&lt;Command&gt; commands = new Stack&lt;Command&gt;();</span><br><span class="line"></span><br><span class="line">    private static final String SAVE = &quot;src/main/java/design22/save/save.txt&quot;;</span><br><span class="line"></span><br><span class="line">    private static final String ENCODING = &quot;UTF-8&quot;;</span><br><span class="line"></span><br><span class="line">    private MyCanvas canvas;</span><br><span class="line"></span><br><span class="line">    public MacroCommand(MyCanvas canvas) &#123;</span><br><span class="line">        this.canvas = canvas;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void execute() &#123;</span><br><span class="line">        Iterator&lt;Command&gt; iterator = this.commands.iterator();</span><br><span class="line">        while (iterator.hasNext()) iterator.next().execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void append(Command cmd) &#123;</span><br><span class="line">        if (this != cmd) this.commands.push(cmd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void clear() &#123;</span><br><span class="line">        this.commands.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void undo() &#123;</span><br><span class="line">        if (!this.commands.isEmpty()) this.commands.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void save() &#123;</span><br><span class="line">        List&lt;String&gt; data = this.strList();</span><br><span class="line">        FileOutputStream fo = null;</span><br><span class="line">        OutputStreamWriter ow = null;</span><br><span class="line">        BufferedWriter bw = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            fo = new FileOutputStream(new File(MacroCommand.SAVE));</span><br><span class="line">            ow = new OutputStreamWriter(fo, MacroCommand.ENCODING);</span><br><span class="line">            bw = new BufferedWriter(ow);</span><br><span class="line">            for (String str : data) &#123;</span><br><span class="line">                bw.write(str);</span><br><span class="line">                bw.newLine();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                bw.close();</span><br><span class="line">                ow.close();</span><br><span class="line">                fo.close();</span><br><span class="line">            &#125; catch (Exception ef) &#123;</span><br><span class="line">                ef.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;String&gt; strList() &#123;</span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">        Iterator&lt;Command&gt; iterator = this.commands.iterator();</span><br><span class="line">        while (iterator.hasNext()) list.addAll(iterator.next().strList());</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void load() &#123;</span><br><span class="line">        this.clear();</span><br><span class="line">        this.canvas.init();</span><br><span class="line">        FileInputStream fi = null;</span><br><span class="line">        InputStreamReader ir = null;</span><br><span class="line">        BufferedReader br = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            fi = new FileInputStream(new File(MacroCommand.SAVE));</span><br><span class="line">            ir = new InputStreamReader(fi, MacroCommand.ENCODING);</span><br><span class="line">            br = new BufferedReader(ir);</span><br><span class="line">            String lineTxt = null;</span><br><span class="line">            while (!StringUtils.isBlank((lineTxt = br.readLine()))) &#123;</span><br><span class="line">                JSONObject jo = JSONObject.parseObject(lineTxt);</span><br><span class="line">                String className = jo.get(&quot;type&quot;).toString();</span><br><span class="line">                Command cmd = null;</span><br><span class="line">                if (DrawCommand.class.getName().equals(className)) &#123;</span><br><span class="line">                    cmd = new DrawCommand(this.canvas, new Point(Integer.parseInt(jo.get(&quot;pointX&quot;).toString()), Integer.parseInt(jo.get(&quot;pointY&quot;).toString())));</span><br><span class="line">                &#125; else if (ColorCommand.class.getName().equals(className)) &#123;</span><br><span class="line">                    cmd = new ColorCommand(this.canvas, new Color(Integer.parseInt(jo.get(&quot;colorRGB&quot;).toString())));</span><br><span class="line">                &#125; else if (BrushCommand.class.getName().equals(className)) &#123;</span><br><span class="line">                    cmd = new BrushCommand(this.canvas, Integer.parseInt(jo.get(&quot;brushWidth&quot;).toString()));</span><br><span class="line">                &#125;</span><br><span class="line">                if (null != cmd) this.append(cmd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                br.close();</span><br><span class="line">                ir.close();</span><br><span class="line">                fi.close();</span><br><span class="line">            &#125; catch (Exception ef) &#123;</span><br><span class="line">                ef.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MacroCommand类就是前文提到的，实现了Command接口的指令集。其最核心的字段就是commands了。对于这个字段，我们有两点需要说明：</p><ol><li>之所以声明为栈，是为了便于进行撤销操作。</li><li>栈的泛型类型是Command，而MacroCommand类本身又实现了Command接口。这意味着commands字段中同样可以添加MacroCommand类型的数据。也就是说，指令集中的某条指令同样可以是另一个指令集，这在MacroCommand类execute()中也有所体现：最终我们是使用递归执行栈中的所有指令的(为防止无限递归下去，我们禁止将自身添加到commands字段中)。这其实是对<a href="">11.Composite模式</a>的一种应用。</li></ol><p>commands是本程序中最核心的字段，其中存储了所有的指令。程序做的所有操作最终其实都是在操作这个字段：</p><ul><li>清空画布：即清空commands字段。而后按照commands字段重绘图形，因为commands已被清空，自然就起到了清空画布的效果。</li><li>撤销最后一次操作：弹出最后一条指令，而后按照commands字段重绘图形，因为最后一条指令已被弹出，自然就相当于撤销操作了。</li><li>保存：将commands中的命令按顺序存储入文件。</li><li>读取：将文件中的命令按顺序读取入commands字段，而后依commands重绘图形，起到读档的作用。</li></ul><p><strong>DrawCommand类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package design22.command;</span><br><span class="line"></span><br><span class="line">import java.awt.Point;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">import com.alibaba.fastjson.JSONObject;</span><br><span class="line"></span><br><span class="line">import design22.view.MyCanvas;</span><br><span class="line"></span><br><span class="line">public class DrawCommand implements Command &#123;</span><br><span class="line"></span><br><span class="line">    private MyCanvas canvas;</span><br><span class="line"></span><br><span class="line">    private Point point;</span><br><span class="line"></span><br><span class="line">    public DrawCommand(MyCanvas canvas, Point point) &#123;</span><br><span class="line">        this.canvas = canvas;</span><br><span class="line">        this.point = point;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void execute() &#123;</span><br><span class="line">        this.canvas.draw(this.point);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;String&gt; strList() &#123;</span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;String&gt;(1);</span><br><span class="line">        JSONObject jo = new JSONObject();</span><br><span class="line">        jo.put(&quot;type&quot;, DrawCommand.class.getName());</span><br><span class="line">        jo.put(&quot;pointX&quot;, this.point.x);</span><br><span class="line">        jo.put(&quot;pointY&quot;, this.point.y);</span><br><span class="line">        list.add(jo.toJSONString());</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>命令：在画布特定的位置上绘制一个点。</p><p><strong>ColorCommand类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package design22.command;</span><br><span class="line"></span><br><span class="line">import java.awt.Color;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">import com.alibaba.fastjson.JSONObject;</span><br><span class="line"></span><br><span class="line">import design22.view.MyCanvas;</span><br><span class="line"></span><br><span class="line">public class ColorCommand implements Command &#123;</span><br><span class="line"></span><br><span class="line">    private MyCanvas canvas;</span><br><span class="line"></span><br><span class="line">    private Color color;</span><br><span class="line"></span><br><span class="line">    public ColorCommand(MyCanvas canvas, Color color) &#123;</span><br><span class="line">        this.canvas = canvas;</span><br><span class="line">        this.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void execute() &#123;</span><br><span class="line">        this.canvas.setColor(this.color);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;String&gt; strList() &#123;</span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;String&gt;(1);</span><br><span class="line">        JSONObject jo = new JSONObject();</span><br><span class="line">        jo.put(&quot;type&quot;, ColorCommand.class.getName());</span><br><span class="line">        jo.put(&quot;colorRGB&quot;, this.color.getRGB());</span><br><span class="line">        list.add(jo.toJSONString());</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>命令：将画笔变更为特定的颜色。</p><p><strong>BrushCommand类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package design22.command;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">import com.alibaba.fastjson.JSONObject;</span><br><span class="line"></span><br><span class="line">import design22.view.MyCanvas;</span><br><span class="line"></span><br><span class="line">public class BrushCommand implements Command &#123;</span><br><span class="line"></span><br><span class="line">    private MyCanvas canvas;</span><br><span class="line"></span><br><span class="line">    private int width;</span><br><span class="line"></span><br><span class="line">    public BrushCommand(MyCanvas canvas, int width) &#123;</span><br><span class="line">        this.canvas = canvas;</span><br><span class="line">        this.width = width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void execute() &#123;</span><br><span class="line">        this.canvas.setR(this.width);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;String&gt; strList() &#123;</span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;String&gt;(1);</span><br><span class="line">        JSONObject jo = new JSONObject();</span><br><span class="line">        jo.put(&quot;type&quot;, BrushCommand.class.getName());</span><br><span class="line">        jo.put(&quot;brushWidth&quot;, this.width);</span><br><span class="line">        list.add(jo.toJSONString());</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>命令：将画笔变更为特定的粗细。</p><p>然后是view包：</p><p><strong>MyCanvas类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">package design22.view;</span><br><span class="line"></span><br><span class="line">import java.awt.Canvas;</span><br><span class="line">import java.awt.Color;</span><br><span class="line">import java.awt.Graphics;</span><br><span class="line">import java.awt.Point;</span><br><span class="line"></span><br><span class="line">import design22.command.MacroCommand;</span><br><span class="line"></span><br><span class="line">public class MyCanvas extends Canvas &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">    private static final Color DEF_COLOR = Color.BLACK;</span><br><span class="line"></span><br><span class="line">    private static final int DEF_R = 10;</span><br><span class="line"></span><br><span class="line">    Color color = MyCanvas.DEF_COLOR;</span><br><span class="line"></span><br><span class="line">    int r = MyCanvas.DEF_R;</span><br><span class="line"></span><br><span class="line">    MacroCommand history = new MacroCommand(this);</span><br><span class="line"></span><br><span class="line">    public MyCanvas(int width, int height) &#123;</span><br><span class="line">        this.setSize(width, height);</span><br><span class="line">        this.setBackground(Color.WHITE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void paint(Graphics g) &#123;</span><br><span class="line">        this.init();</span><br><span class="line">        this.history.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void draw(Point point) &#123;</span><br><span class="line">        Graphics g = this.getGraphics();</span><br><span class="line">        g.setColor(this.color);</span><br><span class="line">        g.fillOval(point.x - this.r, point.y - this.r, 2 * this.r, 2 * this.r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setColor(Color color) &#123;</span><br><span class="line">        this.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setR(int r) &#123;</span><br><span class="line">        this.r = r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void init() &#123;</span><br><span class="line">        this.color = MyCanvas.DEF_COLOR;</span><br><span class="line">        this.r = MyCanvas.DEF_R;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即为自己实现的画板类。</p><p><strong>View类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line">package design22.view;</span><br><span class="line"></span><br><span class="line">import java.awt.Color;</span><br><span class="line">import java.awt.event.ActionEvent;</span><br><span class="line">import java.awt.event.ActionListener;</span><br><span class="line">import java.awt.event.MouseEvent;</span><br><span class="line">import java.awt.event.MouseMotionAdapter;</span><br><span class="line">import java.awt.event.WindowAdapter;</span><br><span class="line">import java.awt.event.WindowEvent;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">import javax.swing.Box;</span><br><span class="line">import javax.swing.BoxLayout;</span><br><span class="line">import javax.swing.ButtonGroup;</span><br><span class="line">import javax.swing.JButton;</span><br><span class="line">import javax.swing.JCheckBox;</span><br><span class="line">import javax.swing.JFrame;</span><br><span class="line"></span><br><span class="line">import design22.command.BrushCommand;</span><br><span class="line">import design22.command.ColorCommand;</span><br><span class="line">import design22.command.Command;</span><br><span class="line">import design22.command.DrawCommand;</span><br><span class="line"></span><br><span class="line">public class View extends JFrame implements ActionListener &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">    MyCanvas canvas = new MyCanvas(50 * 16, 50 * 9);</span><br><span class="line"></span><br><span class="line">    private int maxBrush = 20;</span><br><span class="line"></span><br><span class="line">    private List&lt;JCheckBox&gt; brushBoxs = new ArrayList&lt;JCheckBox&gt;();</span><br><span class="line"></span><br><span class="line">    private List&lt;ColorBox&gt; colorBoxs = new ArrayList&lt;ColorBox&gt;();</span><br><span class="line"></span><br><span class="line">    private List&lt;JButton&gt; buttons = new ArrayList&lt;JButton&gt;();</span><br><span class="line"></span><br><span class="line">    public View() &#123;</span><br><span class="line">        // 制作按钮</span><br><span class="line">        this.buttons.add(new JButton(&quot;清空&quot;));</span><br><span class="line">        this.buttons.add(new JButton(&quot;撤销&quot;));</span><br><span class="line">        this.buttons.add(new JButton(&quot;保存&quot;));</span><br><span class="line">        this.buttons.add(new JButton(&quot;读取&quot;));</span><br><span class="line">        for (JButton button : this.buttons) button.addActionListener(this);</span><br><span class="line">        // 制作颜色CheckBox</span><br><span class="line">        this.colorBoxs.add(new ColorBox(Color.BLACK, &quot;黑&quot;, this));</span><br><span class="line">        this.colorBoxs.add(new ColorBox(Color.DARK_GRAY, &quot;深灰&quot;, this));</span><br><span class="line">        this.colorBoxs.add(new ColorBox(Color.GRAY, &quot;灰&quot;, this));</span><br><span class="line">        this.colorBoxs.add(new ColorBox(Color.LIGHT_GRAY, &quot;浅灰&quot;, this));</span><br><span class="line">        this.colorBoxs.add(new ColorBox(Color.BLUE, &quot;蓝&quot;, this));</span><br><span class="line">        this.colorBoxs.add(new ColorBox(Color.CYAN, &quot;青&quot;, this));</span><br><span class="line">        this.colorBoxs.add(new ColorBox(Color.GREEN, &quot;绿&quot;, this));</span><br><span class="line">        this.colorBoxs.add(new ColorBox(Color.MAGENTA, &quot;洋红&quot;, this));</span><br><span class="line">        this.colorBoxs.add(new ColorBox(Color.RED, &quot;红&quot;, this));</span><br><span class="line">        this.colorBoxs.add(new ColorBox(Color.PINK, &quot;粉&quot;, this));</span><br><span class="line">        this.colorBoxs.add(new ColorBox(Color.ORANGE, &quot;橘&quot;, this));</span><br><span class="line">        this.colorBoxs.add(new ColorBox(Color.YELLOW, &quot;黄&quot;, this));</span><br><span class="line">        ButtonGroup colorGroup = new ButtonGroup();</span><br><span class="line">        for (ColorBox colorBox : this.colorBoxs) &#123;</span><br><span class="line">            colorBox.checkBox.addActionListener(this);</span><br><span class="line">            colorGroup.add(colorBox.checkBox);</span><br><span class="line">        &#125;</span><br><span class="line">        // 制作画笔CheckBox</span><br><span class="line">        ButtonGroup brushGroup = new ButtonGroup();</span><br><span class="line">        for (int i = 1; i &lt;= this.maxBrush; i++) &#123;</span><br><span class="line">            JCheckBox brushCheckBox = new JCheckBox(i + &quot;&quot;, i == this.canvas.r);</span><br><span class="line">            this.brushBoxs.add(brushCheckBox);</span><br><span class="line">            brushCheckBox.addActionListener(this);</span><br><span class="line">            brushGroup.add(brushCheckBox);</span><br><span class="line">        &#125;</span><br><span class="line">        // 画布拖动监听</span><br><span class="line">        this.canvas.addMouseMotionListener(</span><br><span class="line">            new MouseMotionAdapter() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void mouseDragged(MouseEvent e) &#123;</span><br><span class="line">                    Command cmd = new DrawCommand(View.this.canvas, e.getPoint());</span><br><span class="line">                    View.this.canvas.history.append(cmd);</span><br><span class="line">                    cmd.execute();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">        // 布局</span><br><span class="line">        Box firstBox = new Box(BoxLayout.X_AXIS);</span><br><span class="line">        for (JButton button : this.buttons) firstBox.add(button);</span><br><span class="line">        Box secondBox = new Box(BoxLayout.X_AXIS);</span><br><span class="line">        Box brushBox = new Box(BoxLayout.Y_AXIS);</span><br><span class="line">        for (JCheckBox temp : this.brushBoxs) brushBox.add(temp);</span><br><span class="line">        secondBox.add(brushBox);</span><br><span class="line">        secondBox.add(this.canvas);</span><br><span class="line">        Box colorBox = new Box(BoxLayout.Y_AXIS);</span><br><span class="line">        for (ColorBox temp : this.colorBoxs) colorBox.add(temp.checkBox);</span><br><span class="line">        secondBox.add(colorBox);</span><br><span class="line">        Box mainBox = new Box(BoxLayout.Y_AXIS);</span><br><span class="line">        mainBox.add(firstBox);</span><br><span class="line">        mainBox.add(secondBox);</span><br><span class="line">        super.getContentPane().add(mainBox);</span><br><span class="line">        // 关闭</span><br><span class="line">        this.addWindowListener(</span><br><span class="line">            new WindowAdapter() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void windowClosing(WindowEvent e) &#123;</span><br><span class="line">                    System.exit(0);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">        // 显示</span><br><span class="line">        super.pack();</span><br><span class="line">        super.setVisible(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void actionPerformed(ActionEvent e) &#123;</span><br><span class="line">        for (JButton button : this.buttons) &#123;</span><br><span class="line">            if (e.getSource() == button) &#123;</span><br><span class="line">                if (&quot;清空&quot;.equals(button.getText())) &#123;</span><br><span class="line">                    this.canvas.history.clear();</span><br><span class="line">                    this.canvas.repaint();</span><br><span class="line">                &#125; else if (&quot;撤销&quot;.equals(button.getText())) &#123;</span><br><span class="line">                    this.canvas.history.undo();</span><br><span class="line">                    this.canvas.repaint();</span><br><span class="line">                &#125; else if (&quot;保存&quot;.equals(button.getText())) &#123;</span><br><span class="line">                    this.canvas.history.save();</span><br><span class="line">                &#125; else if (&quot;读取&quot;.equals(button.getText())) &#123;</span><br><span class="line">                    this.canvas.history.load();</span><br><span class="line">                    this.canvas.repaint();</span><br><span class="line">                &#125;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (ColorBox colorBox : this.colorBoxs) &#123;</span><br><span class="line">            if (e.getSource() == colorBox.checkBox) &#123;</span><br><span class="line">                Command cmd = new ColorCommand(this.canvas, colorBox.color);</span><br><span class="line">                this.canvas.history.append(cmd);</span><br><span class="line">                cmd.execute();</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (JCheckBox brushBox : this.brushBoxs) &#123;</span><br><span class="line">            if (e.getSource() == brushBox) &#123;</span><br><span class="line">                Command cmd = new BrushCommand(this.canvas, Integer.parseInt(brushBox.getText()));</span><br><span class="line">                this.canvas.history.append(cmd);</span><br><span class="line">                cmd.execute();</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ColorBox &#123;</span><br><span class="line"></span><br><span class="line">    Color color;</span><br><span class="line"></span><br><span class="line">    JCheckBox checkBox;</span><br><span class="line"></span><br><span class="line">    String desc;</span><br><span class="line"></span><br><span class="line">    ColorBox (Color color, String desc, View view) &#123;</span><br><span class="line">        this.color = color;</span><br><span class="line">        this.checkBox = new JCheckBox(desc, this.color == view.canvas.color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>View负责创建及调用命令。方式主要有两种。</p><p>第一种为创建命令并直接调用。以切换颜色为例，会触发actionPerformed()监听事件。从代码中可以看到，我们会创建并直接执行命令。当然，我们也会将该命令存入MacroCommand类的commands字段中，以形成存档，View作为面板，每个实例都会创建并绑定一个MyCanvas(画布)类的实例，而每一个画布，同样会创建并绑定一个MacroCommand类的实例：在MyCanvas中，这个MacroCommand被称为history。</p><p>第二种并不会创建新命令，但会导致commands中的已有命令会被重新全部执行一遍。例如当我们按下”撤销”按钮后，会触发actionPerformed()方法。其中undo()会导致commands中最新的命令被弹出，而repaint()则会先清空画布，而后将commands中剩余的命令重新执行一遍。</p><p><strong>save.txt</strong></p><p>我们会在save包下存放存档。该存档只有一份，反复存档只会导致存档覆盖。因为拖动时每一个点都会生成1条命令，因此这个文件行数通常都会很多。上文绘制房子的那个存档文件就有16000+的行数。现只截取最开始的那部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;brushWidth&quot;:20,&quot;type&quot;:&quot;design22.command.BrushCommand&quot;&#125;</span><br><span class="line">&#123;&quot;colorRGB&quot;:-16711936,&quot;type&quot;:&quot;design22.command.ColorCommand&quot;&#125;</span><br><span class="line">&#123;&quot;pointX&quot;:4,&quot;pointY&quot;:411,&quot;type&quot;:&quot;design22.command.DrawCommand&quot;&#125;</span><br><span class="line">&#123;&quot;pointX&quot;:6,&quot;pointY&quot;:411,&quot;type&quot;:&quot;design22.command.DrawCommand&quot;&#125;</span><br><span class="line">&#123;&quot;pointX&quot;:8,&quot;pointY&quot;:411,&quot;type&quot;:&quot;design22.command.DrawCommand&quot;&#125;</span><br><span class="line">&#123;&quot;pointX&quot;:10,&quot;pointY&quot;:411,&quot;type&quot;:&quot;design22.command.DrawCommand&quot;&#125;</span><br><span class="line">&#123;&quot;pointX&quot;:13,&quot;pointY&quot;:411,&quot;type&quot;:&quot;design22.command.DrawCommand&quot;&#125;</span><br><span class="line">&#123;&quot;pointX&quot;:16,&quot;pointY&quot;:411,&quot;type&quot;:&quot;design22.command.DrawCommand&quot;&#125;</span><br><span class="line">&#123;&quot;pointX&quot;:20,&quot;pointY&quot;:411,&quot;type&quot;:&quot;design22.command.DrawCommand&quot;&#125;</span><br><span class="line">&#123;&quot;pointX&quot;:25,&quot;pointY&quot;:411,&quot;type&quot;:&quot;design22.command.DrawCommand&quot;&#125;</span><br><span class="line">&#123;&quot;pointX&quot;:29,&quot;pointY&quot;:411,&quot;type&quot;:&quot;design22.command.DrawCommand&quot;&#125;</span><br><span class="line">&#123;&quot;pointX&quot;:32,&quot;pointY&quot;:411,&quot;type&quot;:&quot;design22.command.DrawCommand&quot;&#125;</span><br><span class="line">&#123;&quot;pointX&quot;:35,&quot;pointY&quot;:411,&quot;type&quot;:&quot;design22.command.DrawCommand&quot;&#125;</span><br><span class="line">&#123;&quot;pointX&quot;:37,&quot;pointY&quot;:411,&quot;type&quot;:&quot;design22.command.DrawCommand&quot;&#125;</span><br><span class="line">&#123;&quot;pointX&quot;:40,&quot;pointY&quot;:411,&quot;type&quot;:&quot;design22.command.DrawCommand&quot;&#125;</span><br><span class="line">&#123;&quot;pointX&quot;:42,&quot;pointY&quot;:411,&quot;type&quot;:&quot;design22.command.DrawCommand&quot;&#125;</span><br><span class="line">&#123;&quot;pointX&quot;:45,&quot;pointY&quot;:411,&quot;type&quot;:&quot;design22.command.DrawCommand&quot;&#125;</span><br><span class="line">&#123;&quot;pointX&quot;:48,&quot;pointY&quot;:411,&quot;type&quot;:&quot;design22.command.DrawCommand&quot;&#125;</span><br><span class="line">&#123;&quot;pointX&quot;:52,&quot;pointY&quot;:411,&quot;type&quot;:&quot;design22.command.DrawCommand&quot;&#125;</span><br><span class="line">&#123;&quot;pointX&quot;:54,&quot;pointY&quot;:411,&quot;type&quot;:&quot;design22.command.DrawCommand&quot;&#125;</span><br><span class="line">&#123;&quot;pointX&quot;:56,&quot;pointY&quot;:411,&quot;type&quot;:&quot;design22.command.DrawCommand&quot;&#125;</span><br><span class="line">&#123;&quot;pointX&quot;:60,&quot;pointY&quot;:411,&quot;type&quot;:&quot;design22.command.DrawCommand&quot;&#125;</span><br><span class="line">&#123;&quot;pointX&quot;:63,&quot;pointY&quot;:411,&quot;type&quot;:&quot;design22.command.DrawCommand&quot;&#125;</span><br><span class="line">&#123;&quot;pointX&quot;:67,&quot;pointY&quot;:411,&quot;type&quot;:&quot;design22.command.DrawCommand&quot;&#125;</span><br><span class="line">&#123;&quot;pointX&quot;:72,&quot;pointY&quot;:412,&quot;type&quot;:&quot;design22.command.DrawCommand&quot;&#125;</span><br></pre></td></tr></table></figure><p>最后是直接位于design22包下的Main.java：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package design22;</span><br><span class="line"></span><br><span class="line">import design22.view.View;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new View();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行该类后，即可启动程序。</p><h1 id="登场角色"><a href="#登场角色" class="headerlink" title="登场角色"></a>登场角色</h1><p>上面的示例程序介绍了Command模式的Java实现，下面咱们试着跳出语言层面，抽象出Command模式中登场的角色。</p><p><strong>Command(命令)</strong></p><p>在示例程序中，由Command接口扮演这个角色。</p><p><strong>ConcreteCommand(具体的命令)</strong></p><p>在示例程序中，由MacroCommand类，DrawCommand类，ColorCommand类，BrushCommand类联袂扮演这个角色。</p><p><strong>Receiver(接收者)</strong></p><p>接收命令，或是受命令影响的角色。在示例程序中，由MyCanvas类扮演这个角色。</p><p><strong>Invoker(发动者)</strong></p><p>Invoker是Command的触发者(通常也是创建者)。在示例程序中，由View类扮演这个角色。</p><h1 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h1><p>在此，我想说点与Command模式没什么关系的事。</p><p>在示例程序中，View实现监听的方式是写匿名的适配器类。例如我们在为画布添加拖动鼠标的监听时，是这样做的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">this.canvas.addMouseMotionListener(</span><br><span class="line">    new MouseMotionAdapter() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void mouseDragged(MouseEvent e) &#123;</span><br><span class="line">            Command cmd = new DrawCommand(View.this.canvas, e.getPoint());</span><br><span class="line">            View.this.canvas.history.append(cmd);</span><br><span class="line">            cmd.execute();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>我们不妨稍微看下源码。这个this.canvas.addMouseMotionListener()的方法定义为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void addMouseMotionListener(MouseMotionListener l)</span><br></pre></td></tr></table></figure><p>很显然，它接收一个MouseMotionListener类型的数据，而这个MouseMotionListener则是一个接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package java.awt.event;</span><br><span class="line"></span><br><span class="line">import java.util.EventListener;</span><br><span class="line"></span><br><span class="line">public interface MouseMotionListener extends EventListener &#123;</span><br><span class="line"></span><br><span class="line">    public void mouseDragged(MouseEvent e);</span><br><span class="line"></span><br><span class="line">    public void mouseMoved(MouseEvent e);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是MouseMotionListener接口的全部源码。其中mouseDragged()表示”按住鼠标拖动”这一事件；而mouseMoved()则表示鼠标移动事件。</p><p>那么自然，我们传入的这个MouseMotionAdapter就该实现MouseMotionListener啦，那么是不是呢：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package java.awt.event;</span><br><span class="line"></span><br><span class="line">public abstract class MouseMotionAdapter implements MouseMotionListener &#123;</span><br><span class="line"></span><br><span class="line">    public void mouseDragged(MouseEvent e) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public void mouseMoved(MouseEvent e) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码不长，我就全部贴出了。可以看到，MouseMotionAdapter除了将接口中约束的两个方法声明非抽象的以外，实际上什么都没做。</p><p>其实比起这种使用匿名内部类，也就是适配器的做法，我们其实可以直接找一个类实现MouseMotionListener接口，然后将这个类的实例传给addMouseMotionListener()方法(通常来说，我们会让面板去实现这个接口，也就是说传入this)。那么二者各有什么利弊呢？</p><p>先说说使用匿名类的好处吧。如果要自己写一个类去实现监听接口，这就意味着必须要强制实现接口中所有约束的方法。例如，此时我们就必须实现mouseMoved()了，即便我们根本不关心鼠标移动事件，那也要写一个空方法放在那里才行。这在接口本身约束很多(例如WindowListener)，而实际用到的很少时尤其的麻烦：我们需要写大量的空方法，使得代码有失优雅。而使用适配器类则解决了这个问题。MouseMotionAdapter被声明为了抽象类，但其中并没有抽象方法。这样做的原因有二：类被声明为抽象的是不希望直接new出对象来，要写继承的子类才行；而方法均不是抽象的则让自己只需要重写需要的约束即可。</p><p>然后说一下继承接口的好处。使用匿名类的问题在于，每次使用都会初始化一个新的匿名类，在需要多次使用同一个监听时将会很不方便。如果专门弄一个类去监听，又显得小题大做。当然，直接让面板或其他组件更是糟糕的决策：从使用上讲，因为Java是单继承的语言，这会消耗掉宝贵的继承机会；另一方面，组件根本就不是监听器，也就是根本不符合里氏替换原则及合成聚合复用原则，从逻辑上更是说不通。因此，此时让面板直接实现接口就成为了最好的选择：View便直接实现了ActionListener，而后将需要此监听的按钮及选框均与其绑定。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在《图解设计模式》一书中，Command模式被归入了第10部分&lt;a href=&quot;&quot;&gt;用类来表现&lt;/a&gt;。在GoF原书中，Command模式则被归入了&lt;a href=&quot;&quot;&gt;行为型设计模式&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Java 设计模式" scheme="http://yoursite.com/categories/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java 设计模式-21.Proxy模式</title>
    <link href="http://yoursite.com/2018/09/05/Java%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-21Proxy%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/09/05/Java 设计模式-21Proxy模式/</id>
    <published>2018-09-05T07:34:49.000Z</published>
    <updated>2018-09-05T12:23:53.262Z</updated>
    
    <content type="html"><![CDATA[<p>在《图解设计模式》一书中，Proxy模式被归入了第9部分<a href="">避免浪费</a>。在GoF原书中，Proxy模式则被归入了<a href="">结构型设计模式</a>。</p><a id="more"></a><h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><p>在日常生活中，我们常会遇到如下类似的情况：</p><ul><li>场景1：<strong>消费者(角色1)</strong>想买菜，于是他找到<strong>商人(角色2)</strong>，商人卖给消费者他从<strong>菜农(角色3)</strong>那收上来的菜。</li><li>场景2：<strong>产品经理(角色2)</strong>收集<strong>用户(角色1)</strong>的需求，将其汇总整理后提给<strong>程序员(角色3)</strong>。</li><li>场景3：<strong>用户(角色1)</strong>发现了产品的问题，于是他打电话给<strong>客服(角色2)</strong>，客服再将问题转交给<strong>技术人员(角色3)</strong>。</li></ul><p>虽然场景不同，但是上述示例均由如下3个角色构成：</p><ul><li>角色1：提出需求的人</li><li>角色2：将角色1的需求转交给角色3</li><li>角色3：实际完成需求的人</li></ul><p>这么来看，角色二似乎是可有可无的。这也是为什么在古代商人一直遭人轻贱的重要原因之一。直至今日，也总会冒出下面这样的广告，试图甩掉角色2：</p><p><img src="/images/blog_pic/Java 设计模式/21Proxy模式/0.jpg" alt="0.jpg"></p><p>那么实际上是这样的吗？</p><p>当然不是。</p><p><img src="/images/blog_pic/Java 设计模式/21Proxy模式/1.jpg" alt="1.jpg"></p><p>客观的说，如果必须要在这3个角色中拿掉一个的话，那么还是会拿掉角色2。因为角色1与角色3构成了事件的根基，二者如果缺了任一个事件本身就进展不下去了，这也是为什么我们会觉得角色2可有可无的原因。但是如果如果没有角色2，角色1与角色3的沟通将异常艰难，也很难形成健康的关系。这就好比物质基础与精神追求哪一个对人更重要那样：如果硬要只能选一个的话，那肯定是物质基础，毕竟活下去是前提条件。但是如果成为一个健全的人，精神追求是必不可少的。</p><p>我们可以具体分析一下角色2的作用。在上述需求中，角色3作为实际需求的处理者，往往不愿意，或者说是没能力直接对接角色1。我们以场景2为例。假如没有了产品经理，客户直接与程序员对接。那么在客户看来，我就只是说加一个按钮，面前这个家伙就神神叨叨的说了一大堆自己听不懂的专业名词；而在程序员看来，面前的这家伙就是个SB，提的都是什么智障需求，感觉做什么似乎都很容易。换句话说，我们需要这样一个角色，他既能听懂程序员在说什么，也知道说什么客户能听懂，这自然就是角色2，产品经理啦。</p><p>不仅如此，在所有场景中，角色1一般都是远多于角色3的。而每个角色1的需求又总会略有不同。如果角色1与角色3直接碰面。那么角色3就不得不面对形形色色的需求。但实际上，角色3通常都只会完成一个或者至多几个原型，将哪个原型交给哪个角色1，或者是将哪个原型微调1下交给角色1，这又是角色2的工作了。</p><p>简单来说，虽然角色3最终的目的是为角色1服务，但是在具体的需求中，角色3通常是无法面面俱到考虑到角色1所有的需求的。此时就需要角色2，也就是代理登场了。角色1与角色3完成了解耦，而角色2则承担起了代理人的作用。</p><p>由此，演化出来的设计模式就是Proxy模式。</p><p>说到这里，我们很容易就会想到另一个设计模式：<a href="">2.Adapter模式</a>。在Adapter模式中，也有如下3个角色：</p><ul><li>角色1：需要数据</li><li>角色2：转换数据格式以适配</li><li>角色3：提供数据</li></ul><p>这样看来，二者确实极为接近。不过，二者最本质的不同在于角色2，也就是各自的核心角色。在Adapter模式中，角色2被称为适配器，它只承载很简单的转换的功能，我们以显示器通过适配器连接主机为例，显示器(角色1)很明确最终数据还是主机(角色3)提供的，只不过格式对不上，因此需要适配器(角色2)转换一下，此时，角色2只是一个小小的原件。而在Proxy模式中，角色2被称为代理，顾名思义，在角色1看来，角色3仿佛是不存在的。或者说，角色2就是角色3。举个例子，作为消费者(角色1)，当我们向菜贩(角色2)买菜时，我们根本不会关心菜到底是哪个菜农(角色3)种的。</p><p>不仅如此，适配器仅仅只是在转换数据，不具有任何制造数据的能力。而在代理存在的场景中，角色1的核心需求由角色3完成。这意味着，对于一些不那么核心的需求而言，代理则无需麻烦角色3。以上文的场景3为例，客服并不会将用户所有的投诉都反馈给技术人员，对于那些明显简单或者明显逗逼的投诉客服自己就会处理掉 – 这是非常重要的，正如我们前文讲到的，在应用代理的场景下，角色1的数量往往远多于角色3。代理的这种能力能够在很大程度上缓解角色3的压力。</p><h1 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h1><p>下面我们来看一个应用了Proxy模式的小例子。该程序会通过代理(角色2)为调用者(角色1)找到工人(角色3)。首先是类图：</p><p><img src="/images/blog_pic/Java 设计模式/21Proxy模式/2.jpg" alt="2.jpg"></p><p>本程序中的所有代码将被统一置于design21包下，结构如下：</p><p><img src="/images/blog_pic/Java 设计模式/21Proxy模式/3.jpg" alt="3.jpg"></p><p>下面将逐个贴出每个类的源码。</p><p><strong>Workable接口</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package design21;</span><br><span class="line"></span><br><span class="line">public interface Workable &#123;</span><br><span class="line"></span><br><span class="line">    String getType();</span><br><span class="line"></span><br><span class="line">    void work();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Worker类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package design21;</span><br><span class="line"></span><br><span class="line">public class Worker implements Workable &#123;</span><br><span class="line"></span><br><span class="line">    private String type;</span><br><span class="line"></span><br><span class="line">    Worker(String type) &#123;</span><br><span class="line">        this.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getType() &#123;</span><br><span class="line">        return this.type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void work() &#123;</span><br><span class="line">        System.out.println(this.type + &quot;在工作&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>WorkerProxy类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package design21;</span><br><span class="line"></span><br><span class="line">public class WorkerProxy implements Workable &#123;</span><br><span class="line"></span><br><span class="line">    private Worker worker;</span><br><span class="line"></span><br><span class="line">    private String type;</span><br><span class="line"></span><br><span class="line">    public WorkerProxy(String type) &#123;</span><br><span class="line">        this.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getType() &#123;</span><br><span class="line">        return this.type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void work() &#123;</span><br><span class="line">        if (null == worker) this.worker = new Worker(this.type);</span><br><span class="line">        this.worker.work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Main类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package design21;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Workable worker = new WorkerProxy(&quot;水暖工&quot;);</span><br><span class="line">        System.out.println(worker.getType());</span><br><span class="line">        worker.work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行后，输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">水暖工</span><br><span class="line">水暖工在工作</span><br></pre></td></tr></table></figure><p>代码整体比较简单，不过还是有如下几点需要说明一下，大家可以对照着前文的综述加深理解。</p><p>本程序中，Main类是角色1，WorkerProxy类是角色2，而Worker类则是角色3。剩下的Workable接口则是抽象WorkerProxy与Worker后得到的。如果仅讨论Proxy模式最核心的功能，那么是不需要Workable，此时Main只能感知得到WorkerProxy。而在引入了Workable之后(通常我们都是会引入的)，Main连WorkerProxy都无需感知了。在示例程序中，WorkerProxy实例是在main方法中new出来的，这可能会给大家造成误解，不过在更常见的场景中，这个Workable应该是作为参数传递给角色1的，角色1根本不需要也不想要了解这个Workable到底是什么：这确实很合乎逻辑，对于调用者而言，他要的就是一个工人，或者更具体的来说，他要的不是工人，他要的是工作被完成。所以对调用者而言，其实他根部不在意这个Workable具体是个啥，到底做了啥，什么代理，什么委托，和调用者都没半毛钱的关系。因此抽象出Workable可以将调用者很好的与其他的角色解耦。</p><p>然后是问题二，调用者只需要一个Workable我们已经理解了。但是为什么要让WorkerProxy与Worker均实现Workable呢？换句话说，代理是代理，工人是工人。为什么要让角色2与角色3实现相同的接口呢？</p><p>这样的好处在于，代理与工人因此就具备了统一性。从逻辑上讲，对于调用者而言，为他服务的这个Workable其实只有一个身份：”能帮助自己完成工作的人”。至于这个人是自己亲自做还是委托给他人调用者并不在意，从这个角度来看，角色2与角色3的身份确实是统一的；从实际的代码结构来看，代理是可以分级的。换句话说，代理找到的并不一定是真正的工人，它还有可能是另一个代理，只要身份统一，它就可以扮演工人的角色。很显然，这是对<a href="">11.Composite模式</a>的应用。</p><p>正因为如此，这种将WorkerProxy与Worker统一起来的方式也成为了Proxy模式的默认思路。只不过，这同样会产生一些问题。因为Workable是调用者需要的接口，换句话说，它内部约束的那些方法就是调用者提出的需要。让WorkerProxy实现这个接口倒没什么。但是让Worker直接暴露在调用者的需求下却不太妥当。正如前文分析过的，角色3通常只会生成少量的几个原型，代理有一个很重要的工作就是将这几个原型稍加修改从而适应千变万化的需求。因此某些场景下，我们也会将角色2与角色3严格分隔开。这样角色1提出的需求对于角色3而言就是完全透明的了。</p><p>对于Main而言，当new出WorkerProxy时，它就认为工人已经生成好了。但是实际上，直到work()方法被调用之前，其实都并没有真正的生成工人。这其中还包括一个worker.getType()，也就是说main还像模像样的获取了一下工人的类型。只不过，该功能其实是被代理直接完成了，并不需要真正的工人(还记得综述中那个客服的例子吗)，因此依然不需要生成工人。直到不生成不行，也就是要让工人工作的时候，代理才通过懒加载的方式创建了工人，而后委托工人工作。这样就对工人的生成尽可能的做出了推迟，在系统规模较大时，这种将操作尽量移出初始化的做法可以极大的减少系统的启动时间。</p><p>在本示例中，Worker是无需感知到WorkerProxy的，这是理所当然的。而WorkerProxy为了能够将工作委托给Worker，则必须能够感知得到Worker才行(示例程序将Worker加为了WorkerProxy的字段)，这在逻辑上也是说得通的。不过在实际应用中，为了进一步提高灵活性，角色2与角色3也会解耦，即代理也不会记录实际工作的人是谁。在需要实际工人时，我们传递一个一个标志给代理，告诉它：”我要用这个工人！”。通常这会是一个表征类的字符串，然后代理会通过反射将其解析出来。这样的坏处在于：虽然将角色2与角色3进行了解耦，但需要在调用时由角色1告知角色2要用哪个角色3，无形中又将角色1与角色3耦合在了一起，所以其实是有利有弊。</p><h1 id="登场角色"><a href="#登场角色" class="headerlink" title="登场角色"></a>登场角色</h1><p>上面的示例程序介绍了Proxy模式的Java实现，下面咱们试着跳出语言层面，抽象出Proxy模式中登场的角色。</p><p><strong>Subject(主体功能)</strong></p><p>Subject抽象出了调用者的需求。Proxy与Real也因为Subject而具有了一致性。在示例程序中，由Workable接口扮演这个角色。</p><p><strong>Real(实际的工人)</strong></p><p>在示例程序中，由Worker类扮演这个角色。</p><p><strong>Proxy(代理人)</strong></p><p>在示例程序中，由WorkerProxy类扮演这个角色。</p><p><strong>Client(请求者)</strong></p><p>在示例程序中，由Main类扮演这个角色。</p><p>下面是抽象后，无关语言的类图：</p><p><img src="/images/blog_pic/Java 设计模式/21Proxy模式/4.jpg" alt="4.jpg"></p><h1 id="HTTP代理"><a href="#HTTP代理" class="headerlink" title="HTTP代理"></a>HTTP代理</h1><p>提到代理，我们很容易想到HTTP代理。HTTP代理是指位于HTTP服务器(Web服务器)和HTTP客户端(Web浏览器)之间的一组软件。我们可以把其看作是对Proxy模式的一种应用。其中，HTTP服务器是Real，HTTP代理是Proxy，Web浏览器则是Client。我们不妨以HTTP代理的缓存功能来说明一下。在我们通过Web浏览器访问Web页面时，并非每次都会真的去访问HTTP服务器，而是会先去获取HTTP代理缓存的页面，只有当没有缓存，缓存有更新或是缓存失效时才会真的去访问Web浏览器。</p><h1 id="代理的各种形式"><a href="#代理的各种形式" class="headerlink" title="代理的各种形式"></a>代理的各种形式</h1><p><strong>Virtual Proxy(虚拟代理)</strong></p><p>本文介绍的Proxy模式及给出的示例采用的就是这种方式，也是最基本的代理。只有当真正需要实例时才会生成。</p><p><strong>Remote Proxy(远程代理)</strong></p><p>当Real角色处于网络远端时，Remote Proxy可以让我们仿佛使用本地实例那样使用它们。Java的RMI(Remote Method Invocation，远程方法调用)就是Remote Proxy的应用。</p><p><strong>Access Proxy</strong></p><p>较之普通的Proxy，Access Proxy引入了访问权限。即我们可以只允许指定的用户调用指定的方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在《图解设计模式》一书中，Proxy模式被归入了第9部分&lt;a href=&quot;&quot;&gt;避免浪费&lt;/a&gt;。在GoF原书中，Proxy模式则被归入了&lt;a href=&quot;&quot;&gt;结构型设计模式&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Java 设计模式" scheme="http://yoursite.com/categories/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java 设计模式-20.Flyweight模式</title>
    <link href="http://yoursite.com/2018/09/04/Java%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-20Flyweight%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/09/04/Java 设计模式-20Flyweight模式/</id>
    <published>2018-09-04T09:41:49.000Z</published>
    <updated>2018-09-05T07:03:24.402Z</updated>
    
    <content type="html"><![CDATA[<p>在《图解设计模式》一书中，Flyweight模式被归入了第9部分<a href="">避免浪费</a>。在GoF原书中，Flyweight模式则被归入了<a href="">结构型设计模式</a>。</p><a id="more"></a><h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><p>flyweight这个单词的释义为”次最轻量级的拳击选手”。顾名思义，Flyweight模式的目的就是让对象”变轻”。更具体的来说，是让对象消耗的资源变少。其中最易于理解的消耗自然就是内存占用了。通俗来说，Flyweight模式就是在通过共享实例来尽量避免new出实例(少进行new的操作其实也相当于减少了时间的消耗，只是这没有内存减耗那么明显)。JVM所管理的”字符串常量池”遵循的其实也是类似的思想。</p><h1 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h1><p>下面来看一段应用了Flyweight模式的小例子。首先我们有0-9这10个数字的10张png图片：</p><p><img src="/images/blog_pic/Java 设计模式/20Flyweight模式/0.jpg" alt="0.jpg"></p><p>我们希望在输入一段数字后，程序能通过拼接这10张素材图片，从而生成一张新的图片。这里就用我的女神，苏联卫国战争时期的王牌女飞行员，被称为”斯大林格勒的白百合”的莉莉娅的生日为例吧</p><p>女神(↓↓)</p><p><img src="/images/blog_pic/Java 设计模式/20Flyweight模式/1.jpg" alt="1.jpg"></p><p>输入19210818后，程序最终会输出：</p><p><img src="/images/blog_pic/Java 设计模式/20Flyweight模式/2.jpg" alt="2.jpg"></p><p>在具体编写代码之前，我们可以先思考一下如何去做。最为简单的思路就是需要什么我们就去加载什么。如果我们将每一张原始的素材图片都视为一个对象的话，那么，对于19210818而言，毫无疑问，我们需要生成8个这样的图片对象。然后将这8个对象拼接为一个新的对象。显然，这是可行的做法。但这真的是最优的做法吗？</p><p>当然不是。</p><p>细心的朋友们应该都已经注意到了，虽然最终拼接需要8个对象，但实际用到的数字只有”19208”这5个，有3个数字是重复的。省掉这3个重复的数字的空间就是Flyweight模式要做的工作。</p><p>下面就赶快来看代码吧~首先是类图：</p><p><img src="/images/blog_pic/Java 设计模式/20Flyweight模式/3.jpg" alt="3.jpg"></p><p>本程序中的所有代码将被统一置于design20包下，结构如下：</p><p><img src="/images/blog_pic/Java 设计模式/20Flyweight模式/4.jpg" alt="4.jpg"></p><p>其中Main.java是测试代码，并没有出现在类图中。而img包下则是前文展示的那10张数字素材图片。</p><p>下面将逐个贴出每个类的源码。</p><p><strong>Img类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package design20;</span><br><span class="line"></span><br><span class="line">import java.awt.image.BufferedImage;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">import javax.imageio.ImageIO;</span><br><span class="line"></span><br><span class="line">import design19.view.View;</span><br><span class="line"></span><br><span class="line">public class Img &#123;</span><br><span class="line"></span><br><span class="line">    int number;</span><br><span class="line"></span><br><span class="line">    BufferedImage image;</span><br><span class="line"></span><br><span class="line">    Img(int number) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            this.image = ImageIO.read(View.class.getClassLoader().getResource(&quot;design20/img/&quot; + number + &quot;.png&quot;));</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ImgFactory类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package design20;</span><br><span class="line"></span><br><span class="line">import java.awt.image.BufferedImage;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class ImgFactory &#123;</span><br><span class="line"></span><br><span class="line">    private Map&lt;Integer, Img&gt; pool = new HashMap&lt;Integer, Img&gt;();</span><br><span class="line"></span><br><span class="line">    private static ImgFactory SINGLETON;</span><br><span class="line"></span><br><span class="line">    public static final int WIDTH = 88;</span><br><span class="line"></span><br><span class="line">    public static final int HEIGHT = 151;</span><br><span class="line"></span><br><span class="line">    private ImgFactory() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static ImgFactory getInstance() &#123;</span><br><span class="line">        if (null == ImgFactory.SINGLETON) ImgFactory.SINGLETON = new ImgFactory();</span><br><span class="line">        return ImgFactory.SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BufferedImage getNumImg(int number) &#123;</span><br><span class="line">        if (!this.pool.containsKey(number)) this.pool.put(number, new Img(number));</span><br><span class="line">        return this.pool.get(number).image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从逻辑的角度分析，生产Img的工厂是一个独立的个体，因此应该允许其生成实例而非使用类方法。同时工厂又只需要有一个，因此应用了<a href="">5.Singleton模式</a>。</p><p>对外界而言，是否应用Flyweight模式并没有什么不同。因为他们只是在调用getNumImg()方法获得自己想要的数字对应的图片。至于这个图片是新生成的还是复用之前已经存在的，他们并不在意。而在ImgFactory内部，我们创建了一个存储Img的”池”pool：调用方传入的数字千千万万，但池中最多只会存储0-9共计十张图片，这就从一定程度上节省了内存的开销。</p><p>虽然与Flyweight模式无关，本程序还在试图从另一个维度上节省开销。本文在创建Img的策略上采用了懒加载，初始时pool中是空的，只有当获取某个具体数字对应的图片时才会检查该图片是否已在pool中，如果在则返回，反之则创建后返回。这相当于将图片初始化的时间由pool的初始化推迟至调用时。不仅如此，我们还可以很容易想到，如果某个数字就是不会被调用，那么它永远不会被初始化，和一开始就全部初始化好相比，不仅节省了时间，还节省了空间。</p><p>当然，懒加载对时间的节省只是相对的。它能让程序启动时间大大减少。但正所谓出来混总是要还的，既然要使用，那么终究还是要初始化的，懒加载只是将初始化的实际延后了。不仅如此，这种延后还要付出更大的时间代价：如果最初就将pool中的图片全部初始化好，那么在getNumImg()时直接返回即可，因为我们确信此时pool中已经有了所有需要的图片了。反之，使用懒加载后，每次取图片时都需判断图片是否已经生成，反而相当于增加了时间开销。因此，是否使用懒加载，完全是要根据实际情况具体问题具体分析的。</p><p><strong>Main类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package design20;</span><br><span class="line"></span><br><span class="line">import java.awt.image.BufferedImage;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">import javax.imageio.ImageIO;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        Main.createImg(&quot;19210818&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void createImg(String str) throws IOException &#123;</span><br><span class="line">        int length = str.length();</span><br><span class="line">        BufferedImage bufferedImage = new BufferedImage(ImgFactory.WIDTH * length, ImgFactory.HEIGHT, BufferedImage.TYPE_INT_RGB);</span><br><span class="line">        for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">            int tempNum = Integer.parseInt(str.substring(i, i + 1));</span><br><span class="line">            BufferedImage tempImg = ImgFactory.getInstance().getNumImg(tempNum);</span><br><span class="line">            for (int y = 0; y &lt; tempImg.getHeight(); y++)</span><br><span class="line">                for (int x = 0; x &lt; tempImg.getWidth(); x++)</span><br><span class="line">                    bufferedImage.setRGB(x + i * ImgFactory.WIDTH, y, tempImg.getRGB(x, y));</span><br><span class="line">        &#125;</span><br><span class="line">        ImageIO.write(bufferedImage, &quot;jpg&quot;, new File(&quot;D:\\img.jpg&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行后，即可得到前文展示的结果。</p><h1 id="登场角色"><a href="#登场角色" class="headerlink" title="登场角色"></a>登场角色</h1><p>上面的示例程序介绍了Flyweight模式的Java实现，下面咱们试着跳出语言层面，抽象出Flyweight模式中登场的角色。</p><p><strong>Flyweight(轻量级类)</strong></p><p>即可共享的类，在示例程序中，由Img类扮演这个角色。</p><p><strong>FlyweightFactory(轻量级类工厂)</strong></p><p>即控制Flyweight共享情况的工厂。在示例程序中，由ImgFactory类扮演这个角色。</p><p>下面是抽象后，无关语言的类图：</p><p><img src="/images/blog_pic/Java 设计模式/20Flyweight模式/5.jpg" alt="5.jpg"></p><h1 id="Intrinsic与Extrinsic"><a href="#Intrinsic与Extrinsic" class="headerlink" title="Intrinsic与Extrinsic"></a>Intrinsic与Extrinsic</h1><p>Flyweight模式的核心在于共享实例。这里隐含着一个前提，那就是必须先判断实例能否被共享(因为共享实例的改变，会导致所有用到它的地方所得到的实例均会发生变化)，只有能被共享的实例，才有资格进一步考虑到底要不要共享。在编程领域，可以被共享的信息被称为Intrinsic信息，Intrinsic意思是”本质的，固有的”，顾名思义，这是指那些不会因调用环境不同而改变的信息；相对的，不能被共享的信息被称为Extrinsic信息，Extrinsic的含义是”外在的，非本质的”。</p><p>依这种思路来分析，类字段均应是Intrinsic信息，被定义为单例的实例中存储的也均应是Intrinsic信息。</p><p>在本示例中，每个数字对应的图片是唯一且不可变的，属于Intrinsic信息，当我们输入数字”11”时，这两个1对应的都是那同一张代表1的图片，因此这些图片实例可以成为Flyweight角色被共享。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在《图解设计模式》一书中，Flyweight模式被归入了第9部分&lt;a href=&quot;&quot;&gt;避免浪费&lt;/a&gt;。在GoF原书中，Flyweight模式则被归入了&lt;a href=&quot;&quot;&gt;结构型设计模式&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Java 设计模式" scheme="http://yoursite.com/categories/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java 设计模式-19.State模式</title>
    <link href="http://yoursite.com/2018/08/31/Java%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-19State%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/08/31/Java 设计模式-19State模式/</id>
    <published>2018-08-31T12:25:49.000Z</published>
    <updated>2018-09-03T10:09:20.982Z</updated>
    
    <content type="html"><![CDATA[<p>在《图解设计模式》一书中，State模式被归入了第8部分<a href="">管理状态</a>。在GoF原书中，State模式则被归入了<a href="">行为型设计模式</a>。</p><a id="more"></a><h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><p>在面向对象编程领域，有这样一句话：一切都是对象，对象就是一切。这话虽说有些绝对了，但也从一个侧面说明对象在面向对象编程领域的普遍性。在我们通常的认知中，对象指的是某个具体的事物，例如一张桌子，一把椅子。但是对象其实还可以表示一些抽象的事物，例如本文要提到的”状态”。</p><p>漫画《七龙珠》的主人公是卡卡罗特(孙悟空)。将卡卡罗特看作一个对象是比较好理解的。但我们同样也可以将卡卡罗特所处于的状态视为对象。例如我们可以将普通状态视为一个类，超级赛亚人状态视为另一个类。这样再描述卡卡罗特所处于的状态时，就可以用具体状态的实例来表示。</p><p>普通状态(左)与超级赛亚人状态(右)下的卡卡罗特：</p><p><img src="/images/blog_pic/Java 设计模式/19State模式/0.jpg" alt="0.jpg"></p><p>在编程领域，由此演化而来的设计模式就是State模式。以类来表示状态后，我们就能通过切换表示状态的类来方便的改变对象所处于的状态。同时，当需要增加新的状态时(例如为卡卡罗特再增加一个巨猿状态)，条理也会更为清晰。</p><h1 id="示例需求描述"><a href="#示例需求描述" class="headerlink" title="示例需求描述"></a>示例需求描述</h1><p>狂野女猎手-奈德丽(Nidalee)是一位出自游戏英雄联盟(LOL)的女英雄，在描述具体的需求之前，先展示几张她的皮肤原画吧~</p><p><strong>默认</strong></p><p><img src="/images/blog_pic/Java 设计模式/19State模式/1.jpg" alt="1.jpg"></p><hr><p><strong>雪装</strong></p><p><img src="/images/blog_pic/Java 设计模式/19State模式/2.jpg" alt="2.jpg"></p><hr><p><strong>丛林猎豹</strong></p><p><img src="/images/blog_pic/Java 设计模式/19State模式/3.jpg" alt="3.jpg"></p><hr><p><strong>法国女仆</strong></p><p><img src="/images/blog_pic/Java 设计模式/19State模式/4.jpg" alt="4.jpg"></p><hr><p><strong>艳后</strong></p><p><img src="/images/blog_pic/Java 设计模式/19State模式/5.jpg" alt="5.jpg"></p><hr><p><strong>魅惑女巫(2011年万圣节)</strong></p><p><img src="/images/blog_pic/Java 设计模式/19State模式/6.jpg" alt="6.jpg"></p><hr><p><strong>枭姬 孙尚香</strong></p><p><img src="/images/blog_pic/Java 设计模式/19State模式/7.jpg" alt="7.jpg"></p><hr><p><strong>勇者</strong></p><p><img src="/images/blog_pic/Java 设计模式/19State模式/8.jpg" alt="8.jpg"></p><p>好漂亮啊有没有，尤其是枭姬，英姿勃发。不过我们之所以介绍得这么详细并不完全是因为她生得俊俏(你够了)，而是因为她是具有双形态的英雄。下面就以枭姬这个皮肤的3D模型来展示一下：</p><p><strong>人形态</strong></p><p><img src="/images/blog_pic/Java 设计模式/19State模式/9.jpg" alt="9.jpg"></p><hr><p><strong>豹形态</strong></p><p><img src="/images/blog_pic/Java 设计模式/19State模式/10.jpg" alt="10.jpg"></p><p>奈德丽的R技能为形态切换。在各自的形态下，她有着独立的两套QWE技能(传说中拥有7个主动技能的女人)。本文的示例程序将应用State模式模拟奈德丽的技能释放。</p><h1 id="示例需求分析"><a href="#示例需求分析" class="headerlink" title="示例需求分析"></a>示例需求分析</h1><p>不知不觉中GoF的23种设计模式也快介绍到尾声了(19/23)，之前给出的设计模式的示例程序大多很简单，也很粗糙，其目的仅仅是为了说明某个设计模式的核心思想。本文将打破这一点(毕竟总写一些实验性质的小demo着实无聊)，会写一个相对完整的产品出来。关于奈德丽具体的英雄参数可参见<a href="http://cha.17173.com/lol/heros/details/76.html" target="_blank" rel="noopener">奈德丽数据介绍</a>。本程序会以奈德丽的满级(18级)属性为基础，再进行适当的提升(因为人物是会穿装备的)。</p><p>GUI设计技术为Java AWT，程序启动后初始状态如下：</p><p><img src="/images/blog_pic/Java 设计模式/19State模式/11.jpg" alt="11.jpg"></p><p>这也是程序的主体面板界面。它的区域介绍如下：</p><p><img src="/images/blog_pic/Java 设计模式/19State模式/12.jpg" alt="12.jpg"></p><p>默认形态为人形态。此时：</p><ul><li><strong>区域一：</strong>人形态是有MP的，因此血条与蓝条均会展示，初始时默认血蓝全满。</li><li><strong>区域二：</strong>人形态下的立绘采用我最喜欢的枭姬皮肤(啦啦啦)。</li><li><strong>区域三：</strong>此时展示的是人形态下的技能图标。</li></ul><p>当按下键盘上的R键后，即被认为释放了一次R技能(QWE技能同理)，此时奈德丽会从人形态切换为豹形态：</p><p><img src="/images/blog_pic/Java 设计模式/19State模式/13.jpg" alt="13.jpg"></p><p>切换后：</p><ul><li><strong>区域一：</strong>因为奈德丽在豹形态下是没有MP的，因此不绘制蓝条。</li><li><strong>区域二：</strong>立绘切换为枭姬皮肤的豹形态(没找到太合适的图，比较遗憾)。</li><li><strong>区域三：</strong>技能图标切换为豹形态。</li></ul><p>关于技能图标，有以下几点需要说明：</p><p>第一，我们可以注意到上图中豹形态下的R技能”黑了一块”。这表示R技能在冷却。只有当它冷却完成后，我们才能再次释放，以切换为人形态。因为奈德丽的7个技能都是主动技能，因此其他技能的冷却机制同理。</p><p>当R技能冷却完成后：</p><p><img src="/images/blog_pic/Java 设计模式/19State模式/14.jpg" alt="14.jpg"></p><p>我们可以注意到，相较于人形态，奈德丽的R技能的图标并没有改变。这也是我们要说的第二点，QWE技能是独立的，而R技能只有一个(因此我们才说奈德丽有7个技能，而非8个)。</p><p>QWE独立还意味着，QWE技能的冷却时间计算也是独立的，例如我们可以在人形态下快速释放QWE(俗称脸滚键盘)，使他们均进入冷却状态：</p><p><img src="/images/blog_pic/Java 设计模式/19State模式/15.jpg" alt="15.jpg"></p><p>此时如果我们再按下R切换为豹形态，我们会发现豹形态下的QWE又是可释放的了，不过R技能因为人豹形态共用一个，因此进入了冷却状态。此时我们可以在豹形态下再QWE脸滚键盘一波：</p><p><img src="/images/blog_pic/Java 设计模式/19State模式/16.jpg" alt="16.jpg"></p><p>当R技能冷却完成后，我们又可以切换回人形态，如果我们进行如上人-豹-人的操作的速度足够快，当我们再切回人形态时，情况可能是这样的：</p><p><img src="/images/blog_pic/Java 设计模式/19State模式/17.jpg" alt="17.jpg"></p><p>R技能又开始接着计算冷却了，这个前文已经介绍过原因，并没有什么。但是除了冷却时间较短的Q技能之外，人形态下的WE技能并没有冷却完。这个效果当我们在R技能冷却好再次切到豹形态时也是同理的(只不过豹形态下技能CD普遍较短，不太容易看出来)。之所以会这样，是因为QWE技能独立同样意味着技能CD独立。举例来说，如果人形态的Q技能的CD为6秒，那么无论如何，它都只能6秒后才能再次释放，我们切换为豹形态会让我们看不到人形态Q技能的CD情况，但也仅仅只是看不到而已，它依然在不停的倒数自身的冷却时间。</p><p>由上文的技能CD介绍还能看出的是，人形态下释放QWE技能导致MP减少(蓝条变短)。而豹形态的技能则是无消耗的。R技能作为形态切换的桥梁也是无消耗的。这意味着，豹形态技能的释放只受CD的影响，而人形态在此之上，还需剩余的蓝量大于技能的消耗。</p><p>蓝条可以通过技能释放来减少。为了模拟血条减少，我们规定当按下键盘上的X键后，会扣一定数值的血量：</p><p><img src="/images/blog_pic/Java 设计模式/19State模式/18.jpg" alt="18.jpg"></p><p>虽然用静态的图片无法表现，不过HP与MP均会按一定速率自动回复。</p><p>按照一般游戏的设定，蓝条始终都会是蓝色的，而血条则会在减少的过程中逐渐由绿转黄，再由黄转红(所谓的满血，黄血，红血)。本程序也是如此。上文已经展示了血量比较健康时血条的颜色，下面我们来看一张半血时的：</p><p><img src="/images/blog_pic/Java 设计模式/19State模式/19.jpg" alt="19.jpg"></p><p>然后是残血时的：</p><p><img src="/images/blog_pic/Java 设计模式/19State模式/20.jpg" alt="20.jpg"></p><p>奈德丽人形态下的E技能会为指向的英雄回复一定的HP，本程序默认会对自身释放，因此人形态释放E技能后会回复一定数值的HP(按照设定，回复量在一个范围之间，HP越低回复量越多)。除此之外，除了R技能会导致形态切换，其他技能(人形态的QW，豹形态的QWE)均为对敌方造成伤害，在本程序中不会有所体现。</p><p>当HP降到0时，英雄会死亡：</p><p><img src="/images/blog_pic/Java 设计模式/19State模式/21.jpg" alt="21.jpg"></p><p><img src="/images/blog_pic/Java 设计模式/19State模式/22.jpg" alt="22.jpg"></p><p>形态会被定格在死亡的那一刻。届时将不再接受任何键盘输入，也不会提供初始化的方法，只能关掉重来。此时：</p><ul><li><strong>区域一：</strong>血条当然是清空了。而人形态下的蓝条将定格在死亡的时刻，不再变动。</li><li><strong>区域二：</strong>立绘将被虚化，同时添加表示阵亡的文字。</li><li><strong>区域三：</strong>技能图标将被虚化，同时清除可能会存在的尚未完成的CD遮挡。</li></ul><p>呼~需求终于大致描述完了。累死我了。</p><p>作为一名技术，我们很少会关注产品经理的工作，不过即便是这么小的一个需求，我在整理并力求没有歧义的描述清楚(而且我并不敢说真的就描述清楚了)时，也费了很大的力气。这说明产品经理确实在日常的工作中为我们屏蔽了很多技术不愿意关注的点。之所以会有矛盾冲突，我想大多是因为需求本身就充斥着更多的冲突，没有产品经理，技术将更难以工作。</p><h1 id="伪代码分析"><a href="#伪代码分析" class="headerlink" title="伪代码分析"></a>伪代码分析</h1><p>需求描述完了，下面就来思考一下怎么写。</p><p>假设我们只考虑Q技能的释放，那么最容易想到的写法是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">类 奈德丽 &#123;</span><br><span class="line"></span><br><span class="line">    方法 释放Q &#123;</span><br><span class="line">        if (当前状态为人形态) &#123;</span><br><span class="line">    人形态下释放Q</span><br><span class="line">&#125; else if (当前状态为豹形态) &#123;</span><br><span class="line">    豹形态下释放Q</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    异常</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做当然没什么毛病，但是问题在于每当我们要做什么操作时都需要先判断一下状态。随着状态的增多，代码逻辑的复杂，这种判断的成本将越来越高，同时也越发的不易于维护。</p><p>如果使用State模式，我们就可以将形态抽象为类:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">类 人形态 &#123;</span><br><span class="line"></span><br><span class="line">    方法 释放Q &#123;</span><br><span class="line">        人形态下释放Q</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">类 豹形态 &#123;</span><br><span class="line"></span><br><span class="line">    方法 释放Q &#123;</span><br><span class="line">        豹形态下释放Q</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时奈德丽类就可以这样写了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">类 奈德丽 &#123;</span><br><span class="line"></span><br><span class="line">    字段 当前状态</span><br><span class="line"></span><br><span class="line">    方法 释放Q &#123;</span><br><span class="line">        当前状态.方法 释放Q</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，代码逻辑变得清晰了许多，也更利于维护。</p><h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><p>首先是类图：</p><p><img src="/images/blog_pic/Java 设计模式/19State模式/23.jpg" alt="23.jpg"></p><p>因为希望能做出一个相对完整的产品，所以添加了很多无关State模式的代码。因此较之真实的程序，类图将只描述与State模式相关的那一部分。</p><p>本程序中的所有代码将被统一置于design19包下，结构如下：</p><p><img src="/images/blog_pic/Java 设计模式/19State模式/24.jpg" alt="24.jpg"></p><p>下面将逐个贴出每个类的源码。</p><p>首先要说明的是，既然较之此前的设计模式(我想此后的其实也一样)，我费了更大的力气写需求分析。那么我在介绍示例代码时，也打算说得详细一些：并不仅仅是说State模式本身，而是把用到的其他的模式与想法也都详细介绍一下，算是我个人这段时间学习的总结。</p><p>程序是以简化版的MVC模式设计的(即只有M与V，没有C)。下面先来介绍M。</p><p><strong>Hero类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">package design19.model;</span><br><span class="line"></span><br><span class="line">public abstract class Hero &#123;</span><br><span class="line"></span><br><span class="line">    protected boolean ifDeath;</span><br><span class="line"></span><br><span class="line">    protected int maxHealth = 2 * (370 + 90 * 17);</span><br><span class="line"></span><br><span class="line">    protected int healthRegen = (int)(3 * (1 + 0.12 * 17));</span><br><span class="line"></span><br><span class="line">    protected int health = maxHealth;</span><br><span class="line"></span><br><span class="line">    protected int ap;</span><br><span class="line"></span><br><span class="line">    public abstract void useQ();</span><br><span class="line"></span><br><span class="line">    public abstract void useW();</span><br><span class="line"></span><br><span class="line">    public abstract void useE();</span><br><span class="line"></span><br><span class="line">    public abstract void useR();</span><br><span class="line"></span><br><span class="line">    public abstract boolean ifHaveMana();</span><br><span class="line"></span><br><span class="line">    protected abstract double manaRate();</span><br><span class="line"></span><br><span class="line">    public abstract String getImgKeyWord();</span><br><span class="line"></span><br><span class="line">    public abstract double remainQ();</span><br><span class="line"></span><br><span class="line">    public abstract double remainW();</span><br><span class="line"></span><br><span class="line">    public abstract double remainE();</span><br><span class="line"></span><br><span class="line">    public abstract double remainR();</span><br><span class="line"></span><br><span class="line">    Hero() &#123;</span><br><span class="line">        // 回血</span><br><span class="line">        new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                while (true) &#123;</span><br><span class="line">                    if (Hero.this.ifDeath) &#123;</span><br><span class="line">                        Hero.this.health = 0;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        int tempHealth = Hero.this.health + Hero.this.healthRegen;</span><br><span class="line">                        Hero.this.health = tempHealth &gt; Hero.this.maxHealth ? Hero.this.maxHealth : tempHealth;</span><br><span class="line">                        Thread.sleep(1000);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isDeath() &#123;</span><br><span class="line">        return ifDeath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void damage(int value) &#123;</span><br><span class="line">        int tempHealth = this.health - value;</span><br><span class="line">        if (tempHealth &lt;= 0) &#123;</span><br><span class="line">            this.ifDeath = true;</span><br><span class="line">            this.health = 0;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        this.health = tempHealth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double getHealthRate() &#123;</span><br><span class="line">        return 1.0 * this.health / this.maxHealth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double getManaRate() &#123;</span><br><span class="line">        if (!this.ifHaveMana()) throw new UnsupportedOperationException();</span><br><span class="line">        return this.manaRate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    long remainTime(Skill skill) &#123;</span><br><span class="line">        long pass = System.currentTimeMillis() - skill.last;</span><br><span class="line">        return (pass - skill.cd) &gt;= 0 ? 0 : (skill.cd - pass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boolean check(String mark) &#123;</span><br><span class="line">        if (this.ifDeath) return false;</span><br><span class="line">        if (&quot;Q&quot;.equals(mark))</span><br><span class="line">            if (this.remainQ() &gt; 0) return false;</span><br><span class="line">        if (&quot;W&quot;.equals(mark))</span><br><span class="line">            if (this.remainW() &gt; 0) return false;</span><br><span class="line">        if (&quot;E&quot;.equals(mark))</span><br><span class="line">            if (this.remainE() &gt; 0) return false;</span><br><span class="line">        if (&quot;R&quot;.equals(mark))</span><br><span class="line">            if (this.remainR() &gt; 0) return false;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从逻辑上来说，Hero类与后文要介绍的Skill类是model模块中外部(本程序中是View)能感知到的仅有的两个类。因为英雄联盟有很多位英雄，对于外部调用者而言，针对不同英雄写不同的代码是很不现实的，相反，正如其他MVC中的V那样，V需要的是M能提供一套通用的API。具体到本示例，就是”英雄释放技能，造成影响”。这都是很抽象的东西，换句话说，如果我们将奈德丽换为另一位英雄，例如寒冰射手艾希，View层不应做任何或只应做极少的修改。</p><p>因为本示例的逻辑相对简单，因此对外暴露的API仅仅只有Hero类一个。Skill类依逻辑可以暴露API，只是没必要。而model中的其他类则是不准暴露。这点务必要理解透彻才可以。</p><p>为了不使得程序看着过于臃肿，除非是需要对外提供的API，model内部各个类之间互相使用字段时尽量都没有写get-set方法，而仅仅只是通过访问权限来屏蔽外界，这在比较严谨的场合(例如实际工作时的代码)往往是不可以的。</p><p>之所以将Hero声明为抽象类而非接口，比较直观的解释自然就是我们希望在其中添加一些属于实例的字段及方法，以及我们确信在本程序中继承Hero的Nidalee类不会有其他父类。不过更本质的原因在于，这种继承关系遵循合成聚合复用原则(奈德丽是一位英雄，即ISA)及里氏替换原则，这才是原因所在，最开始说的那个所谓的”直观的解释”，比起原因，更像是由原因导致的现象。</p><p>作为LOL这种竞技游戏通常都会有的属性，HP与MP。我只将HP及HP相关的属性作为字段加入到了Hero类中。其原因就在于所有的英雄都有HP，但并不是所有的英雄都会有MP。比如就会有德玛西亚之力盖伦，不祥之刃卡特琳娜这种完全没有MP的英雄，或是盲僧李青，蛮族之王泰达米尔这种拥有能量或是怒气等与MP性质类似的东西的英雄。再或者是甚至像本文介绍的拥有双形态的奈德丽，某个形态下像大多英雄那样拥有MP，某个形态下又像盖伦那样无消耗。基于这个考虑，我将MP沉到了再下一个层级：如果这个英雄有MP，那么就在自己内部添加。而Hero这一层尽量只添加所有英雄都会有的字段。这也是抽象的本质思路所在：抽取相同的部分以形成更高的层级。因为相同的原因，就很容易理解Hero类中剩下的两个字段了：表示是否死亡的ifDeath，以及表示魔法能力的ap值。作为一个英雄，其实还会有更多复杂的属性，例如ad，护甲，魔抗，移速等等。本示例只使用了少量需要的部分。</p><p>除了字段之外，我们还将其他对HP的操作都尽量提到了Hero这一层，因为这是所有英雄通用的。我在Hero的构造函数中起了一个线程模拟回血。还提供了damage()方法供外部调用模拟扣血。</p><p>use Q/w/E/R方法表示外界按下了一次QWER键。而remain Q/w/E/R方法则返回QWER技能技能CD恢复的百分比。很显然，该值的取值范围为[0,1]。当该值等于0时说明技能没有进入冷却，可以释放(当然仅仅只是冷却好了，人形态下还要蓝够才可以)；而等于1则说明技能刚进入冷却。</p><p>ifHaveMana()这个方法会判断英雄是否有蓝条(本程序在设计时就不考虑怒气能量等奇怪的东西了)。依上文所说的MP下沉的思路，这个方法放在Hero类里虽然有点不太美观，但终归是还能接受。而getManaRate()方法就有些诡异了，它返回的是当前MP值占MP最大值的比例，是为了显示蓝条长度用的。由代码不难看出，当外部调用该方法后，会先再判断一次ifHaveMana()，如果返回false，即英雄没有MP，则抛出异常。反之才会调用子类本身计算比例的manaRate()方法，这里运用了Template Method模式。不过这不是重点。我想说的是，对于没有MP的英雄而言，这个方法是根本不该被调用的，这种提供了功能却在内部抛出异常的做法相当于甩锅给调用方，显然是很不优雅的。更有问题的是，明明将MP下沉到了更下一层，却还是在Hero这一层出现了这么具体的计算MP相关值的方法，看着着实扎眼。说了这么多，之所以千不该万不是还是把代码写成了这样，是因为我们在写代码时，比起面面俱到，更多时候是在两害相权取其轻。因为我们要向外界暴露一个通用的Hero而非具体的英雄，那么在外界需要蓝条时，只能做一个这样折中的方案。或是将程序写得更复杂：例如抽象出一个能统合MP，怒气，能量，甚至是无的东西，代表释放技能的代价。不过本程序显然没必要那么复杂就是了。</p><p><strong>Skill类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package design19.model;</span><br><span class="line"></span><br><span class="line">public class Skill &#123;</span><br><span class="line"></span><br><span class="line">    long cd;</span><br><span class="line"></span><br><span class="line">    long last;</span><br><span class="line"></span><br><span class="line">    int cost;</span><br><span class="line"></span><br><span class="line">    Skill(long cd, int cost) &#123;</span><br><span class="line">        this.cd = cd;</span><br><span class="line">        this.cost = cost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相对而言，Skill类就要简单得多了。也没有提供对外的API。</p><p><strong>Nidalee类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">package design19.model;</span><br><span class="line"></span><br><span class="line">public class Nidalee extends Hero &#123;</span><br><span class="line"></span><br><span class="line">    Skill skillR = new Skill(4000L, 0);</span><br><span class="line"></span><br><span class="line">    NidaleeState state;</span><br><span class="line"></span><br><span class="line">    public Nidalee() &#123;</span><br><span class="line">        NidaleeState humanState = new HumanState(this);</span><br><span class="line">        NidaleeState leopardState = new LeopardState(this);</span><br><span class="line">        humanState.otherState = leopardState;</span><br><span class="line">        leopardState.otherState = humanState;</span><br><span class="line">        this.state = humanState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void useQ() &#123;</span><br><span class="line">        this.state.useQ();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void useW() &#123;</span><br><span class="line">        this.state.useW();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void useE() &#123;</span><br><span class="line">        this.state.useE();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void useR() &#123;</span><br><span class="line">        this.state.useR();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean ifHaveMana() &#123;</span><br><span class="line">        return this.state.maxMana &gt; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public double manaRate() &#123;</span><br><span class="line">        return 1.0 * this.state.mana / this.state.maxMana;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getImgKeyWord() &#123;</span><br><span class="line">        return this.state.type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public double remainQ() &#123;</span><br><span class="line">        if (this.ifDeath) return 0.0;</span><br><span class="line">        return 1.0 * this.remainTime(this.state.skillQ) / this.state.skillQ.cd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public double remainW() &#123;</span><br><span class="line">        if (this.ifDeath) return 0.0;</span><br><span class="line">        return 1.0 * this.remainTime(this.state.skillW) / this.state.skillW.cd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public double remainE() &#123;</span><br><span class="line">        if (this.ifDeath) return 0.0;</span><br><span class="line">        return 1.0 * this.remainTime(this.state.skillE) / this.state.skillE.cd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public double remainR() &#123;</span><br><span class="line">        if (this.ifDeath) return 0.0;</span><br><span class="line">        return 1.0 * this.remainTime(this.skillR) / this.skillR.cd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>state字段表示奈德丽当前处于的状态。在构造函数中，我们将默认的状态设置为人形态。然后我们又声明了一个豹形态的对象。将人形态与豹形态互相绑定。这意味着，在按下R技能，需要进行形态切换时，Nidalee类是不需要做任何操作的，切换操作将由表示形态的类完成：人形态时变为豹形态，豹形态时变为人形态。进而，Nidalee类在使用state时(我们可以看到，Nidalee类中绝大多数的操作最终实际都是由state完成的)，并不关心当前到底处于什么形态，它都会当做只有一个形态那样去使用。</p><p>本程序中，Nidalee类中只会存储一个表示形态的字段。形态的切换由形态本身完成。它并不能统计出当前一共有多少种形态 – 这当然是State模式的设计方式之一。这样的好处在于既然Nidalee类将状态相关的处理都委托给各State类去做，那么”状态切换”显然也是相关处理之一。那么在它被触发的地方直接完成显然是最简洁干脆的做法 – 正如本文所做的那样。不过，这样做的问题在于，State之间需要彼此感知，因为唯有这样，一个State才能知道要切换为谁。这其实并不是十分符合逻辑：因为各State类之间其实是兄弟关系，并没有义务互相感知。从这个思路来想，负责切换的工作应该交给再上一层，也就是这些State类的宿主Nidalee类。此时，Nidalee类就需要记录自己保管的所有State类，以及它们之间的切换逻辑。</p><p>奈德丽共有7个不同的技能。我们将人形态的QWE与豹形态的QWE均放在了对应形态的类中，因为我们认为这些技能是属于那个形态特有的。而将人豹共用的R技能提到了Nidalee类中。同理，我们依然没有将MP放到Nidalee类中，而是将它继续下放：因为只有人形态下才有MP，豹形态下没有。</p><p><strong>NidaleeState类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">package design19.model;</span><br><span class="line"></span><br><span class="line">public abstract class NidaleeState &#123;</span><br><span class="line"></span><br><span class="line">    protected Nidalee nidalee;</span><br><span class="line"></span><br><span class="line">    protected String type;</span><br><span class="line"></span><br><span class="line">    protected NidaleeState otherState;</span><br><span class="line"></span><br><span class="line">    protected int maxMana;</span><br><span class="line"></span><br><span class="line">    protected int manaRegen;</span><br><span class="line"></span><br><span class="line">    protected int mana;</span><br><span class="line"></span><br><span class="line">    protected Skill skillQ;</span><br><span class="line"></span><br><span class="line">    protected Skill skillW;</span><br><span class="line"></span><br><span class="line">    protected Skill skillE;</span><br><span class="line"></span><br><span class="line">    protected abstract void handleQ();</span><br><span class="line"></span><br><span class="line">    protected abstract void handleW();</span><br><span class="line"></span><br><span class="line">    protected abstract void handleE();</span><br><span class="line"></span><br><span class="line">    NidaleeState(Nidalee nidalee) &#123;</span><br><span class="line">        this.nidalee = nidalee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void useQ() &#123;</span><br><span class="line">        if (!this.nidalee.check(&quot;Q&quot;)) return;</span><br><span class="line">        if (this.mana &lt; this.skillQ.cost) return;</span><br><span class="line">        this.skillQ.last = System.currentTimeMillis();</span><br><span class="line">        this.handleQ();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void useW() &#123;</span><br><span class="line">        if (!this.nidalee.check(&quot;W&quot;)) return;</span><br><span class="line">        if (this.mana &lt; this.skillW.cost) return;</span><br><span class="line">        this.skillW.last = System.currentTimeMillis();</span><br><span class="line">        this.handleW();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void useE() &#123;</span><br><span class="line">        if (!this.nidalee.check(&quot;E&quot;)) return;</span><br><span class="line">        if (this.mana &lt; this.skillE.cost) return;</span><br><span class="line">        this.skillE.last = System.currentTimeMillis();</span><br><span class="line">        this.handleE();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void useR() &#123;</span><br><span class="line">        if (!this.nidalee.check(&quot;R&quot;)) return;</span><br><span class="line">        this.nidalee.skillR.last = System.currentTimeMillis();</span><br><span class="line">        this.nidalee.state = this.otherState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NidaleeState类是奈德丽这个英雄特有的，由其双状态提取共性后抽象出的类。正如V需要一个相对通用的Hero那样。Nidalee类也需要一个通用的表示状态的类。对于更上面的层级而言(Hero，View)，奈德丽拥有双形态是其自身内部的事，它们并不会，也不需要感知得到。</p><p>另外一个有趣的点是，Hero作为直接暴露在外的类，会提供很多与外部逻辑紧密相关的功能。例如Hero中的ifHaveMana()，而Nidalee作为它的子类也必须实现。但是作为最终工作者的NidaleeState中却没有这个方法 – Nidalee的ifHaveMana()实际是通过判断当前状态的maxMana来实现的。关于这一点我想说的是，外部需求是在不停扩充的，需求也将千变万化。而不论Hero也好，Nidalee也罢，其实都是model模块内部的类。这会导致model与外部需求耦合得过于紧密，不利于代码的维护。而通常的做法是，我们会在M与V之间再加入一个DAO，也就是数据传输层。因为本质上来说，MVC其实就是”V向M要数据”以及”V触发M修改自身的数据”(很少会出现”M主动向V推送数据”的情况，因为下层一般无需对上层负责，毕竟M都是被动的，笑)。而DAO则是M与V之间的桥梁。当引入DAO后，这部分与V耦合得过于紧密的代码就可以自M转移到DAO中了。从更大的视角来看，这个所谓的DAO，实际上是MVC中C所承载的功能的一部分。所以说，出来混终归是要还的。本示例程序节省了C这一层，终究还是给程序引入了风险(话是这么说没错啦，小程序其实问题不大。还是要具体问题具体分析)。</p><p><strong>HumanState类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">package design19.model;</span><br><span class="line"></span><br><span class="line">public class HumanState extends NidaleeState &#123;</span><br><span class="line"></span><br><span class="line">    HumanState(Nidalee nidalee) &#123;</span><br><span class="line">        super(nidalee);</span><br><span class="line">        this.type = &quot;human&quot;;</span><br><span class="line">        this.maxMana = 4 * (220 + 45 * 17);</span><br><span class="line">        this.manaRegen = (int)(5 * (0.9 + 0.06 * 17));</span><br><span class="line">        this.mana = maxMana;</span><br><span class="line">        this.skillQ = new Skill(6000L, 90);</span><br><span class="line">        this.skillW = new Skill(18000L, 60);</span><br><span class="line">        this.skillE = new Skill(10000L, 120);</span><br><span class="line">        // 回蓝</span><br><span class="line">        new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                while (true) &#123;</span><br><span class="line">                    if (HumanState.this.nidalee.ifDeath) break;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        int tempMana = HumanState.this.mana + HumanState.this.manaRegen;</span><br><span class="line">                        HumanState.this.mana = tempMana &gt; HumanState.this.maxMana ? HumanState.this.maxMana : tempMana;</span><br><span class="line">                        Thread.sleep(1000);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void handleQ() &#123;</span><br><span class="line">        this.modMana(this.skillQ.cost);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void handleW() &#123;</span><br><span class="line">        this.modMana(this.skillW.cost);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void handleE() &#123;</span><br><span class="line">        this.modMana(this.skillE.cost);</span><br><span class="line">        double loseHealthRate = 1.0 - this.nidalee.getHealthRate();</span><br><span class="line">        double addHealthBase = 115 + (230 - 115) * loseHealthRate;</span><br><span class="line">        double addHealthAP = this.nidalee.ap * (0.325 + (0.65 - 0.325) * loseHealthRate);</span><br><span class="line">        int tempHealth = this.nidalee.health + (int)(addHealthBase + addHealthAP);</span><br><span class="line">        this.nidalee.health = tempHealth &gt;= this.nidalee.maxHealth ? this.nidalee.maxHealth : tempHealth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void modMana(int cost) &#123;</span><br><span class="line">        if (this.mana &lt; cost) return;</span><br><span class="line">        int tempMana = this.mana - cost;</span><br><span class="line">        this.mana = tempMana &gt; 0 ? tempMana : 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>奈德丽的人形态。我们可以看到，MP相关的操作都在这个类中。</p><p><strong>LeopardState类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package design19.model;</span><br><span class="line"></span><br><span class="line">public class LeopardState extends NidaleeState &#123;</span><br><span class="line"></span><br><span class="line">    LeopardState(Nidalee nidalee) &#123;</span><br><span class="line">        super(nidalee);</span><br><span class="line">        this.type = &quot;leopard&quot;;</span><br><span class="line">        this.skillQ = new Skill(5000L, 0);</span><br><span class="line">        this.skillW = new Skill(3500L, 0);</span><br><span class="line">        this.skillE = new Skill(6000L, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void handleQ() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void handleW() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void handleE() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>handle Q/W/E方法都是空的，这意味着这些技能不会产生什么效果。实际中当然不会这样，因此这样写程序其实并没有问题。</p><p>介绍完了HumanState与LeopardState，我想说的是，很多时候，表征状态的类通常都是单例的，因为状态本就是一个相对抽象的东西。只不过，在本程序中，状态还和很多特有的属性(例如MP，技能恢复CD)挂钩，因此不能声明为单例。</p><p><strong>View类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line">package design19.view;</span><br><span class="line"></span><br><span class="line">import java.awt.Color;</span><br><span class="line">import java.awt.Frame;</span><br><span class="line">import java.awt.Graphics;</span><br><span class="line">import java.awt.Image;</span><br><span class="line">import java.awt.event.KeyAdapter;</span><br><span class="line">import java.awt.event.KeyEvent;</span><br><span class="line">import java.awt.event.WindowAdapter;</span><br><span class="line">import java.awt.event.WindowEvent;</span><br><span class="line">import java.awt.image.BufferedImage;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">import javax.imageio.ImageIO;</span><br><span class="line"></span><br><span class="line">import design19.model.Hero;</span><br><span class="line">import design19.model.Nidalee;</span><br><span class="line"></span><br><span class="line">public class View extends Frame &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">    private Hero nidalee = new Nidalee();</span><br><span class="line"></span><br><span class="line">    public void launchFrame() &#123;</span><br><span class="line">        super.setLocation(500, 200);</span><br><span class="line">        super.setSize(330, 713);</span><br><span class="line">        new Thread(this.new RepaintRunnable()).start();</span><br><span class="line">        super.addWindowListener(</span><br><span class="line">            new WindowAdapter() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void windowClosing(WindowEvent e) &#123;</span><br><span class="line">                    System.exit(0);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">        super.addKeyListener(</span><br><span class="line">            new KeyAdapter() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void keyReleased(KeyEvent e) &#123;</span><br><span class="line">                    switch(e.getKeyCode()) &#123;</span><br><span class="line">                    case KeyEvent.VK_Q:</span><br><span class="line">                        View.this.nidalee.useQ();</span><br><span class="line">                        break;</span><br><span class="line">                    case KeyEvent.VK_W:</span><br><span class="line">                        View.this.nidalee.useW();</span><br><span class="line">                        break;</span><br><span class="line">                    case KeyEvent.VK_E:</span><br><span class="line">                        View.this.nidalee.useE();</span><br><span class="line">                        break;</span><br><span class="line">                    case KeyEvent.VK_R:</span><br><span class="line">                        View.this.nidalee.useR();</span><br><span class="line">                        break;</span><br><span class="line">                    case KeyEvent.VK_X:</span><br><span class="line">                        View.this.nidalee.damage(1000);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">        super.setVisible(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void paint(Graphics g) &#123;</span><br><span class="line">        // 基本参数</span><br><span class="line">        int leftBar = 11;</span><br><span class="line">        int aboveBar = 45;</span><br><span class="line">        int imgWidth = 308;</span><br><span class="line">        int imgHeight = 560;</span><br><span class="line">        int skillWidth = 308 / 4;</span><br><span class="line">        // 血条蓝条</span><br><span class="line">        int slotHeight = 10;</span><br><span class="line">        g.setColor(this.getHealthColor());</span><br><span class="line">        g.fillRect(leftBar, aboveBar, (int)(imgWidth * this.nidalee.getHealthRate()), slotHeight);</span><br><span class="line">        if (this.nidalee.ifHaveMana()) &#123;</span><br><span class="line">            g.setColor(Color.BLUE);</span><br><span class="line">            g.fillRect(leftBar, aboveBar + slotHeight, (int)(imgWidth * this.nidalee.getManaRate()), slotHeight);</span><br><span class="line">        &#125;</span><br><span class="line">        // 图片</span><br><span class="line">        g.drawImage(this.loadImgWeaken(this.nidalee.getImgKeyWord() + &quot;.jpg&quot;), leftBar, aboveBar + 2 * slotHeight, null);</span><br><span class="line">        // 技能图标</span><br><span class="line">        int skillH = aboveBar + 2 * slotHeight + imgHeight;</span><br><span class="line">        g.drawImage(this.loadImgWeaken(this.nidalee.getImgKeyWord() + &quot;Q.jpg&quot;), leftBar, skillH, null);</span><br><span class="line">        g.drawImage(this.loadImgWeaken(this.nidalee.getImgKeyWord() + &quot;W.jpg&quot;), leftBar + skillWidth, skillH, null);</span><br><span class="line">        g.drawImage(this.loadImgWeaken(this.nidalee.getImgKeyWord() + &quot;E.jpg&quot;), leftBar + skillWidth * 2, skillH, null);</span><br><span class="line">        g.drawImage(this.loadImgWeaken(&quot;R.jpg&quot;), leftBar + skillWidth * 3, skillH, null);</span><br><span class="line">        // 技能冷却</span><br><span class="line">        g.setColor(Color.BLACK);</span><br><span class="line">        int qCDHeight = (int)(this.nidalee.remainQ() * skillWidth);</span><br><span class="line">        g.fillRect(leftBar, skillH + skillWidth - qCDHeight, skillWidth, qCDHeight);</span><br><span class="line">        int wCDHeight = (int)(this.nidalee.remainW() * skillWidth);</span><br><span class="line">        g.fillRect(leftBar + skillWidth, skillH + skillWidth - wCDHeight, skillWidth, wCDHeight);</span><br><span class="line">        int eCDHeight = (int)(this.nidalee.remainE() * skillWidth);</span><br><span class="line">        g.fillRect(leftBar + skillWidth * 2, skillH + skillWidth - eCDHeight, skillWidth, eCDHeight);</span><br><span class="line">        int rCDHeight = (int)(this.nidalee.remainR() * skillWidth);</span><br><span class="line">        g.fillRect(leftBar + skillWidth * 3, skillH + skillWidth - rCDHeight, skillWidth, rCDHeight);</span><br><span class="line">        // 阵亡文字</span><br><span class="line">        if (this.nidalee.isDeath()) g.drawImage(this.loadImg(&quot;death.png&quot;), leftBar + 35, aboveBar + 250, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private class RepaintRunnable implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    View.this.repaint();</span><br><span class="line">                    Thread.sleep(40);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void update(Graphics g) &#123;</span><br><span class="line">        Image bImage = super.createImage(this.getWidth(), this.getHeight());</span><br><span class="line">        Graphics bg = bImage.getGraphics();</span><br><span class="line">        this.paint(bg);</span><br><span class="line">        bg.dispose();</span><br><span class="line">        g.drawImage(bImage, 0, 0, this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private BufferedImage loadImg(String name) &#123;</span><br><span class="line">        BufferedImage bImage = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            bImage = ImageIO.read(View.class.getClassLoader().getResource(&quot;design19/img/&quot; + name));</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return bImage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private BufferedImage loadImgWeaken(String name) &#123;</span><br><span class="line">        BufferedImage bufferedImage = this.loadImg(name);</span><br><span class="line">        if (!this.nidalee.isDeath()) return bufferedImage;</span><br><span class="line">        final int width = 1;</span><br><span class="line">        boolean ifShowY = true;</span><br><span class="line">        int nowY = 0;</span><br><span class="line">        for (int y = 0; y &lt; bufferedImage.getHeight(); y++) &#123;</span><br><span class="line">            if (!ifShowY) &#123;</span><br><span class="line">                for (int x = 0; x &lt; bufferedImage.getWidth(); x++)</span><br><span class="line">                    bufferedImage.setRGB(x, y, 0);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                boolean ifShowX = true;</span><br><span class="line">                int nowX = 0;</span><br><span class="line">                for (int x = 0; x &lt; bufferedImage.getWidth(); x++) &#123;</span><br><span class="line">                    if(!ifShowX) bufferedImage.setRGB(x, y, 0);</span><br><span class="line">                    nowX++;</span><br><span class="line">                    if (nowX == width) &#123;</span><br><span class="line">                        nowX = 0;</span><br><span class="line">                        ifShowX = !ifShowX;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            nowY++;</span><br><span class="line">            if (nowY == width) &#123;</span><br><span class="line">                nowY = 0;</span><br><span class="line">                ifShowY = !ifShowY;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return bufferedImage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Color getHealthColor() &#123;</span><br><span class="line">        int red;</span><br><span class="line">        int green;</span><br><span class="line">        if (this.nidalee.getHealthRate() &gt;= 0.5) &#123;</span><br><span class="line">            green = 255;</span><br><span class="line">            red = (int)(255 * (1.0 - this.nidalee.getHealthRate()) * 2);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            red = 255;</span><br><span class="line">            green = (int)(255 * this.nidalee.getHealthRate() * 2);</span><br><span class="line">        &#125;</span><br><span class="line">        return new Color(red, green, 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很长，不过其中大多是Java AWT套路话的东西，需要说的只有以下几点。</p><p>首先，为了代码书写简单，我写了很多硬编码。通常这种涉及面板参数的操作，都会写得更灵活，例如支持面板整体的缩放等。其次，在加载图片时，我其实是每刷新一次面板就重新加载了一次，这显然是很浪费CPU的，通常来说都会在一个地方将需要用的图片加载入内存，形成静态字段。</p><p>其次，就是两个小算法啦。先来说第一个：血条绿-黄-红的渐变。这个功能主要写在getHealthColor()方法中。本质上来说，这个算法就是通过控制RGB中RED-GREEN-BLUE三个分量的值来调制出需要的颜色。对于RGB颜色而言：</p><ul><li>绿：(0,255,0)</li><li>黄：(255,255,0)</li><li>红：(255,0,0)</li></ul><p>假如我们将HP的变化趋势考虑为递减(递增其实也同理，相当于是逆过程)：</p><p>首先，无论如何，蓝色分量均为0。</p><p>在HP由100%-50%的过程中，绿色分量始终为255，而红色分量由0逐渐增加至255。</p><p>当血量达到50%时，RGB颜色为(255,255,0)，即标准的黄色。</p><p>随后，在HP由50%-0的过程中，红色分量始终为255，而绿色分量则由255逐渐减少为0。</p><p>然后再来说第二个：也就是图片虚化效果的实现。功能代码在loadImgWeaken()方法中，实现的效果就是行与列均是每隔一个像素点输出一个，形成网格效果。同时，由于输出的像素点变少，图片整体也会变暗。具体的算法逻辑可参见<a href="/2018/05/20/Java AWT-以像素为单位操纵图片/">Java AWT-以像素为单位操纵图片</a>。</p><p><strong>Main类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package design19;</span><br><span class="line"></span><br><span class="line">import design19.view.View;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new View().launchFrame();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后，即可按需求输出结果。</p><p><strong>用到的图片</strong></p><p>最后，贴一下本程序用到的图片。</p><p>人形态立绘human.jpg</p><p><img src="/images/blog_pic/Java 设计模式/19State模式/25.jpg" alt="25.jpg"></p><hr><p>豹形态立绘leopard.jpg</p><p><img src="/images/blog_pic/Java 设计模式/19State模式/26.jpg" alt="26.jpg"></p><hr><p>人形态Q技能humanQ.jpg</p><p><img src="/images/blog_pic/Java 设计模式/19State模式/27.jpg" alt="27.jpg"></p><hr><p>人形态W技能humanW.jpg</p><p><img src="/images/blog_pic/Java 设计模式/19State模式/28.jpg" alt="28.jpg"></p><hr><p>人形态E技能humanE.jpg</p><p><img src="/images/blog_pic/Java 设计模式/19State模式/29.jpg" alt="29.jpg"></p><hr><p>豹形态Q技能leopardQ.jpg</p><p><img src="/images/blog_pic/Java 设计模式/19State模式/30.jpg" alt="30.jpg"></p><hr><p>豹形态W技能leopardW.jpg</p><p><img src="/images/blog_pic/Java 设计模式/19State模式/31.jpg" alt="31.jpg"></p><hr><p>豹形态E技能leopardE.jpg</p><p><img src="/images/blog_pic/Java 设计模式/19State模式/32.jpg" alt="32.jpg"></p><hr><p>R技能R.jpg</p><p><img src="/images/blog_pic/Java 设计模式/19State模式/33.jpg" alt="33.jpg"></p><hr><p>死亡文字提示death.png</p><p><img src="/images/blog_pic/Java 设计模式/19State模式/34.png" alt="34.png"></p><h1 id="登场角色"><a href="#登场角色" class="headerlink" title="登场角色"></a>登场角色</h1><p>上面的示例程序介绍了State模式的Java实现，下面咱们试着跳出语言层面，抽象出State模式中登场的角色。</p><p><strong>State(状态)</strong></p><p>在示例程序中，由NidaleeState类扮演这个角色。</p><p><strong>ConcreteState(具体的状态)</strong></p><p>在示例程序中，由HumanState及LeopardState联袂扮演这个角色。</p><p><strong>Context(上下文)</strong></p><p>实际就是拥有State的宿主，在示例程序中，由Nidalee类扮演这个角色。</p><p>下面是抽象后，无关语言的类图：</p><p><img src="/images/blog_pic/Java 设计模式/19State模式/35.jpg" alt="35.jpg"></p><p>较之示例程序，本类图少了不少类。其原因就在于，从本质上来说。State模式就是在将State角色自Context角色中分离出去。因此核心角色其实就只有这两个。</p><p>此外，示例程序中的NidaleeState是一个抽象类，而本类图中的State是一个接口。之所以会产生这种不同，是因为State只要表示的含义是一个抽象的状态即可，具体的形式应依具体使用场景而定。</p><h1 id="易于增加xx，难以xx"><a href="#易于增加xx，难以xx" class="headerlink" title="易于增加xx，难以xx"></a>易于增加xx，难以xx</h1><p>在State模式中，增加一个新的State相对容易，我们只需要让它实现上层的抽象类或接口，然后按约束编写代码即可。而在上层的抽象类或接口中增加一个新的方法则相对费事：这需要每一个State都增加这个新的方法。因为代码相对分散，每个State的编码思路可能大不相同，所以写起来会麻烦得多。</p><p>仔细回忆此前写过的设计模式相关的博客，这种”易于xx，难以xx”其实已经出现过很多次了。例如，在<a href="">8.Abstract Factory模式</a>中我们就曾说过，Abstract Factory模式”易于扩展具体的工厂，难以增加新的零件”。</p><p>其实这种特性源于继承或是实现。按照抽象的上层的约束写成新的下层相对容易，因为这遵循开闭原则。此时只需增加新代码，而无需对原有代码做出修改。而在抽象的上层中添加新功能则相对困难，因为这相当于所有已有的下层类都需要修改，违背了开闭原则。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在《图解设计模式》一书中，State模式被归入了第8部分&lt;a href=&quot;&quot;&gt;管理状态&lt;/a&gt;。在GoF原书中，State模式则被归入了&lt;a href=&quot;&quot;&gt;行为型设计模式&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Java 设计模式" scheme="http://yoursite.com/categories/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java 设计模式-18.Memento模式</title>
    <link href="http://yoursite.com/2018/08/30/Java%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-18Memento%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/08/30/Java 设计模式-18Memento模式/</id>
    <published>2018-08-30T02:30:49.000Z</published>
    <updated>2018-08-30T08:25:32.618Z</updated>
    
    <content type="html"><![CDATA[<p>在《图解设计模式》一书中，Observer模式被归入了第8部分<a href="">管理状态</a>。在GoF原书中，Observer模式则被归入了<a href="">行为型设计模式</a>。</p><a id="more"></a><h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><p>大多数的文本编辑软件，都会支持撤销操作：我们可以通过该操作将文本恢复为之前的版本。而且这种撤销通常可以进行不止一次，即我们能够通过反复撤销将文本恢复为很久以前的版本。</p><p>如果打算使用面向对象的语言实现这个功能的话，该怎么做呢？</p><p>首先，既然要恢复，就必须将此前的状态保存下来。那么到底该如何进行这个保存操作呢？比较容易想到的方案就是在哪里变更，就在变更之前进行保存。但是既然要保存对象，就必须能够访问对象内部的数据结构才行，如果需要保存的地方有多处，就会使得访问内部数据结构的逻辑散落在代码的多个位置，不利于程序的维护。在编程领域，这被称为”破坏了封装性”。</p><p>因此我们引入了Memento模式。Memento有”遗物，纪念品”的含义。顾名思义，它会将对象某个时间点需保存的属性记录下来，形成快照。然后在需要时再拿来使用。这样对对象状态的封装就被封装进了一个个Memento实例中。当外界需要快照时，就调用对象相关的方法生成Memento实例。而当需要恢复为某个Memento实例的状态时，就将该Memento实例传递给对象，让对象自行恢复到以前的状态(颇有些游戏存档-读档的意思)。这样，对于外部而言，对象内部的数据结构依然是黑盒的。</p><p>在这里要明确的是，Memento实例和它所记录的对象实例是不同的。这种不同一方面当然来自时间性上，对象本身是有时间维度的，它可能会随着时间的推进变更内部存储的值，而Memento实例则是记录某个时间点上对象的状态，仿佛就是一张定格的照片，是静态的。另一方面，Memento实例也并非是某个时间点上对对象属性的完全复制(拍照片还有失真呢)，当然我们也可以做到完全复制，不过这通常是没有意义的。我们往往只会将我们关心的，又会随时间变化的属性记录下来，用于恢复。</p><p>说到这里，大家有没有想到些什么呢？对啦！就是Java的序列化(java.io.Serializable接口)功能。实现了该接口的类就有能力保存自身在某个时间点上的状态，以供后续的恢复。其基本思路和Memento模式还是很像的。只不过，二者的应用目标还是不同的，Java的序列化主要是为了空间上的便利性：即在A地生成的对象，可以通过序列化存储至磁盘上，然后经由网络等通路传递至B地，再恢复为原对象。这是一个完整的对象打包再解包的过程，因此序列化通常会保存对象的所有核心属性(不管是否随时间变化的都会保存)。</p><h1 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h1><p>下面我们来看一个应用了Memento模式的小例子。作为一个demo小程序，我们当然不会实现一个记事本。在此我们用Java AWT实现了一个小窗体。小窗体上只有一个数字，表示得分：</p><p><img src="/images/blog_pic/Java 设计模式/18Memento模式/0.jpg" alt="0.jpg"></p><p>该程序会监听键盘事件：</p><ul><li>上箭头：加1分</li><li>下箭头：减1分</li><li>左箭头：撤销一次之前的加/减操作</li><li>右箭头：显示当前存储的快照</li><li>其他按键：无</li></ul><p>下面就赶快来看代码吧~首先是类图：</p><p><img src="/images/blog_pic/Java 设计模式/18Memento模式/1.jpg" alt="1.jpg"></p><p>本程序中的所有代码将被统一置于design18包下，结构如下：</p><p><img src="/images/blog_pic/Java 设计模式/18Memento模式/2.jpg" alt="2.jpg"></p><p>其中Main.java是测试代码，并没有出现在类图中。</p><p>下面将逐个贴出每个类的源码。</p><p><strong>Subject类</strong></p><p>首先是待保存状态的对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package design18;</span><br><span class="line"></span><br><span class="line">public class Subject &#123;</span><br><span class="line"></span><br><span class="line">    private int score;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public Subject(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getScore() &#123;</span><br><span class="line">        return score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setScore(int score) &#123;</span><br><span class="line">        this.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Memento createSnapshot() &#123;</span><br><span class="line">        return new Memento(this.score);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void recovery(Memento memento) &#123;</span><br><span class="line">        this.score = memento.getScore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Memento类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package design18;</span><br><span class="line"></span><br><span class="line">public class Memento &#123;</span><br><span class="line"></span><br><span class="line">    private int score;</span><br><span class="line"></span><br><span class="line">    Memento(int score) &#123;</span><br><span class="line">        this.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int getScore() &#123;</span><br><span class="line">        return score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Memento [score=&quot; + score + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然代码比较短，但毫无疑问，从名字上也能看出，Memento类就是Memento模式最重要的一个类了。在本示例中，它记录了Subject对象的状态。关于这个类，有如下几点需要说明：</p><ul><li>单从本文的代码来看，Memento与Subject似乎毫无关联。但实际上，Memento完全附属于Subject。因此实际情况下我们通常会将Memento写为Subject的内部类，或是非public类。本文将Memento单独提取出一个文件，主要是为了能使类图更清晰，便于理解。</li><li>Subject中有name和score两个属性，但是name是不会随时间变化的，因此Memento中就只记录了score。</li><li>除了toString()之外，Memento中的所有字段和方法的最高访问权限都只到无修饰符，也就是同包下可访问。说实话这个权限还是给大了，因为我们其实希望只有Subject类能访问到这些字段和方法，这也算是没有将Memento写为Subject的内部类的另一个后遗症吧，使得权限控制变得有些混乱了。</li></ul><p>接最后一小点。其实我们可以再扩展一下。在面向对象编程中，我们可以按访问权限将方法分为两类，需要注意的是，下文中说的接口指得其实是广义上的方法API，而非狭义上Java中的接口：</p><ul><li>wide interface(宽接口)：暴露大量内部信息的接口，通常只供比较”亲密”的内部人员调用。</li><li>narrow interface(窄接口)：只保留少量非核心的信息，供外部调用。</li></ul><p>这样做可以很好的划定模块间的界限，防止对象的封装性被破坏。显然，对于Memento而言，构造函数以及getScore()均是窄接口，而toString()则是宽接口。</p><p><strong>View类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">package design18;</span><br><span class="line"></span><br><span class="line">import java.awt.Font;</span><br><span class="line">import java.awt.Frame;</span><br><span class="line">import java.awt.Graphics;</span><br><span class="line">import java.awt.Image;</span><br><span class="line">import java.awt.event.KeyAdapter;</span><br><span class="line">import java.awt.event.KeyEvent;</span><br><span class="line">import java.awt.event.WindowAdapter;</span><br><span class="line">import java.awt.event.WindowEvent;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class View extends Frame &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">    private Subject subject;</span><br><span class="line"></span><br><span class="line">    private List&lt;Memento&gt; snapshotList = new ArrayList&lt;Memento&gt;();</span><br><span class="line"></span><br><span class="line">    public View(Subject subject) &#123;</span><br><span class="line">        this.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void launchFrame() &#123;</span><br><span class="line">        super.setLocation(700, 300);</span><br><span class="line">        super.setSize(200, 150);</span><br><span class="line">        super.setTitle(this.subject.getName());</span><br><span class="line">        new Thread(this.new RepaintRunnable()).start();</span><br><span class="line">        super.addWindowListener(</span><br><span class="line">            new WindowAdapter() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void windowClosing(WindowEvent e) &#123;</span><br><span class="line">                    System.exit(0);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">        super.addKeyListener(</span><br><span class="line">            new KeyAdapter() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void keyReleased(KeyEvent e) &#123;</span><br><span class="line">                    switch(e.getKeyCode()) &#123;</span><br><span class="line">                    case KeyEvent.VK_UP:</span><br><span class="line">                        System.out.println(&quot;上箭头被按下，加分。&quot;);</span><br><span class="line">                        View.this.snapshotList.add(View.this.subject.createSnapshot());</span><br><span class="line">                        View.this.subject.setScore(View.this.subject.getScore() + 1);</span><br><span class="line">                        break;</span><br><span class="line">                    case KeyEvent.VK_DOWN:</span><br><span class="line">                        System.out.println(&quot;下箭头被按下，减分。&quot;);</span><br><span class="line">                        View.this.snapshotList.add(View.this.subject.createSnapshot());</span><br><span class="line">                        View.this.subject.setScore(View.this.subject.getScore() - 1);</span><br><span class="line">                        break;</span><br><span class="line">                    case KeyEvent.VK_LEFT:</span><br><span class="line">                        System.out.println(&quot;左箭头被按下，撤销上一次操作。&quot;);</span><br><span class="line">                        if (View.this.snapshotList.size() &gt; 0) &#123;</span><br><span class="line">                            Memento lastMemento = View.this.snapshotList.get(View.this.snapshotList.size() - 1);</span><br><span class="line">                            View.this.snapshotList.remove(View.this.snapshotList.size() - 1);</span><br><span class="line">                            View.this.subject.recovery(lastMemento);</span><br><span class="line">                        &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    case KeyEvent.VK_RIGHT:</span><br><span class="line">                        System.out.println(&quot;右箭头被按下，在控制台中打印当前存储的快照。&quot;);</span><br><span class="line">                        System.out.println(&quot;============================&quot;);</span><br><span class="line">                        for (int i = 0; i &lt; View.this.snapshotList.size(); i++)</span><br><span class="line">                            System.out.println(i + &quot;---&quot; + View.this.snapshotList.get(i));</span><br><span class="line">                        System.out.println(&quot;============================&quot;);</span><br><span class="line">                        break;</span><br><span class="line">                    default:</span><br><span class="line">                        System.out.println(&quot;非法按键，键值=&quot; + e.getKeyCode());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">        super.setVisible(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void paint(Graphics g) &#123;</span><br><span class="line">        g.setFont(new Font(null, Font.BOLD, 30));</span><br><span class="line">        g.drawString(&quot;&quot; + View.this.subject.getScore(), 50, 100);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private class RepaintRunnable implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    View.this.repaint();</span><br><span class="line">                    Thread.sleep(40);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void update(Graphics g) &#123;</span><br><span class="line">        Image bImage = super.createImage(this.getWidth(), this.getHeight());</span><br><span class="line">        Graphics bg = bImage.getGraphics();</span><br><span class="line">        this.paint(bg);</span><br><span class="line">        bg.dispose();</span><br><span class="line">        g.drawImage(bImage, 0, 0, this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码看起来比较长，不过大部分都是Java AWT中模板化的东西。和本文最相关的那部分逻辑被封装在了launchFrame()方法的super.addKeyListener()中。从代码中我们可以看到，View对快照的生成过程是完全黑盒的，它只是调用了Subject的createSnapshot()方法，然后将其存储到自身管理的快照列表snapshotList中。而后在需要显示和恢复时，直接使用即可。不过即便是恢复，View也仅仅是将需要恢复为的那份Memento通过Subject的recovery()方法传递给Subject而已，这个过程依然是黑盒的。</p><p><strong>Main类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package design18;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new View(new Subject(&quot;博丽灵梦&quot;)).launchFrame();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行该类后，程序即可按照规定的由键盘控制分数的加减。在此输出部分最初的在控制台中打印的文字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">上箭头被按下，加分。</span><br><span class="line">右箭头被按下，在控制台中打印当前存储的快照。</span><br><span class="line">============================</span><br><span class="line">0---Memento [score=0]</span><br><span class="line">============================</span><br><span class="line">上箭头被按下，加分。</span><br><span class="line">上箭头被按下，加分。</span><br><span class="line">上箭头被按下，加分。</span><br><span class="line">上箭头被按下，加分。</span><br><span class="line">下箭头被按下，减分。</span><br><span class="line">右箭头被按下，在控制台中打印当前存储的快照。</span><br><span class="line">============================</span><br><span class="line">0---Memento [score=0]</span><br><span class="line">1---Memento [score=1]</span><br><span class="line">2---Memento [score=2]</span><br><span class="line">3---Memento [score=3]</span><br><span class="line">4---Memento [score=4]</span><br><span class="line">5---Memento [score=5]</span><br><span class="line">============================</span><br><span class="line">左箭头被按下，撤销上一次操作。</span><br><span class="line">左箭头被按下，撤销上一次操作。</span><br><span class="line">右箭头被按下，在控制台中打印当前存储的快照。</span><br><span class="line">============================</span><br><span class="line">0---Memento [score=0]</span><br><span class="line">1---Memento [score=1]</span><br><span class="line">2---Memento [score=2]</span><br><span class="line">3---Memento [score=3]</span><br><span class="line">============================</span><br><span class="line">左箭头被按下，撤销上一次操作。</span><br><span class="line">左箭头被按下，撤销上一次操作。</span><br><span class="line">右箭头被按下，在控制台中打印当前存储的快照。</span><br><span class="line">============================</span><br><span class="line">0---Memento [score=0]</span><br><span class="line">1---Memento [score=1]</span><br><span class="line">============================</span><br></pre></td></tr></table></figure><h1 id="登场角色"><a href="#登场角色" class="headerlink" title="登场角色"></a>登场角色</h1><p>上面的示例程序介绍了Observer模式的Java实现，下面咱们试着跳出语言层面，抽象出Observer模式中登场的角色。</p><p><strong>Originator(生成者)</strong></p><p>Originator能够生成某时刻表示自身当前状态的Memento角色。也能根据传入的Memento恢复到此前的状态。在示例程序中，由Subject类扮演这个角色。</p><p><strong>Memento(纪念品)</strong></p><p>在示例程序中，由Memento类扮演这个角色。</p><p><strong>Caretaker(负责人)</strong></p><p>Caretaker相当于外部调用人。在需要时它会要求Originator生成Memento，并存储该Memento。不过Caretaker只能调用Memento提供的窄接口，更直白的说，相当于Originator及Memento对Caretaker而言依然还是黑盒的。在合适的时机，Caretaker会将此前的某个Memento传递给Originator，以让Originator恢复为当时的状态。在示例程序中，由View类扮演这个角色。</p><p>下面是抽象后，无关语言的类图：</p><p><img src="/images/blog_pic/Java 设计模式/18Memento模式/3.jpg" alt="3.jpg"></p><h1 id="Memento的过期"><a href="#Memento的过期" class="headerlink" title="Memento的过期"></a>Memento的过期</h1><p>在前文的分析中，我们说Java提供的序列化在空间上提供备份，Memento模式在时间上提供备份。这样说其实并不完善。从本质上来说，Memento模式就是保存对象某个时间点的快照，以供以后操作。事实上，Memento模式照下的快照也不总是在内存中的。最常见的就是游戏的存档，当游戏退出时，存档通常是会作为存档文件被保存在磁盘上的，下次启动或是需要的时候再读取某个档(SL大法万岁！)。</p><p>将快照保存为静态文件提高了程序的灵活性，却也增加了新的风险：我们要注意快照的过期。即随着程序的升级，如果对象的数据结构发生了较大的变化，新程序中的对象可能会无法读取之前版本的快照，此时就会导致快照”过期”。</p><h1 id="Memento的存储技巧"><a href="#Memento的存储技巧" class="headerlink" title="Memento的存储技巧"></a>Memento的存储技巧</h1><p>本文示例程序中每个Memento对象需要存储的信息很少。但是很多时候，比如前文提到的游戏存档，每个Memento可能都会占用大量的内存和磁盘空间。最基本的解决办法自然是使用各种压缩技术。不过在此之上，我们还有什么其他的好办法吗？</p><p>我们可以参考一下git管理代码的技术。git可以很方便的将代码恢复为之前的版本，从本质上来说实现的基本功能和Memento对象是类似的。只不过，假设我们在git上提交了一次代码，导致代码库由版本1升至了版本2。此时git并不是将版本1全部拍为快照，而是只记录快照间的变化情况。这样在恢复时只需要反向的追溯这种变化即可。在编程领域，这是少有的用时间换空间的例子。</p><p>类似的，虽然普通场景下两个连续的快照间的关联没有那么强，但是如果两次变动间绝大多数的数据都没有变化，那么我们也可以只记录发生变化的值，进而构建变化链，达到类似的节省空间的效果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在《图解设计模式》一书中，Observer模式被归入了第8部分&lt;a href=&quot;&quot;&gt;管理状态&lt;/a&gt;。在GoF原书中，Observer模式则被归入了&lt;a href=&quot;&quot;&gt;行为型设计模式&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Java 设计模式" scheme="http://yoursite.com/categories/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
